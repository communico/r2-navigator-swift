(()=>{var __webpack_modules__={89:(__unused_webpack_module,exports)=>{"use strict";eval('var __webpack_unused_export__;\n\n/**\n * Implementation of Myers\' online approximate string matching algorithm [1],\n * with additional optimizations suggested by [2].\n *\n * This has O((k/w) * n) complexity where `n` is the length of the text, `k` is\n * the maximum number of errors allowed (always <= the pattern length) and `w`\n * is the word size. Because JS only supports bitwise operations on 32 bit\n * integers, `w` is 32.\n *\n * As far as I am aware, there aren\'t any online algorithms which are\n * significantly better for a wide range of input parameters. The problem can be\n * solved faster using "filter then verify" approaches which first filter out\n * regions of the text that cannot match using a "cheap" check and then verify\n * the remaining potential matches. The verify step requires an algorithm such\n * as this one however.\n *\n * The algorithm\'s approach is essentially to optimize the classic dynamic\n * programming solution to the problem by computing columns of the matrix in\n * word-sized chunks (ie. dealing with 32 chars of the pattern at a time) and\n * avoiding calculating regions of the matrix where the minimum error count is\n * guaranteed to exceed the input threshold.\n *\n * The paper consists of two parts, the first describes the core algorithm for\n * matching patterns <= the size of a word (implemented by `advanceBlock` here).\n * The second uses the core algorithm as part of a larger block-based algorithm\n * to handle longer patterns.\n *\n * [1] G. Myers, “A Fast Bit-Vector Algorithm for Approximate String Matching\n * Based on Dynamic Programming,” vol. 46, no. 3, pp. 395–415, 1999.\n *\n * [2] Šošić, M. (2014). An simd dynamic programming c/c++ library (Doctoral\n * dissertation, Fakultet Elektrotehnike i računarstva, Sveučilište u Zagrebu).\n */\n__webpack_unused_export__ = ({ value: true });\nfunction reverse(s) {\n    return s\n        .split("")\n        .reverse()\n        .join("");\n}\n/**\n * Given the ends of approximate matches for `pattern` in `text`, find\n * the start of the matches.\n *\n * @param findEndFn - Function for finding the end of matches in\n * text.\n * @return Matches with the `start` property set.\n */\nfunction findMatchStarts(text, pattern, matches) {\n    var patRev = reverse(pattern);\n    return matches.map(function (m) {\n        // Find start of each match by reversing the pattern and matching segment\n        // of text and searching for an approx match with the same number of\n        // errors.\n        var minStart = Math.max(0, m.end - pattern.length - m.errors);\n        var textRev = reverse(text.slice(minStart, m.end));\n        // If there are multiple possible start points, choose the one that\n        // maximizes the length of the match.\n        var start = findMatchEnds(textRev, patRev, m.errors).reduce(function (min, rm) {\n            if (m.end - rm.end < min) {\n                return m.end - rm.end;\n            }\n            return min;\n        }, m.end);\n        return {\n            start: start,\n            end: m.end,\n            errors: m.errors\n        };\n    });\n}\n/**\n * Return 1 if a number is non-zero or zero otherwise, without using\n * conditional operators.\n *\n * This should get inlined into `advanceBlock` below by the JIT.\n *\n * Adapted from https://stackoverflow.com/a/3912218/434243\n */\nfunction oneIfNotZero(n) {\n    return ((n | -n) >> 31) & 1;\n}\n/**\n * Block calculation step of the algorithm.\n *\n * From Fig 8. on p. 408 of [1], additionally optimized to replace conditional\n * checks with bitwise operations as per Section 4.2.3 of [2].\n *\n * @param ctx - The pattern context object\n * @param peq - The `peq` array for the current character (`ctx.peq.get(ch)`)\n * @param b - The block level\n * @param hIn - Horizontal input delta ∈ {1,0,-1}\n * @return Horizontal output delta ∈ {1,0,-1}\n */\nfunction advanceBlock(ctx, peq, b, hIn) {\n    var pV = ctx.P[b];\n    var mV = ctx.M[b];\n    var hInIsNegative = hIn >>> 31; // 1 if hIn < 0 or 0 otherwise.\n    var eq = peq[b] | hInIsNegative;\n    // Step 1: Compute horizontal deltas.\n    var xV = eq | mV;\n    var xH = (((eq & pV) + pV) ^ pV) | eq;\n    var pH = mV | ~(xH | pV);\n    var mH = pV & xH;\n    // Step 2: Update score (value of last row of this block).\n    var hOut = oneIfNotZero(pH & ctx.lastRowMask[b]) -\n        oneIfNotZero(mH & ctx.lastRowMask[b]);\n    // Step 3: Update vertical deltas for use when processing next char.\n    pH <<= 1;\n    mH <<= 1;\n    mH |= hInIsNegative;\n    pH |= oneIfNotZero(hIn) - hInIsNegative; // set pH[0] if hIn > 0\n    pV = mH | ~(xV | pH);\n    mV = pH & xV;\n    ctx.P[b] = pV;\n    ctx.M[b] = mV;\n    return hOut;\n}\n/**\n * Find the ends and error counts for matches of `pattern` in `text`.\n *\n * Only the matches with the lowest error count are reported. Other matches\n * with error counts <= maxErrors are discarded.\n *\n * This is the block-based search algorithm from Fig. 9 on p.410 of [1].\n */\nfunction findMatchEnds(text, pattern, maxErrors) {\n    if (pattern.length === 0) {\n        return [];\n    }\n    // Clamp error count so we can rely on the `maxErrors` and `pattern.length`\n    // rows being in the same block below.\n    maxErrors = Math.min(maxErrors, pattern.length);\n    var matches = [];\n    // Word size.\n    var w = 32;\n    // Index of maximum block level.\n    var bMax = Math.ceil(pattern.length / w) - 1;\n    // Context used across block calculations.\n    var ctx = {\n        P: new Uint32Array(bMax + 1),\n        M: new Uint32Array(bMax + 1),\n        lastRowMask: new Uint32Array(bMax + 1)\n    };\n    ctx.lastRowMask.fill(1 << 31);\n    ctx.lastRowMask[bMax] = 1 << (pattern.length - 1) % w;\n    // Dummy "peq" array for chars in the text which do not occur in the pattern.\n    var emptyPeq = new Uint32Array(bMax + 1);\n    // Map of UTF-16 character code to bit vector indicating positions in the\n    // pattern that equal that character.\n    var peq = new Map();\n    // Version of `peq` that only stores mappings for small characters. This\n    // allows faster lookups when iterating through the text because a simple\n    // array lookup can be done instead of a hash table lookup.\n    var asciiPeq = [];\n    for (var i = 0; i < 256; i++) {\n        asciiPeq.push(emptyPeq);\n    }\n    // Calculate `ctx.peq` - a map of character values to bitmasks indicating\n    // positions of that character within the pattern, where each bit represents\n    // a position in the pattern.\n    for (var c = 0; c < pattern.length; c += 1) {\n        var val = pattern.charCodeAt(c);\n        if (peq.has(val)) {\n            // Duplicate char in pattern.\n            continue;\n        }\n        var charPeq = new Uint32Array(bMax + 1);\n        peq.set(val, charPeq);\n        if (val < asciiPeq.length) {\n            asciiPeq[val] = charPeq;\n        }\n        for (var b = 0; b <= bMax; b += 1) {\n            charPeq[b] = 0;\n            // Set all the bits where the pattern matches the current char (ch).\n            // For indexes beyond the end of the pattern, always set the bit as if the\n            // pattern contained a wildcard char in that position.\n            for (var r = 0; r < w; r += 1) {\n                var idx = b * w + r;\n                if (idx >= pattern.length) {\n                    continue;\n                }\n                var match = pattern.charCodeAt(idx) === val;\n                if (match) {\n                    charPeq[b] |= 1 << r;\n                }\n            }\n        }\n    }\n    // Index of last-active block level in the column.\n    var y = Math.max(0, Math.ceil(maxErrors / w) - 1);\n    // Initialize maximum error count at bottom of each block.\n    var score = new Uint32Array(bMax + 1);\n    for (var b = 0; b <= y; b += 1) {\n        score[b] = (b + 1) * w;\n    }\n    score[bMax] = pattern.length;\n    // Initialize vertical deltas for each block.\n    for (var b = 0; b <= y; b += 1) {\n        ctx.P[b] = ~0;\n        ctx.M[b] = 0;\n    }\n    // Process each char of the text, computing the error count for `w` chars of\n    // the pattern at a time.\n    for (var j = 0; j < text.length; j += 1) {\n        // Lookup the bitmask representing the positions of the current char from\n        // the text within the pattern.\n        var charCode = text.charCodeAt(j);\n        var charPeq = void 0;\n        if (charCode < asciiPeq.length) {\n            // Fast array lookup.\n            charPeq = asciiPeq[charCode];\n        }\n        else {\n            // Slower hash table lookup.\n            charPeq = peq.get(charCode);\n            if (typeof charPeq === "undefined") {\n                charPeq = emptyPeq;\n            }\n        }\n        // Calculate error count for blocks that we definitely have to process for\n        // this column.\n        var carry = 0;\n        for (var b = 0; b <= y; b += 1) {\n            carry = advanceBlock(ctx, charPeq, b, carry);\n            score[b] += carry;\n        }\n        // Check if we also need to compute an additional block, or if we can reduce\n        // the number of blocks processed for the next column.\n        if (score[y] - carry <= maxErrors &&\n            y < bMax &&\n            (charPeq[y + 1] & 1 || carry < 0)) {\n            // Error count for bottom block is under threshold, increase the number of\n            // blocks processed for this column & next by 1.\n            y += 1;\n            ctx.P[y] = ~0;\n            ctx.M[y] = 0;\n            var maxBlockScore = y === bMax ? pattern.length % w : w;\n            score[y] =\n                score[y - 1] +\n                    maxBlockScore -\n                    carry +\n                    advanceBlock(ctx, charPeq, y, carry);\n        }\n        else {\n            // Error count for bottom block exceeds threshold, reduce the number of\n            // blocks processed for the next column.\n            while (y > 0 && score[y] >= maxErrors + w) {\n                y -= 1;\n            }\n        }\n        // If error count is under threshold, report a match.\n        if (y === bMax && score[y] <= maxErrors) {\n            if (score[y] < maxErrors) {\n                // Discard any earlier, worse matches.\n                matches.splice(0, matches.length);\n            }\n            matches.push({\n                start: -1,\n                end: j + 1,\n                errors: score[y]\n            });\n            // Because `search` only reports the matches with the lowest error count,\n            // we can "ratchet down" the max error threshold whenever a match is\n            // encountered and thereby save a small amount of work for the remainder\n            // of the text.\n            maxErrors = score[y];\n        }\n    }\n    return matches;\n}\n/**\n * Search for matches for `pattern` in `text` allowing up to `maxErrors` errors.\n *\n * Returns the start, and end positions and error counts for each lowest-cost\n * match. Only the "best" matches are returned.\n */\nfunction search(text, pattern, maxErrors) {\n    var matches = findMatchEnds(text, pattern, maxErrors);\n    return findMatchStarts(text, pattern, matches);\n}\nexports.Z = search;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFkaXVtLWpzLy4vbm9kZV9tb2R1bGVzL2FwcHJveC1zdHJpbmctbWF0Y2gvZGlzdC9pbmRleC5qcz83MjMwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QyxDQUFDLGNBQWMsQ0FBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsb0JBQW9CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFdBQVc7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsT0FBTztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixRQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBZSIsImZpbGUiOiI4OS5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBJbXBsZW1lbnRhdGlvbiBvZiBNeWVycycgb25saW5lIGFwcHJveGltYXRlIHN0cmluZyBtYXRjaGluZyBhbGdvcml0aG0gWzFdLFxuICogd2l0aCBhZGRpdGlvbmFsIG9wdGltaXphdGlvbnMgc3VnZ2VzdGVkIGJ5IFsyXS5cbiAqXG4gKiBUaGlzIGhhcyBPKChrL3cpICogbikgY29tcGxleGl0eSB3aGVyZSBgbmAgaXMgdGhlIGxlbmd0aCBvZiB0aGUgdGV4dCwgYGtgIGlzXG4gKiB0aGUgbWF4aW11bSBudW1iZXIgb2YgZXJyb3JzIGFsbG93ZWQgKGFsd2F5cyA8PSB0aGUgcGF0dGVybiBsZW5ndGgpIGFuZCBgd2BcbiAqIGlzIHRoZSB3b3JkIHNpemUuIEJlY2F1c2UgSlMgb25seSBzdXBwb3J0cyBiaXR3aXNlIG9wZXJhdGlvbnMgb24gMzIgYml0XG4gKiBpbnRlZ2VycywgYHdgIGlzIDMyLlxuICpcbiAqIEFzIGZhciBhcyBJIGFtIGF3YXJlLCB0aGVyZSBhcmVuJ3QgYW55IG9ubGluZSBhbGdvcml0aG1zIHdoaWNoIGFyZVxuICogc2lnbmlmaWNhbnRseSBiZXR0ZXIgZm9yIGEgd2lkZSByYW5nZSBvZiBpbnB1dCBwYXJhbWV0ZXJzLiBUaGUgcHJvYmxlbSBjYW4gYmVcbiAqIHNvbHZlZCBmYXN0ZXIgdXNpbmcgXCJmaWx0ZXIgdGhlbiB2ZXJpZnlcIiBhcHByb2FjaGVzIHdoaWNoIGZpcnN0IGZpbHRlciBvdXRcbiAqIHJlZ2lvbnMgb2YgdGhlIHRleHQgdGhhdCBjYW5ub3QgbWF0Y2ggdXNpbmcgYSBcImNoZWFwXCIgY2hlY2sgYW5kIHRoZW4gdmVyaWZ5XG4gKiB0aGUgcmVtYWluaW5nIHBvdGVudGlhbCBtYXRjaGVzLiBUaGUgdmVyaWZ5IHN0ZXAgcmVxdWlyZXMgYW4gYWxnb3JpdGhtIHN1Y2hcbiAqIGFzIHRoaXMgb25lIGhvd2V2ZXIuXG4gKlxuICogVGhlIGFsZ29yaXRobSdzIGFwcHJvYWNoIGlzIGVzc2VudGlhbGx5IHRvIG9wdGltaXplIHRoZSBjbGFzc2ljIGR5bmFtaWNcbiAqIHByb2dyYW1taW5nIHNvbHV0aW9uIHRvIHRoZSBwcm9ibGVtIGJ5IGNvbXB1dGluZyBjb2x1bW5zIG9mIHRoZSBtYXRyaXggaW5cbiAqIHdvcmQtc2l6ZWQgY2h1bmtzIChpZS4gZGVhbGluZyB3aXRoIDMyIGNoYXJzIG9mIHRoZSBwYXR0ZXJuIGF0IGEgdGltZSkgYW5kXG4gKiBhdm9pZGluZyBjYWxjdWxhdGluZyByZWdpb25zIG9mIHRoZSBtYXRyaXggd2hlcmUgdGhlIG1pbmltdW0gZXJyb3IgY291bnQgaXNcbiAqIGd1YXJhbnRlZWQgdG8gZXhjZWVkIHRoZSBpbnB1dCB0aHJlc2hvbGQuXG4gKlxuICogVGhlIHBhcGVyIGNvbnNpc3RzIG9mIHR3byBwYXJ0cywgdGhlIGZpcnN0IGRlc2NyaWJlcyB0aGUgY29yZSBhbGdvcml0aG0gZm9yXG4gKiBtYXRjaGluZyBwYXR0ZXJucyA8PSB0aGUgc2l6ZSBvZiBhIHdvcmQgKGltcGxlbWVudGVkIGJ5IGBhZHZhbmNlQmxvY2tgIGhlcmUpLlxuICogVGhlIHNlY29uZCB1c2VzIHRoZSBjb3JlIGFsZ29yaXRobSBhcyBwYXJ0IG9mIGEgbGFyZ2VyIGJsb2NrLWJhc2VkIGFsZ29yaXRobVxuICogdG8gaGFuZGxlIGxvbmdlciBwYXR0ZXJucy5cbiAqXG4gKiBbMV0gRy4gTXllcnMsIOKAnEEgRmFzdCBCaXQtVmVjdG9yIEFsZ29yaXRobSBmb3IgQXBwcm94aW1hdGUgU3RyaW5nIE1hdGNoaW5nXG4gKiBCYXNlZCBvbiBEeW5hbWljIFByb2dyYW1taW5nLOKAnSB2b2wuIDQ2LCBuby4gMywgcHAuIDM5NeKAkzQxNSwgMTk5OS5cbiAqXG4gKiBbMl0gxaBvxaFpxIcsIE0uICgyMDE0KS4gQW4gc2ltZCBkeW5hbWljIHByb2dyYW1taW5nIGMvYysrIGxpYnJhcnkgKERvY3RvcmFsXG4gKiBkaXNzZXJ0YXRpb24sIEZha3VsdGV0IEVsZWt0cm90ZWhuaWtlIGkgcmHEjXVuYXJzdHZhLCBTdmV1xI1pbGnFoXRlIHUgWmFncmVidSkuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmZ1bmN0aW9uIHJldmVyc2Uocykge1xuICAgIHJldHVybiBzXG4gICAgICAgIC5zcGxpdChcIlwiKVxuICAgICAgICAucmV2ZXJzZSgpXG4gICAgICAgIC5qb2luKFwiXCIpO1xufVxuLyoqXG4gKiBHaXZlbiB0aGUgZW5kcyBvZiBhcHByb3hpbWF0ZSBtYXRjaGVzIGZvciBgcGF0dGVybmAgaW4gYHRleHRgLCBmaW5kXG4gKiB0aGUgc3RhcnQgb2YgdGhlIG1hdGNoZXMuXG4gKlxuICogQHBhcmFtIGZpbmRFbmRGbiAtIEZ1bmN0aW9uIGZvciBmaW5kaW5nIHRoZSBlbmQgb2YgbWF0Y2hlcyBpblxuICogdGV4dC5cbiAqIEByZXR1cm4gTWF0Y2hlcyB3aXRoIHRoZSBgc3RhcnRgIHByb3BlcnR5IHNldC5cbiAqL1xuZnVuY3Rpb24gZmluZE1hdGNoU3RhcnRzKHRleHQsIHBhdHRlcm4sIG1hdGNoZXMpIHtcbiAgICB2YXIgcGF0UmV2ID0gcmV2ZXJzZShwYXR0ZXJuKTtcbiAgICByZXR1cm4gbWF0Y2hlcy5tYXAoZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgLy8gRmluZCBzdGFydCBvZiBlYWNoIG1hdGNoIGJ5IHJldmVyc2luZyB0aGUgcGF0dGVybiBhbmQgbWF0Y2hpbmcgc2VnbWVudFxuICAgICAgICAvLyBvZiB0ZXh0IGFuZCBzZWFyY2hpbmcgZm9yIGFuIGFwcHJveCBtYXRjaCB3aXRoIHRoZSBzYW1lIG51bWJlciBvZlxuICAgICAgICAvLyBlcnJvcnMuXG4gICAgICAgIHZhciBtaW5TdGFydCA9IE1hdGgubWF4KDAsIG0uZW5kIC0gcGF0dGVybi5sZW5ndGggLSBtLmVycm9ycyk7XG4gICAgICAgIHZhciB0ZXh0UmV2ID0gcmV2ZXJzZSh0ZXh0LnNsaWNlKG1pblN0YXJ0LCBtLmVuZCkpO1xuICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbXVsdGlwbGUgcG9zc2libGUgc3RhcnQgcG9pbnRzLCBjaG9vc2UgdGhlIG9uZSB0aGF0XG4gICAgICAgIC8vIG1heGltaXplcyB0aGUgbGVuZ3RoIG9mIHRoZSBtYXRjaC5cbiAgICAgICAgdmFyIHN0YXJ0ID0gZmluZE1hdGNoRW5kcyh0ZXh0UmV2LCBwYXRSZXYsIG0uZXJyb3JzKS5yZWR1Y2UoZnVuY3Rpb24gKG1pbiwgcm0pIHtcbiAgICAgICAgICAgIGlmIChtLmVuZCAtIHJtLmVuZCA8IG1pbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBtLmVuZCAtIHJtLmVuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtaW47XG4gICAgICAgIH0sIG0uZW5kKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgIGVuZDogbS5lbmQsXG4gICAgICAgICAgICBlcnJvcnM6IG0uZXJyb3JzXG4gICAgICAgIH07XG4gICAgfSk7XG59XG4vKipcbiAqIFJldHVybiAxIGlmIGEgbnVtYmVyIGlzIG5vbi16ZXJvIG9yIHplcm8gb3RoZXJ3aXNlLCB3aXRob3V0IHVzaW5nXG4gKiBjb25kaXRpb25hbCBvcGVyYXRvcnMuXG4gKlxuICogVGhpcyBzaG91bGQgZ2V0IGlubGluZWQgaW50byBgYWR2YW5jZUJsb2NrYCBiZWxvdyBieSB0aGUgSklULlxuICpcbiAqIEFkYXB0ZWQgZnJvbSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzkxMjIxOC80MzQyNDNcbiAqL1xuZnVuY3Rpb24gb25lSWZOb3RaZXJvKG4pIHtcbiAgICByZXR1cm4gKChuIHwgLW4pID4+IDMxKSAmIDE7XG59XG4vKipcbiAqIEJsb2NrIGNhbGN1bGF0aW9uIHN0ZXAgb2YgdGhlIGFsZ29yaXRobS5cbiAqXG4gKiBGcm9tIEZpZyA4LiBvbiBwLiA0MDggb2YgWzFdLCBhZGRpdGlvbmFsbHkgb3B0aW1pemVkIHRvIHJlcGxhY2UgY29uZGl0aW9uYWxcbiAqIGNoZWNrcyB3aXRoIGJpdHdpc2Ugb3BlcmF0aW9ucyBhcyBwZXIgU2VjdGlvbiA0LjIuMyBvZiBbMl0uXG4gKlxuICogQHBhcmFtIGN0eCAtIFRoZSBwYXR0ZXJuIGNvbnRleHQgb2JqZWN0XG4gKiBAcGFyYW0gcGVxIC0gVGhlIGBwZXFgIGFycmF5IGZvciB0aGUgY3VycmVudCBjaGFyYWN0ZXIgKGBjdHgucGVxLmdldChjaClgKVxuICogQHBhcmFtIGIgLSBUaGUgYmxvY2sgbGV2ZWxcbiAqIEBwYXJhbSBoSW4gLSBIb3Jpem9udGFsIGlucHV0IGRlbHRhIOKIiCB7MSwwLC0xfVxuICogQHJldHVybiBIb3Jpem9udGFsIG91dHB1dCBkZWx0YSDiiIggezEsMCwtMX1cbiAqL1xuZnVuY3Rpb24gYWR2YW5jZUJsb2NrKGN0eCwgcGVxLCBiLCBoSW4pIHtcbiAgICB2YXIgcFYgPSBjdHguUFtiXTtcbiAgICB2YXIgbVYgPSBjdHguTVtiXTtcbiAgICB2YXIgaEluSXNOZWdhdGl2ZSA9IGhJbiA+Pj4gMzE7IC8vIDEgaWYgaEluIDwgMCBvciAwIG90aGVyd2lzZS5cbiAgICB2YXIgZXEgPSBwZXFbYl0gfCBoSW5Jc05lZ2F0aXZlO1xuICAgIC8vIFN0ZXAgMTogQ29tcHV0ZSBob3Jpem9udGFsIGRlbHRhcy5cbiAgICB2YXIgeFYgPSBlcSB8IG1WO1xuICAgIHZhciB4SCA9ICgoKGVxICYgcFYpICsgcFYpIF4gcFYpIHwgZXE7XG4gICAgdmFyIHBIID0gbVYgfCB+KHhIIHwgcFYpO1xuICAgIHZhciBtSCA9IHBWICYgeEg7XG4gICAgLy8gU3RlcCAyOiBVcGRhdGUgc2NvcmUgKHZhbHVlIG9mIGxhc3Qgcm93IG9mIHRoaXMgYmxvY2spLlxuICAgIHZhciBoT3V0ID0gb25lSWZOb3RaZXJvKHBIICYgY3R4Lmxhc3RSb3dNYXNrW2JdKSAtXG4gICAgICAgIG9uZUlmTm90WmVybyhtSCAmIGN0eC5sYXN0Um93TWFza1tiXSk7XG4gICAgLy8gU3RlcCAzOiBVcGRhdGUgdmVydGljYWwgZGVsdGFzIGZvciB1c2Ugd2hlbiBwcm9jZXNzaW5nIG5leHQgY2hhci5cbiAgICBwSCA8PD0gMTtcbiAgICBtSCA8PD0gMTtcbiAgICBtSCB8PSBoSW5Jc05lZ2F0aXZlO1xuICAgIHBIIHw9IG9uZUlmTm90WmVybyhoSW4pIC0gaEluSXNOZWdhdGl2ZTsgLy8gc2V0IHBIWzBdIGlmIGhJbiA+IDBcbiAgICBwViA9IG1IIHwgfih4ViB8IHBIKTtcbiAgICBtViA9IHBIICYgeFY7XG4gICAgY3R4LlBbYl0gPSBwVjtcbiAgICBjdHguTVtiXSA9IG1WO1xuICAgIHJldHVybiBoT3V0O1xufVxuLyoqXG4gKiBGaW5kIHRoZSBlbmRzIGFuZCBlcnJvciBjb3VudHMgZm9yIG1hdGNoZXMgb2YgYHBhdHRlcm5gIGluIGB0ZXh0YC5cbiAqXG4gKiBPbmx5IHRoZSBtYXRjaGVzIHdpdGggdGhlIGxvd2VzdCBlcnJvciBjb3VudCBhcmUgcmVwb3J0ZWQuIE90aGVyIG1hdGNoZXNcbiAqIHdpdGggZXJyb3IgY291bnRzIDw9IG1heEVycm9ycyBhcmUgZGlzY2FyZGVkLlxuICpcbiAqIFRoaXMgaXMgdGhlIGJsb2NrLWJhc2VkIHNlYXJjaCBhbGdvcml0aG0gZnJvbSBGaWcuIDkgb24gcC40MTAgb2YgWzFdLlxuICovXG5mdW5jdGlvbiBmaW5kTWF0Y2hFbmRzKHRleHQsIHBhdHRlcm4sIG1heEVycm9ycykge1xuICAgIGlmIChwYXR0ZXJuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIC8vIENsYW1wIGVycm9yIGNvdW50IHNvIHdlIGNhbiByZWx5IG9uIHRoZSBgbWF4RXJyb3JzYCBhbmQgYHBhdHRlcm4ubGVuZ3RoYFxuICAgIC8vIHJvd3MgYmVpbmcgaW4gdGhlIHNhbWUgYmxvY2sgYmVsb3cuXG4gICAgbWF4RXJyb3JzID0gTWF0aC5taW4obWF4RXJyb3JzLCBwYXR0ZXJuLmxlbmd0aCk7XG4gICAgdmFyIG1hdGNoZXMgPSBbXTtcbiAgICAvLyBXb3JkIHNpemUuXG4gICAgdmFyIHcgPSAzMjtcbiAgICAvLyBJbmRleCBvZiBtYXhpbXVtIGJsb2NrIGxldmVsLlxuICAgIHZhciBiTWF4ID0gTWF0aC5jZWlsKHBhdHRlcm4ubGVuZ3RoIC8gdykgLSAxO1xuICAgIC8vIENvbnRleHQgdXNlZCBhY3Jvc3MgYmxvY2sgY2FsY3VsYXRpb25zLlxuICAgIHZhciBjdHggPSB7XG4gICAgICAgIFA6IG5ldyBVaW50MzJBcnJheShiTWF4ICsgMSksXG4gICAgICAgIE06IG5ldyBVaW50MzJBcnJheShiTWF4ICsgMSksXG4gICAgICAgIGxhc3RSb3dNYXNrOiBuZXcgVWludDMyQXJyYXkoYk1heCArIDEpXG4gICAgfTtcbiAgICBjdHgubGFzdFJvd01hc2suZmlsbCgxIDw8IDMxKTtcbiAgICBjdHgubGFzdFJvd01hc2tbYk1heF0gPSAxIDw8IChwYXR0ZXJuLmxlbmd0aCAtIDEpICUgdztcbiAgICAvLyBEdW1teSBcInBlcVwiIGFycmF5IGZvciBjaGFycyBpbiB0aGUgdGV4dCB3aGljaCBkbyBub3Qgb2NjdXIgaW4gdGhlIHBhdHRlcm4uXG4gICAgdmFyIGVtcHR5UGVxID0gbmV3IFVpbnQzMkFycmF5KGJNYXggKyAxKTtcbiAgICAvLyBNYXAgb2YgVVRGLTE2IGNoYXJhY3RlciBjb2RlIHRvIGJpdCB2ZWN0b3IgaW5kaWNhdGluZyBwb3NpdGlvbnMgaW4gdGhlXG4gICAgLy8gcGF0dGVybiB0aGF0IGVxdWFsIHRoYXQgY2hhcmFjdGVyLlxuICAgIHZhciBwZXEgPSBuZXcgTWFwKCk7XG4gICAgLy8gVmVyc2lvbiBvZiBgcGVxYCB0aGF0IG9ubHkgc3RvcmVzIG1hcHBpbmdzIGZvciBzbWFsbCBjaGFyYWN0ZXJzLiBUaGlzXG4gICAgLy8gYWxsb3dzIGZhc3RlciBsb29rdXBzIHdoZW4gaXRlcmF0aW5nIHRocm91Z2ggdGhlIHRleHQgYmVjYXVzZSBhIHNpbXBsZVxuICAgIC8vIGFycmF5IGxvb2t1cCBjYW4gYmUgZG9uZSBpbnN0ZWFkIG9mIGEgaGFzaCB0YWJsZSBsb29rdXAuXG4gICAgdmFyIGFzY2lpUGVxID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICAgICAgICBhc2NpaVBlcS5wdXNoKGVtcHR5UGVxKTtcbiAgICB9XG4gICAgLy8gQ2FsY3VsYXRlIGBjdHgucGVxYCAtIGEgbWFwIG9mIGNoYXJhY3RlciB2YWx1ZXMgdG8gYml0bWFza3MgaW5kaWNhdGluZ1xuICAgIC8vIHBvc2l0aW9ucyBvZiB0aGF0IGNoYXJhY3RlciB3aXRoaW4gdGhlIHBhdHRlcm4sIHdoZXJlIGVhY2ggYml0IHJlcHJlc2VudHNcbiAgICAvLyBhIHBvc2l0aW9uIGluIHRoZSBwYXR0ZXJuLlxuICAgIGZvciAodmFyIGMgPSAwOyBjIDwgcGF0dGVybi5sZW5ndGg7IGMgKz0gMSkge1xuICAgICAgICB2YXIgdmFsID0gcGF0dGVybi5jaGFyQ29kZUF0KGMpO1xuICAgICAgICBpZiAocGVxLmhhcyh2YWwpKSB7XG4gICAgICAgICAgICAvLyBEdXBsaWNhdGUgY2hhciBpbiBwYXR0ZXJuLlxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNoYXJQZXEgPSBuZXcgVWludDMyQXJyYXkoYk1heCArIDEpO1xuICAgICAgICBwZXEuc2V0KHZhbCwgY2hhclBlcSk7XG4gICAgICAgIGlmICh2YWwgPCBhc2NpaVBlcS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGFzY2lpUGVxW3ZhbF0gPSBjaGFyUGVxO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGIgPSAwOyBiIDw9IGJNYXg7IGIgKz0gMSkge1xuICAgICAgICAgICAgY2hhclBlcVtiXSA9IDA7XG4gICAgICAgICAgICAvLyBTZXQgYWxsIHRoZSBiaXRzIHdoZXJlIHRoZSBwYXR0ZXJuIG1hdGNoZXMgdGhlIGN1cnJlbnQgY2hhciAoY2gpLlxuICAgICAgICAgICAgLy8gRm9yIGluZGV4ZXMgYmV5b25kIHRoZSBlbmQgb2YgdGhlIHBhdHRlcm4sIGFsd2F5cyBzZXQgdGhlIGJpdCBhcyBpZiB0aGVcbiAgICAgICAgICAgIC8vIHBhdHRlcm4gY29udGFpbmVkIGEgd2lsZGNhcmQgY2hhciBpbiB0aGF0IHBvc2l0aW9uLlxuICAgICAgICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCB3OyByICs9IDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgaWR4ID0gYiAqIHcgKyByO1xuICAgICAgICAgICAgICAgIGlmIChpZHggPj0gcGF0dGVybi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IHBhdHRlcm4uY2hhckNvZGVBdChpZHgpID09PSB2YWw7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYXJQZXFbYl0gfD0gMSA8PCByO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBJbmRleCBvZiBsYXN0LWFjdGl2ZSBibG9jayBsZXZlbCBpbiB0aGUgY29sdW1uLlxuICAgIHZhciB5ID0gTWF0aC5tYXgoMCwgTWF0aC5jZWlsKG1heEVycm9ycyAvIHcpIC0gMSk7XG4gICAgLy8gSW5pdGlhbGl6ZSBtYXhpbXVtIGVycm9yIGNvdW50IGF0IGJvdHRvbSBvZiBlYWNoIGJsb2NrLlxuICAgIHZhciBzY29yZSA9IG5ldyBVaW50MzJBcnJheShiTWF4ICsgMSk7XG4gICAgZm9yICh2YXIgYiA9IDA7IGIgPD0geTsgYiArPSAxKSB7XG4gICAgICAgIHNjb3JlW2JdID0gKGIgKyAxKSAqIHc7XG4gICAgfVxuICAgIHNjb3JlW2JNYXhdID0gcGF0dGVybi5sZW5ndGg7XG4gICAgLy8gSW5pdGlhbGl6ZSB2ZXJ0aWNhbCBkZWx0YXMgZm9yIGVhY2ggYmxvY2suXG4gICAgZm9yICh2YXIgYiA9IDA7IGIgPD0geTsgYiArPSAxKSB7XG4gICAgICAgIGN0eC5QW2JdID0gfjA7XG4gICAgICAgIGN0eC5NW2JdID0gMDtcbiAgICB9XG4gICAgLy8gUHJvY2VzcyBlYWNoIGNoYXIgb2YgdGhlIHRleHQsIGNvbXB1dGluZyB0aGUgZXJyb3IgY291bnQgZm9yIGB3YCBjaGFycyBvZlxuICAgIC8vIHRoZSBwYXR0ZXJuIGF0IGEgdGltZS5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRleHQubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgLy8gTG9va3VwIHRoZSBiaXRtYXNrIHJlcHJlc2VudGluZyB0aGUgcG9zaXRpb25zIG9mIHRoZSBjdXJyZW50IGNoYXIgZnJvbVxuICAgICAgICAvLyB0aGUgdGV4dCB3aXRoaW4gdGhlIHBhdHRlcm4uXG4gICAgICAgIHZhciBjaGFyQ29kZSA9IHRleHQuY2hhckNvZGVBdChqKTtcbiAgICAgICAgdmFyIGNoYXJQZXEgPSB2b2lkIDA7XG4gICAgICAgIGlmIChjaGFyQ29kZSA8IGFzY2lpUGVxLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gRmFzdCBhcnJheSBsb29rdXAuXG4gICAgICAgICAgICBjaGFyUGVxID0gYXNjaWlQZXFbY2hhckNvZGVdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gU2xvd2VyIGhhc2ggdGFibGUgbG9va3VwLlxuICAgICAgICAgICAgY2hhclBlcSA9IHBlcS5nZXQoY2hhckNvZGUpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjaGFyUGVxID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgY2hhclBlcSA9IGVtcHR5UGVxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIENhbGN1bGF0ZSBlcnJvciBjb3VudCBmb3IgYmxvY2tzIHRoYXQgd2UgZGVmaW5pdGVseSBoYXZlIHRvIHByb2Nlc3MgZm9yXG4gICAgICAgIC8vIHRoaXMgY29sdW1uLlxuICAgICAgICB2YXIgY2FycnkgPSAwO1xuICAgICAgICBmb3IgKHZhciBiID0gMDsgYiA8PSB5OyBiICs9IDEpIHtcbiAgICAgICAgICAgIGNhcnJ5ID0gYWR2YW5jZUJsb2NrKGN0eCwgY2hhclBlcSwgYiwgY2FycnkpO1xuICAgICAgICAgICAgc2NvcmVbYl0gKz0gY2Fycnk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgaWYgd2UgYWxzbyBuZWVkIHRvIGNvbXB1dGUgYW4gYWRkaXRpb25hbCBibG9jaywgb3IgaWYgd2UgY2FuIHJlZHVjZVxuICAgICAgICAvLyB0aGUgbnVtYmVyIG9mIGJsb2NrcyBwcm9jZXNzZWQgZm9yIHRoZSBuZXh0IGNvbHVtbi5cbiAgICAgICAgaWYgKHNjb3JlW3ldIC0gY2FycnkgPD0gbWF4RXJyb3JzICYmXG4gICAgICAgICAgICB5IDwgYk1heCAmJlxuICAgICAgICAgICAgKGNoYXJQZXFbeSArIDFdICYgMSB8fCBjYXJyeSA8IDApKSB7XG4gICAgICAgICAgICAvLyBFcnJvciBjb3VudCBmb3IgYm90dG9tIGJsb2NrIGlzIHVuZGVyIHRocmVzaG9sZCwgaW5jcmVhc2UgdGhlIG51bWJlciBvZlxuICAgICAgICAgICAgLy8gYmxvY2tzIHByb2Nlc3NlZCBmb3IgdGhpcyBjb2x1bW4gJiBuZXh0IGJ5IDEuXG4gICAgICAgICAgICB5ICs9IDE7XG4gICAgICAgICAgICBjdHguUFt5XSA9IH4wO1xuICAgICAgICAgICAgY3R4Lk1beV0gPSAwO1xuICAgICAgICAgICAgdmFyIG1heEJsb2NrU2NvcmUgPSB5ID09PSBiTWF4ID8gcGF0dGVybi5sZW5ndGggJSB3IDogdztcbiAgICAgICAgICAgIHNjb3JlW3ldID1cbiAgICAgICAgICAgICAgICBzY29yZVt5IC0gMV0gK1xuICAgICAgICAgICAgICAgICAgICBtYXhCbG9ja1Njb3JlIC1cbiAgICAgICAgICAgICAgICAgICAgY2FycnkgK1xuICAgICAgICAgICAgICAgICAgICBhZHZhbmNlQmxvY2soY3R4LCBjaGFyUGVxLCB5LCBjYXJyeSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBFcnJvciBjb3VudCBmb3IgYm90dG9tIGJsb2NrIGV4Y2VlZHMgdGhyZXNob2xkLCByZWR1Y2UgdGhlIG51bWJlciBvZlxuICAgICAgICAgICAgLy8gYmxvY2tzIHByb2Nlc3NlZCBmb3IgdGhlIG5leHQgY29sdW1uLlxuICAgICAgICAgICAgd2hpbGUgKHkgPiAwICYmIHNjb3JlW3ldID49IG1heEVycm9ycyArIHcpIHtcbiAgICAgICAgICAgICAgICB5IC09IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgZXJyb3IgY291bnQgaXMgdW5kZXIgdGhyZXNob2xkLCByZXBvcnQgYSBtYXRjaC5cbiAgICAgICAgaWYgKHkgPT09IGJNYXggJiYgc2NvcmVbeV0gPD0gbWF4RXJyb3JzKSB7XG4gICAgICAgICAgICBpZiAoc2NvcmVbeV0gPCBtYXhFcnJvcnMpIHtcbiAgICAgICAgICAgICAgICAvLyBEaXNjYXJkIGFueSBlYXJsaWVyLCB3b3JzZSBtYXRjaGVzLlxuICAgICAgICAgICAgICAgIG1hdGNoZXMuc3BsaWNlKDAsIG1hdGNoZXMubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1hdGNoZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IC0xLFxuICAgICAgICAgICAgICAgIGVuZDogaiArIDEsXG4gICAgICAgICAgICAgICAgZXJyb3JzOiBzY29yZVt5XVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBCZWNhdXNlIGBzZWFyY2hgIG9ubHkgcmVwb3J0cyB0aGUgbWF0Y2hlcyB3aXRoIHRoZSBsb3dlc3QgZXJyb3IgY291bnQsXG4gICAgICAgICAgICAvLyB3ZSBjYW4gXCJyYXRjaGV0IGRvd25cIiB0aGUgbWF4IGVycm9yIHRocmVzaG9sZCB3aGVuZXZlciBhIG1hdGNoIGlzXG4gICAgICAgICAgICAvLyBlbmNvdW50ZXJlZCBhbmQgdGhlcmVieSBzYXZlIGEgc21hbGwgYW1vdW50IG9mIHdvcmsgZm9yIHRoZSByZW1haW5kZXJcbiAgICAgICAgICAgIC8vIG9mIHRoZSB0ZXh0LlxuICAgICAgICAgICAgbWF4RXJyb3JzID0gc2NvcmVbeV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1hdGNoZXM7XG59XG4vKipcbiAqIFNlYXJjaCBmb3IgbWF0Y2hlcyBmb3IgYHBhdHRlcm5gIGluIGB0ZXh0YCBhbGxvd2luZyB1cCB0byBgbWF4RXJyb3JzYCBlcnJvcnMuXG4gKlxuICogUmV0dXJucyB0aGUgc3RhcnQsIGFuZCBlbmQgcG9zaXRpb25zIGFuZCBlcnJvciBjb3VudHMgZm9yIGVhY2ggbG93ZXN0LWNvc3RcbiAqIG1hdGNoLiBPbmx5IHRoZSBcImJlc3RcIiBtYXRjaGVzIGFyZSByZXR1cm5lZC5cbiAqL1xuZnVuY3Rpb24gc2VhcmNoKHRleHQsIHBhdHRlcm4sIG1heEVycm9ycykge1xuICAgIHZhciBtYXRjaGVzID0gZmluZE1hdGNoRW5kcyh0ZXh0LCBwYXR0ZXJuLCBtYXhFcnJvcnMpO1xuICAgIHJldHVybiBmaW5kTWF0Y2hTdGFydHModGV4dCwgcGF0dGVybiwgbWF0Y2hlcyk7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBzZWFyY2g7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///89\n')},581:()=>{eval('//\n//  Copyright 2021 Readium Foundation. All rights reserved.\n//  Use of this source code is governed by the BSD-style license\n//  available in the top-level LICENSE file of the project.\n//\n\nwindow.addEventListener("DOMContentLoaded", function () {\n  // If we don\'t set the CSS cursor property to pointer, then the click events are not triggered pre-iOS 13.\n  document.body.style.cursor = "pointer";\n\n  document.addEventListener("click", onClick, false);\n});\n\nfunction onClick(event) {\n  if (!window.getSelection().isCollapsed) {\n    // There\'s an on-going selection, the tap will dismiss it so we don\'t forward it.\n    return;\n  }\n\n  // Send the tap data over the JS bridge even if it\'s been handled\n  // within the webview, so that it can be preserved and used\n  // by the WKNavigationDelegate if needed.\n  webkit.messageHandlers.tap.postMessage({\n    defaultPrevented: event.defaultPrevented,\n    screenX: event.screenX,\n    screenY: event.screenY,\n    clientX: event.clientX,\n    clientY: event.clientY,\n    targetElement: event.target.outerHTML,\n    interactiveElement: nearestInteractiveElement(event.target),\n  });\n\n  // We don\'t want to disable the default WebView behavior as it breaks some features without bringing any value.\n  //    event.stopPropagation();\n  //    event.preventDefault();\n}\n\n// See. https://github.com/JayPanoz/architecture/tree/touch-handling/misc/touch-handling\nfunction nearestInteractiveElement(element) {\n  var interactiveTags = [\n    "a",\n    "audio",\n    "button",\n    "canvas",\n    "details",\n    "input",\n    "label",\n    "option",\n    "select",\n    "submit",\n    "textarea",\n    "video",\n  ];\n  if (interactiveTags.indexOf(element.nodeName.toLowerCase()) !== -1) {\n    return element.outerHTML;\n  }\n\n  // Checks whether the element is editable by the user.\n  if (\n    element.hasAttribute("contenteditable") &&\n    element.getAttribute("contenteditable").toLowerCase() != "false"\n  ) {\n    return element.outerHTML;\n  }\n\n  // Checks parents recursively because the touch might be for example on an <em> inside a <a>.\n  if (element.parentElement) {\n    return nearestInteractiveElement(element.parentElement);\n  }\n\n  return null;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFkaXVtLWpzLy4vc3JjL2dlc3R1cmVzLmpzPzE0YzIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsImZpbGUiOiI1ODEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvL1xuLy8gIENvcHlyaWdodCAyMDIxIFJlYWRpdW0gRm91bmRhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSB0aGUgQlNELXN0eWxlIGxpY2Vuc2Vcbi8vICBhdmFpbGFibGUgaW4gdGhlIHRvcC1sZXZlbCBMSUNFTlNFIGZpbGUgb2YgdGhlIHByb2plY3QuXG4vL1xuXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgZnVuY3Rpb24gKCkge1xuICAvLyBJZiB3ZSBkb24ndCBzZXQgdGhlIENTUyBjdXJzb3IgcHJvcGVydHkgdG8gcG9pbnRlciwgdGhlbiB0aGUgY2xpY2sgZXZlbnRzIGFyZSBub3QgdHJpZ2dlcmVkIHByZS1pT1MgMTMuXG4gIGRvY3VtZW50LmJvZHkuc3R5bGUuY3Vyc29yID0gXCJwb2ludGVyXCI7XG5cbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIG9uQ2xpY2ssIGZhbHNlKTtcbn0pO1xuXG5mdW5jdGlvbiBvbkNsaWNrKGV2ZW50KSB7XG4gIGlmICghd2luZG93LmdldFNlbGVjdGlvbigpLmlzQ29sbGFwc2VkKSB7XG4gICAgLy8gVGhlcmUncyBhbiBvbi1nb2luZyBzZWxlY3Rpb24sIHRoZSB0YXAgd2lsbCBkaXNtaXNzIGl0IHNvIHdlIGRvbid0IGZvcndhcmQgaXQuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gU2VuZCB0aGUgdGFwIGRhdGEgb3ZlciB0aGUgSlMgYnJpZGdlIGV2ZW4gaWYgaXQncyBiZWVuIGhhbmRsZWRcbiAgLy8gd2l0aGluIHRoZSB3ZWJ2aWV3LCBzbyB0aGF0IGl0IGNhbiBiZSBwcmVzZXJ2ZWQgYW5kIHVzZWRcbiAgLy8gYnkgdGhlIFdLTmF2aWdhdGlvbkRlbGVnYXRlIGlmIG5lZWRlZC5cbiAgd2Via2l0Lm1lc3NhZ2VIYW5kbGVycy50YXAucG9zdE1lc3NhZ2Uoe1xuICAgIGRlZmF1bHRQcmV2ZW50ZWQ6IGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQsXG4gICAgc2NyZWVuWDogZXZlbnQuc2NyZWVuWCxcbiAgICBzY3JlZW5ZOiBldmVudC5zY3JlZW5ZLFxuICAgIGNsaWVudFg6IGV2ZW50LmNsaWVudFgsXG4gICAgY2xpZW50WTogZXZlbnQuY2xpZW50WSxcbiAgICB0YXJnZXRFbGVtZW50OiBldmVudC50YXJnZXQub3V0ZXJIVE1MLFxuICAgIGludGVyYWN0aXZlRWxlbWVudDogbmVhcmVzdEludGVyYWN0aXZlRWxlbWVudChldmVudC50YXJnZXQpLFxuICB9KTtcblxuICAvLyBXZSBkb24ndCB3YW50IHRvIGRpc2FibGUgdGhlIGRlZmF1bHQgV2ViVmlldyBiZWhhdmlvciBhcyBpdCBicmVha3Mgc29tZSBmZWF0dXJlcyB3aXRob3V0IGJyaW5naW5nIGFueSB2YWx1ZS5cbiAgLy8gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIC8vICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG59XG5cbi8vIFNlZS4gaHR0cHM6Ly9naXRodWIuY29tL0pheVBhbm96L2FyY2hpdGVjdHVyZS90cmVlL3RvdWNoLWhhbmRsaW5nL21pc2MvdG91Y2gtaGFuZGxpbmdcbmZ1bmN0aW9uIG5lYXJlc3RJbnRlcmFjdGl2ZUVsZW1lbnQoZWxlbWVudCkge1xuICB2YXIgaW50ZXJhY3RpdmVUYWdzID0gW1xuICAgIFwiYVwiLFxuICAgIFwiYXVkaW9cIixcbiAgICBcImJ1dHRvblwiLFxuICAgIFwiY2FudmFzXCIsXG4gICAgXCJkZXRhaWxzXCIsXG4gICAgXCJpbnB1dFwiLFxuICAgIFwibGFiZWxcIixcbiAgICBcIm9wdGlvblwiLFxuICAgIFwic2VsZWN0XCIsXG4gICAgXCJzdWJtaXRcIixcbiAgICBcInRleHRhcmVhXCIsXG4gICAgXCJ2aWRlb1wiLFxuICBdO1xuICBpZiAoaW50ZXJhY3RpdmVUYWdzLmluZGV4T2YoZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKSAhPT0gLTEpIHtcbiAgICByZXR1cm4gZWxlbWVudC5vdXRlckhUTUw7XG4gIH1cblxuICAvLyBDaGVja3Mgd2hldGhlciB0aGUgZWxlbWVudCBpcyBlZGl0YWJsZSBieSB0aGUgdXNlci5cbiAgaWYgKFxuICAgIGVsZW1lbnQuaGFzQXR0cmlidXRlKFwiY29udGVudGVkaXRhYmxlXCIpICYmXG4gICAgZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJjb250ZW50ZWRpdGFibGVcIikudG9Mb3dlckNhc2UoKSAhPSBcImZhbHNlXCJcbiAgKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQub3V0ZXJIVE1MO1xuICB9XG5cbiAgLy8gQ2hlY2tzIHBhcmVudHMgcmVjdXJzaXZlbHkgYmVjYXVzZSB0aGUgdG91Y2ggbWlnaHQgYmUgZm9yIGV4YW1wbGUgb24gYW4gPGVtPiBpbnNpZGUgYSA8YT4uXG4gIGlmIChlbGVtZW50LnBhcmVudEVsZW1lbnQpIHtcbiAgICByZXR1cm4gbmVhcmVzdEludGVyYWN0aXZlRWxlbWVudChlbGVtZW50LnBhcmVudEVsZW1lbnQpO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///581\n')},990:(__unused_webpack_module,__unused_webpack___webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXTERNAL MODULE: ./src/gestures.js\nvar gestures = __webpack_require__(581);\n// EXTERNAL MODULE: ./node_modules/approx-string-match/dist/index.js\nvar dist = __webpack_require__(89);\n;// CONCATENATED MODULE: ./src/vendor/hypothesis/anchoring/match-quote.js\n\n\n/**\n * @typedef {import(\'approx-string-match\').Match} StringMatch\n */\n\n/**\n * @typedef Match\n * @prop {number} start - Start offset of match in text\n * @prop {number} end - End offset of match in text\n * @prop {number} score -\n *   Score for the match between 0 and 1.0, where 1.0 indicates a perfect match\n *   for the quote and context.\n */\n\n/**\n * Find the best approximate matches for `str` in `text` allowing up to `maxErrors` errors.\n *\n * @param {string} text\n * @param {string} str\n * @param {number} maxErrors\n * @return {StringMatch[]}\n */\nfunction search(text, str, maxErrors) {\n  // Do a fast search for exact matches. The `approx-string-match` library\n  // doesn\'t currently incorporate this optimization itself.\n  let matchPos = 0;\n  let exactMatches = [];\n  while (matchPos !== -1) {\n    matchPos = text.indexOf(str, matchPos);\n    if (matchPos !== -1) {\n      exactMatches.push({\n        start: matchPos,\n        end: matchPos + str.length,\n        errors: 0,\n      });\n      matchPos += 1;\n    }\n  }\n  if (exactMatches.length > 0) {\n    return exactMatches;\n  }\n\n  // If there are no exact matches, do a more expensive search for matches\n  // with errors.\n  return (0,dist/* default */.Z)(text, str, maxErrors);\n}\n\n/**\n * Compute a score between 0 and 1.0 for the similarity between `text` and `str`.\n *\n * @param {string} text\n * @param {string} str\n */\nfunction textMatchScore(text, str) {\n  /* istanbul ignore next - `scoreMatch` will never pass an empty string */\n  if (str.length === 0 || text.length === 0) {\n    return 0.0;\n  }\n  const matches = search(text, str, str.length);\n\n  // prettier-ignore\n  return 1 - (matches[0].errors / str.length);\n}\n\n/**\n * Find the best approximate match for `quote` in `text`.\n *\n * Returns `null` if no match exceeding the minimum quality threshold was found.\n *\n * @param {string} text - Document text to search\n * @param {string} quote - String to find within `text`\n * @param {Object} context -\n *   Context in which the quote originally appeared. This is used to choose the\n *   best match.\n *   @param {string} [context.prefix] - Expected text before the quote\n *   @param {string} [context.suffix] - Expected text after the quote\n *   @param {number} [context.hint] - Expected offset of match within text\n * @return {Match|null}\n */\nfunction matchQuote(text, quote, context = {}) {\n  if (quote.length === 0) {\n    return null;\n  }\n\n  // Choose the maximum number of errors to allow for the initial search.\n  // This choice involves a tradeoff between:\n  //\n  //  - Recall (proportion of "good" matches found)\n  //  - Precision (proportion of matches found which are "good")\n  //  - Cost of the initial search and of processing the candidate matches [1]\n  //\n  // [1] Specifically, the expected-time complexity of the initial search is\n  //     `O((maxErrors / 32) * text.length)`. See `approx-string-match` docs.\n  const maxErrors = Math.min(256, quote.length / 2);\n\n  // Find closest matches for `quote` in `text` based on edit distance.\n  const matches = search(text, quote, maxErrors);\n\n  if (matches.length === 0) {\n    return null;\n  }\n\n  /**\n   * Compute a score between 0 and 1.0 for a match candidate.\n   *\n   * @param {StringMatch} match\n   */\n  const scoreMatch = match => {\n    const quoteWeight = 50; // Similarity of matched text to quote.\n    const prefixWeight = 20; // Similarity of text before matched text to `context.prefix`.\n    const suffixWeight = 20; // Similarity of text after matched text to `context.suffix`.\n    const posWeight = 2; // Proximity to expected location. Used as a tie-breaker.\n\n    const quoteScore = 1 - match.errors / quote.length;\n\n    const prefixScore = context.prefix\n      ? textMatchScore(\n          text.slice(Math.max(0, match.start - context.prefix.length), match.start),\n          context.prefix\n        )\n      : 1.0;\n    const suffixScore = context.suffix\n      ? textMatchScore(\n          text.slice(match.end, match.end + context.suffix.length),\n          context.suffix\n        )\n      : 1.0;\n\n    let posScore = 1.0;\n    if (typeof context.hint === \'number\') {\n      const offset = Math.abs(match.start - context.hint);\n      posScore = 1.0 - offset / text.length;\n    }\n\n    const rawScore =\n      quoteWeight * quoteScore +\n      prefixWeight * prefixScore +\n      suffixWeight * suffixScore +\n      posWeight * posScore;\n    const maxScore = quoteWeight + prefixWeight + suffixWeight + posWeight;\n    const normalizedScore = rawScore / maxScore;\n\n    return normalizedScore;\n  };\n\n  // Rank matches based on similarity of actual and expected surrounding text\n  // and actual/expected offset in the document text.\n  const scoredMatches = matches.map(m => ({\n    start: m.start,\n    end: m.end,\n    score: scoreMatch(m),\n  }));\n\n  // Choose match with highest score.\n  scoredMatches.sort((a, b) => b.score - a.score);\n  return scoredMatches[0];\n}\n\n;// CONCATENATED MODULE: ./src/vendor/hypothesis/anchoring/text-range.js\n/**\n * Return the combined length of text nodes contained in `node`.\n *\n * @param {Node} node\n */\nfunction nodeTextLength(node) {\n  switch (node.nodeType) {\n    case Node.ELEMENT_NODE:\n    case Node.TEXT_NODE:\n      // nb. `textContent` excludes text in comments and processing instructions\n      // when called on a parent element, so we don\'t need to subtract that here.\n\n      return /** @type {string} */ (node.textContent).length;\n    default:\n      return 0;\n  }\n}\n\n/**\n * Return the total length of the text of all previous siblings of `node`.\n *\n * @param {Node} node\n */\nfunction previousSiblingsTextLength(node) {\n  let sibling = node.previousSibling;\n  let length = 0;\n  while (sibling) {\n    length += nodeTextLength(sibling);\n    sibling = sibling.previousSibling;\n  }\n  return length;\n}\n\n/**\n * Resolve one or more character offsets within an element to (text node, position)\n * pairs.\n *\n * @param {Element} element\n * @param {number[]} offsets - Offsets, which must be sorted in ascending order\n * @return {{ node: Text, offset: number }[]}\n */\nfunction resolveOffsets(element, ...offsets) {\n  let nextOffset = offsets.shift();\n  const nodeIter = /** @type {Document} */ (\n    element.ownerDocument\n  ).createNodeIterator(element, NodeFilter.SHOW_TEXT);\n  const results = [];\n\n  let currentNode = nodeIter.nextNode();\n  let textNode;\n  let length = 0;\n\n  // Find the text node containing the `nextOffset`th character from the start\n  // of `element`.\n  while (nextOffset !== undefined && currentNode) {\n    textNode = /** @type {Text} */ (currentNode);\n    if (length + textNode.data.length > nextOffset) {\n      results.push({ node: textNode, offset: nextOffset - length });\n      nextOffset = offsets.shift();\n    } else {\n      currentNode = nodeIter.nextNode();\n      length += textNode.data.length;\n    }\n  }\n\n  // Boundary case.\n  while (nextOffset !== undefined && textNode && length === nextOffset) {\n    results.push({ node: textNode, offset: textNode.data.length });\n    nextOffset = offsets.shift();\n  }\n\n  if (nextOffset !== undefined) {\n    throw new RangeError(\'Offset exceeds text length\');\n  }\n\n  return results;\n}\n\nlet RESOLVE_FORWARDS = 1;\nlet RESOLVE_BACKWARDS = 2;\n\n/**\n * Represents an offset within the text content of an element.\n *\n * This position can be resolved to a specific descendant node in the current\n * DOM subtree of the element using the `resolve` method.\n */\nclass text_range_TextPosition {\n  /**\n   * Construct a `TextPosition` that refers to the text position `offset` within\n   * the text content of `element`.\n   *\n   * @param {Element} element\n   * @param {number} offset\n   */\n  constructor(element, offset) {\n    if (offset < 0) {\n      throw new Error(\'Offset is invalid\');\n    }\n\n    /** Element that `offset` is relative to. */\n    this.element = element;\n\n    /** Character offset from the start of the element\'s `textContent`. */\n    this.offset = offset;\n  }\n\n  /**\n   * Return a copy of this position with offset relative to a given ancestor\n   * element.\n   *\n   * @param {Element} parent - Ancestor of `this.element`\n   * @return {TextPosition}\n   */\n  relativeTo(parent) {\n    if (!parent.contains(this.element)) {\n      throw new Error(\'Parent is not an ancestor of current element\');\n    }\n\n    let el = this.element;\n    let offset = this.offset;\n    while (el !== parent) {\n      offset += previousSiblingsTextLength(el);\n      el = /** @type {Element} */ (el.parentElement);\n    }\n\n    return new text_range_TextPosition(el, offset);\n  }\n\n  /**\n   * Resolve the position to a specific text node and offset within that node.\n   *\n   * Throws if `this.offset` exceeds the length of the element\'s text. In the\n   * case where the element has no text and `this.offset` is 0, the `direction`\n   * option determines what happens.\n   *\n   * Offsets at the boundary between two nodes are resolved to the start of the\n   * node that begins at the boundary.\n   *\n   * @param {Object} [options]\n   *   @param {RESOLVE_FORWARDS|RESOLVE_BACKWARDS} [options.direction] -\n   *     Specifies in which direction to search for the nearest text node if\n   *     `this.offset` is `0` and `this.element` has no text. If not specified\n   *     an error is thrown.\n   * @return {{ node: Text, offset: number }}\n   * @throws {RangeError}\n   */\n  resolve(options = {}) {\n    try {\n      return resolveOffsets(this.element, this.offset)[0];\n    } catch (err) {\n      if (this.offset === 0 && options.direction !== undefined) {\n        const tw = document.createTreeWalker(\n          this.element.getRootNode(),\n          NodeFilter.SHOW_TEXT\n        );\n        tw.currentNode = this.element;\n        const forwards = options.direction === RESOLVE_FORWARDS;\n        const text = /** @type {Text|null} */ (\n          forwards ? tw.nextNode() : tw.previousNode()\n        );\n        if (!text) {\n          throw err;\n        }\n        return { node: text, offset: forwards ? 0 : text.data.length };\n      } else {\n        throw err;\n      }\n    }\n  }\n\n  /**\n   * Construct a `TextPosition` that refers to the `offset`th character within\n   * `node`.\n   *\n   * @param {Node} node\n   * @param {number} offset\n   * @return {TextPosition}\n   */\n  static fromCharOffset(node, offset) {\n    switch (node.nodeType) {\n      case Node.TEXT_NODE:\n        return text_range_TextPosition.fromPoint(node, offset);\n      case Node.ELEMENT_NODE:\n        return new text_range_TextPosition(/** @type {Element} */ (node), offset);\n      default:\n        throw new Error(\'Node is not an element or text node\');\n    }\n  }\n\n  /**\n   * Construct a `TextPosition` representing the range start or end point (node, offset).\n   *\n   * @param {Node} node - Text or Element node\n   * @param {number} offset - Offset within the node.\n   * @return {TextPosition}\n   */\n  static fromPoint(node, offset) {\n    switch (node.nodeType) {\n      case Node.TEXT_NODE: {\n        if (offset < 0 || offset > /** @type {Text} */ (node).data.length) {\n          throw new Error(\'Text node offset is out of range\');\n        }\n\n        if (!node.parentElement) {\n          throw new Error(\'Text node has no parent\');\n        }\n\n        // Get the offset from the start of the parent element.\n        const textOffset = previousSiblingsTextLength(node) + offset;\n\n        return new text_range_TextPosition(node.parentElement, textOffset);\n      }\n      case Node.ELEMENT_NODE: {\n        if (offset < 0 || offset > node.childNodes.length) {\n          throw new Error(\'Child node offset is out of range\');\n        }\n\n        // Get the text length before the `offset`th child of element.\n        let textOffset = 0;\n        for (let i = 0; i < offset; i++) {\n          textOffset += nodeTextLength(node.childNodes[i]);\n        }\n\n        return new text_range_TextPosition(/** @type {Element} */ (node), textOffset);\n      }\n      default:\n        throw new Error(\'Point is not in an element or text node\');\n    }\n  }\n}\n\n/**\n * Represents a region of a document as a (start, end) pair of `TextPosition` points.\n *\n * Representing a range in this way allows for changes in the DOM content of the\n * range which don\'t affect its text content, without affecting the text content\n * of the range itself.\n */\nclass text_range_TextRange {\n  /**\n   * Construct an immutable `TextRange` from a `start` and `end` point.\n   *\n   * @param {TextPosition} start\n   * @param {TextPosition} end\n   */\n  constructor(start, end) {\n    this.start = start;\n    this.end = end;\n  }\n\n  /**\n   * Return a copy of this range with start and end positions relative to a\n   * given ancestor. See `TextPosition.relativeTo`.\n   *\n   * @param {Element} element\n   */\n  relativeTo(element) {\n    return new text_range_TextRange(\n      this.start.relativeTo(element),\n      this.end.relativeTo(element)\n    );\n  }\n\n  /**\n   * Resolve the `TextRange` to a DOM range.\n   *\n   * The resulting DOM Range will always start and end in a `Text` node.\n   * Hence `TextRange.fromRange(range).toRange()` can be used to "shrink" a\n   * range to the text it contains.\n   *\n   * May throw if the `start` or `end` positions cannot be resolved to a range.\n   *\n   * @return {Range}\n   */\n  toRange() {\n    let start;\n    let end;\n\n    if (\n      this.start.element === this.end.element &&\n      this.start.offset <= this.end.offset\n    ) {\n      // Fast path for start and end points in same element.\n      [start, end] = resolveOffsets(\n        this.start.element,\n        this.start.offset,\n        this.end.offset\n      );\n    } else {\n      start = this.start.resolve({ direction: RESOLVE_FORWARDS });\n      end = this.end.resolve({ direction: RESOLVE_BACKWARDS });\n    }\n\n    const range = new Range();\n    range.setStart(start.node, start.offset);\n    range.setEnd(end.node, end.offset);\n    return range;\n  }\n\n  /**\n   * Convert an existing DOM `Range` to a `TextRange`\n   *\n   * @param {Range} range\n   * @return {TextRange}\n   */\n  static fromRange(range) {\n    const start = text_range_TextPosition.fromPoint(\n      range.startContainer,\n      range.startOffset\n    );\n    const end = text_range_TextPosition.fromPoint(range.endContainer, range.endOffset);\n    return new text_range_TextRange(start, end);\n  }\n\n  /**\n   * Return a `TextRange` from the `start`th to `end`th characters in `root`.\n   *\n   * @param {Element} root\n   * @param {number} start\n   * @param {number} end\n   */\n  static fromOffsets(root, start, end) {\n    return new text_range_TextRange(\n      new text_range_TextPosition(root, start),\n      new text_range_TextPosition(root, end)\n    );\n  }\n}\n\n;// CONCATENATED MODULE: ./src/vendor/hypothesis/anchoring/types.js\n/**\n * This module exports a set of classes for converting between DOM `Range`\n * objects and different types of selectors. It is mostly a thin wrapper around a\n * set of anchoring libraries. It serves two main purposes:\n *\n *  1. Providing a consistent interface across different types of anchors.\n *  2. Insulating the rest of the code from API changes in the underlying anchoring\n *     libraries.\n */\n\n\n\n\n\n/**\n * @typedef {import(\'../../types/api\').RangeSelector} RangeSelector\n * @typedef {import(\'../../types/api\').TextPositionSelector} TextPositionSelector\n * @typedef {import(\'../../types/api\').TextQuoteSelector} TextQuoteSelector\n */\n\n/**\n * Converts between `RangeSelector` selectors and `Range` objects.\n */\nclass RangeAnchor {\n  /**\n   * @param {Node} root - A root element from which to anchor.\n   * @param {Range} range -  A range describing the anchor.\n   */\n  constructor(root, range) {\n    this.root = root;\n    this.range = range;\n  }\n\n  /**\n   * @param {Node} root -  A root element from which to anchor.\n   * @param {Range} range -  A range describing the anchor.\n   */\n  static fromRange(root, range) {\n    return new RangeAnchor(root, range);\n  }\n\n  /**\n   * Create an anchor from a serialized `RangeSelector` selector.\n   *\n   * @param {Element} root -  A root element from which to anchor.\n   * @param {RangeSelector} selector\n   */\n  static fromSelector(root, selector) {\n    const startContainer = nodeFromXPath(selector.startContainer, root);\n    if (!startContainer) {\n      throw new Error(\'Failed to resolve startContainer XPath\');\n    }\n\n    const endContainer = nodeFromXPath(selector.endContainer, root);\n    if (!endContainer) {\n      throw new Error(\'Failed to resolve endContainer XPath\');\n    }\n\n    const startPos = TextPosition.fromCharOffset(\n      startContainer,\n      selector.startOffset\n    );\n    const endPos = TextPosition.fromCharOffset(\n      endContainer,\n      selector.endOffset\n    );\n\n    const range = new TextRange(startPos, endPos).toRange();\n    return new RangeAnchor(root, range);\n  }\n\n  toRange() {\n    return this.range;\n  }\n\n  /**\n   * @return {RangeSelector}\n   */\n  toSelector() {\n    // "Shrink" the range so that it tightly wraps its text. This ensures more\n    // predictable output for a given text selection.\n    const normalizedRange = TextRange.fromRange(this.range).toRange();\n\n    const textRange = TextRange.fromRange(normalizedRange);\n    const startContainer = xpathFromNode(textRange.start.element, this.root);\n    const endContainer = xpathFromNode(textRange.end.element, this.root);\n\n    return {\n      type: \'RangeSelector\',\n      startContainer,\n      startOffset: textRange.start.offset,\n      endContainer,\n      endOffset: textRange.end.offset,\n    };\n  }\n}\n\n/**\n * Converts between `TextPositionSelector` selectors and `Range` objects.\n */\nclass TextPositionAnchor {\n  /**\n   * @param {Element} root\n   * @param {number} start\n   * @param {number} end\n   */\n  constructor(root, start, end) {\n    this.root = root;\n    this.start = start;\n    this.end = end;\n  }\n\n  /**\n   * @param {Element} root\n   * @param {Range} range\n   */\n  static fromRange(root, range) {\n    const textRange = text_range_TextRange.fromRange(range).relativeTo(root);\n    return new TextPositionAnchor(\n      root,\n      textRange.start.offset,\n      textRange.end.offset\n    );\n  }\n  /**\n   * @param {Element} root\n   * @param {TextPositionSelector} selector\n   */\n  static fromSelector(root, selector) {\n    return new TextPositionAnchor(root, selector.start, selector.end);\n  }\n\n  /**\n   * @return {TextPositionSelector}\n   */\n  toSelector() {\n    return {\n      type: \'TextPositionSelector\',\n      start: this.start,\n      end: this.end,\n    };\n  }\n\n  toRange() {\n    return text_range_TextRange.fromOffsets(this.root, this.start, this.end).toRange();\n  }\n}\n\n/**\n * @typedef QuoteMatchOptions\n * @prop {number} [hint] - Expected position of match in text. See `matchQuote`.\n */\n\n/**\n * Converts between `TextQuoteSelector` selectors and `Range` objects.\n */\nclass types_TextQuoteAnchor {\n  /**\n   * @param {Element} root - A root element from which to anchor.\n   * @param {string} exact\n   * @param {Object} context\n   *   @param {string} [context.prefix]\n   *   @param {string} [context.suffix]\n   */\n  constructor(root, exact, context = {}) {\n    this.root = root;\n    this.exact = exact;\n    this.context = context;\n  }\n\n  /**\n   * Create a `TextQuoteAnchor` from a range.\n   *\n   * Will throw if `range` does not contain any text nodes.\n   *\n   * @param {Element} root\n   * @param {Range} range\n   */\n  static fromRange(root, range) {\n    const text = /** @type {string} */ (root.textContent);\n    const textRange = text_range_TextRange.fromRange(range).relativeTo(root);\n\n    const start = textRange.start.offset;\n    const end = textRange.end.offset;\n\n    // Number of characters around the quote to capture as context. We currently\n    // always use a fixed amount, but it would be better if this code was aware\n    // of logical boundaries in the document (paragraph, article etc.) to avoid\n    // capturing text unrelated to the quote.\n    //\n    // In regular prose the ideal content would often be the surrounding sentence.\n    // This is a natural unit of meaning which enables displaying quotes in\n    // context even when the document is not available. We could use `Intl.Segmenter`\n    // for this when available.\n    const contextLen = 32;\n\n    return new types_TextQuoteAnchor(root, text.slice(start, end), {\n      prefix: text.slice(Math.max(0, start - contextLen), start),\n      suffix: text.slice(end, Math.min(text.length, end + contextLen)),\n    });\n  }\n\n  /**\n   * @param {Element} root\n   * @param {TextQuoteSelector} selector\n   */\n  static fromSelector(root, selector) {\n    const { prefix, suffix } = selector;\n    return new types_TextQuoteAnchor(root, selector.exact, { prefix, suffix });\n  }\n\n  /**\n   * @return {TextQuoteSelector}\n   */\n  toSelector() {\n    return {\n      type: \'TextQuoteSelector\',\n      exact: this.exact,\n      prefix: this.context.prefix,\n      suffix: this.context.suffix,\n    };\n  }\n\n  /**\n   * @param {QuoteMatchOptions} [options]\n   */\n  toRange(options = {}) {\n    return this.toPositionAnchor(options).toRange();\n  }\n\n  /**\n   * @param {QuoteMatchOptions} [options]\n   */\n  toPositionAnchor(options = {}) {\n    const text = /** @type {string} */ (this.root.textContent);\n    const match = matchQuote(text, this.exact, {\n      ...this.context,\n      hint: options.hint,\n    });\n    if (!match) {\n      throw new Error(\'Quote not found\');\n    }\n    return new TextPositionAnchor(this.root, match.start, match.end);\n  }\n}\n\n;// CONCATENATED MODULE: ./src/utils.js\n//\n//  Copyright 2021 Readium Foundation. All rights reserved.\n//  Use of this source code is governed by the BSD-style license\n//  available in the top-level LICENSE file of the project.\n//\n\n// Catch JS errors to log them in the app.\n\n\n\nwindow.addEventListener(\n  "error",\n  function (event) {\n    webkit.messageHandlers.logError.postMessage({\n      message: event.message,\n      filename: event.filename,\n      line: event.lineno,\n    });\n  },\n  false\n);\n\n// Notify native code that the page has loaded.\nwindow.addEventListener(\n  "load",\n  function () {\n    // on page load\n    window.addEventListener("orientationchange", function () {\n      orientationChanged();\n      snapCurrentPosition();\n    });\n    orientationChanged();\n  },\n  false\n);\n\nvar last_known_scrollX_position = 0;\nvar last_known_scrollY_position = 0;\nvar ticking = false;\nvar maxScreenX = 0;\n\n// Position in range [0 - 1].\nfunction update(position) {\n  var positionString = position.toString();\n  webkit.messageHandlers.progressionChanged.postMessage(positionString);\n}\n\nwindow.addEventListener("scroll", function () {\n  last_known_scrollY_position =\n    window.scrollY / document.scrollingElement.scrollHeight;\n  // Using Math.abs because for RTL books, the value will be negative.\n  last_known_scrollX_position = Math.abs(\n    window.scrollX / document.scrollingElement.scrollWidth\n  );\n\n  // Window is hidden\n  if (\n    document.scrollingElement.scrollWidth === 0 ||\n    document.scrollingElement.scrollHeight === 0\n  ) {\n    return;\n  }\n\n  if (!ticking) {\n    window.requestAnimationFrame(function () {\n      update(\n        isScrollModeEnabled()\n          ? last_known_scrollY_position\n          : last_known_scrollX_position\n      );\n      ticking = false;\n    });\n  }\n  ticking = true;\n});\n\ndocument.addEventListener(\n  "selectionchange",\n  debounce(50, function () {\n    var info = {};\n    var selection = document.getSelection();\n    if (selection && selection.rangeCount > 0) {\n      var rect = selection.getRangeAt(0).getBoundingClientRect();\n      info["text"] = selection.toString().trim();\n      info["frame"] = {\n        x: rect.left,\n        y: rect.top,\n        width: rect.width,\n        height: rect.height,\n      };\n    }\n\n    webkit.messageHandlers.selectionChanged.postMessage(info);\n  })\n);\n\nfunction orientationChanged() {\n  maxScreenX =\n    window.orientation === 0 || window.orientation == 180\n      ? screen.width\n      : screen.height;\n}\n\nfunction isScrollModeEnabled() {\n  return (\n    document.documentElement.style\n      .getPropertyValue("--USER__scroll")\n      .toString()\n      .trim() === "readium-scroll-on"\n  );\n}\n\n// Scroll to the given TagId in document and snap.\nfunction scrollToId(id) {\n  var element = document.getElementById(id);\n  if (!element) {\n    return false;\n  }\n  element.scrollIntoView();\n\n  if (!isScrollModeEnabled()) {\n    var currentOffset = window.scrollX;\n    var pageWidth = window.innerWidth;\n    // Adds half a page to make sure we don\'t snap to the previous page.\n    document.scrollingElement.scrollLeft = snapOffset(\n      currentOffset + pageWidth / 2\n    );\n  }\n  return true;\n}\n\n// Position must be in the range [0 - 1], 0-100%.\nfunction scrollToPosition(position, dir) {\n  console.log("ScrollToPosition");\n  if (position < 0 || position > 1) {\n    console.log("InvalidPosition");\n    return;\n  }\n\n  if (isScrollModeEnabled()) {\n    let offset = document.scrollingElement.scrollHeight * position;\n    document.scrollingElement.scrollTop = offset;\n    // window.scrollTo(0, offset);\n  } else {\n    var documentWidth = document.scrollingElement.scrollWidth;\n    var factor = dir == "rtl" ? -1 : 1;\n    let offset = documentWidth * position * factor;\n    document.scrollingElement.scrollLeft = snapOffset(offset);\n  }\n}\n\n// Scrolls to the first occurrence of the given text snippet.\n//\n// The expected text argument is a Locator Text object, as defined here:\n// https://readium.org/architecture/models/locators/\nfunction scrollToText(text) {\n  let range = rangeFromLocator({ text });\n  if (!range) {\n    return false;\n  }\n  scrollToRange(range);\n  return true;\n}\n\nfunction scrollToRange(range) {\n  var rect = range.getBoundingClientRect();\n  if (isScrollModeEnabled()) {\n    document.scrollingElement.scrollTop =\n      rect.top + window.scrollY - window.innerHeight / 2;\n  } else {\n    document.scrollingElement.scrollLeft = rect.left + window.scrollX;\n    snapCurrentPosition();\n  }\n}\n\n// Returns false if the page is already at the left-most scroll offset.\nfunction scrollLeft(dir) {\n  var isRTL = dir == "rtl";\n  var documentWidth = document.scrollingElement.scrollWidth;\n  var pageWidth = window.innerWidth;\n  var offset = window.scrollX - pageWidth;\n  var minOffset = isRTL ? -(documentWidth - pageWidth) : 0;\n  return scrollToOffset(Math.max(offset, minOffset));\n}\n\n// Returns false if the page is already at the right-most scroll offset.\nfunction scrollRight(dir) {\n  var isRTL = dir == "rtl";\n  var documentWidth = document.scrollingElement.scrollWidth;\n  var pageWidth = window.innerWidth;\n  var offset = window.scrollX + pageWidth;\n  var maxOffset = isRTL ? 0 : documentWidth - pageWidth;\n  return scrollToOffset(Math.min(offset, maxOffset));\n}\n\n// Scrolls to the given left offset.\n// Returns false if the page scroll position is already close enough to the given offset.\nfunction scrollToOffset(offset) {\n  var currentOffset = window.scrollX;\n  var pageWidth = window.innerWidth;\n  document.scrollingElement.scrollLeft = offset;\n  // In some case the scrollX cannot reach the position respecting to innerWidth\n  var diff = Math.abs(currentOffset - offset) / pageWidth;\n  return diff > 0.01;\n}\n\n// Snap the offset to the screen width (page width).\nfunction snapOffset(offset) {\n  var value = offset + 1;\n\n  return value - (value % maxScreenX);\n}\n\nfunction snapCurrentPosition() {\n  if (isScrollModeEnabled()) {\n    return;\n  }\n  var currentOffset = window.scrollX;\n  var currentOffsetSnapped = snapOffset(currentOffset + 1);\n\n  document.scrollingElement.scrollLeft = currentOffsetSnapped;\n}\n\nfunction rangeFromLocator(locator) {\n  let text = locator.text;\n  if (!text || !text.highlight) {\n    return null;\n  }\n  try {\n    let anchor = new types_TextQuoteAnchor(document.body, text.highlight, {\n      prefix: text.before,\n      suffix: text.after,\n    });\n    return anchor.toRange();\n  } catch (e) {\n    utils_logException(e);\n    return null;\n  }\n}\n\n/// User Settings.\n\n// For setting user setting.\nfunction setProperty(key, value) {\n  var root = document.documentElement;\n\n  root.style.setProperty(key, value);\n}\n\n// For removing user setting.\nfunction removeProperty(key) {\n  var root = document.documentElement;\n\n  root.style.removeProperty(key);\n}\n\n/// Toolkit\n\nfunction debounce(delay, func) {\n  var timeout;\n  return function () {\n    var self = this;\n    var args = arguments;\n    function callback() {\n      func.apply(self, args);\n      timeout = null;\n    }\n    clearTimeout(timeout);\n    timeout = setTimeout(callback, delay);\n  };\n}\n\nfunction log() {\n  var message = Array.prototype.slice.call(arguments).join(" ");\n  webkit.messageHandlers.log.postMessage(message);\n}\n\nfunction utils_logException(e) {\n  webkit.messageHandlers.logError.postMessage({\n    message: e.message,\n  });\n}\n\n;// CONCATENATED MODULE: ./src/selection.js\n//\n//  Copyright 2021 Readium Foundation. All rights reserved.\n//  Use of this source code is governed by the BSD-style license\n//  available in the top-level LICENSE file of the project.\n//\n\n\n\n\nconst debug = true;\n\nfunction getSelectionRect() {\n  try {\n    let sel = window.getSelection();\n    if (!sel) {\n      return;\n    }\n    let range = sel.getRangeAt(0);\n\n    const clientRect = range.getBoundingClientRect();\n\n    return {\n      screenWidth: window.outerWidth,\n      screenHeight: window.outerHeight,\n      left: clientRect.left,\n      width: clientRect.width,\n      top: clientRect.top,\n      height: clientRect.height,\n    };\n  } catch (e) {\n    utils_logException(e);\n    return null;\n  }\n}\n\nfunction getCurrentSelectionInfo() {\n  const selection = window.getSelection();\n  if (!selection) {\n    return undefined;\n  }\n  if (selection.isCollapsed) {\n    selection_log("^^^ SELECTION COLLAPSED.");\n    return undefined;\n  }\n  const rawText = selection.toString();\n  const cleanText = rawText.trim().replace(/\\n/g, " ").replace(/\\s\\s+/g, " ");\n  if (cleanText.length === 0) {\n    selection_log("^^^ SELECTION TEXT EMPTY.");\n    return undefined;\n  }\n  if (!selection.anchorNode || !selection.focusNode) {\n    return undefined;\n  }\n  const range =\n    selection.rangeCount === 1\n      ? selection.getRangeAt(0)\n      : createOrderedRange(\n          selection.anchorNode,\n          selection.anchorOffset,\n          selection.focusNode,\n          selection.focusOffset\n        );\n  if (!range || range.collapsed) {\n    selection_log("$$$$$$$$$$$$$$$$$ CANNOT GET NON-COLLAPSED SELECTION RANGE?!");\n    return undefined;\n  }\n  const rangeInfo = convertRange(range, fullQualifiedSelector);\n  if (!rangeInfo) {\n    selection_log("^^^ SELECTION RANGE INFO FAIL?!");\n    return undefined;\n  }\n\n  const text = document.body.textContent;\n  const textRange = text_range_TextRange.fromRange(range).relativeTo(document.body);\n  const start = textRange.start.offset;\n  const end = textRange.end.offset;\n\n  const snippetLength = 200;\n\n  // Compute the text before the highlight, ignoring the first "word", which might be cut.\n  let before = text.slice(Math.max(0, start - snippetLength), start);\n  let firstWordStart = before.search(/\\P{L}\\p{L}/gu);\n  if (firstWordStart !== -1) {\n    before = before.slice(firstWordStart + 1);\n  }\n\n  // Compute the text after the highlight, ignoring the last "word", which might be cut.\n  let after = text.slice(end, Math.min(text.length, end + snippetLength));\n  let lastWordEnd = Array.from(after.matchAll(/\\p{L}\\P{L}/gu)).pop();\n  if (lastWordEnd !== undefined && lastWordEnd.index > 1) {\n    after = after.slice(0, lastWordEnd.index + 1);\n  }\n\n  return {\n    locations: rangeInfo2Location(rangeInfo),\n    text: {\n      highlight: rawText,\n      before: before,\n      after: after,\n    },\n  };\n}\n\nfunction createOrderedRange(startNode, startOffset, endNode, endOffset) {\n  const range = new Range();\n  range.setStart(startNode, startOffset);\n  range.setEnd(endNode, endOffset);\n  if (!range.collapsed) {\n    return range;\n  }\n  selection_log(">>> createOrderedRange COLLAPSED ... RANGE REVERSE?");\n  const rangeReverse = new Range();\n  rangeReverse.setStart(endNode, endOffset);\n  rangeReverse.setEnd(startNode, startOffset);\n  if (!rangeReverse.collapsed) {\n    selection_log(">>> createOrderedRange RANGE REVERSE OK.");\n    return range;\n  }\n  selection_log(">>> createOrderedRange RANGE REVERSE ALSO COLLAPSED?!");\n  return undefined;\n}\n\nfunction convertRange(range, getCssSelector) {\n  const startIsElement = range.startContainer.nodeType === Node.ELEMENT_NODE;\n  const startContainerElement = startIsElement\n    ? range.startContainer\n    : range.startContainer.parentNode &&\n      range.startContainer.parentNode.nodeType === Node.ELEMENT_NODE\n    ? range.startContainer.parentNode\n    : undefined;\n  if (!startContainerElement) {\n    return undefined;\n  }\n  const startContainerChildTextNodeIndex = startIsElement\n    ? -1\n    : Array.from(startContainerElement.childNodes).indexOf(\n        range.startContainer\n      );\n  if (startContainerChildTextNodeIndex < -1) {\n    return undefined;\n  }\n  const startContainerElementCssSelector = getCssSelector(\n    startContainerElement\n  );\n\n  const endIsElement = range.endContainer.nodeType === Node.ELEMENT_NODE;\n  const endContainerElement = endIsElement\n    ? range.endContainer\n    : range.endContainer.parentNode &&\n      range.endContainer.parentNode.nodeType === Node.ELEMENT_NODE\n    ? range.endContainer.parentNode\n    : undefined;\n  if (!endContainerElement) {\n    return undefined;\n  }\n  const endContainerChildTextNodeIndex = endIsElement\n    ? -1\n    : Array.from(endContainerElement.childNodes).indexOf(range.endContainer);\n  if (endContainerChildTextNodeIndex < -1) {\n    return undefined;\n  }\n  const endContainerElementCssSelector = getCssSelector(endContainerElement);\n\n  const commonElementAncestor = getCommonAncestorElement(\n    range.startContainer,\n    range.endContainer\n  );\n  if (!commonElementAncestor) {\n    selection_log("^^^ NO RANGE COMMON ANCESTOR?!");\n    return undefined;\n  }\n  if (range.commonAncestorContainer) {\n    const rangeCommonAncestorElement =\n      range.commonAncestorContainer.nodeType === Node.ELEMENT_NODE\n        ? range.commonAncestorContainer\n        : range.commonAncestorContainer.parentNode;\n    if (\n      rangeCommonAncestorElement &&\n      rangeCommonAncestorElement.nodeType === Node.ELEMENT_NODE\n    ) {\n      if (commonElementAncestor !== rangeCommonAncestorElement) {\n        selection_log(">>>>>> COMMON ANCESTOR CONTAINER DIFF??!");\n        selection_log(getCssSelector(commonElementAncestor));\n        selection_log(getCssSelector(rangeCommonAncestorElement));\n      }\n    }\n  }\n  return {\n    endContainerChildTextNodeIndex,\n    endContainerElementCssSelector,\n    endOffset: range.endOffset,\n    startContainerChildTextNodeIndex,\n    startContainerElementCssSelector,\n    startOffset: range.startOffset,\n  };\n}\n\nfunction getCommonAncestorElement(node1, node2) {\n  if (node1.nodeType === Node.ELEMENT_NODE && node1 === node2) {\n    return node1;\n  }\n  if (node1.nodeType === Node.ELEMENT_NODE && node1.contains(node2)) {\n    return node1;\n  }\n  if (node2.nodeType === Node.ELEMENT_NODE && node2.contains(node1)) {\n    return node2;\n  }\n  const node1ElementAncestorChain = [];\n  let parent = node1.parentNode;\n  while (parent && parent.nodeType === Node.ELEMENT_NODE) {\n    node1ElementAncestorChain.push(parent);\n    parent = parent.parentNode;\n  }\n  const node2ElementAncestorChain = [];\n  parent = node2.parentNode;\n  while (parent && parent.nodeType === Node.ELEMENT_NODE) {\n    node2ElementAncestorChain.push(parent);\n    parent = parent.parentNode;\n  }\n  let commonAncestor = node1ElementAncestorChain.find(\n    (node1ElementAncestor) => {\n      return node2ElementAncestorChain.indexOf(node1ElementAncestor) >= 0;\n    }\n  );\n  if (!commonAncestor) {\n    commonAncestor = node2ElementAncestorChain.find((node2ElementAncestor) => {\n      return node1ElementAncestorChain.indexOf(node2ElementAncestor) >= 0;\n    });\n  }\n  return commonAncestor;\n}\n\nfunction convertRangeInfo(document, rangeInfo) {\n  const startElement = document.querySelector(\n    rangeInfo.startContainerElementCssSelector\n  );\n  if (!startElement) {\n    selection_log("^^^ convertRangeInfo NO START ELEMENT CSS SELECTOR?!");\n    return undefined;\n  }\n  let startContainer = startElement;\n  if (rangeInfo.startContainerChildTextNodeIndex >= 0) {\n    if (\n      rangeInfo.startContainerChildTextNodeIndex >=\n      startElement.childNodes.length\n    ) {\n      selection_log(\n        "^^^ convertRangeInfo rangeInfo.startContainerChildTextNodeIndex >= startElement.childNodes.length?!"\n      );\n      return undefined;\n    }\n    startContainer =\n      startElement.childNodes[rangeInfo.startContainerChildTextNodeIndex];\n    if (startContainer.nodeType !== Node.TEXT_NODE) {\n      selection_log("^^^ convertRangeInfo startContainer.nodeType !== Node.TEXT_NODE?!");\n      return undefined;\n    }\n  }\n  const endElement = document.querySelector(\n    rangeInfo.endContainerElementCssSelector\n  );\n  if (!endElement) {\n    selection_log("^^^ convertRangeInfo NO END ELEMENT CSS SELECTOR?!");\n    return undefined;\n  }\n  let endContainer = endElement;\n  if (rangeInfo.endContainerChildTextNodeIndex >= 0) {\n    if (\n      rangeInfo.endContainerChildTextNodeIndex >= endElement.childNodes.length\n    ) {\n      selection_log(\n        "^^^ convertRangeInfo rangeInfo.endContainerChildTextNodeIndex >= endElement.childNodes.length?!"\n      );\n      return undefined;\n    }\n    endContainer =\n      endElement.childNodes[rangeInfo.endContainerChildTextNodeIndex];\n    if (endContainer.nodeType !== Node.TEXT_NODE) {\n      selection_log("^^^ convertRangeInfo endContainer.nodeType !== Node.TEXT_NODE?!");\n      return undefined;\n    }\n  }\n  return createOrderedRange(\n    startContainer,\n    rangeInfo.startOffset,\n    endContainer,\n    rangeInfo.endOffset\n  );\n}\n\nfunction rangeInfo2Location(rangeInfo) {\n  return {\n    cssSelector: rangeInfo.startContainerElementCssSelector,\n    domRange: {\n      start: {\n        cssSelector: rangeInfo.startContainerElementCssSelector,\n        textNodeIndex: rangeInfo.startContainerChildTextNodeIndex,\n        offset: rangeInfo.startOffset,\n      },\n      end: {\n        cssSelector: rangeInfo.endContainerElementCssSelector,\n        textNodeIndex: rangeInfo.endContainerChildTextNodeIndex,\n        offset: rangeInfo.endOffset,\n      },\n    },\n  };\n}\n\nfunction location2RangeInfo(location) {\n  const locations = location.locations;\n  const domRange = locations.domRange;\n  const start = domRange.start;\n  const end = domRange.end;\n\n  return {\n    endContainerChildTextNodeIndex: end.textNodeIndex,\n    endContainerElementCssSelector: end.cssSelector,\n    endOffset: end.offset,\n    startContainerChildTextNodeIndex: start.textNodeIndex,\n    startContainerElementCssSelector: start.cssSelector,\n    startOffset: start.offset,\n  };\n}\n\nfunction fullQualifiedSelector(node) {\n  if (node.nodeType !== Node.ELEMENT_NODE) {\n    return (\n      (node.localName && node.localName.toLowerCase()) ||\n      node.nodeName.toLowerCase()\n    );\n  }\n  //return cssPath(node, justSelector);\n  return cssPath(node, true);\n}\n\nfunction cssPath(node, optimized) {\n  if (node.nodeType !== Node.ELEMENT_NODE) {\n    return "";\n  }\n\n  const steps = [];\n  let contextNode = node;\n  while (contextNode) {\n    const step = _cssPathStep(contextNode, !!optimized, contextNode === node);\n    if (!step) {\n      break; // Error - bail out early.\n    }\n    steps.push(step.value);\n    if (step.optimized) {\n      break;\n    }\n    contextNode = contextNode.parentNode;\n  }\n  steps.reverse();\n  return steps.join(" > ");\n}\n\n// https://chromium.googlesource.com/chromium/blink/+/master/Source/devtools/front_end/components/DOMPresentationUtils.js#316\nfunction _cssPathStep(node, optimized, isTargetNode) {\n  function idSelector(idd) {\n    return "#" + escapeIdentifierIfNeeded(idd);\n  }\n\n  function escapeIdentifierIfNeeded(ident) {\n    if (isCSSIdentifier(ident)) {\n      return ident;\n    }\n\n    const shouldEscapeFirst = /^(?:[0-9]|-[0-9-]?)/.test(ident);\n    const lastIndex = ident.length - 1;\n    return ident.replace(/./g, function (c, ii) {\n      return (shouldEscapeFirst && ii === 0) || !isCSSIdentChar(c)\n        ? escapeAsciiChar(c, ii === lastIndex)\n        : c;\n    });\n  }\n\n  function isCSSIdentifier(value) {\n    return /^-?[a-zA-Z_][a-zA-Z0-9_-]*$/.test(value);\n  }\n\n  function isCSSIdentChar(c) {\n    if (/[a-zA-Z0-9_-]/.test(c)) {\n      return true;\n    }\n    return c.charCodeAt(0) >= 0xa0;\n  }\n\n  function escapeAsciiChar(c, isLast) {\n    return "\\\\" + toHexByte(c) + (isLast ? "" : " ");\n  }\n\n  function toHexByte(c) {\n    let hexByte = c.charCodeAt(0).toString(16);\n    if (hexByte.length === 1) {\n      hexByte = "0" + hexByte;\n    }\n    return hexByte;\n  }\n\n  function prefixedElementClassNames(nd) {\n    const classAttribute = nd.getAttribute("class");\n    if (!classAttribute) {\n      return [];\n    }\n\n    return classAttribute\n      .split(/\\s+/g)\n      .filter(Boolean)\n      .map((nm) => {\n        // The prefix is required to store "__proto__" in a object-based map.\n        return "$" + nm;\n      });\n  }\n\n  if (node.nodeType !== Node.ELEMENT_NODE) {\n    return undefined;\n  }\n  const lowerCaseName =\n    (node.localName && node.localName.toLowerCase()) ||\n    node.nodeName.toLowerCase();\n\n  const element = node;\n\n  const id = element.getAttribute("id");\n\n  if (optimized) {\n    if (id) {\n      return {\n        optimized: true,\n        value: idSelector(id),\n      };\n    }\n    if (\n      lowerCaseName === "body" ||\n      lowerCaseName === "head" ||\n      lowerCaseName === "html"\n    ) {\n      return {\n        optimized: true,\n        value: lowerCaseName, // node.nodeNameInCorrectCase(),\n      };\n    }\n  }\n\n  const nodeName = lowerCaseName; // node.nodeNameInCorrectCase();\n  if (id) {\n    return {\n      optimized: true,\n      value: nodeName + idSelector(id),\n    };\n  }\n\n  const parent = node.parentNode;\n\n  if (!parent || parent.nodeType === Node.DOCUMENT_NODE) {\n    return {\n      optimized: true,\n      value: nodeName,\n    };\n  }\n\n  const prefixedOwnClassNamesArray_ = prefixedElementClassNames(element);\n\n  const prefixedOwnClassNamesArray = []; // .keySet()\n  prefixedOwnClassNamesArray_.forEach((arrItem) => {\n    if (prefixedOwnClassNamesArray.indexOf(arrItem) < 0) {\n      prefixedOwnClassNamesArray.push(arrItem);\n    }\n  });\n\n  let needsClassNames = false;\n  let needsNthChild = false;\n  let ownIndex = -1;\n  let elementIndex = -1;\n  const siblings = parent.children;\n\n  for (\n    let i = 0;\n    (ownIndex === -1 || !needsNthChild) && i < siblings.length;\n    ++i\n  ) {\n    const sibling = siblings[i];\n    if (sibling.nodeType !== Node.ELEMENT_NODE) {\n      continue;\n    }\n    elementIndex += 1;\n    if (sibling === node) {\n      ownIndex = elementIndex;\n      continue;\n    }\n    if (needsNthChild) {\n      continue;\n    }\n\n    // sibling.nodeNameInCorrectCase()\n    const siblingName =\n      (sibling.localName && sibling.localName.toLowerCase()) ||\n      sibling.nodeName.toLowerCase();\n    if (siblingName !== nodeName) {\n      continue;\n    }\n    needsClassNames = true;\n\n    const ownClassNames = [];\n    prefixedOwnClassNamesArray.forEach((arrItem) => {\n      ownClassNames.push(arrItem);\n    });\n    let ownClassNameCount = ownClassNames.length;\n\n    if (ownClassNameCount === 0) {\n      needsNthChild = true;\n      continue;\n    }\n    const siblingClassNamesArray_ = prefixedElementClassNames(sibling);\n    const siblingClassNamesArray = []; // .keySet()\n    siblingClassNamesArray_.forEach((arrItem) => {\n      if (siblingClassNamesArray.indexOf(arrItem) < 0) {\n        siblingClassNamesArray.push(arrItem);\n      }\n    });\n\n    for (const siblingClass of siblingClassNamesArray) {\n      const ind = ownClassNames.indexOf(siblingClass);\n      if (ind < 0) {\n        continue;\n      }\n\n      ownClassNames.splice(ind, 1); // delete ownClassNames[siblingClass];\n\n      if (!--ownClassNameCount) {\n        needsNthChild = true;\n        break;\n      }\n    }\n  }\n\n  let result = nodeName;\n  if (\n    isTargetNode &&\n    nodeName === "input" &&\n    element.getAttribute("type") &&\n    !element.getAttribute("id") &&\n    !element.getAttribute("class")\n  ) {\n    result += \'[type="\' + element.getAttribute("type") + \'"]\';\n  }\n  if (needsNthChild) {\n    result += ":nth-child(" + (ownIndex + 1) + ")";\n  } else if (needsClassNames) {\n    for (const prefixedName of prefixedOwnClassNamesArray) {\n      result += "." + escapeIdentifierIfNeeded(prefixedName.substr(1));\n    }\n  }\n\n  return {\n    optimized: false,\n    value: result,\n  };\n}\n\nfunction selection_log() {\n  if (debug) {\n    log.apply(null, arguments);\n  }\n}\n\n;// CONCATENATED MODULE: ./src/rect.js\n//\n//  Copyright 2021 Readium Foundation. All rights reserved.\n//  Use of this source code is governed by the BSD-style license\n//  available in the top-level LICENSE file of the project.\n//\n\n\n\nconst rect_debug = false;\n\nfunction rect_getClientRectsNoOverlap(\n  range,\n  doNotMergeHorizontallyAlignedRects\n) {\n  let clientRects = range.getClientRects();\n\n  const tolerance = 1;\n  const originalRects = [];\n  for (const rangeClientRect of clientRects) {\n    originalRects.push({\n      bottom: rangeClientRect.bottom,\n      height: rangeClientRect.height,\n      left: rangeClientRect.left,\n      right: rangeClientRect.right,\n      top: rangeClientRect.top,\n      width: rangeClientRect.width,\n    });\n  }\n  const mergedRects = mergeTouchingRects(\n    originalRects,\n    tolerance,\n    doNotMergeHorizontallyAlignedRects\n  );\n  const noContainedRects = removeContainedRects(mergedRects, tolerance);\n  const newRects = replaceOverlapingRects(noContainedRects);\n  const minArea = 2 * 2;\n  for (let j = newRects.length - 1; j >= 0; j--) {\n    const rect = newRects[j];\n    const bigEnough = rect.width * rect.height > minArea;\n    if (!bigEnough) {\n      if (newRects.length > 1) {\n        rect_log("CLIENT RECT: remove small");\n        newRects.splice(j, 1);\n      } else {\n        rect_log("CLIENT RECT: remove small, but keep otherwise empty!");\n        break;\n      }\n    }\n  }\n  rect_log(`CLIENT RECT: reduced ${originalRects.length} --\x3e ${newRects.length}`);\n  return newRects;\n}\n\nfunction mergeTouchingRects(\n  rects,\n  tolerance,\n  doNotMergeHorizontallyAlignedRects\n) {\n  for (let i = 0; i < rects.length; i++) {\n    for (let j = i + 1; j < rects.length; j++) {\n      const rect1 = rects[i];\n      const rect2 = rects[j];\n      if (rect1 === rect2) {\n        rect_log("mergeTouchingRects rect1 === rect2 ??!");\n        continue;\n      }\n      const rectsLineUpVertically =\n        almostEqual(rect1.top, rect2.top, tolerance) &&\n        almostEqual(rect1.bottom, rect2.bottom, tolerance);\n      const rectsLineUpHorizontally =\n        almostEqual(rect1.left, rect2.left, tolerance) &&\n        almostEqual(rect1.right, rect2.right, tolerance);\n      const horizontalAllowed = !doNotMergeHorizontallyAlignedRects;\n      const aligned =\n        (rectsLineUpHorizontally && horizontalAllowed) ||\n        (rectsLineUpVertically && !rectsLineUpHorizontally);\n      const canMerge = aligned && rectsTouchOrOverlap(rect1, rect2, tolerance);\n      if (canMerge) {\n        rect_log(\n          `CLIENT RECT: merging two into one, VERTICAL: ${rectsLineUpVertically} HORIZONTAL: ${rectsLineUpHorizontally} (${doNotMergeHorizontallyAlignedRects})`\n        );\n        const newRects = rects.filter((rect) => {\n          return rect !== rect1 && rect !== rect2;\n        });\n        const replacementClientRect = getBoundingRect(rect1, rect2);\n        newRects.push(replacementClientRect);\n        return mergeTouchingRects(\n          newRects,\n          tolerance,\n          doNotMergeHorizontallyAlignedRects\n        );\n      }\n    }\n  }\n  return rects;\n}\n\nfunction getBoundingRect(rect1, rect2) {\n  const left = Math.min(rect1.left, rect2.left);\n  const right = Math.max(rect1.right, rect2.right);\n  const top = Math.min(rect1.top, rect2.top);\n  const bottom = Math.max(rect1.bottom, rect2.bottom);\n  return {\n    bottom,\n    height: bottom - top,\n    left,\n    right,\n    top,\n    width: right - left,\n  };\n}\n\nfunction removeContainedRects(rects, tolerance) {\n  const rectsToKeep = new Set(rects);\n  for (const rect of rects) {\n    const bigEnough = rect.width > 1 && rect.height > 1;\n    if (!bigEnough) {\n      rect_log("CLIENT RECT: remove tiny");\n      rectsToKeep.delete(rect);\n      continue;\n    }\n    for (const possiblyContainingRect of rects) {\n      if (rect === possiblyContainingRect) {\n        continue;\n      }\n      if (!rectsToKeep.has(possiblyContainingRect)) {\n        continue;\n      }\n      if (rectContains(possiblyContainingRect, rect, tolerance)) {\n        rect_log("CLIENT RECT: remove contained");\n        rectsToKeep.delete(rect);\n        break;\n      }\n    }\n  }\n  return Array.from(rectsToKeep);\n}\n\nfunction rectContains(rect1, rect2, tolerance) {\n  return (\n    rectContainsPoint(rect1, rect2.left, rect2.top, tolerance) &&\n    rectContainsPoint(rect1, rect2.right, rect2.top, tolerance) &&\n    rectContainsPoint(rect1, rect2.left, rect2.bottom, tolerance) &&\n    rectContainsPoint(rect1, rect2.right, rect2.bottom, tolerance)\n  );\n}\n\nfunction rectContainsPoint(rect, x, y, tolerance) {\n  return (\n    (rect.left < x || almostEqual(rect.left, x, tolerance)) &&\n    (rect.right > x || almostEqual(rect.right, x, tolerance)) &&\n    (rect.top < y || almostEqual(rect.top, y, tolerance)) &&\n    (rect.bottom > y || almostEqual(rect.bottom, y, tolerance))\n  );\n}\n\nfunction replaceOverlapingRects(rects) {\n  for (let i = 0; i < rects.length; i++) {\n    for (let j = i + 1; j < rects.length; j++) {\n      const rect1 = rects[i];\n      const rect2 = rects[j];\n      if (rect1 === rect2) {\n        rect_log("replaceOverlapingRects rect1 === rect2 ??!");\n        continue;\n      }\n      if (rectsTouchOrOverlap(rect1, rect2, -1)) {\n        let toAdd = [];\n        let toRemove;\n        const subtractRects1 = rectSubtract(rect1, rect2);\n        if (subtractRects1.length === 1) {\n          toAdd = subtractRects1;\n          toRemove = rect1;\n        } else {\n          const subtractRects2 = rectSubtract(rect2, rect1);\n          if (subtractRects1.length < subtractRects2.length) {\n            toAdd = subtractRects1;\n            toRemove = rect1;\n          } else {\n            toAdd = subtractRects2;\n            toRemove = rect2;\n          }\n        }\n        rect_log(`CLIENT RECT: overlap, cut one rect into ${toAdd.length}`);\n        const newRects = rects.filter((rect) => {\n          return rect !== toRemove;\n        });\n        Array.prototype.push.apply(newRects, toAdd);\n        return replaceOverlapingRects(newRects);\n      }\n    }\n  }\n  return rects;\n}\n\nfunction rectSubtract(rect1, rect2) {\n  const rectIntersected = rectIntersect(rect2, rect1);\n  if (rectIntersected.height === 0 || rectIntersected.width === 0) {\n    return [rect1];\n  }\n  const rects = [];\n  {\n    const rectA = {\n      bottom: rect1.bottom,\n      height: 0,\n      left: rect1.left,\n      right: rectIntersected.left,\n      top: rect1.top,\n      width: 0,\n    };\n    rectA.width = rectA.right - rectA.left;\n    rectA.height = rectA.bottom - rectA.top;\n    if (rectA.height !== 0 && rectA.width !== 0) {\n      rects.push(rectA);\n    }\n  }\n  {\n    const rectB = {\n      bottom: rectIntersected.top,\n      height: 0,\n      left: rectIntersected.left,\n      right: rectIntersected.right,\n      top: rect1.top,\n      width: 0,\n    };\n    rectB.width = rectB.right - rectB.left;\n    rectB.height = rectB.bottom - rectB.top;\n    if (rectB.height !== 0 && rectB.width !== 0) {\n      rects.push(rectB);\n    }\n  }\n  {\n    const rectC = {\n      bottom: rect1.bottom,\n      height: 0,\n      left: rectIntersected.left,\n      right: rectIntersected.right,\n      top: rectIntersected.bottom,\n      width: 0,\n    };\n    rectC.width = rectC.right - rectC.left;\n    rectC.height = rectC.bottom - rectC.top;\n    if (rectC.height !== 0 && rectC.width !== 0) {\n      rects.push(rectC);\n    }\n  }\n  {\n    const rectD = {\n      bottom: rect1.bottom,\n      height: 0,\n      left: rectIntersected.right,\n      right: rect1.right,\n      top: rect1.top,\n      width: 0,\n    };\n    rectD.width = rectD.right - rectD.left;\n    rectD.height = rectD.bottom - rectD.top;\n    if (rectD.height !== 0 && rectD.width !== 0) {\n      rects.push(rectD);\n    }\n  }\n  return rects;\n}\n\nfunction rectIntersect(rect1, rect2) {\n  const maxLeft = Math.max(rect1.left, rect2.left);\n  const minRight = Math.min(rect1.right, rect2.right);\n  const maxTop = Math.max(rect1.top, rect2.top);\n  const minBottom = Math.min(rect1.bottom, rect2.bottom);\n  return {\n    bottom: minBottom,\n    height: Math.max(0, minBottom - maxTop),\n    left: maxLeft,\n    right: minRight,\n    top: maxTop,\n    width: Math.max(0, minRight - maxLeft),\n  };\n}\n\nfunction rectsTouchOrOverlap(rect1, rect2, tolerance) {\n  return (\n    (rect1.left < rect2.right ||\n      (tolerance >= 0 && almostEqual(rect1.left, rect2.right, tolerance))) &&\n    (rect2.left < rect1.right ||\n      (tolerance >= 0 && almostEqual(rect2.left, rect1.right, tolerance))) &&\n    (rect1.top < rect2.bottom ||\n      (tolerance >= 0 && almostEqual(rect1.top, rect2.bottom, tolerance))) &&\n    (rect2.top < rect1.bottom ||\n      (tolerance >= 0 && almostEqual(rect2.top, rect1.bottom, tolerance)))\n  );\n}\n\nfunction almostEqual(a, b, tolerance) {\n  return Math.abs(a - b) <= tolerance;\n}\n\nfunction rect_log() {\n  if (rect_debug) {\n    log.apply(null, arguments);\n  }\n}\n\n;// CONCATENATED MODULE: ./src/highlight.js\n//\n//  Copyright 2021 Readium Foundation. All rights reserved.\n//  Use of this source code is governed by the BSD-style license\n//  available in the top-level LICENSE file of the project.\n//\n\n\n\n\n\n\nconst highlight_debug = false;\n\nconst ID_HIGHLIGHTS_CONTAINER = "R2_ID_HIGHLIGHTS_CONTAINER";\nconst CLASS_HIGHLIGHT_CONTAINER = "R2_CLASS_HIGHLIGHT_CONTAINER";\nconst CLASS_HIGHLIGHT_AREA = "R2_CLASS_HIGHLIGHT_AREA";\nconst CLASS_HIGHLIGHT_BOUNDING_AREA = "R2_CLASS_HIGHLIGHT_BOUNDING_AREA";\n\nconst _highlights = [];\nlet _highlightsContainer;\n\nconst defaultBackgroundOpacity = 0.3;\n\nconst defaultBackgroundColor = {\n  blue: 100,\n  green: 50,\n  red: 230,\n};\n\nwindow.addEventListener(\n  "load",\n  function () {\n    // on page load\n    const body = document.body;\n    var lastSize = { width: 0, height: 0 };\n    const observer = new ResizeObserver(() => {\n      log(body.clientWidth, body.clientHeight);\n      if (\n        lastSize.width === body.clientWidth &&\n        lastSize.height === body.clientHeight\n      ) {\n        return;\n      }\n      lastSize = {\n        width: body.clientWidth,\n        height: body.clientHeight,\n      };\n      resetHighlights();\n    });\n    observer.observe(body);\n  },\n  false\n);\n\nfunction rectForHighlightWithID(id) {\n  const clientRects = frameForHighlightWithID(id);\n\n  return {\n    screenWidth: window.outerWidth,\n    screenHeight: window.outerHeight,\n    left: clientRects[0].left,\n    width: clientRects[0].width,\n    top: clientRects[0].top,\n    height: clientRects[0].height,\n  };\n}\n\nfunction clearHighlights() {\n  hideAllHighlights();\n  _highlights.splice(0, _highlights.length);\n}\n\nfunction hideAllHighlights() {\n  if (_highlightsContainer) {\n    _highlightsContainer.remove();\n    _highlightsContainer = null;\n  }\n}\n\nfunction resetHighlights() {\n  hideAllHighlights();\n\n  let i = _highlights.length;\n  while (i--) {\n    let highlight = _highlights[i];\n    if (highlight.transient) {\n      _highlights.splice(i, 1);\n    } else {\n      createHighlightDOM(highlight);\n    }\n  }\n}\n\nfunction highlight(locator) {\n  let text = locator.text;\n  if (!text || !text.highlight) {\n    return;\n  }\n\n  try {\n    let anchor = new TextQuoteAnchor(document.body, text.highlight, {\n      prefix: text.before,\n      suffix: text.after,\n    });\n    anchor.toRange();\n    highlightRange(anchor.toRange());\n  } catch (e) {\n    logException(e);\n  }\n}\n\nfunction highlightRange(range) {\n  // FIXME: Use user-provided ID.\n  let id = "R2_HIGHLIGHT_" + Date.now();\n\n  destroyHighlight(id);\n\n  const highlight = {\n    color: defaultBackgroundColor,\n    id,\n    pointerInteraction: true,\n    range: range,\n    transient: true,\n  };\n  _highlights.push(highlight);\n  createHighlightDOM(highlight);\n\n  return highlight;\n}\n\nfunction destroyHighlight(id) {\n  let i = -1;\n  let _document = window.document;\n  const highlight = _highlights.find((h, j) => {\n    i = j;\n    return h.id === id;\n  });\n  if (highlight && i >= 0 && i < _highlights.length) {\n    _highlights.splice(i, 1);\n  }\n  const highlightContainer = _document.getElementById(id);\n  if (highlightContainer) {\n    highlightContainer.remove();\n  }\n}\n\nfunction createHighlightDOM(highlight) {\n  if (!highlight.range) {\n    return undefined;\n  }\n\n  const scrollElement = document.scrollingElement;\n\n  const paginated = !isScrollModeEnabled();\n  const highlightsContainer = ensureContainer(window);\n  const highlightParent = document.createElement("div");\n\n  highlightParent.setAttribute("id", highlight.id);\n  highlightParent.setAttribute("class", CLASS_HIGHLIGHT_CONTAINER);\n\n  highlightParent.style.setProperty("pointer-events", "none");\n  if (highlight.pointerInteraction) {\n    highlightParent.setAttribute("data-click", "1");\n  }\n\n  const bodyRect = document.body.getBoundingClientRect();\n  const drawUnderline = false;\n  const drawStrikeThrough = false;\n  const doNotMergeHorizontallyAlignedRects = drawUnderline || drawStrikeThrough;\n  const clientRects = rect_getClientRectsNoOverlap(\n    highlight.range,\n    doNotMergeHorizontallyAlignedRects\n  );\n  const roundedCorner = 3;\n  const underlineThickness = 2;\n  const strikeThroughLineThickness = 3;\n  const opacity = defaultBackgroundOpacity;\n  let extra = "";\n\n  let xOffset = paginated ? -scrollElement.scrollLeft : bodyRect.left;\n  let yOffset = paginated ? -scrollElement.scrollTop : bodyRect.top;\n\n  for (const clientRect of clientRects) {\n    const highlightArea = document.createElement("div");\n\n    highlightArea.setAttribute("class", CLASS_HIGHLIGHT_AREA);\n\n    if (highlight_debug) {\n      const rgb = Math.round(0xffffff * Math.random());\n      const r = rgb >> 16;\n      const g = (rgb >> 8) & 255;\n      const b = rgb & 255;\n      extra = `outline-color: rgb(${r}, ${g}, ${b}); outline-style: solid; outline-width: 1px; outline-offset: -1px;`;\n    } else {\n      if (drawUnderline) {\n        extra += `border-bottom: ${underlineThickness}px solid rgba(${highlight.color.red}, ${highlight.color.green}, ${highlight.color.blue}, ${opacity}) !important`;\n      }\n    }\n    highlightArea.setAttribute(\n      "style",\n      `border-radius: ${roundedCorner}px !important; background-color: rgba(${highlight.color.red}, ${highlight.color.green}, ${highlight.color.blue}, ${opacity}) !important; ${extra}`\n    );\n    highlightArea.style.setProperty("pointer-events", "none");\n    highlightArea.style.position = "absolute";\n    highlightArea.scale = 1;\n    /*\n         highlightArea.rect = {\n         height: clientRect.height,\n         left: clientRect.left - xOffset,\n         top: clientRect.top - yOffset,\n         width: clientRect.width,\n         };\n         */\n    highlightArea.rect = {\n      height: clientRect.height,\n      left: clientRect.left - xOffset,\n      top: clientRect.top - yOffset,\n      width: clientRect.width,\n    };\n\n    highlightArea.style.width = `${highlightArea.rect.width}px`;\n    highlightArea.style.height = `${highlightArea.rect.height}px`;\n    highlightArea.style.left = `${highlightArea.rect.left}px`;\n    highlightArea.style.top = `${highlightArea.rect.top}px`;\n    highlightParent.append(highlightArea);\n    if (!highlight_debug && drawStrikeThrough) {\n      //if (drawStrikeThrough) {\n      const highlightAreaLine = document.createElement("div");\n      highlightAreaLine.setAttribute("class", CLASS_HIGHLIGHT_AREA);\n\n      highlightAreaLine.setAttribute(\n        "style",\n        `background-color: rgba(${highlight.color.red}, ${highlight.color.green}, ${highlight.color.blue}, ${opacity}) !important;`\n      );\n      highlightAreaLine.style.setProperty("pointer-events", "none");\n      highlightAreaLine.style.position = paginated ? "fixed" : "absolute";\n      highlightAreaLine.scale = 1;\n      /*\n             highlightAreaLine.rect = {\n             height: clientRect.height,\n             left: clientRect.left - xOffset,\n             top: clientRect.top - yOffset,\n             width: clientRect.width,\n             };\n             */\n\n      highlightAreaLine.rect = {\n        height: clientRect.height,\n        left: clientRect.left - xOffset,\n        top: clientRect.top - yOffset,\n        width: clientRect.width,\n      };\n\n      highlightAreaLine.style.width = `${highlightAreaLine.rect.width}px`;\n      highlightAreaLine.style.height = `${strikeThroughLineThickness}px`;\n      highlightAreaLine.style.left = `${highlightAreaLine.rect.left}px`;\n      highlightAreaLine.style.top = `${\n        highlightAreaLine.rect.top +\n        highlightAreaLine.rect.height / 2 -\n        strikeThroughLineThickness / 2\n      }px`;\n      highlightParent.append(highlightAreaLine);\n    }\n  }\n\n  const highlightBounding = document.createElement("div");\n  highlightBounding.setAttribute("class", CLASS_HIGHLIGHT_BOUNDING_AREA);\n\n  highlightBounding.style.setProperty("pointer-events", "none");\n  highlightBounding.style.position = paginated ? "fixed" : "absolute";\n  highlightBounding.scale = 1;\n\n  if (highlight_debug) {\n    highlightBounding.setAttribute(\n      "style",\n      `outline-color: magenta; outline-style: solid; outline-width: 1px; outline-offset: -1px;`\n    );\n  }\n\n  const rangeBoundingClientRect = highlight.range.getBoundingClientRect();\n  highlightBounding.rect = {\n    height: rangeBoundingClientRect.height,\n    left: rangeBoundingClientRect.left - xOffset,\n    top: rangeBoundingClientRect.top - yOffset,\n    width: rangeBoundingClientRect.width,\n  };\n\n  highlightBounding.style.width = `${highlightBounding.rect.width}px`;\n  highlightBounding.style.height = `${highlightBounding.rect.height}px`;\n  highlightBounding.style.left = `${highlightBounding.rect.left}px`;\n  highlightBounding.style.top = `${highlightBounding.rect.top}px`;\n\n  highlightParent.append(highlightBounding);\n  highlightsContainer.append(highlightParent);\n\n  return highlightParent;\n}\n\nfunction ensureContainer(win) {\n  const document = win.document;\n\n  if (!_highlightsContainer) {\n    _highlightsContainer = document.createElement("div");\n    _highlightsContainer.setAttribute("id", ID_HIGHLIGHTS_CONTAINER);\n\n    _highlightsContainer.style.setProperty("pointer-events", "none");\n    document.body.append(_highlightsContainer);\n  }\n\n  return _highlightsContainer;\n}\n\nfunction frameForHighlightWithID(id) {\n  const highlight = highlightWithID(id);\n  if (!highlight) return;\n\n  if (!highlight.range) {\n    return undefined;\n  }\n\n  const drawUnderline = false;\n  const drawStrikeThrough = false;\n  const doNotMergeHorizontallyAlignedRects = drawUnderline || drawStrikeThrough;\n  return getClientRectsNoOverlap(\n    highlight.range,\n    doNotMergeHorizontallyAlignedRects\n  );\n}\n\nfunction highlightWithID(id) {\n  return _highlights.find((h) => {\n    return h.id === id;\n  });\n}\n\n;// CONCATENATED MODULE: ./src/decorator.js\n//\n//  Copyright 2021 Readium Foundation. All rights reserved.\n//  Use of this source code is governed by the BSD-style license\n//  available in the top-level LICENSE file of the project.\n//\n\n\n\n\nconst decorator_debug = false;\n\nconst decorator_defaultBackgroundOpacity = 0.3;\n\nconst decorator_defaultBackgroundColor = {\n  blue: 100,\n  green: 50,\n  red: 230,\n};\n\nlet groups = new Map();\nvar lastGroupId = 0;\n\nfunction getDecorations(groupIdentifier) {\n  var group = groups.get(groupIdentifier);\n  if (!group) {\n    let id = "r2-decoration-" + lastGroupId++;\n    group = DecorationGroup(id);\n    groups.set(groupIdentifier, group);\n  }\n  return group;\n}\n\nfunction DecorationGroup(groupId) {\n  var items = [];\n  var lastItemId = 0;\n  var container = null;\n\n  function add(decoration) {\n    let id = groupId + "-" + lastItemId++;\n\n    let range = rangeFromLocator(decoration.locator);\n    if (!range) {\n      log("Can\'t locate DOM range for decoration", decoration);\n      return;\n    }\n\n    let item = { id, decoration, range };\n    items.push(item);\n    layout(item);\n  }\n\n  function remove(decorationIdentifier) {\n    let index = items.findIndex(\n      (i) => i.decoration.identifier === decorationIdentifier\n    );\n    if (index === -1) {\n      return;\n    }\n\n    let item = items[index];\n    items.splice(index, 1);\n    let itemContainer = document.getElementById(item.id);\n    if (itemContainer) {\n      itemContainer.remove();\n      itemContainer = null;\n    }\n  }\n\n  function update(decoration) {\n    remove(decoration.identifier);\n    add(decoration);\n  }\n\n  function clear() {\n    clearContainer();\n    items = [];\n  }\n\n  function requestLayout() {\n    clearContainer();\n    items.forEach((item) => layout(item));\n  }\n\n  function layout(item) {\n    let scrollElement = document.scrollingElement;\n    let groupContainer = requireContainer();\n    let paginated = !isScrollModeEnabled();\n\n    let itemContainer = document.createElement("div");\n    itemContainer.setAttribute("id", item.id);\n    itemContainer.style.setProperty("pointer-events", "none");\n    if (item.pointerInteraction) {\n      itemContainer.setAttribute("data-click", "1");\n    }\n\n    let bodyRect = document.body.getBoundingClientRect();\n    let doNotMergeHorizontallyAlignedRects = false;\n    let clientRects = rect_getClientRectsNoOverlap(\n      item.range,\n      doNotMergeHorizontallyAlignedRects\n    );\n    let roundedCorner = 3;\n    let color = decorator_defaultBackgroundColor;\n    let opacity = decorator_defaultBackgroundOpacity;\n    let extra = "";\n\n    let xOffset = paginated ? -scrollElement.scrollLeft : bodyRect.left;\n    let yOffset = paginated ? -scrollElement.scrollTop : bodyRect.top;\n\n    for (let clientRect of clientRects) {\n      const itemArea = document.createElement("div");\n      if (decorator_debug) {\n        const rgb = Math.round(0xffffff * Math.random());\n        const r = rgb >> 16;\n        const g = (rgb >> 8) & 255;\n        const b = rgb & 255;\n        extra = `outline-color: rgb(${r}, ${g}, ${b}); outline-style: solid; outline-width: 1px; outline-offset: -1px;`;\n      }\n      itemArea.setAttribute(\n        "style",\n        `border-radius: ${roundedCorner}px !important; background-color: rgba(${color.red}, ${color.green}, ${color.blue}, ${opacity}) !important; ${extra}`\n      );\n      itemArea.style.setProperty("pointer-events", "none");\n      itemArea.style.position = "absolute";\n      itemArea.scale = 1;\n      itemArea.rect = {\n        height: clientRect.height,\n        left: clientRect.left - xOffset,\n        top: clientRect.top - yOffset,\n        width: clientRect.width,\n      };\n\n      itemArea.style.width = `${itemArea.rect.width}px`;\n      itemArea.style.height = `${itemArea.rect.height}px`;\n      itemArea.style.left = `${itemArea.rect.left}px`;\n      itemArea.style.top = `${itemArea.rect.top}px`;\n      itemContainer.append(itemArea);\n    }\n\n    const itemBounding = document.createElement("div");\n    itemBounding.style.setProperty("pointer-events", "none");\n    itemBounding.style.position = paginated ? "fixed" : "absolute";\n    itemBounding.scale = 1;\n\n    if (decorator_debug) {\n      itemBounding.setAttribute(\n        "style",\n        `outline-color: magenta; outline-style: solid; outline-width: 1px; outline-offset: -1px;`\n      );\n    }\n\n    const rangeBoundingClientRect = item.range.getBoundingClientRect();\n    itemBounding.rect = {\n      height: rangeBoundingClientRect.height,\n      left: rangeBoundingClientRect.left - xOffset,\n      top: rangeBoundingClientRect.top - yOffset,\n      width: rangeBoundingClientRect.width,\n    };\n\n    itemBounding.style.width = `${itemBounding.rect.width}px`;\n    itemBounding.style.height = `${itemBounding.rect.height}px`;\n    itemBounding.style.left = `${itemBounding.rect.left}px`;\n    itemBounding.style.top = `${itemBounding.rect.top}px`;\n\n    itemContainer.append(itemBounding);\n    groupContainer.append(itemContainer);\n  }\n\n  function requireContainer() {\n    if (!container) {\n      container = document.createElement("div");\n      container.setAttribute("id", groupId);\n      container.style.setProperty("pointer-events", "none");\n      document.body.append(container);\n    }\n    return container;\n  }\n\n  function clearContainer() {\n    if (container) {\n      container.remove();\n      container = null;\n    }\n  }\n\n  return { add, remove, update, clear, requestLayout };\n}\n\nwindow.addEventListener(\n  "load",\n  function () {\n    // on page load\n    const body = document.body;\n    var lastSize = { width: 0, height: 0 };\n    const observer = new ResizeObserver(() => {\n      if (\n        lastSize.width === body.clientWidth &&\n        lastSize.height === body.clientHeight\n      ) {\n        return;\n      }\n      lastSize = {\n        width: body.clientWidth,\n        height: body.clientHeight,\n      };\n\n      groups.forEach(function (group) {\n        group.requestLayout();\n      });\n    });\n    observer.observe(body);\n  },\n  false\n);\n\n;// CONCATENATED MODULE: ./src/index.js\n//\n//  Copyright 2021 Readium Foundation. All rights reserved.\n//  Use of this source code is governed by the BSD-style license\n//  available in the top-level LICENSE file of the project.\n//\n\n// Base script used by both reflowable and fixed layout resources.\n\n\n\n\n\n\n\n// Public API used by the navigator.\nwindow.readium = {\n  // utils\n  scrollToId: scrollToId,\n  scrollToPosition: scrollToPosition,\n  scrollToText: scrollToText,\n  scrollLeft: scrollLeft,\n  scrollRight: scrollRight,\n  setProperty: setProperty,\n  removeProperty: removeProperty,\n\n  // decoration\n  getDecorations: getDecorations,\n\n  // selection\n  getSelectionRect: getSelectionRect,\n  getCurrentSelectionInfo: getCurrentSelectionInfo,\n};\n\n;// CONCATENATED MODULE: ./src/index-fixed.js\n//\n//  Copyright 2021 Readium Foundation. All rights reserved.\n//  Use of this source code is governed by the BSD-style license\n//  available in the top-level LICENSE file of the project.\n//\n\n// Script used for fixed layouts resources.\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFkaXVtLWpzLy4vc3JjL3ZlbmRvci9oeXBvdGhlc2lzL2FuY2hvcmluZy9tYXRjaC1xdW90ZS5qcz9kZDZhIiwid2VicGFjazovL3JlYWRpdW0tanMvLi9zcmMvdmVuZG9yL2h5cG90aGVzaXMvYW5jaG9yaW5nL3RleHQtcmFuZ2UuanM/ZmRlZSIsIndlYnBhY2s6Ly9yZWFkaXVtLWpzLy4vc3JjL3ZlbmRvci9oeXBvdGhlc2lzL2FuY2hvcmluZy90eXBlcy5qcz80MDA0Iiwid2VicGFjazovL3JlYWRpdW0tanMvLi9zcmMvdXRpbHMuanM/MDI1ZSIsIndlYnBhY2s6Ly9yZWFkaXVtLWpzLy4vc3JjL3NlbGVjdGlvbi5qcz81OWFjIiwid2VicGFjazovL3JlYWRpdW0tanMvLi9zcmMvcmVjdC5qcz80ZDVhIiwid2VicGFjazovL3JlYWRpdW0tanMvLi9zcmMvaGlnaGxpZ2h0LmpzPzhkYTgiLCJ3ZWJwYWNrOi8vcmVhZGl1bS1qcy8uL3NyYy9kZWNvcmF0b3IuanM/MWIwNCIsIndlYnBhY2s6Ly9yZWFkaXVtLWpzLy4vc3JjL2luZGV4LmpzP2I2MzUiLCJ3ZWJwYWNrOi8vcmVhZGl1bS1qcy8uL3NyYy9pbmRleC1maXhlZC5qcz9kOTlmIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUErQzs7QUFFL0M7QUFDQSxhQUFhLG9DQUFvQztBQUNqRDs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCLFVBQVUsT0FBTztBQUNqQixVQUFVLE9BQU87QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVMsdUJBQVk7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixZQUFZO0FBQ1o7QUFDTyw2Q0FBNkM7QUFDcEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLDRCQUE0QjtBQUM1Qiw0QkFBNEI7QUFDNUIsd0JBQXdCOztBQUV4Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7OztBQzdKQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixhQUFhLDZCQUE2QjtBQUMxQztBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsU0FBUztBQUN2QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixLQUFLO0FBQy9CO0FBQ0Esb0JBQW9CLDhDQUE4QztBQUNsRTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLCtDQUErQztBQUNqRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVPO0FBQ0E7O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sTUFBTSx1QkFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixRQUFRO0FBQzlCOztBQUVBLGVBQWUsdUJBQVk7QUFDM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsZUFBZSxtQ0FBbUM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGNBQWM7QUFDZDtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFVBQVU7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEtBQUs7QUFDbEIsYUFBYSxPQUFPO0FBQ3BCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsdUJBQVk7QUFDM0I7QUFDQSxtQkFBbUIsdUJBQVksWUFBWSxRQUFRO0FBQ25EO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsS0FBSztBQUNsQixhQUFhLE9BQU87QUFDcEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLEtBQUs7QUFDbkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtQkFBbUIsdUJBQVk7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCLFlBQVk7QUFDbkM7QUFDQTs7QUFFQSxtQkFBbUIsdUJBQVksWUFBWSxRQUFRO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLE1BQU0sb0JBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCLGFBQWEsYUFBYTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQSxlQUFlLG9CQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxrQ0FBa0MsOEJBQThCO0FBQ2hFLDhCQUE4QiwrQkFBK0I7QUFDN0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkIsY0FBYztBQUNkO0FBQ0E7QUFDQSxrQkFBa0IsdUJBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHVCQUFZO0FBQzVCLGVBQWUsb0JBQVM7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBLGVBQWUsb0JBQVM7QUFDeEIsVUFBVSx1QkFBWTtBQUN0QixVQUFVLHVCQUFZO0FBQ3RCO0FBQ0E7QUFDQTs7O0FDeFVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFMkM7QUFDWTtBQUNBOztBQUV2RDtBQUNBLGFBQWEsd0NBQXdDO0FBQ3JELGFBQWEsK0NBQStDO0FBQzVELGFBQWEsNENBQTRDO0FBQ3pEOztBQUVBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxhQUFhLEtBQUs7QUFDbEIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLEtBQUs7QUFDbEIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLGNBQWM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBLHNCQUFzQiw4QkFBbUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxxQkFBcUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsZ0NBQXFCO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsT0FBTztBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDTyxNQUFNLHFCQUFlO0FBQzVCO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0EsNEJBQTRCLE9BQU87QUFDbkMsc0JBQXNCLDhCQUFtQjs7QUFFekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLHFCQUFlO0FBQzlCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxrQkFBa0I7QUFDL0I7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLGVBQWUscUJBQWUsd0JBQXdCLGlCQUFpQjtBQUN2RTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLGtCQUFrQjtBQUMvQjtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBOztBQUVBO0FBQ0EsYUFBYSxrQkFBa0I7QUFDL0I7QUFDQSwrQkFBK0I7QUFDL0IsNEJBQTRCLE9BQU87QUFDbkMsa0JBQWtCLFVBQVU7QUFDNUI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3BQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVzRTs7QUFFdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxnQ0FBZ0MsT0FBTztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixxQkFBZTtBQUNwQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNILElBQUksa0JBQVk7QUFDaEI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ087QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ087QUFDUDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVPLFNBQVMsa0JBQVk7QUFDNUI7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FDelJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXlEO0FBQ1k7O0FBRXJFOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsSUFBSSxrQkFBWTtBQUNoQjtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxhQUFHO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksYUFBRztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksYUFBRztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxhQUFHO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQiw4QkFBbUI7QUFDdkM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EseUNBQXlDLEVBQUUsR0FBRyxFQUFFO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0RBQWtELEVBQUUsR0FBRyxFQUFFO0FBQ3pEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsYUFBRztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxhQUFHO0FBQ1A7QUFDQTtBQUNBLEVBQUUsYUFBRztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxhQUFHO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxhQUFHO0FBQ1gsUUFBUSxhQUFHO0FBQ1gsUUFBUSxhQUFHO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksYUFBRztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLGFBQUc7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sYUFBRztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxhQUFHO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLGFBQUc7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sYUFBRztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9B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QUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsUUFBRyw0Q0FBNEMsYUFBYTtBQUNwRTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFNBQVMsUUFBRztBQUNaLE1BQU0sVUFBSztBQUNYLElBQUksU0FBZTtBQUNuQjtBQUNBOzs7QUMzU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFbUU7QUFDbEI7QUFDZ0I7QUFDSzs7QUFFdEUsTUFBTSxlQUFLOztBQUVYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JB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QTtBQUNBO0FBQ0E7O0FBRUE7O0FBRWlCIiwiZmlsZSI6Ijk5MC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBhcHByb3hTZWFyY2ggZnJvbSAnYXBwcm94LXN0cmluZy1tYXRjaCc7XG5cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnYXBwcm94LXN0cmluZy1tYXRjaCcpLk1hdGNofSBTdHJpbmdNYXRjaFxuICovXG5cbi8qKlxuICogQHR5cGVkZWYgTWF0Y2hcbiAqIEBwcm9wIHtudW1iZXJ9IHN0YXJ0IC0gU3RhcnQgb2Zmc2V0IG9mIG1hdGNoIGluIHRleHRcbiAqIEBwcm9wIHtudW1iZXJ9IGVuZCAtIEVuZCBvZmZzZXQgb2YgbWF0Y2ggaW4gdGV4dFxuICogQHByb3Age251bWJlcn0gc2NvcmUgLVxuICogICBTY29yZSBmb3IgdGhlIG1hdGNoIGJldHdlZW4gMCBhbmQgMS4wLCB3aGVyZSAxLjAgaW5kaWNhdGVzIGEgcGVyZmVjdCBtYXRjaFxuICogICBmb3IgdGhlIHF1b3RlIGFuZCBjb250ZXh0LlxuICovXG5cbi8qKlxuICogRmluZCB0aGUgYmVzdCBhcHByb3hpbWF0ZSBtYXRjaGVzIGZvciBgc3RyYCBpbiBgdGV4dGAgYWxsb3dpbmcgdXAgdG8gYG1heEVycm9yc2AgZXJyb3JzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4RXJyb3JzXG4gKiBAcmV0dXJuIHtTdHJpbmdNYXRjaFtdfVxuICovXG5mdW5jdGlvbiBzZWFyY2godGV4dCwgc3RyLCBtYXhFcnJvcnMpIHtcbiAgLy8gRG8gYSBmYXN0IHNlYXJjaCBmb3IgZXhhY3QgbWF0Y2hlcy4gVGhlIGBhcHByb3gtc3RyaW5nLW1hdGNoYCBsaWJyYXJ5XG4gIC8vIGRvZXNuJ3QgY3VycmVudGx5IGluY29ycG9yYXRlIHRoaXMgb3B0aW1pemF0aW9uIGl0c2VsZi5cbiAgbGV0IG1hdGNoUG9zID0gMDtcbiAgbGV0IGV4YWN0TWF0Y2hlcyA9IFtdO1xuICB3aGlsZSAobWF0Y2hQb3MgIT09IC0xKSB7XG4gICAgbWF0Y2hQb3MgPSB0ZXh0LmluZGV4T2Yoc3RyLCBtYXRjaFBvcyk7XG4gICAgaWYgKG1hdGNoUG9zICE9PSAtMSkge1xuICAgICAgZXhhY3RNYXRjaGVzLnB1c2goe1xuICAgICAgICBzdGFydDogbWF0Y2hQb3MsXG4gICAgICAgIGVuZDogbWF0Y2hQb3MgKyBzdHIubGVuZ3RoLFxuICAgICAgICBlcnJvcnM6IDAsXG4gICAgICB9KTtcbiAgICAgIG1hdGNoUG9zICs9IDE7XG4gICAgfVxuICB9XG4gIGlmIChleGFjdE1hdGNoZXMubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBleGFjdE1hdGNoZXM7XG4gIH1cblxuICAvLyBJZiB0aGVyZSBhcmUgbm8gZXhhY3QgbWF0Y2hlcywgZG8gYSBtb3JlIGV4cGVuc2l2ZSBzZWFyY2ggZm9yIG1hdGNoZXNcbiAgLy8gd2l0aCBlcnJvcnMuXG4gIHJldHVybiBhcHByb3hTZWFyY2godGV4dCwgc3RyLCBtYXhFcnJvcnMpO1xufVxuXG4vKipcbiAqIENvbXB1dGUgYSBzY29yZSBiZXR3ZWVuIDAgYW5kIDEuMCBmb3IgdGhlIHNpbWlsYXJpdHkgYmV0d2VlbiBgdGV4dGAgYW5kIGBzdHJgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKi9cbmZ1bmN0aW9uIHRleHRNYXRjaFNjb3JlKHRleHQsIHN0cikge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAtIGBzY29yZU1hdGNoYCB3aWxsIG5ldmVyIHBhc3MgYW4gZW1wdHkgc3RyaW5nICovXG4gIGlmIChzdHIubGVuZ3RoID09PSAwIHx8IHRleHQubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIDAuMDtcbiAgfVxuICBjb25zdCBtYXRjaGVzID0gc2VhcmNoKHRleHQsIHN0ciwgc3RyLmxlbmd0aCk7XG5cbiAgLy8gcHJldHRpZXItaWdub3JlXG4gIHJldHVybiAxIC0gKG1hdGNoZXNbMF0uZXJyb3JzIC8gc3RyLmxlbmd0aCk7XG59XG5cbi8qKlxuICogRmluZCB0aGUgYmVzdCBhcHByb3hpbWF0ZSBtYXRjaCBmb3IgYHF1b3RlYCBpbiBgdGV4dGAuXG4gKlxuICogUmV0dXJucyBgbnVsbGAgaWYgbm8gbWF0Y2ggZXhjZWVkaW5nIHRoZSBtaW5pbXVtIHF1YWxpdHkgdGhyZXNob2xkIHdhcyBmb3VuZC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIERvY3VtZW50IHRleHQgdG8gc2VhcmNoXG4gKiBAcGFyYW0ge3N0cmluZ30gcXVvdGUgLSBTdHJpbmcgdG8gZmluZCB3aXRoaW4gYHRleHRgXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dCAtXG4gKiAgIENvbnRleHQgaW4gd2hpY2ggdGhlIHF1b3RlIG9yaWdpbmFsbHkgYXBwZWFyZWQuIFRoaXMgaXMgdXNlZCB0byBjaG9vc2UgdGhlXG4gKiAgIGJlc3QgbWF0Y2guXG4gKiAgIEBwYXJhbSB7c3RyaW5nfSBbY29udGV4dC5wcmVmaXhdIC0gRXhwZWN0ZWQgdGV4dCBiZWZvcmUgdGhlIHF1b3RlXG4gKiAgIEBwYXJhbSB7c3RyaW5nfSBbY29udGV4dC5zdWZmaXhdIC0gRXhwZWN0ZWQgdGV4dCBhZnRlciB0aGUgcXVvdGVcbiAqICAgQHBhcmFtIHtudW1iZXJ9IFtjb250ZXh0LmhpbnRdIC0gRXhwZWN0ZWQgb2Zmc2V0IG9mIG1hdGNoIHdpdGhpbiB0ZXh0XG4gKiBAcmV0dXJuIHtNYXRjaHxudWxsfVxuICovXG5leHBvcnQgZnVuY3Rpb24gbWF0Y2hRdW90ZSh0ZXh0LCBxdW90ZSwgY29udGV4dCA9IHt9KSB7XG4gIGlmIChxdW90ZS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIENob29zZSB0aGUgbWF4aW11bSBudW1iZXIgb2YgZXJyb3JzIHRvIGFsbG93IGZvciB0aGUgaW5pdGlhbCBzZWFyY2guXG4gIC8vIFRoaXMgY2hvaWNlIGludm9sdmVzIGEgdHJhZGVvZmYgYmV0d2VlbjpcbiAgLy9cbiAgLy8gIC0gUmVjYWxsIChwcm9wb3J0aW9uIG9mIFwiZ29vZFwiIG1hdGNoZXMgZm91bmQpXG4gIC8vICAtIFByZWNpc2lvbiAocHJvcG9ydGlvbiBvZiBtYXRjaGVzIGZvdW5kIHdoaWNoIGFyZSBcImdvb2RcIilcbiAgLy8gIC0gQ29zdCBvZiB0aGUgaW5pdGlhbCBzZWFyY2ggYW5kIG9mIHByb2Nlc3NpbmcgdGhlIGNhbmRpZGF0ZSBtYXRjaGVzIFsxXVxuICAvL1xuICAvLyBbMV0gU3BlY2lmaWNhbGx5LCB0aGUgZXhwZWN0ZWQtdGltZSBjb21wbGV4aXR5IG9mIHRoZSBpbml0aWFsIHNlYXJjaCBpc1xuICAvLyAgICAgYE8oKG1heEVycm9ycyAvIDMyKSAqIHRleHQubGVuZ3RoKWAuIFNlZSBgYXBwcm94LXN0cmluZy1tYXRjaGAgZG9jcy5cbiAgY29uc3QgbWF4RXJyb3JzID0gTWF0aC5taW4oMjU2LCBxdW90ZS5sZW5ndGggLyAyKTtcblxuICAvLyBGaW5kIGNsb3Nlc3QgbWF0Y2hlcyBmb3IgYHF1b3RlYCBpbiBgdGV4dGAgYmFzZWQgb24gZWRpdCBkaXN0YW5jZS5cbiAgY29uc3QgbWF0Y2hlcyA9IHNlYXJjaCh0ZXh0LCBxdW90ZSwgbWF4RXJyb3JzKTtcblxuICBpZiAobWF0Y2hlcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wdXRlIGEgc2NvcmUgYmV0d2VlbiAwIGFuZCAxLjAgZm9yIGEgbWF0Y2ggY2FuZGlkYXRlLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ01hdGNofSBtYXRjaFxuICAgKi9cbiAgY29uc3Qgc2NvcmVNYXRjaCA9IG1hdGNoID0+IHtcbiAgICBjb25zdCBxdW90ZVdlaWdodCA9IDUwOyAvLyBTaW1pbGFyaXR5IG9mIG1hdGNoZWQgdGV4dCB0byBxdW90ZS5cbiAgICBjb25zdCBwcmVmaXhXZWlnaHQgPSAyMDsgLy8gU2ltaWxhcml0eSBvZiB0ZXh0IGJlZm9yZSBtYXRjaGVkIHRleHQgdG8gYGNvbnRleHQucHJlZml4YC5cbiAgICBjb25zdCBzdWZmaXhXZWlnaHQgPSAyMDsgLy8gU2ltaWxhcml0eSBvZiB0ZXh0IGFmdGVyIG1hdGNoZWQgdGV4dCB0byBgY29udGV4dC5zdWZmaXhgLlxuICAgIGNvbnN0IHBvc1dlaWdodCA9IDI7IC8vIFByb3hpbWl0eSB0byBleHBlY3RlZCBsb2NhdGlvbi4gVXNlZCBhcyBhIHRpZS1icmVha2VyLlxuXG4gICAgY29uc3QgcXVvdGVTY29yZSA9IDEgLSBtYXRjaC5lcnJvcnMgLyBxdW90ZS5sZW5ndGg7XG5cbiAgICBjb25zdCBwcmVmaXhTY29yZSA9IGNvbnRleHQucHJlZml4XG4gICAgICA/IHRleHRNYXRjaFNjb3JlKFxuICAgICAgICAgIHRleHQuc2xpY2UoTWF0aC5tYXgoMCwgbWF0Y2guc3RhcnQgLSBjb250ZXh0LnByZWZpeC5sZW5ndGgpLCBtYXRjaC5zdGFydCksXG4gICAgICAgICAgY29udGV4dC5wcmVmaXhcbiAgICAgICAgKVxuICAgICAgOiAxLjA7XG4gICAgY29uc3Qgc3VmZml4U2NvcmUgPSBjb250ZXh0LnN1ZmZpeFxuICAgICAgPyB0ZXh0TWF0Y2hTY29yZShcbiAgICAgICAgICB0ZXh0LnNsaWNlKG1hdGNoLmVuZCwgbWF0Y2guZW5kICsgY29udGV4dC5zdWZmaXgubGVuZ3RoKSxcbiAgICAgICAgICBjb250ZXh0LnN1ZmZpeFxuICAgICAgICApXG4gICAgICA6IDEuMDtcblxuICAgIGxldCBwb3NTY29yZSA9IDEuMDtcbiAgICBpZiAodHlwZW9mIGNvbnRleHQuaGludCA9PT0gJ251bWJlcicpIHtcbiAgICAgIGNvbnN0IG9mZnNldCA9IE1hdGguYWJzKG1hdGNoLnN0YXJ0IC0gY29udGV4dC5oaW50KTtcbiAgICAgIHBvc1Njb3JlID0gMS4wIC0gb2Zmc2V0IC8gdGV4dC5sZW5ndGg7XG4gICAgfVxuXG4gICAgY29uc3QgcmF3U2NvcmUgPVxuICAgICAgcXVvdGVXZWlnaHQgKiBxdW90ZVNjb3JlICtcbiAgICAgIHByZWZpeFdlaWdodCAqIHByZWZpeFNjb3JlICtcbiAgICAgIHN1ZmZpeFdlaWdodCAqIHN1ZmZpeFNjb3JlICtcbiAgICAgIHBvc1dlaWdodCAqIHBvc1Njb3JlO1xuICAgIGNvbnN0IG1heFNjb3JlID0gcXVvdGVXZWlnaHQgKyBwcmVmaXhXZWlnaHQgKyBzdWZmaXhXZWlnaHQgKyBwb3NXZWlnaHQ7XG4gICAgY29uc3Qgbm9ybWFsaXplZFNjb3JlID0gcmF3U2NvcmUgLyBtYXhTY29yZTtcblxuICAgIHJldHVybiBub3JtYWxpemVkU2NvcmU7XG4gIH07XG5cbiAgLy8gUmFuayBtYXRjaGVzIGJhc2VkIG9uIHNpbWlsYXJpdHkgb2YgYWN0dWFsIGFuZCBleHBlY3RlZCBzdXJyb3VuZGluZyB0ZXh0XG4gIC8vIGFuZCBhY3R1YWwvZXhwZWN0ZWQgb2Zmc2V0IGluIHRoZSBkb2N1bWVudCB0ZXh0LlxuICBjb25zdCBzY29yZWRNYXRjaGVzID0gbWF0Y2hlcy5tYXAobSA9PiAoe1xuICAgIHN0YXJ0OiBtLnN0YXJ0LFxuICAgIGVuZDogbS5lbmQsXG4gICAgc2NvcmU6IHNjb3JlTWF0Y2gobSksXG4gIH0pKTtcblxuICAvLyBDaG9vc2UgbWF0Y2ggd2l0aCBoaWdoZXN0IHNjb3JlLlxuICBzY29yZWRNYXRjaGVzLnNvcnQoKGEsIGIpID0+IGIuc2NvcmUgLSBhLnNjb3JlKTtcbiAgcmV0dXJuIHNjb3JlZE1hdGNoZXNbMF07XG59XG4iLCIvKipcbiAqIFJldHVybiB0aGUgY29tYmluZWQgbGVuZ3RoIG9mIHRleHQgbm9kZXMgY29udGFpbmVkIGluIGBub2RlYC5cbiAqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAqL1xuZnVuY3Rpb24gbm9kZVRleHRMZW5ndGgobm9kZSkge1xuICBzd2l0Y2ggKG5vZGUubm9kZVR5cGUpIHtcbiAgICBjYXNlIE5vZGUuRUxFTUVOVF9OT0RFOlxuICAgIGNhc2UgTm9kZS5URVhUX05PREU6XG4gICAgICAvLyBuYi4gYHRleHRDb250ZW50YCBleGNsdWRlcyB0ZXh0IGluIGNvbW1lbnRzIGFuZCBwcm9jZXNzaW5nIGluc3RydWN0aW9uc1xuICAgICAgLy8gd2hlbiBjYWxsZWQgb24gYSBwYXJlbnQgZWxlbWVudCwgc28gd2UgZG9uJ3QgbmVlZCB0byBzdWJ0cmFjdCB0aGF0IGhlcmUuXG5cbiAgICAgIHJldHVybiAvKiogQHR5cGUge3N0cmluZ30gKi8gKG5vZGUudGV4dENvbnRlbnQpLmxlbmd0aDtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIDA7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIHRvdGFsIGxlbmd0aCBvZiB0aGUgdGV4dCBvZiBhbGwgcHJldmlvdXMgc2libGluZ3Mgb2YgYG5vZGVgLlxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICovXG5mdW5jdGlvbiBwcmV2aW91c1NpYmxpbmdzVGV4dExlbmd0aChub2RlKSB7XG4gIGxldCBzaWJsaW5nID0gbm9kZS5wcmV2aW91c1NpYmxpbmc7XG4gIGxldCBsZW5ndGggPSAwO1xuICB3aGlsZSAoc2libGluZykge1xuICAgIGxlbmd0aCArPSBub2RlVGV4dExlbmd0aChzaWJsaW5nKTtcbiAgICBzaWJsaW5nID0gc2libGluZy5wcmV2aW91c1NpYmxpbmc7XG4gIH1cbiAgcmV0dXJuIGxlbmd0aDtcbn1cblxuLyoqXG4gKiBSZXNvbHZlIG9uZSBvciBtb3JlIGNoYXJhY3RlciBvZmZzZXRzIHdpdGhpbiBhbiBlbGVtZW50IHRvICh0ZXh0IG5vZGUsIHBvc2l0aW9uKVxuICogcGFpcnMuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge251bWJlcltdfSBvZmZzZXRzIC0gT2Zmc2V0cywgd2hpY2ggbXVzdCBiZSBzb3J0ZWQgaW4gYXNjZW5kaW5nIG9yZGVyXG4gKiBAcmV0dXJuIHt7IG5vZGU6IFRleHQsIG9mZnNldDogbnVtYmVyIH1bXX1cbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZU9mZnNldHMoZWxlbWVudCwgLi4ub2Zmc2V0cykge1xuICBsZXQgbmV4dE9mZnNldCA9IG9mZnNldHMuc2hpZnQoKTtcbiAgY29uc3Qgbm9kZUl0ZXIgPSAvKiogQHR5cGUge0RvY3VtZW50fSAqLyAoXG4gICAgZWxlbWVudC5vd25lckRvY3VtZW50XG4gICkuY3JlYXRlTm9kZUl0ZXJhdG9yKGVsZW1lbnQsIE5vZGVGaWx0ZXIuU0hPV19URVhUKTtcbiAgY29uc3QgcmVzdWx0cyA9IFtdO1xuXG4gIGxldCBjdXJyZW50Tm9kZSA9IG5vZGVJdGVyLm5leHROb2RlKCk7XG4gIGxldCB0ZXh0Tm9kZTtcbiAgbGV0IGxlbmd0aCA9IDA7XG5cbiAgLy8gRmluZCB0aGUgdGV4dCBub2RlIGNvbnRhaW5pbmcgdGhlIGBuZXh0T2Zmc2V0YHRoIGNoYXJhY3RlciBmcm9tIHRoZSBzdGFydFxuICAvLyBvZiBgZWxlbWVudGAuXG4gIHdoaWxlIChuZXh0T2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgY3VycmVudE5vZGUpIHtcbiAgICB0ZXh0Tm9kZSA9IC8qKiBAdHlwZSB7VGV4dH0gKi8gKGN1cnJlbnROb2RlKTtcbiAgICBpZiAobGVuZ3RoICsgdGV4dE5vZGUuZGF0YS5sZW5ndGggPiBuZXh0T2Zmc2V0KSB7XG4gICAgICByZXN1bHRzLnB1c2goeyBub2RlOiB0ZXh0Tm9kZSwgb2Zmc2V0OiBuZXh0T2Zmc2V0IC0gbGVuZ3RoIH0pO1xuICAgICAgbmV4dE9mZnNldCA9IG9mZnNldHMuc2hpZnQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudE5vZGUgPSBub2RlSXRlci5uZXh0Tm9kZSgpO1xuICAgICAgbGVuZ3RoICs9IHRleHROb2RlLmRhdGEubGVuZ3RoO1xuICAgIH1cbiAgfVxuXG4gIC8vIEJvdW5kYXJ5IGNhc2UuXG4gIHdoaWxlIChuZXh0T2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgdGV4dE5vZGUgJiYgbGVuZ3RoID09PSBuZXh0T2Zmc2V0KSB7XG4gICAgcmVzdWx0cy5wdXNoKHsgbm9kZTogdGV4dE5vZGUsIG9mZnNldDogdGV4dE5vZGUuZGF0YS5sZW5ndGggfSk7XG4gICAgbmV4dE9mZnNldCA9IG9mZnNldHMuc2hpZnQoKTtcbiAgfVxuXG4gIGlmIChuZXh0T2Zmc2V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT2Zmc2V0IGV4Y2VlZHMgdGV4dCBsZW5ndGgnKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHRzO1xufVxuXG5leHBvcnQgbGV0IFJFU09MVkVfRk9SV0FSRFMgPSAxO1xuZXhwb3J0IGxldCBSRVNPTFZFX0JBQ0tXQVJEUyA9IDI7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhbiBvZmZzZXQgd2l0aGluIHRoZSB0ZXh0IGNvbnRlbnQgb2YgYW4gZWxlbWVudC5cbiAqXG4gKiBUaGlzIHBvc2l0aW9uIGNhbiBiZSByZXNvbHZlZCB0byBhIHNwZWNpZmljIGRlc2NlbmRhbnQgbm9kZSBpbiB0aGUgY3VycmVudFxuICogRE9NIHN1YnRyZWUgb2YgdGhlIGVsZW1lbnQgdXNpbmcgdGhlIGByZXNvbHZlYCBtZXRob2QuXG4gKi9cbmV4cG9ydCBjbGFzcyBUZXh0UG9zaXRpb24ge1xuICAvKipcbiAgICogQ29uc3RydWN0IGEgYFRleHRQb3NpdGlvbmAgdGhhdCByZWZlcnMgdG8gdGhlIHRleHQgcG9zaXRpb24gYG9mZnNldGAgd2l0aGluXG4gICAqIHRoZSB0ZXh0IGNvbnRlbnQgb2YgYGVsZW1lbnRgLlxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgKi9cbiAgY29uc3RydWN0b3IoZWxlbWVudCwgb2Zmc2V0KSB7XG4gICAgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignT2Zmc2V0IGlzIGludmFsaWQnKTtcbiAgICB9XG5cbiAgICAvKiogRWxlbWVudCB0aGF0IGBvZmZzZXRgIGlzIHJlbGF0aXZlIHRvLiAqL1xuICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG5cbiAgICAvKiogQ2hhcmFjdGVyIG9mZnNldCBmcm9tIHRoZSBzdGFydCBvZiB0aGUgZWxlbWVudCdzIGB0ZXh0Q29udGVudGAuICovXG4gICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGEgY29weSBvZiB0aGlzIHBvc2l0aW9uIHdpdGggb2Zmc2V0IHJlbGF0aXZlIHRvIGEgZ2l2ZW4gYW5jZXN0b3JcbiAgICogZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtFbGVtZW50fSBwYXJlbnQgLSBBbmNlc3RvciBvZiBgdGhpcy5lbGVtZW50YFxuICAgKiBAcmV0dXJuIHtUZXh0UG9zaXRpb259XG4gICAqL1xuICByZWxhdGl2ZVRvKHBhcmVudCkge1xuICAgIGlmICghcGFyZW50LmNvbnRhaW5zKHRoaXMuZWxlbWVudCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUGFyZW50IGlzIG5vdCBhbiBhbmNlc3RvciBvZiBjdXJyZW50IGVsZW1lbnQnKTtcbiAgICB9XG5cbiAgICBsZXQgZWwgPSB0aGlzLmVsZW1lbnQ7XG4gICAgbGV0IG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgIHdoaWxlIChlbCAhPT0gcGFyZW50KSB7XG4gICAgICBvZmZzZXQgKz0gcHJldmlvdXNTaWJsaW5nc1RleHRMZW5ndGgoZWwpO1xuICAgICAgZWwgPSAvKiogQHR5cGUge0VsZW1lbnR9ICovIChlbC5wYXJlbnRFbGVtZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFRleHRQb3NpdGlvbihlbCwgb2Zmc2V0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNvbHZlIHRoZSBwb3NpdGlvbiB0byBhIHNwZWNpZmljIHRleHQgbm9kZSBhbmQgb2Zmc2V0IHdpdGhpbiB0aGF0IG5vZGUuXG4gICAqXG4gICAqIFRocm93cyBpZiBgdGhpcy5vZmZzZXRgIGV4Y2VlZHMgdGhlIGxlbmd0aCBvZiB0aGUgZWxlbWVudCdzIHRleHQuIEluIHRoZVxuICAgKiBjYXNlIHdoZXJlIHRoZSBlbGVtZW50IGhhcyBubyB0ZXh0IGFuZCBgdGhpcy5vZmZzZXRgIGlzIDAsIHRoZSBgZGlyZWN0aW9uYFxuICAgKiBvcHRpb24gZGV0ZXJtaW5lcyB3aGF0IGhhcHBlbnMuXG4gICAqXG4gICAqIE9mZnNldHMgYXQgdGhlIGJvdW5kYXJ5IGJldHdlZW4gdHdvIG5vZGVzIGFyZSByZXNvbHZlZCB0byB0aGUgc3RhcnQgb2YgdGhlXG4gICAqIG5vZGUgdGhhdCBiZWdpbnMgYXQgdGhlIGJvdW5kYXJ5LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgQHBhcmFtIHtSRVNPTFZFX0ZPUldBUkRTfFJFU09MVkVfQkFDS1dBUkRTfSBbb3B0aW9ucy5kaXJlY3Rpb25dIC1cbiAgICogICAgIFNwZWNpZmllcyBpbiB3aGljaCBkaXJlY3Rpb24gdG8gc2VhcmNoIGZvciB0aGUgbmVhcmVzdCB0ZXh0IG5vZGUgaWZcbiAgICogICAgIGB0aGlzLm9mZnNldGAgaXMgYDBgIGFuZCBgdGhpcy5lbGVtZW50YCBoYXMgbm8gdGV4dC4gSWYgbm90IHNwZWNpZmllZFxuICAgKiAgICAgYW4gZXJyb3IgaXMgdGhyb3duLlxuICAgKiBAcmV0dXJuIHt7IG5vZGU6IFRleHQsIG9mZnNldDogbnVtYmVyIH19XG4gICAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9XG4gICAqL1xuICByZXNvbHZlKG9wdGlvbnMgPSB7fSkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZU9mZnNldHModGhpcy5lbGVtZW50LCB0aGlzLm9mZnNldClbMF07XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAodGhpcy5vZmZzZXQgPT09IDAgJiYgb3B0aW9ucy5kaXJlY3Rpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCB0dyA9IGRvY3VtZW50LmNyZWF0ZVRyZWVXYWxrZXIoXG4gICAgICAgICAgdGhpcy5lbGVtZW50LmdldFJvb3ROb2RlKCksXG4gICAgICAgICAgTm9kZUZpbHRlci5TSE9XX1RFWFRcbiAgICAgICAgKTtcbiAgICAgICAgdHcuY3VycmVudE5vZGUgPSB0aGlzLmVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IGZvcndhcmRzID0gb3B0aW9ucy5kaXJlY3Rpb24gPT09IFJFU09MVkVfRk9SV0FSRFM7XG4gICAgICAgIGNvbnN0IHRleHQgPSAvKiogQHR5cGUge1RleHR8bnVsbH0gKi8gKFxuICAgICAgICAgIGZvcndhcmRzID8gdHcubmV4dE5vZGUoKSA6IHR3LnByZXZpb3VzTm9kZSgpXG4gICAgICAgICk7XG4gICAgICAgIGlmICghdGV4dCkge1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBub2RlOiB0ZXh0LCBvZmZzZXQ6IGZvcndhcmRzID8gMCA6IHRleHQuZGF0YS5sZW5ndGggfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgYFRleHRQb3NpdGlvbmAgdGhhdCByZWZlcnMgdG8gdGhlIGBvZmZzZXRgdGggY2hhcmFjdGVyIHdpdGhpblxuICAgKiBgbm9kZWAuXG4gICAqXG4gICAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqIEByZXR1cm4ge1RleHRQb3NpdGlvbn1cbiAgICovXG4gIHN0YXRpYyBmcm9tQ2hhck9mZnNldChub2RlLCBvZmZzZXQpIHtcbiAgICBzd2l0Y2ggKG5vZGUubm9kZVR5cGUpIHtcbiAgICAgIGNhc2UgTm9kZS5URVhUX05PREU6XG4gICAgICAgIHJldHVybiBUZXh0UG9zaXRpb24uZnJvbVBvaW50KG5vZGUsIG9mZnNldCk7XG4gICAgICBjYXNlIE5vZGUuRUxFTUVOVF9OT0RFOlxuICAgICAgICByZXR1cm4gbmV3IFRleHRQb3NpdGlvbigvKiogQHR5cGUge0VsZW1lbnR9ICovIChub2RlKSwgb2Zmc2V0KTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm9kZSBpcyBub3QgYW4gZWxlbWVudCBvciB0ZXh0IG5vZGUnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgYFRleHRQb3NpdGlvbmAgcmVwcmVzZW50aW5nIHRoZSByYW5nZSBzdGFydCBvciBlbmQgcG9pbnQgKG5vZGUsIG9mZnNldCkuXG4gICAqXG4gICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSAtIFRleHQgb3IgRWxlbWVudCBub2RlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgLSBPZmZzZXQgd2l0aGluIHRoZSBub2RlLlxuICAgKiBAcmV0dXJuIHtUZXh0UG9zaXRpb259XG4gICAqL1xuICBzdGF0aWMgZnJvbVBvaW50KG5vZGUsIG9mZnNldCkge1xuICAgIHN3aXRjaCAobm9kZS5ub2RlVHlwZSkge1xuICAgICAgY2FzZSBOb2RlLlRFWFRfTk9ERToge1xuICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgPiAvKiogQHR5cGUge1RleHR9ICovIChub2RlKS5kYXRhLmxlbmd0aCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGV4dCBub2RlIG9mZnNldCBpcyBvdXQgb2YgcmFuZ2UnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbm9kZS5wYXJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUZXh0IG5vZGUgaGFzIG5vIHBhcmVudCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gR2V0IHRoZSBvZmZzZXQgZnJvbSB0aGUgc3RhcnQgb2YgdGhlIHBhcmVudCBlbGVtZW50LlxuICAgICAgICBjb25zdCB0ZXh0T2Zmc2V0ID0gcHJldmlvdXNTaWJsaW5nc1RleHRMZW5ndGgobm9kZSkgKyBvZmZzZXQ7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0UG9zaXRpb24obm9kZS5wYXJlbnRFbGVtZW50LCB0ZXh0T2Zmc2V0KTtcbiAgICAgIH1cbiAgICAgIGNhc2UgTm9kZS5FTEVNRU5UX05PREU6IHtcbiAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ID4gbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2hpbGQgbm9kZSBvZmZzZXQgaXMgb3V0IG9mIHJhbmdlJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHZXQgdGhlIHRleHQgbGVuZ3RoIGJlZm9yZSB0aGUgYG9mZnNldGB0aCBjaGlsZCBvZiBlbGVtZW50LlxuICAgICAgICBsZXQgdGV4dE9mZnNldCA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb2Zmc2V0OyBpKyspIHtcbiAgICAgICAgICB0ZXh0T2Zmc2V0ICs9IG5vZGVUZXh0TGVuZ3RoKG5vZGUuY2hpbGROb2Rlc1tpXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IFRleHRQb3NpdGlvbigvKiogQHR5cGUge0VsZW1lbnR9ICovIChub2RlKSwgdGV4dE9mZnNldCk7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BvaW50IGlzIG5vdCBpbiBhbiBlbGVtZW50IG9yIHRleHQgbm9kZScpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYSByZWdpb24gb2YgYSBkb2N1bWVudCBhcyBhIChzdGFydCwgZW5kKSBwYWlyIG9mIGBUZXh0UG9zaXRpb25gIHBvaW50cy5cbiAqXG4gKiBSZXByZXNlbnRpbmcgYSByYW5nZSBpbiB0aGlzIHdheSBhbGxvd3MgZm9yIGNoYW5nZXMgaW4gdGhlIERPTSBjb250ZW50IG9mIHRoZVxuICogcmFuZ2Ugd2hpY2ggZG9uJ3QgYWZmZWN0IGl0cyB0ZXh0IGNvbnRlbnQsIHdpdGhvdXQgYWZmZWN0aW5nIHRoZSB0ZXh0IGNvbnRlbnRcbiAqIG9mIHRoZSByYW5nZSBpdHNlbGYuXG4gKi9cbmV4cG9ydCBjbGFzcyBUZXh0UmFuZ2Uge1xuICAvKipcbiAgICogQ29uc3RydWN0IGFuIGltbXV0YWJsZSBgVGV4dFJhbmdlYCBmcm9tIGEgYHN0YXJ0YCBhbmQgYGVuZGAgcG9pbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7VGV4dFBvc2l0aW9ufSBzdGFydFxuICAgKiBAcGFyYW0ge1RleHRQb3NpdGlvbn0gZW5kXG4gICAqL1xuICBjb25zdHJ1Y3RvcihzdGFydCwgZW5kKSB7XG4gICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgIHRoaXMuZW5kID0gZW5kO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhIGNvcHkgb2YgdGhpcyByYW5nZSB3aXRoIHN0YXJ0IGFuZCBlbmQgcG9zaXRpb25zIHJlbGF0aXZlIHRvIGFcbiAgICogZ2l2ZW4gYW5jZXN0b3IuIFNlZSBgVGV4dFBvc2l0aW9uLnJlbGF0aXZlVG9gLlxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAgICovXG4gIHJlbGF0aXZlVG8oZWxlbWVudCkge1xuICAgIHJldHVybiBuZXcgVGV4dFJhbmdlKFxuICAgICAgdGhpcy5zdGFydC5yZWxhdGl2ZVRvKGVsZW1lbnQpLFxuICAgICAgdGhpcy5lbmQucmVsYXRpdmVUbyhlbGVtZW50KVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogUmVzb2x2ZSB0aGUgYFRleHRSYW5nZWAgdG8gYSBET00gcmFuZ2UuXG4gICAqXG4gICAqIFRoZSByZXN1bHRpbmcgRE9NIFJhbmdlIHdpbGwgYWx3YXlzIHN0YXJ0IGFuZCBlbmQgaW4gYSBgVGV4dGAgbm9kZS5cbiAgICogSGVuY2UgYFRleHRSYW5nZS5mcm9tUmFuZ2UocmFuZ2UpLnRvUmFuZ2UoKWAgY2FuIGJlIHVzZWQgdG8gXCJzaHJpbmtcIiBhXG4gICAqIHJhbmdlIHRvIHRoZSB0ZXh0IGl0IGNvbnRhaW5zLlxuICAgKlxuICAgKiBNYXkgdGhyb3cgaWYgdGhlIGBzdGFydGAgb3IgYGVuZGAgcG9zaXRpb25zIGNhbm5vdCBiZSByZXNvbHZlZCB0byBhIHJhbmdlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtSYW5nZX1cbiAgICovXG4gIHRvUmFuZ2UoKSB7XG4gICAgbGV0IHN0YXJ0O1xuICAgIGxldCBlbmQ7XG5cbiAgICBpZiAoXG4gICAgICB0aGlzLnN0YXJ0LmVsZW1lbnQgPT09IHRoaXMuZW5kLmVsZW1lbnQgJiZcbiAgICAgIHRoaXMuc3RhcnQub2Zmc2V0IDw9IHRoaXMuZW5kLm9mZnNldFxuICAgICkge1xuICAgICAgLy8gRmFzdCBwYXRoIGZvciBzdGFydCBhbmQgZW5kIHBvaW50cyBpbiBzYW1lIGVsZW1lbnQuXG4gICAgICBbc3RhcnQsIGVuZF0gPSByZXNvbHZlT2Zmc2V0cyhcbiAgICAgICAgdGhpcy5zdGFydC5lbGVtZW50LFxuICAgICAgICB0aGlzLnN0YXJ0Lm9mZnNldCxcbiAgICAgICAgdGhpcy5lbmQub2Zmc2V0XG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydCA9IHRoaXMuc3RhcnQucmVzb2x2ZSh7IGRpcmVjdGlvbjogUkVTT0xWRV9GT1JXQVJEUyB9KTtcbiAgICAgIGVuZCA9IHRoaXMuZW5kLnJlc29sdmUoeyBkaXJlY3Rpb246IFJFU09MVkVfQkFDS1dBUkRTIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IHJhbmdlID0gbmV3IFJhbmdlKCk7XG4gICAgcmFuZ2Uuc2V0U3RhcnQoc3RhcnQubm9kZSwgc3RhcnQub2Zmc2V0KTtcbiAgICByYW5nZS5zZXRFbmQoZW5kLm5vZGUsIGVuZC5vZmZzZXQpO1xuICAgIHJldHVybiByYW5nZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGFuIGV4aXN0aW5nIERPTSBgUmFuZ2VgIHRvIGEgYFRleHRSYW5nZWBcbiAgICpcbiAgICogQHBhcmFtIHtSYW5nZX0gcmFuZ2VcbiAgICogQHJldHVybiB7VGV4dFJhbmdlfVxuICAgKi9cbiAgc3RhdGljIGZyb21SYW5nZShyYW5nZSkge1xuICAgIGNvbnN0IHN0YXJ0ID0gVGV4dFBvc2l0aW9uLmZyb21Qb2ludChcbiAgICAgIHJhbmdlLnN0YXJ0Q29udGFpbmVyLFxuICAgICAgcmFuZ2Uuc3RhcnRPZmZzZXRcbiAgICApO1xuICAgIGNvbnN0IGVuZCA9IFRleHRQb3NpdGlvbi5mcm9tUG9pbnQocmFuZ2UuZW5kQ29udGFpbmVyLCByYW5nZS5lbmRPZmZzZXQpO1xuICAgIHJldHVybiBuZXcgVGV4dFJhbmdlKHN0YXJ0LCBlbmQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhIGBUZXh0UmFuZ2VgIGZyb20gdGhlIGBzdGFydGB0aCB0byBgZW5kYHRoIGNoYXJhY3RlcnMgaW4gYHJvb3RgLlxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IHJvb3RcbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBlbmRcbiAgICovXG4gIHN0YXRpYyBmcm9tT2Zmc2V0cyhyb290LCBzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIG5ldyBUZXh0UmFuZ2UoXG4gICAgICBuZXcgVGV4dFBvc2l0aW9uKHJvb3QsIHN0YXJ0KSxcbiAgICAgIG5ldyBUZXh0UG9zaXRpb24ocm9vdCwgZW5kKVxuICAgICk7XG4gIH1cbn1cbiIsIi8qKlxuICogVGhpcyBtb2R1bGUgZXhwb3J0cyBhIHNldCBvZiBjbGFzc2VzIGZvciBjb252ZXJ0aW5nIGJldHdlZW4gRE9NIGBSYW5nZWBcbiAqIG9iamVjdHMgYW5kIGRpZmZlcmVudCB0eXBlcyBvZiBzZWxlY3RvcnMuIEl0IGlzIG1vc3RseSBhIHRoaW4gd3JhcHBlciBhcm91bmQgYVxuICogc2V0IG9mIGFuY2hvcmluZyBsaWJyYXJpZXMuIEl0IHNlcnZlcyB0d28gbWFpbiBwdXJwb3NlczpcbiAqXG4gKiAgMS4gUHJvdmlkaW5nIGEgY29uc2lzdGVudCBpbnRlcmZhY2UgYWNyb3NzIGRpZmZlcmVudCB0eXBlcyBvZiBhbmNob3JzLlxuICogIDIuIEluc3VsYXRpbmcgdGhlIHJlc3Qgb2YgdGhlIGNvZGUgZnJvbSBBUEkgY2hhbmdlcyBpbiB0aGUgdW5kZXJseWluZyBhbmNob3JpbmdcbiAqICAgICBsaWJyYXJpZXMuXG4gKi9cblxuaW1wb3J0IHsgbWF0Y2hRdW90ZSB9IGZyb20gJy4vbWF0Y2gtcXVvdGUnO1xuaW1wb3J0IHsgVGV4dFJhbmdlLCBUZXh0UG9zaXRpb24gfSBmcm9tICcuL3RleHQtcmFuZ2UnO1xuaW1wb3J0IHsgbm9kZUZyb21YUGF0aCwgeHBhdGhGcm9tTm9kZSB9IGZyb20gJy4veHBhdGgnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4uLy4uL3R5cGVzL2FwaScpLlJhbmdlU2VsZWN0b3J9IFJhbmdlU2VsZWN0b3JcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4uLy4uL3R5cGVzL2FwaScpLlRleHRQb3NpdGlvblNlbGVjdG9yfSBUZXh0UG9zaXRpb25TZWxlY3RvclxuICogQHR5cGVkZWYge2ltcG9ydCgnLi4vLi4vdHlwZXMvYXBpJykuVGV4dFF1b3RlU2VsZWN0b3J9IFRleHRRdW90ZVNlbGVjdG9yXG4gKi9cblxuLyoqXG4gKiBDb252ZXJ0cyBiZXR3ZWVuIGBSYW5nZVNlbGVjdG9yYCBzZWxlY3RvcnMgYW5kIGBSYW5nZWAgb2JqZWN0cy5cbiAqL1xuZXhwb3J0IGNsYXNzIFJhbmdlQW5jaG9yIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7Tm9kZX0gcm9vdCAtIEEgcm9vdCBlbGVtZW50IGZyb20gd2hpY2ggdG8gYW5jaG9yLlxuICAgKiBAcGFyYW0ge1JhbmdlfSByYW5nZSAtICBBIHJhbmdlIGRlc2NyaWJpbmcgdGhlIGFuY2hvci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHJvb3QsIHJhbmdlKSB7XG4gICAgdGhpcy5yb290ID0gcm9vdDtcbiAgICB0aGlzLnJhbmdlID0gcmFuZ2U7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtOb2RlfSByb290IC0gIEEgcm9vdCBlbGVtZW50IGZyb20gd2hpY2ggdG8gYW5jaG9yLlxuICAgKiBAcGFyYW0ge1JhbmdlfSByYW5nZSAtICBBIHJhbmdlIGRlc2NyaWJpbmcgdGhlIGFuY2hvci5cbiAgICovXG4gIHN0YXRpYyBmcm9tUmFuZ2Uocm9vdCwgcmFuZ2UpIHtcbiAgICByZXR1cm4gbmV3IFJhbmdlQW5jaG9yKHJvb3QsIHJhbmdlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gYW5jaG9yIGZyb20gYSBzZXJpYWxpemVkIGBSYW5nZVNlbGVjdG9yYCBzZWxlY3Rvci5cbiAgICpcbiAgICogQHBhcmFtIHtFbGVtZW50fSByb290IC0gIEEgcm9vdCBlbGVtZW50IGZyb20gd2hpY2ggdG8gYW5jaG9yLlxuICAgKiBAcGFyYW0ge1JhbmdlU2VsZWN0b3J9IHNlbGVjdG9yXG4gICAqL1xuICBzdGF0aWMgZnJvbVNlbGVjdG9yKHJvb3QsIHNlbGVjdG9yKSB7XG4gICAgY29uc3Qgc3RhcnRDb250YWluZXIgPSBub2RlRnJvbVhQYXRoKHNlbGVjdG9yLnN0YXJ0Q29udGFpbmVyLCByb290KTtcbiAgICBpZiAoIXN0YXJ0Q29udGFpbmVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byByZXNvbHZlIHN0YXJ0Q29udGFpbmVyIFhQYXRoJyk7XG4gICAgfVxuXG4gICAgY29uc3QgZW5kQ29udGFpbmVyID0gbm9kZUZyb21YUGF0aChzZWxlY3Rvci5lbmRDb250YWluZXIsIHJvb3QpO1xuICAgIGlmICghZW5kQ29udGFpbmVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byByZXNvbHZlIGVuZENvbnRhaW5lciBYUGF0aCcpO1xuICAgIH1cblxuICAgIGNvbnN0IHN0YXJ0UG9zID0gVGV4dFBvc2l0aW9uLmZyb21DaGFyT2Zmc2V0KFxuICAgICAgc3RhcnRDb250YWluZXIsXG4gICAgICBzZWxlY3Rvci5zdGFydE9mZnNldFxuICAgICk7XG4gICAgY29uc3QgZW5kUG9zID0gVGV4dFBvc2l0aW9uLmZyb21DaGFyT2Zmc2V0KFxuICAgICAgZW5kQ29udGFpbmVyLFxuICAgICAgc2VsZWN0b3IuZW5kT2Zmc2V0XG4gICAgKTtcblxuICAgIGNvbnN0IHJhbmdlID0gbmV3IFRleHRSYW5nZShzdGFydFBvcywgZW5kUG9zKS50b1JhbmdlKCk7XG4gICAgcmV0dXJuIG5ldyBSYW5nZUFuY2hvcihyb290LCByYW5nZSk7XG4gIH1cblxuICB0b1JhbmdlKCkge1xuICAgIHJldHVybiB0aGlzLnJhbmdlO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge1JhbmdlU2VsZWN0b3J9XG4gICAqL1xuICB0b1NlbGVjdG9yKCkge1xuICAgIC8vIFwiU2hyaW5rXCIgdGhlIHJhbmdlIHNvIHRoYXQgaXQgdGlnaHRseSB3cmFwcyBpdHMgdGV4dC4gVGhpcyBlbnN1cmVzIG1vcmVcbiAgICAvLyBwcmVkaWN0YWJsZSBvdXRwdXQgZm9yIGEgZ2l2ZW4gdGV4dCBzZWxlY3Rpb24uXG4gICAgY29uc3Qgbm9ybWFsaXplZFJhbmdlID0gVGV4dFJhbmdlLmZyb21SYW5nZSh0aGlzLnJhbmdlKS50b1JhbmdlKCk7XG5cbiAgICBjb25zdCB0ZXh0UmFuZ2UgPSBUZXh0UmFuZ2UuZnJvbVJhbmdlKG5vcm1hbGl6ZWRSYW5nZSk7XG4gICAgY29uc3Qgc3RhcnRDb250YWluZXIgPSB4cGF0aEZyb21Ob2RlKHRleHRSYW5nZS5zdGFydC5lbGVtZW50LCB0aGlzLnJvb3QpO1xuICAgIGNvbnN0IGVuZENvbnRhaW5lciA9IHhwYXRoRnJvbU5vZGUodGV4dFJhbmdlLmVuZC5lbGVtZW50LCB0aGlzLnJvb3QpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdSYW5nZVNlbGVjdG9yJyxcbiAgICAgIHN0YXJ0Q29udGFpbmVyLFxuICAgICAgc3RhcnRPZmZzZXQ6IHRleHRSYW5nZS5zdGFydC5vZmZzZXQsXG4gICAgICBlbmRDb250YWluZXIsXG4gICAgICBlbmRPZmZzZXQ6IHRleHRSYW5nZS5lbmQub2Zmc2V0LFxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBiZXR3ZWVuIGBUZXh0UG9zaXRpb25TZWxlY3RvcmAgc2VsZWN0b3JzIGFuZCBgUmFuZ2VgIG9iamVjdHMuXG4gKi9cbmV4cG9ydCBjbGFzcyBUZXh0UG9zaXRpb25BbmNob3Ige1xuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSByb290XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydFxuICAgKiBAcGFyYW0ge251bWJlcn0gZW5kXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihyb290LCBzdGFydCwgZW5kKSB7XG4gICAgdGhpcy5yb290ID0gcm9vdDtcbiAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgdGhpcy5lbmQgPSBlbmQ7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSByb290XG4gICAqIEBwYXJhbSB7UmFuZ2V9IHJhbmdlXG4gICAqL1xuICBzdGF0aWMgZnJvbVJhbmdlKHJvb3QsIHJhbmdlKSB7XG4gICAgY29uc3QgdGV4dFJhbmdlID0gVGV4dFJhbmdlLmZyb21SYW5nZShyYW5nZSkucmVsYXRpdmVUbyhyb290KTtcbiAgICByZXR1cm4gbmV3IFRleHRQb3NpdGlvbkFuY2hvcihcbiAgICAgIHJvb3QsXG4gICAgICB0ZXh0UmFuZ2Uuc3RhcnQub2Zmc2V0LFxuICAgICAgdGV4dFJhbmdlLmVuZC5vZmZzZXRcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IHJvb3RcbiAgICogQHBhcmFtIHtUZXh0UG9zaXRpb25TZWxlY3Rvcn0gc2VsZWN0b3JcbiAgICovXG4gIHN0YXRpYyBmcm9tU2VsZWN0b3Iocm9vdCwgc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gbmV3IFRleHRQb3NpdGlvbkFuY2hvcihyb290LCBzZWxlY3Rvci5zdGFydCwgc2VsZWN0b3IuZW5kKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtUZXh0UG9zaXRpb25TZWxlY3Rvcn1cbiAgICovXG4gIHRvU2VsZWN0b3IoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdUZXh0UG9zaXRpb25TZWxlY3RvcicsXG4gICAgICBzdGFydDogdGhpcy5zdGFydCxcbiAgICAgIGVuZDogdGhpcy5lbmQsXG4gICAgfTtcbiAgfVxuXG4gIHRvUmFuZ2UoKSB7XG4gICAgcmV0dXJuIFRleHRSYW5nZS5mcm9tT2Zmc2V0cyh0aGlzLnJvb3QsIHRoaXMuc3RhcnQsIHRoaXMuZW5kKS50b1JhbmdlKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBAdHlwZWRlZiBRdW90ZU1hdGNoT3B0aW9uc1xuICogQHByb3Age251bWJlcn0gW2hpbnRdIC0gRXhwZWN0ZWQgcG9zaXRpb24gb2YgbWF0Y2ggaW4gdGV4dC4gU2VlIGBtYXRjaFF1b3RlYC5cbiAqL1xuXG4vKipcbiAqIENvbnZlcnRzIGJldHdlZW4gYFRleHRRdW90ZVNlbGVjdG9yYCBzZWxlY3RvcnMgYW5kIGBSYW5nZWAgb2JqZWN0cy5cbiAqL1xuZXhwb3J0IGNsYXNzIFRleHRRdW90ZUFuY2hvciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IHJvb3QgLSBBIHJvb3QgZWxlbWVudCBmcm9tIHdoaWNoIHRvIGFuY2hvci5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV4YWN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gICAqICAgQHBhcmFtIHtzdHJpbmd9IFtjb250ZXh0LnByZWZpeF1cbiAgICogICBAcGFyYW0ge3N0cmluZ30gW2NvbnRleHQuc3VmZml4XVxuICAgKi9cbiAgY29uc3RydWN0b3Iocm9vdCwgZXhhY3QsIGNvbnRleHQgPSB7fSkge1xuICAgIHRoaXMucm9vdCA9IHJvb3Q7XG4gICAgdGhpcy5leGFjdCA9IGV4YWN0O1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgYFRleHRRdW90ZUFuY2hvcmAgZnJvbSBhIHJhbmdlLlxuICAgKlxuICAgKiBXaWxsIHRocm93IGlmIGByYW5nZWAgZG9lcyBub3QgY29udGFpbiBhbnkgdGV4dCBub2Rlcy5cbiAgICpcbiAgICogQHBhcmFtIHtFbGVtZW50fSByb290XG4gICAqIEBwYXJhbSB7UmFuZ2V9IHJhbmdlXG4gICAqL1xuICBzdGF0aWMgZnJvbVJhbmdlKHJvb3QsIHJhbmdlKSB7XG4gICAgY29uc3QgdGV4dCA9IC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAocm9vdC50ZXh0Q29udGVudCk7XG4gICAgY29uc3QgdGV4dFJhbmdlID0gVGV4dFJhbmdlLmZyb21SYW5nZShyYW5nZSkucmVsYXRpdmVUbyhyb290KTtcblxuICAgIGNvbnN0IHN0YXJ0ID0gdGV4dFJhbmdlLnN0YXJ0Lm9mZnNldDtcbiAgICBjb25zdCBlbmQgPSB0ZXh0UmFuZ2UuZW5kLm9mZnNldDtcblxuICAgIC8vIE51bWJlciBvZiBjaGFyYWN0ZXJzIGFyb3VuZCB0aGUgcXVvdGUgdG8gY2FwdHVyZSBhcyBjb250ZXh0LiBXZSBjdXJyZW50bHlcbiAgICAvLyBhbHdheXMgdXNlIGEgZml4ZWQgYW1vdW50LCBidXQgaXQgd291bGQgYmUgYmV0dGVyIGlmIHRoaXMgY29kZSB3YXMgYXdhcmVcbiAgICAvLyBvZiBsb2dpY2FsIGJvdW5kYXJpZXMgaW4gdGhlIGRvY3VtZW50IChwYXJhZ3JhcGgsIGFydGljbGUgZXRjLikgdG8gYXZvaWRcbiAgICAvLyBjYXB0dXJpbmcgdGV4dCB1bnJlbGF0ZWQgdG8gdGhlIHF1b3RlLlxuICAgIC8vXG4gICAgLy8gSW4gcmVndWxhciBwcm9zZSB0aGUgaWRlYWwgY29udGVudCB3b3VsZCBvZnRlbiBiZSB0aGUgc3Vycm91bmRpbmcgc2VudGVuY2UuXG4gICAgLy8gVGhpcyBpcyBhIG5hdHVyYWwgdW5pdCBvZiBtZWFuaW5nIHdoaWNoIGVuYWJsZXMgZGlzcGxheWluZyBxdW90ZXMgaW5cbiAgICAvLyBjb250ZXh0IGV2ZW4gd2hlbiB0aGUgZG9jdW1lbnQgaXMgbm90IGF2YWlsYWJsZS4gV2UgY291bGQgdXNlIGBJbnRsLlNlZ21lbnRlcmBcbiAgICAvLyBmb3IgdGhpcyB3aGVuIGF2YWlsYWJsZS5cbiAgICBjb25zdCBjb250ZXh0TGVuID0gMzI7XG5cbiAgICByZXR1cm4gbmV3IFRleHRRdW90ZUFuY2hvcihyb290LCB0ZXh0LnNsaWNlKHN0YXJ0LCBlbmQpLCB7XG4gICAgICBwcmVmaXg6IHRleHQuc2xpY2UoTWF0aC5tYXgoMCwgc3RhcnQgLSBjb250ZXh0TGVuKSwgc3RhcnQpLFxuICAgICAgc3VmZml4OiB0ZXh0LnNsaWNlKGVuZCwgTWF0aC5taW4odGV4dC5sZW5ndGgsIGVuZCArIGNvbnRleHRMZW4pKSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IHJvb3RcbiAgICogQHBhcmFtIHtUZXh0UXVvdGVTZWxlY3Rvcn0gc2VsZWN0b3JcbiAgICovXG4gIHN0YXRpYyBmcm9tU2VsZWN0b3Iocm9vdCwgc2VsZWN0b3IpIHtcbiAgICBjb25zdCB7IHByZWZpeCwgc3VmZml4IH0gPSBzZWxlY3RvcjtcbiAgICByZXR1cm4gbmV3IFRleHRRdW90ZUFuY2hvcihyb290LCBzZWxlY3Rvci5leGFjdCwgeyBwcmVmaXgsIHN1ZmZpeCB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtUZXh0UXVvdGVTZWxlY3Rvcn1cbiAgICovXG4gIHRvU2VsZWN0b3IoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdUZXh0UXVvdGVTZWxlY3RvcicsXG4gICAgICBleGFjdDogdGhpcy5leGFjdCxcbiAgICAgIHByZWZpeDogdGhpcy5jb250ZXh0LnByZWZpeCxcbiAgICAgIHN1ZmZpeDogdGhpcy5jb250ZXh0LnN1ZmZpeCxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7UXVvdGVNYXRjaE9wdGlvbnN9IFtvcHRpb25zXVxuICAgKi9cbiAgdG9SYW5nZShvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy50b1Bvc2l0aW9uQW5jaG9yKG9wdGlvbnMpLnRvUmFuZ2UoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1F1b3RlTWF0Y2hPcHRpb25zfSBbb3B0aW9uc11cbiAgICovXG4gIHRvUG9zaXRpb25BbmNob3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgdGV4dCA9IC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAodGhpcy5yb290LnRleHRDb250ZW50KTtcbiAgICBjb25zdCBtYXRjaCA9IG1hdGNoUXVvdGUodGV4dCwgdGhpcy5leGFjdCwge1xuICAgICAgLi4udGhpcy5jb250ZXh0LFxuICAgICAgaGludDogb3B0aW9ucy5oaW50LFxuICAgIH0pO1xuICAgIGlmICghbWF0Y2gpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUXVvdGUgbm90IGZvdW5kJyk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVGV4dFBvc2l0aW9uQW5jaG9yKHRoaXMucm9vdCwgbWF0Y2guc3RhcnQsIG1hdGNoLmVuZCk7XG4gIH1cbn1cbiIsIi8vXG4vLyAgQ29weXJpZ2h0IDIwMjEgUmVhZGl1bSBGb3VuZGF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IHRoZSBCU0Qtc3R5bGUgbGljZW5zZVxuLy8gIGF2YWlsYWJsZSBpbiB0aGUgdG9wLWxldmVsIExJQ0VOU0UgZmlsZSBvZiB0aGUgcHJvamVjdC5cbi8vXG5cbi8vIENhdGNoIEpTIGVycm9ycyB0byBsb2cgdGhlbSBpbiB0aGUgYXBwLlxuXG5pbXBvcnQgeyBUZXh0UXVvdGVBbmNob3IgfSBmcm9tIFwiLi92ZW5kb3IvaHlwb3RoZXNpcy9hbmNob3JpbmcvdHlwZXNcIjtcblxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXG4gIFwiZXJyb3JcIixcbiAgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgd2Via2l0Lm1lc3NhZ2VIYW5kbGVycy5sb2dFcnJvci5wb3N0TWVzc2FnZSh7XG4gICAgICBtZXNzYWdlOiBldmVudC5tZXNzYWdlLFxuICAgICAgZmlsZW5hbWU6IGV2ZW50LmZpbGVuYW1lLFxuICAgICAgbGluZTogZXZlbnQubGluZW5vLFxuICAgIH0pO1xuICB9LFxuICBmYWxzZVxuKTtcblxuLy8gTm90aWZ5IG5hdGl2ZSBjb2RlIHRoYXQgdGhlIHBhZ2UgaGFzIGxvYWRlZC5cbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKFxuICBcImxvYWRcIixcbiAgZnVuY3Rpb24gKCkge1xuICAgIC8vIG9uIHBhZ2UgbG9hZFxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwib3JpZW50YXRpb25jaGFuZ2VcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgb3JpZW50YXRpb25DaGFuZ2VkKCk7XG4gICAgICBzbmFwQ3VycmVudFBvc2l0aW9uKCk7XG4gICAgfSk7XG4gICAgb3JpZW50YXRpb25DaGFuZ2VkKCk7XG4gIH0sXG4gIGZhbHNlXG4pO1xuXG52YXIgbGFzdF9rbm93bl9zY3JvbGxYX3Bvc2l0aW9uID0gMDtcbnZhciBsYXN0X2tub3duX3Njcm9sbFlfcG9zaXRpb24gPSAwO1xudmFyIHRpY2tpbmcgPSBmYWxzZTtcbnZhciBtYXhTY3JlZW5YID0gMDtcblxuLy8gUG9zaXRpb24gaW4gcmFuZ2UgWzAgLSAxXS5cbmZ1bmN0aW9uIHVwZGF0ZShwb3NpdGlvbikge1xuICB2YXIgcG9zaXRpb25TdHJpbmcgPSBwb3NpdGlvbi50b1N0cmluZygpO1xuICB3ZWJraXQubWVzc2FnZUhhbmRsZXJzLnByb2dyZXNzaW9uQ2hhbmdlZC5wb3N0TWVzc2FnZShwb3NpdGlvblN0cmluZyk7XG59XG5cbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIGZ1bmN0aW9uICgpIHtcbiAgbGFzdF9rbm93bl9zY3JvbGxZX3Bvc2l0aW9uID1cbiAgICB3aW5kb3cuc2Nyb2xsWSAvIGRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnQuc2Nyb2xsSGVpZ2h0O1xuICAvLyBVc2luZyBNYXRoLmFicyBiZWNhdXNlIGZvciBSVEwgYm9va3MsIHRoZSB2YWx1ZSB3aWxsIGJlIG5lZ2F0aXZlLlxuICBsYXN0X2tub3duX3Njcm9sbFhfcG9zaXRpb24gPSBNYXRoLmFicyhcbiAgICB3aW5kb3cuc2Nyb2xsWCAvIGRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnQuc2Nyb2xsV2lkdGhcbiAgKTtcblxuICAvLyBXaW5kb3cgaXMgaGlkZGVuXG4gIGlmIChcbiAgICBkb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50LnNjcm9sbFdpZHRoID09PSAwIHx8XG4gICAgZG9jdW1lbnQuc2Nyb2xsaW5nRWxlbWVudC5zY3JvbGxIZWlnaHQgPT09IDBcbiAgKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKCF0aWNraW5nKSB7XG4gICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICB1cGRhdGUoXG4gICAgICAgIGlzU2Nyb2xsTW9kZUVuYWJsZWQoKVxuICAgICAgICAgID8gbGFzdF9rbm93bl9zY3JvbGxZX3Bvc2l0aW9uXG4gICAgICAgICAgOiBsYXN0X2tub3duX3Njcm9sbFhfcG9zaXRpb25cbiAgICAgICk7XG4gICAgICB0aWNraW5nID0gZmFsc2U7XG4gICAgfSk7XG4gIH1cbiAgdGlja2luZyA9IHRydWU7XG59KTtcblxuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcbiAgXCJzZWxlY3Rpb25jaGFuZ2VcIixcbiAgZGVib3VuY2UoNTAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaW5mbyA9IHt9O1xuICAgIHZhciBzZWxlY3Rpb24gPSBkb2N1bWVudC5nZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoc2VsZWN0aW9uICYmIHNlbGVjdGlvbi5yYW5nZUNvdW50ID4gMCkge1xuICAgICAgdmFyIHJlY3QgPSBzZWxlY3Rpb24uZ2V0UmFuZ2VBdCgwKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGluZm9bXCJ0ZXh0XCJdID0gc2VsZWN0aW9uLnRvU3RyaW5nKCkudHJpbSgpO1xuICAgICAgaW5mb1tcImZyYW1lXCJdID0ge1xuICAgICAgICB4OiByZWN0LmxlZnQsXG4gICAgICAgIHk6IHJlY3QudG9wLFxuICAgICAgICB3aWR0aDogcmVjdC53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiByZWN0LmhlaWdodCxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgd2Via2l0Lm1lc3NhZ2VIYW5kbGVycy5zZWxlY3Rpb25DaGFuZ2VkLnBvc3RNZXNzYWdlKGluZm8pO1xuICB9KVxuKTtcblxuZnVuY3Rpb24gb3JpZW50YXRpb25DaGFuZ2VkKCkge1xuICBtYXhTY3JlZW5YID1cbiAgICB3aW5kb3cub3JpZW50YXRpb24gPT09IDAgfHwgd2luZG93Lm9yaWVudGF0aW9uID09IDE4MFxuICAgICAgPyBzY3JlZW4ud2lkdGhcbiAgICAgIDogc2NyZWVuLmhlaWdodDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzU2Nyb2xsTW9kZUVuYWJsZWQoKSB7XG4gIHJldHVybiAoXG4gICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlXG4gICAgICAuZ2V0UHJvcGVydHlWYWx1ZShcIi0tVVNFUl9fc2Nyb2xsXCIpXG4gICAgICAudG9TdHJpbmcoKVxuICAgICAgLnRyaW0oKSA9PT0gXCJyZWFkaXVtLXNjcm9sbC1vblwiXG4gICk7XG59XG5cbi8vIFNjcm9sbCB0byB0aGUgZ2l2ZW4gVGFnSWQgaW4gZG9jdW1lbnQgYW5kIHNuYXAuXG5leHBvcnQgZnVuY3Rpb24gc2Nyb2xsVG9JZChpZCkge1xuICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKTtcbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGVsZW1lbnQuc2Nyb2xsSW50b1ZpZXcoKTtcblxuICBpZiAoIWlzU2Nyb2xsTW9kZUVuYWJsZWQoKSkge1xuICAgIHZhciBjdXJyZW50T2Zmc2V0ID0gd2luZG93LnNjcm9sbFg7XG4gICAgdmFyIHBhZ2VXaWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgIC8vIEFkZHMgaGFsZiBhIHBhZ2UgdG8gbWFrZSBzdXJlIHdlIGRvbid0IHNuYXAgdG8gdGhlIHByZXZpb3VzIHBhZ2UuXG4gICAgZG9jdW1lbnQuc2Nyb2xsaW5nRWxlbWVudC5zY3JvbGxMZWZ0ID0gc25hcE9mZnNldChcbiAgICAgIGN1cnJlbnRPZmZzZXQgKyBwYWdlV2lkdGggLyAyXG4gICAgKTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gUG9zaXRpb24gbXVzdCBiZSBpbiB0aGUgcmFuZ2UgWzAgLSAxXSwgMC0xMDAlLlxuZXhwb3J0IGZ1bmN0aW9uIHNjcm9sbFRvUG9zaXRpb24ocG9zaXRpb24sIGRpcikge1xuICBjb25zb2xlLmxvZyhcIlNjcm9sbFRvUG9zaXRpb25cIik7XG4gIGlmIChwb3NpdGlvbiA8IDAgfHwgcG9zaXRpb24gPiAxKSB7XG4gICAgY29uc29sZS5sb2coXCJJbnZhbGlkUG9zaXRpb25cIik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGlzU2Nyb2xsTW9kZUVuYWJsZWQoKSkge1xuICAgIGxldCBvZmZzZXQgPSBkb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50LnNjcm9sbEhlaWdodCAqIHBvc2l0aW9uO1xuICAgIGRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnQuc2Nyb2xsVG9wID0gb2Zmc2V0O1xuICAgIC8vIHdpbmRvdy5zY3JvbGxUbygwLCBvZmZzZXQpO1xuICB9IGVsc2Uge1xuICAgIHZhciBkb2N1bWVudFdpZHRoID0gZG9jdW1lbnQuc2Nyb2xsaW5nRWxlbWVudC5zY3JvbGxXaWR0aDtcbiAgICB2YXIgZmFjdG9yID0gZGlyID09IFwicnRsXCIgPyAtMSA6IDE7XG4gICAgbGV0IG9mZnNldCA9IGRvY3VtZW50V2lkdGggKiBwb3NpdGlvbiAqIGZhY3RvcjtcbiAgICBkb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50LnNjcm9sbExlZnQgPSBzbmFwT2Zmc2V0KG9mZnNldCk7XG4gIH1cbn1cblxuLy8gU2Nyb2xscyB0byB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiB0aGUgZ2l2ZW4gdGV4dCBzbmlwcGV0LlxuLy9cbi8vIFRoZSBleHBlY3RlZCB0ZXh0IGFyZ3VtZW50IGlzIGEgTG9jYXRvciBUZXh0IG9iamVjdCwgYXMgZGVmaW5lZCBoZXJlOlxuLy8gaHR0cHM6Ly9yZWFkaXVtLm9yZy9hcmNoaXRlY3R1cmUvbW9kZWxzL2xvY2F0b3JzL1xuZXhwb3J0IGZ1bmN0aW9uIHNjcm9sbFRvVGV4dCh0ZXh0KSB7XG4gIGxldCByYW5nZSA9IHJhbmdlRnJvbUxvY2F0b3IoeyB0ZXh0IH0pO1xuICBpZiAoIXJhbmdlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHNjcm9sbFRvUmFuZ2UocmFuZ2UpO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gc2Nyb2xsVG9SYW5nZShyYW5nZSkge1xuICB2YXIgcmVjdCA9IHJhbmdlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICBpZiAoaXNTY3JvbGxNb2RlRW5hYmxlZCgpKSB7XG4gICAgZG9jdW1lbnQuc2Nyb2xsaW5nRWxlbWVudC5zY3JvbGxUb3AgPVxuICAgICAgcmVjdC50b3AgKyB3aW5kb3cuc2Nyb2xsWSAtIHdpbmRvdy5pbm5lckhlaWdodCAvIDI7XG4gIH0gZWxzZSB7XG4gICAgZG9jdW1lbnQuc2Nyb2xsaW5nRWxlbWVudC5zY3JvbGxMZWZ0ID0gcmVjdC5sZWZ0ICsgd2luZG93LnNjcm9sbFg7XG4gICAgc25hcEN1cnJlbnRQb3NpdGlvbigpO1xuICB9XG59XG5cbi8vIFJldHVybnMgZmFsc2UgaWYgdGhlIHBhZ2UgaXMgYWxyZWFkeSBhdCB0aGUgbGVmdC1tb3N0IHNjcm9sbCBvZmZzZXQuXG5leHBvcnQgZnVuY3Rpb24gc2Nyb2xsTGVmdChkaXIpIHtcbiAgdmFyIGlzUlRMID0gZGlyID09IFwicnRsXCI7XG4gIHZhciBkb2N1bWVudFdpZHRoID0gZG9jdW1lbnQuc2Nyb2xsaW5nRWxlbWVudC5zY3JvbGxXaWR0aDtcbiAgdmFyIHBhZ2VXaWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICB2YXIgb2Zmc2V0ID0gd2luZG93LnNjcm9sbFggLSBwYWdlV2lkdGg7XG4gIHZhciBtaW5PZmZzZXQgPSBpc1JUTCA/IC0oZG9jdW1lbnRXaWR0aCAtIHBhZ2VXaWR0aCkgOiAwO1xuICByZXR1cm4gc2Nyb2xsVG9PZmZzZXQoTWF0aC5tYXgob2Zmc2V0LCBtaW5PZmZzZXQpKTtcbn1cblxuLy8gUmV0dXJucyBmYWxzZSBpZiB0aGUgcGFnZSBpcyBhbHJlYWR5IGF0IHRoZSByaWdodC1tb3N0IHNjcm9sbCBvZmZzZXQuXG5leHBvcnQgZnVuY3Rpb24gc2Nyb2xsUmlnaHQoZGlyKSB7XG4gIHZhciBpc1JUTCA9IGRpciA9PSBcInJ0bFwiO1xuICB2YXIgZG9jdW1lbnRXaWR0aCA9IGRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnQuc2Nyb2xsV2lkdGg7XG4gIHZhciBwYWdlV2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgdmFyIG9mZnNldCA9IHdpbmRvdy5zY3JvbGxYICsgcGFnZVdpZHRoO1xuICB2YXIgbWF4T2Zmc2V0ID0gaXNSVEwgPyAwIDogZG9jdW1lbnRXaWR0aCAtIHBhZ2VXaWR0aDtcbiAgcmV0dXJuIHNjcm9sbFRvT2Zmc2V0KE1hdGgubWluKG9mZnNldCwgbWF4T2Zmc2V0KSk7XG59XG5cbi8vIFNjcm9sbHMgdG8gdGhlIGdpdmVuIGxlZnQgb2Zmc2V0LlxuLy8gUmV0dXJucyBmYWxzZSBpZiB0aGUgcGFnZSBzY3JvbGwgcG9zaXRpb24gaXMgYWxyZWFkeSBjbG9zZSBlbm91Z2ggdG8gdGhlIGdpdmVuIG9mZnNldC5cbmZ1bmN0aW9uIHNjcm9sbFRvT2Zmc2V0KG9mZnNldCkge1xuICB2YXIgY3VycmVudE9mZnNldCA9IHdpbmRvdy5zY3JvbGxYO1xuICB2YXIgcGFnZVdpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XG4gIGRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnQuc2Nyb2xsTGVmdCA9IG9mZnNldDtcbiAgLy8gSW4gc29tZSBjYXNlIHRoZSBzY3JvbGxYIGNhbm5vdCByZWFjaCB0aGUgcG9zaXRpb24gcmVzcGVjdGluZyB0byBpbm5lcldpZHRoXG4gIHZhciBkaWZmID0gTWF0aC5hYnMoY3VycmVudE9mZnNldCAtIG9mZnNldCkgLyBwYWdlV2lkdGg7XG4gIHJldHVybiBkaWZmID4gMC4wMTtcbn1cblxuLy8gU25hcCB0aGUgb2Zmc2V0IHRvIHRoZSBzY3JlZW4gd2lkdGggKHBhZ2Ugd2lkdGgpLlxuZnVuY3Rpb24gc25hcE9mZnNldChvZmZzZXQpIHtcbiAgdmFyIHZhbHVlID0gb2Zmc2V0ICsgMTtcblxuICByZXR1cm4gdmFsdWUgLSAodmFsdWUgJSBtYXhTY3JlZW5YKTtcbn1cblxuZnVuY3Rpb24gc25hcEN1cnJlbnRQb3NpdGlvbigpIHtcbiAgaWYgKGlzU2Nyb2xsTW9kZUVuYWJsZWQoKSkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgY3VycmVudE9mZnNldCA9IHdpbmRvdy5zY3JvbGxYO1xuICB2YXIgY3VycmVudE9mZnNldFNuYXBwZWQgPSBzbmFwT2Zmc2V0KGN1cnJlbnRPZmZzZXQgKyAxKTtcblxuICBkb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50LnNjcm9sbExlZnQgPSBjdXJyZW50T2Zmc2V0U25hcHBlZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJhbmdlRnJvbUxvY2F0b3IobG9jYXRvcikge1xuICBsZXQgdGV4dCA9IGxvY2F0b3IudGV4dDtcbiAgaWYgKCF0ZXh0IHx8ICF0ZXh0LmhpZ2hsaWdodCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHRyeSB7XG4gICAgbGV0IGFuY2hvciA9IG5ldyBUZXh0UXVvdGVBbmNob3IoZG9jdW1lbnQuYm9keSwgdGV4dC5oaWdobGlnaHQsIHtcbiAgICAgIHByZWZpeDogdGV4dC5iZWZvcmUsXG4gICAgICBzdWZmaXg6IHRleHQuYWZ0ZXIsXG4gICAgfSk7XG4gICAgcmV0dXJuIGFuY2hvci50b1JhbmdlKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBsb2dFeGNlcHRpb24oZSk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLy8vIFVzZXIgU2V0dGluZ3MuXG5cbi8vIEZvciBzZXR0aW5nIHVzZXIgc2V0dGluZy5cbmV4cG9ydCBmdW5jdGlvbiBzZXRQcm9wZXJ0eShrZXksIHZhbHVlKSB7XG4gIHZhciByb290ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG4gIHJvb3Quc3R5bGUuc2V0UHJvcGVydHkoa2V5LCB2YWx1ZSk7XG59XG5cbi8vIEZvciByZW1vdmluZyB1c2VyIHNldHRpbmcuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlUHJvcGVydHkoa2V5KSB7XG4gIHZhciByb290ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG4gIHJvb3Quc3R5bGUucmVtb3ZlUHJvcGVydHkoa2V5KTtcbn1cblxuLy8vIFRvb2xraXRcblxuZnVuY3Rpb24gZGVib3VuY2UoZGVsYXksIGZ1bmMpIHtcbiAgdmFyIHRpbWVvdXQ7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgIGZ1bmN0aW9uIGNhbGxiYWNrKCkge1xuICAgICAgZnVuYy5hcHBseShzZWxmLCBhcmdzKTtcbiAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgIH1cbiAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgdGltZW91dCA9IHNldFRpbWVvdXQoY2FsbGJhY2ssIGRlbGF5KTtcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxvZygpIHtcbiAgdmFyIG1lc3NhZ2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLmpvaW4oXCIgXCIpO1xuICB3ZWJraXQubWVzc2FnZUhhbmRsZXJzLmxvZy5wb3N0TWVzc2FnZShtZXNzYWdlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxvZ0V4Y2VwdGlvbihlKSB7XG4gIHdlYmtpdC5tZXNzYWdlSGFuZGxlcnMubG9nRXJyb3IucG9zdE1lc3NhZ2Uoe1xuICAgIG1lc3NhZ2U6IGUubWVzc2FnZSxcbiAgfSk7XG59XG4iLCIvL1xuLy8gIENvcHlyaWdodCAyMDIxIFJlYWRpdW0gRm91bmRhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSB0aGUgQlNELXN0eWxlIGxpY2Vuc2Vcbi8vICBhdmFpbGFibGUgaW4gdGhlIHRvcC1sZXZlbCBMSUNFTlNFIGZpbGUgb2YgdGhlIHByb2plY3QuXG4vL1xuXG5pbXBvcnQgeyBsb2cgYXMgbG9nTmF0aXZlLCBsb2dFeGNlcHRpb24gfSBmcm9tIFwiLi91dGlsc1wiO1xuaW1wb3J0IHsgVGV4dFJhbmdlIH0gZnJvbSBcIi4vdmVuZG9yL2h5cG90aGVzaXMvYW5jaG9yaW5nL3RleHQtcmFuZ2VcIjtcblxuY29uc3QgZGVidWcgPSB0cnVlO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2VsZWN0aW9uUmVjdCgpIHtcbiAgdHJ5IHtcbiAgICBsZXQgc2VsID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgIGlmICghc2VsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCByYW5nZSA9IHNlbC5nZXRSYW5nZUF0KDApO1xuXG4gICAgY29uc3QgY2xpZW50UmVjdCA9IHJhbmdlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHNjcmVlbldpZHRoOiB3aW5kb3cub3V0ZXJXaWR0aCxcbiAgICAgIHNjcmVlbkhlaWdodDogd2luZG93Lm91dGVySGVpZ2h0LFxuICAgICAgbGVmdDogY2xpZW50UmVjdC5sZWZ0LFxuICAgICAgd2lkdGg6IGNsaWVudFJlY3Qud2lkdGgsXG4gICAgICB0b3A6IGNsaWVudFJlY3QudG9wLFxuICAgICAgaGVpZ2h0OiBjbGllbnRSZWN0LmhlaWdodCxcbiAgICB9O1xuICB9IGNhdGNoIChlKSB7XG4gICAgbG9nRXhjZXB0aW9uKGUpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDdXJyZW50U2VsZWN0aW9uSW5mbygpIHtcbiAgY29uc3Qgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICBpZiAoIXNlbGVjdGlvbikge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKHNlbGVjdGlvbi5pc0NvbGxhcHNlZCkge1xuICAgIGxvZyhcIl5eXiBTRUxFQ1RJT04gQ09MTEFQU0VELlwiKTtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGNvbnN0IHJhd1RleHQgPSBzZWxlY3Rpb24udG9TdHJpbmcoKTtcbiAgY29uc3QgY2xlYW5UZXh0ID0gcmF3VGV4dC50cmltKCkucmVwbGFjZSgvXFxuL2csIFwiIFwiKS5yZXBsYWNlKC9cXHNcXHMrL2csIFwiIFwiKTtcbiAgaWYgKGNsZWFuVGV4dC5sZW5ndGggPT09IDApIHtcbiAgICBsb2coXCJeXl4gU0VMRUNUSU9OIFRFWFQgRU1QVFkuXCIpO1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKCFzZWxlY3Rpb24uYW5jaG9yTm9kZSB8fCAhc2VsZWN0aW9uLmZvY3VzTm9kZSkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgY29uc3QgcmFuZ2UgPVxuICAgIHNlbGVjdGlvbi5yYW5nZUNvdW50ID09PSAxXG4gICAgICA/IHNlbGVjdGlvbi5nZXRSYW5nZUF0KDApXG4gICAgICA6IGNyZWF0ZU9yZGVyZWRSYW5nZShcbiAgICAgICAgICBzZWxlY3Rpb24uYW5jaG9yTm9kZSxcbiAgICAgICAgICBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0LFxuICAgICAgICAgIHNlbGVjdGlvbi5mb2N1c05vZGUsXG4gICAgICAgICAgc2VsZWN0aW9uLmZvY3VzT2Zmc2V0XG4gICAgICAgICk7XG4gIGlmICghcmFuZ2UgfHwgcmFuZ2UuY29sbGFwc2VkKSB7XG4gICAgbG9nKFwiJCQkJCQkJCQkJCQkJCQkJCQgQ0FOTk9UIEdFVCBOT04tQ09MTEFQU0VEIFNFTEVDVElPTiBSQU5HRT8hXCIpO1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgY29uc3QgcmFuZ2VJbmZvID0gY29udmVydFJhbmdlKHJhbmdlLCBmdWxsUXVhbGlmaWVkU2VsZWN0b3IpO1xuICBpZiAoIXJhbmdlSW5mbykge1xuICAgIGxvZyhcIl5eXiBTRUxFQ1RJT04gUkFOR0UgSU5GTyBGQUlMPyFcIik7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIGNvbnN0IHRleHQgPSBkb2N1bWVudC5ib2R5LnRleHRDb250ZW50O1xuICBjb25zdCB0ZXh0UmFuZ2UgPSBUZXh0UmFuZ2UuZnJvbVJhbmdlKHJhbmdlKS5yZWxhdGl2ZVRvKGRvY3VtZW50LmJvZHkpO1xuICBjb25zdCBzdGFydCA9IHRleHRSYW5nZS5zdGFydC5vZmZzZXQ7XG4gIGNvbnN0IGVuZCA9IHRleHRSYW5nZS5lbmQub2Zmc2V0O1xuXG4gIGNvbnN0IHNuaXBwZXRMZW5ndGggPSAyMDA7XG5cbiAgLy8gQ29tcHV0ZSB0aGUgdGV4dCBiZWZvcmUgdGhlIGhpZ2hsaWdodCwgaWdub3JpbmcgdGhlIGZpcnN0IFwid29yZFwiLCB3aGljaCBtaWdodCBiZSBjdXQuXG4gIGxldCBiZWZvcmUgPSB0ZXh0LnNsaWNlKE1hdGgubWF4KDAsIHN0YXJ0IC0gc25pcHBldExlbmd0aCksIHN0YXJ0KTtcbiAgbGV0IGZpcnN0V29yZFN0YXJ0ID0gYmVmb3JlLnNlYXJjaCgvXFxQe0x9XFxwe0x9L2d1KTtcbiAgaWYgKGZpcnN0V29yZFN0YXJ0ICE9PSAtMSkge1xuICAgIGJlZm9yZSA9IGJlZm9yZS5zbGljZShmaXJzdFdvcmRTdGFydCArIDEpO1xuICB9XG5cbiAgLy8gQ29tcHV0ZSB0aGUgdGV4dCBhZnRlciB0aGUgaGlnaGxpZ2h0LCBpZ25vcmluZyB0aGUgbGFzdCBcIndvcmRcIiwgd2hpY2ggbWlnaHQgYmUgY3V0LlxuICBsZXQgYWZ0ZXIgPSB0ZXh0LnNsaWNlKGVuZCwgTWF0aC5taW4odGV4dC5sZW5ndGgsIGVuZCArIHNuaXBwZXRMZW5ndGgpKTtcbiAgbGV0IGxhc3RXb3JkRW5kID0gQXJyYXkuZnJvbShhZnRlci5tYXRjaEFsbCgvXFxwe0x9XFxQe0x9L2d1KSkucG9wKCk7XG4gIGlmIChsYXN0V29yZEVuZCAhPT0gdW5kZWZpbmVkICYmIGxhc3RXb3JkRW5kLmluZGV4ID4gMSkge1xuICAgIGFmdGVyID0gYWZ0ZXIuc2xpY2UoMCwgbGFzdFdvcmRFbmQuaW5kZXggKyAxKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbG9jYXRpb25zOiByYW5nZUluZm8yTG9jYXRpb24ocmFuZ2VJbmZvKSxcbiAgICB0ZXh0OiB7XG4gICAgICBoaWdobGlnaHQ6IHJhd1RleHQsXG4gICAgICBiZWZvcmU6IGJlZm9yZSxcbiAgICAgIGFmdGVyOiBhZnRlcixcbiAgICB9LFxuICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVPcmRlcmVkUmFuZ2Uoc3RhcnROb2RlLCBzdGFydE9mZnNldCwgZW5kTm9kZSwgZW5kT2Zmc2V0KSB7XG4gIGNvbnN0IHJhbmdlID0gbmV3IFJhbmdlKCk7XG4gIHJhbmdlLnNldFN0YXJ0KHN0YXJ0Tm9kZSwgc3RhcnRPZmZzZXQpO1xuICByYW5nZS5zZXRFbmQoZW5kTm9kZSwgZW5kT2Zmc2V0KTtcbiAgaWYgKCFyYW5nZS5jb2xsYXBzZWQpIHtcbiAgICByZXR1cm4gcmFuZ2U7XG4gIH1cbiAgbG9nKFwiPj4+IGNyZWF0ZU9yZGVyZWRSYW5nZSBDT0xMQVBTRUQgLi4uIFJBTkdFIFJFVkVSU0U/XCIpO1xuICBjb25zdCByYW5nZVJldmVyc2UgPSBuZXcgUmFuZ2UoKTtcbiAgcmFuZ2VSZXZlcnNlLnNldFN0YXJ0KGVuZE5vZGUsIGVuZE9mZnNldCk7XG4gIHJhbmdlUmV2ZXJzZS5zZXRFbmQoc3RhcnROb2RlLCBzdGFydE9mZnNldCk7XG4gIGlmICghcmFuZ2VSZXZlcnNlLmNvbGxhcHNlZCkge1xuICAgIGxvZyhcIj4+PiBjcmVhdGVPcmRlcmVkUmFuZ2UgUkFOR0UgUkVWRVJTRSBPSy5cIik7XG4gICAgcmV0dXJuIHJhbmdlO1xuICB9XG4gIGxvZyhcIj4+PiBjcmVhdGVPcmRlcmVkUmFuZ2UgUkFOR0UgUkVWRVJTRSBBTFNPIENPTExBUFNFRD8hXCIpO1xuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0UmFuZ2UocmFuZ2UsIGdldENzc1NlbGVjdG9yKSB7XG4gIGNvbnN0IHN0YXJ0SXNFbGVtZW50ID0gcmFuZ2Uuc3RhcnRDb250YWluZXIubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFO1xuICBjb25zdCBzdGFydENvbnRhaW5lckVsZW1lbnQgPSBzdGFydElzRWxlbWVudFxuICAgID8gcmFuZ2Uuc3RhcnRDb250YWluZXJcbiAgICA6IHJhbmdlLnN0YXJ0Q29udGFpbmVyLnBhcmVudE5vZGUgJiZcbiAgICAgIHJhbmdlLnN0YXJ0Q29udGFpbmVyLnBhcmVudE5vZGUubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFXG4gICAgPyByYW5nZS5zdGFydENvbnRhaW5lci5wYXJlbnROb2RlXG4gICAgOiB1bmRlZmluZWQ7XG4gIGlmICghc3RhcnRDb250YWluZXJFbGVtZW50KSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBjb25zdCBzdGFydENvbnRhaW5lckNoaWxkVGV4dE5vZGVJbmRleCA9IHN0YXJ0SXNFbGVtZW50XG4gICAgPyAtMVxuICAgIDogQXJyYXkuZnJvbShzdGFydENvbnRhaW5lckVsZW1lbnQuY2hpbGROb2RlcykuaW5kZXhPZihcbiAgICAgICAgcmFuZ2Uuc3RhcnRDb250YWluZXJcbiAgICAgICk7XG4gIGlmIChzdGFydENvbnRhaW5lckNoaWxkVGV4dE5vZGVJbmRleCA8IC0xKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBjb25zdCBzdGFydENvbnRhaW5lckVsZW1lbnRDc3NTZWxlY3RvciA9IGdldENzc1NlbGVjdG9yKFxuICAgIHN0YXJ0Q29udGFpbmVyRWxlbWVudFxuICApO1xuXG4gIGNvbnN0IGVuZElzRWxlbWVudCA9IHJhbmdlLmVuZENvbnRhaW5lci5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREU7XG4gIGNvbnN0IGVuZENvbnRhaW5lckVsZW1lbnQgPSBlbmRJc0VsZW1lbnRcbiAgICA/IHJhbmdlLmVuZENvbnRhaW5lclxuICAgIDogcmFuZ2UuZW5kQ29udGFpbmVyLnBhcmVudE5vZGUgJiZcbiAgICAgIHJhbmdlLmVuZENvbnRhaW5lci5wYXJlbnROb2RlLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERVxuICAgID8gcmFuZ2UuZW5kQ29udGFpbmVyLnBhcmVudE5vZGVcbiAgICA6IHVuZGVmaW5lZDtcbiAgaWYgKCFlbmRDb250YWluZXJFbGVtZW50KSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBjb25zdCBlbmRDb250YWluZXJDaGlsZFRleHROb2RlSW5kZXggPSBlbmRJc0VsZW1lbnRcbiAgICA/IC0xXG4gICAgOiBBcnJheS5mcm9tKGVuZENvbnRhaW5lckVsZW1lbnQuY2hpbGROb2RlcykuaW5kZXhPZihyYW5nZS5lbmRDb250YWluZXIpO1xuICBpZiAoZW5kQ29udGFpbmVyQ2hpbGRUZXh0Tm9kZUluZGV4IDwgLTEpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGNvbnN0IGVuZENvbnRhaW5lckVsZW1lbnRDc3NTZWxlY3RvciA9IGdldENzc1NlbGVjdG9yKGVuZENvbnRhaW5lckVsZW1lbnQpO1xuXG4gIGNvbnN0IGNvbW1vbkVsZW1lbnRBbmNlc3RvciA9IGdldENvbW1vbkFuY2VzdG9yRWxlbWVudChcbiAgICByYW5nZS5zdGFydENvbnRhaW5lcixcbiAgICByYW5nZS5lbmRDb250YWluZXJcbiAgKTtcbiAgaWYgKCFjb21tb25FbGVtZW50QW5jZXN0b3IpIHtcbiAgICBsb2coXCJeXl4gTk8gUkFOR0UgQ09NTU9OIEFOQ0VTVE9SPyFcIik7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBpZiAocmFuZ2UuY29tbW9uQW5jZXN0b3JDb250YWluZXIpIHtcbiAgICBjb25zdCByYW5nZUNvbW1vbkFuY2VzdG9yRWxlbWVudCA9XG4gICAgICByYW5nZS5jb21tb25BbmNlc3RvckNvbnRhaW5lci5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREVcbiAgICAgICAgPyByYW5nZS5jb21tb25BbmNlc3RvckNvbnRhaW5lclxuICAgICAgICA6IHJhbmdlLmNvbW1vbkFuY2VzdG9yQ29udGFpbmVyLnBhcmVudE5vZGU7XG4gICAgaWYgKFxuICAgICAgcmFuZ2VDb21tb25BbmNlc3RvckVsZW1lbnQgJiZcbiAgICAgIHJhbmdlQ29tbW9uQW5jZXN0b3JFbGVtZW50Lm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERVxuICAgICkge1xuICAgICAgaWYgKGNvbW1vbkVsZW1lbnRBbmNlc3RvciAhPT0gcmFuZ2VDb21tb25BbmNlc3RvckVsZW1lbnQpIHtcbiAgICAgICAgbG9nKFwiPj4+Pj4+IENPTU1PTiBBTkNFU1RPUiBDT05UQUlORVIgRElGRj8/IVwiKTtcbiAgICAgICAgbG9nKGdldENzc1NlbGVjdG9yKGNvbW1vbkVsZW1lbnRBbmNlc3RvcikpO1xuICAgICAgICBsb2coZ2V0Q3NzU2VsZWN0b3IocmFuZ2VDb21tb25BbmNlc3RvckVsZW1lbnQpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBlbmRDb250YWluZXJDaGlsZFRleHROb2RlSW5kZXgsXG4gICAgZW5kQ29udGFpbmVyRWxlbWVudENzc1NlbGVjdG9yLFxuICAgIGVuZE9mZnNldDogcmFuZ2UuZW5kT2Zmc2V0LFxuICAgIHN0YXJ0Q29udGFpbmVyQ2hpbGRUZXh0Tm9kZUluZGV4LFxuICAgIHN0YXJ0Q29udGFpbmVyRWxlbWVudENzc1NlbGVjdG9yLFxuICAgIHN0YXJ0T2Zmc2V0OiByYW5nZS5zdGFydE9mZnNldCxcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0Q29tbW9uQW5jZXN0b3JFbGVtZW50KG5vZGUxLCBub2RlMikge1xuICBpZiAobm9kZTEubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFICYmIG5vZGUxID09PSBub2RlMikge1xuICAgIHJldHVybiBub2RlMTtcbiAgfVxuICBpZiAobm9kZTEubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFICYmIG5vZGUxLmNvbnRhaW5zKG5vZGUyKSkge1xuICAgIHJldHVybiBub2RlMTtcbiAgfVxuICBpZiAobm9kZTIubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFICYmIG5vZGUyLmNvbnRhaW5zKG5vZGUxKSkge1xuICAgIHJldHVybiBub2RlMjtcbiAgfVxuICBjb25zdCBub2RlMUVsZW1lbnRBbmNlc3RvckNoYWluID0gW107XG4gIGxldCBwYXJlbnQgPSBub2RlMS5wYXJlbnROb2RlO1xuICB3aGlsZSAocGFyZW50ICYmIHBhcmVudC5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICBub2RlMUVsZW1lbnRBbmNlc3RvckNoYWluLnB1c2gocGFyZW50KTtcbiAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZTtcbiAgfVxuICBjb25zdCBub2RlMkVsZW1lbnRBbmNlc3RvckNoYWluID0gW107XG4gIHBhcmVudCA9IG5vZGUyLnBhcmVudE5vZGU7XG4gIHdoaWxlIChwYXJlbnQgJiYgcGFyZW50Lm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgIG5vZGUyRWxlbWVudEFuY2VzdG9yQ2hhaW4ucHVzaChwYXJlbnQpO1xuICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xuICB9XG4gIGxldCBjb21tb25BbmNlc3RvciA9IG5vZGUxRWxlbWVudEFuY2VzdG9yQ2hhaW4uZmluZChcbiAgICAobm9kZTFFbGVtZW50QW5jZXN0b3IpID0+IHtcbiAgICAgIHJldHVybiBub2RlMkVsZW1lbnRBbmNlc3RvckNoYWluLmluZGV4T2Yobm9kZTFFbGVtZW50QW5jZXN0b3IpID49IDA7XG4gICAgfVxuICApO1xuICBpZiAoIWNvbW1vbkFuY2VzdG9yKSB7XG4gICAgY29tbW9uQW5jZXN0b3IgPSBub2RlMkVsZW1lbnRBbmNlc3RvckNoYWluLmZpbmQoKG5vZGUyRWxlbWVudEFuY2VzdG9yKSA9PiB7XG4gICAgICByZXR1cm4gbm9kZTFFbGVtZW50QW5jZXN0b3JDaGFpbi5pbmRleE9mKG5vZGUyRWxlbWVudEFuY2VzdG9yKSA+PSAwO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBjb21tb25BbmNlc3Rvcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRSYW5nZUluZm8oZG9jdW1lbnQsIHJhbmdlSW5mbykge1xuICBjb25zdCBzdGFydEVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFxuICAgIHJhbmdlSW5mby5zdGFydENvbnRhaW5lckVsZW1lbnRDc3NTZWxlY3RvclxuICApO1xuICBpZiAoIXN0YXJ0RWxlbWVudCkge1xuICAgIGxvZyhcIl5eXiBjb252ZXJ0UmFuZ2VJbmZvIE5PIFNUQVJUIEVMRU1FTlQgQ1NTIFNFTEVDVE9SPyFcIik7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBsZXQgc3RhcnRDb250YWluZXIgPSBzdGFydEVsZW1lbnQ7XG4gIGlmIChyYW5nZUluZm8uc3RhcnRDb250YWluZXJDaGlsZFRleHROb2RlSW5kZXggPj0gMCkge1xuICAgIGlmIChcbiAgICAgIHJhbmdlSW5mby5zdGFydENvbnRhaW5lckNoaWxkVGV4dE5vZGVJbmRleCA+PVxuICAgICAgc3RhcnRFbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoXG4gICAgKSB7XG4gICAgICBsb2coXG4gICAgICAgIFwiXl5eIGNvbnZlcnRSYW5nZUluZm8gcmFuZ2VJbmZvLnN0YXJ0Q29udGFpbmVyQ2hpbGRUZXh0Tm9kZUluZGV4ID49IHN0YXJ0RWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aD8hXCJcbiAgICAgICk7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBzdGFydENvbnRhaW5lciA9XG4gICAgICBzdGFydEVsZW1lbnQuY2hpbGROb2Rlc1tyYW5nZUluZm8uc3RhcnRDb250YWluZXJDaGlsZFRleHROb2RlSW5kZXhdO1xuICAgIGlmIChzdGFydENvbnRhaW5lci5ub2RlVHlwZSAhPT0gTm9kZS5URVhUX05PREUpIHtcbiAgICAgIGxvZyhcIl5eXiBjb252ZXJ0UmFuZ2VJbmZvIHN0YXJ0Q29udGFpbmVyLm5vZGVUeXBlICE9PSBOb2RlLlRFWFRfTk9ERT8hXCIpO1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cbiAgY29uc3QgZW5kRWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXG4gICAgcmFuZ2VJbmZvLmVuZENvbnRhaW5lckVsZW1lbnRDc3NTZWxlY3RvclxuICApO1xuICBpZiAoIWVuZEVsZW1lbnQpIHtcbiAgICBsb2coXCJeXl4gY29udmVydFJhbmdlSW5mbyBOTyBFTkQgRUxFTUVOVCBDU1MgU0VMRUNUT1I/IVwiKTtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGxldCBlbmRDb250YWluZXIgPSBlbmRFbGVtZW50O1xuICBpZiAocmFuZ2VJbmZvLmVuZENvbnRhaW5lckNoaWxkVGV4dE5vZGVJbmRleCA+PSAwKSB7XG4gICAgaWYgKFxuICAgICAgcmFuZ2VJbmZvLmVuZENvbnRhaW5lckNoaWxkVGV4dE5vZGVJbmRleCA+PSBlbmRFbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoXG4gICAgKSB7XG4gICAgICBsb2coXG4gICAgICAgIFwiXl5eIGNvbnZlcnRSYW5nZUluZm8gcmFuZ2VJbmZvLmVuZENvbnRhaW5lckNoaWxkVGV4dE5vZGVJbmRleCA+PSBlbmRFbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoPyFcIlxuICAgICAgKTtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGVuZENvbnRhaW5lciA9XG4gICAgICBlbmRFbGVtZW50LmNoaWxkTm9kZXNbcmFuZ2VJbmZvLmVuZENvbnRhaW5lckNoaWxkVGV4dE5vZGVJbmRleF07XG4gICAgaWYgKGVuZENvbnRhaW5lci5ub2RlVHlwZSAhPT0gTm9kZS5URVhUX05PREUpIHtcbiAgICAgIGxvZyhcIl5eXiBjb252ZXJ0UmFuZ2VJbmZvIGVuZENvbnRhaW5lci5ub2RlVHlwZSAhPT0gTm9kZS5URVhUX05PREU/IVwiKTtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBjcmVhdGVPcmRlcmVkUmFuZ2UoXG4gICAgc3RhcnRDb250YWluZXIsXG4gICAgcmFuZ2VJbmZvLnN0YXJ0T2Zmc2V0LFxuICAgIGVuZENvbnRhaW5lcixcbiAgICByYW5nZUluZm8uZW5kT2Zmc2V0XG4gICk7XG59XG5cbmZ1bmN0aW9uIHJhbmdlSW5mbzJMb2NhdGlvbihyYW5nZUluZm8pIHtcbiAgcmV0dXJuIHtcbiAgICBjc3NTZWxlY3RvcjogcmFuZ2VJbmZvLnN0YXJ0Q29udGFpbmVyRWxlbWVudENzc1NlbGVjdG9yLFxuICAgIGRvbVJhbmdlOiB7XG4gICAgICBzdGFydDoge1xuICAgICAgICBjc3NTZWxlY3RvcjogcmFuZ2VJbmZvLnN0YXJ0Q29udGFpbmVyRWxlbWVudENzc1NlbGVjdG9yLFxuICAgICAgICB0ZXh0Tm9kZUluZGV4OiByYW5nZUluZm8uc3RhcnRDb250YWluZXJDaGlsZFRleHROb2RlSW5kZXgsXG4gICAgICAgIG9mZnNldDogcmFuZ2VJbmZvLnN0YXJ0T2Zmc2V0LFxuICAgICAgfSxcbiAgICAgIGVuZDoge1xuICAgICAgICBjc3NTZWxlY3RvcjogcmFuZ2VJbmZvLmVuZENvbnRhaW5lckVsZW1lbnRDc3NTZWxlY3RvcixcbiAgICAgICAgdGV4dE5vZGVJbmRleDogcmFuZ2VJbmZvLmVuZENvbnRhaW5lckNoaWxkVGV4dE5vZGVJbmRleCxcbiAgICAgICAgb2Zmc2V0OiByYW5nZUluZm8uZW5kT2Zmc2V0LFxuICAgICAgfSxcbiAgICB9LFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbG9jYXRpb24yUmFuZ2VJbmZvKGxvY2F0aW9uKSB7XG4gIGNvbnN0IGxvY2F0aW9ucyA9IGxvY2F0aW9uLmxvY2F0aW9ucztcbiAgY29uc3QgZG9tUmFuZ2UgPSBsb2NhdGlvbnMuZG9tUmFuZ2U7XG4gIGNvbnN0IHN0YXJ0ID0gZG9tUmFuZ2Uuc3RhcnQ7XG4gIGNvbnN0IGVuZCA9IGRvbVJhbmdlLmVuZDtcblxuICByZXR1cm4ge1xuICAgIGVuZENvbnRhaW5lckNoaWxkVGV4dE5vZGVJbmRleDogZW5kLnRleHROb2RlSW5kZXgsXG4gICAgZW5kQ29udGFpbmVyRWxlbWVudENzc1NlbGVjdG9yOiBlbmQuY3NzU2VsZWN0b3IsXG4gICAgZW5kT2Zmc2V0OiBlbmQub2Zmc2V0LFxuICAgIHN0YXJ0Q29udGFpbmVyQ2hpbGRUZXh0Tm9kZUluZGV4OiBzdGFydC50ZXh0Tm9kZUluZGV4LFxuICAgIHN0YXJ0Q29udGFpbmVyRWxlbWVudENzc1NlbGVjdG9yOiBzdGFydC5jc3NTZWxlY3RvcixcbiAgICBzdGFydE9mZnNldDogc3RhcnQub2Zmc2V0LFxuICB9O1xufVxuXG5mdW5jdGlvbiBmdWxsUXVhbGlmaWVkU2VsZWN0b3Iobm9kZSkge1xuICBpZiAobm9kZS5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICByZXR1cm4gKFxuICAgICAgKG5vZGUubG9jYWxOYW1lICYmIG5vZGUubG9jYWxOYW1lLnRvTG93ZXJDYXNlKCkpIHx8XG4gICAgICBub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKClcbiAgICApO1xuICB9XG4gIC8vcmV0dXJuIGNzc1BhdGgobm9kZSwganVzdFNlbGVjdG9yKTtcbiAgcmV0dXJuIGNzc1BhdGgobm9kZSwgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGNzc1BhdGgobm9kZSwgb3B0aW1pemVkKSB7XG4gIGlmIChub2RlLm5vZGVUeXBlICE9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgIHJldHVybiBcIlwiO1xuICB9XG5cbiAgY29uc3Qgc3RlcHMgPSBbXTtcbiAgbGV0IGNvbnRleHROb2RlID0gbm9kZTtcbiAgd2hpbGUgKGNvbnRleHROb2RlKSB7XG4gICAgY29uc3Qgc3RlcCA9IF9jc3NQYXRoU3RlcChjb250ZXh0Tm9kZSwgISFvcHRpbWl6ZWQsIGNvbnRleHROb2RlID09PSBub2RlKTtcbiAgICBpZiAoIXN0ZXApIHtcbiAgICAgIGJyZWFrOyAvLyBFcnJvciAtIGJhaWwgb3V0IGVhcmx5LlxuICAgIH1cbiAgICBzdGVwcy5wdXNoKHN0ZXAudmFsdWUpO1xuICAgIGlmIChzdGVwLm9wdGltaXplZCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNvbnRleHROb2RlID0gY29udGV4dE5vZGUucGFyZW50Tm9kZTtcbiAgfVxuICBzdGVwcy5yZXZlcnNlKCk7XG4gIHJldHVybiBzdGVwcy5qb2luKFwiID4gXCIpO1xufVxuXG4vLyBodHRwczovL2Nocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vYmxpbmsvKy9tYXN0ZXIvU291cmNlL2RldnRvb2xzL2Zyb250X2VuZC9jb21wb25lbnRzL0RPTVByZXNlbnRhdGlvblV0aWxzLmpzIzMxNlxuZnVuY3Rpb24gX2Nzc1BhdGhTdGVwKG5vZGUsIG9wdGltaXplZCwgaXNUYXJnZXROb2RlKSB7XG4gIGZ1bmN0aW9uIGlkU2VsZWN0b3IoaWRkKSB7XG4gICAgcmV0dXJuIFwiI1wiICsgZXNjYXBlSWRlbnRpZmllcklmTmVlZGVkKGlkZCk7XG4gIH1cblxuICBmdW5jdGlvbiBlc2NhcGVJZGVudGlmaWVySWZOZWVkZWQoaWRlbnQpIHtcbiAgICBpZiAoaXNDU1NJZGVudGlmaWVyKGlkZW50KSkge1xuICAgICAgcmV0dXJuIGlkZW50O1xuICAgIH1cblxuICAgIGNvbnN0IHNob3VsZEVzY2FwZUZpcnN0ID0gL14oPzpbMC05XXwtWzAtOS1dPykvLnRlc3QoaWRlbnQpO1xuICAgIGNvbnN0IGxhc3RJbmRleCA9IGlkZW50Lmxlbmd0aCAtIDE7XG4gICAgcmV0dXJuIGlkZW50LnJlcGxhY2UoLy4vZywgZnVuY3Rpb24gKGMsIGlpKSB7XG4gICAgICByZXR1cm4gKHNob3VsZEVzY2FwZUZpcnN0ICYmIGlpID09PSAwKSB8fCAhaXNDU1NJZGVudENoYXIoYylcbiAgICAgICAgPyBlc2NhcGVBc2NpaUNoYXIoYywgaWkgPT09IGxhc3RJbmRleClcbiAgICAgICAgOiBjO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNDU1NJZGVudGlmaWVyKHZhbHVlKSB7XG4gICAgcmV0dXJuIC9eLT9bYS16QS1aX11bYS16QS1aMC05Xy1dKiQvLnRlc3QodmFsdWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNDU1NJZGVudENoYXIoYykge1xuICAgIGlmICgvW2EtekEtWjAtOV8tXS8udGVzdChjKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBjLmNoYXJDb2RlQXQoMCkgPj0gMHhhMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVzY2FwZUFzY2lpQ2hhcihjLCBpc0xhc3QpIHtcbiAgICByZXR1cm4gXCJcXFxcXCIgKyB0b0hleEJ5dGUoYykgKyAoaXNMYXN0ID8gXCJcIiA6IFwiIFwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRvSGV4Qnl0ZShjKSB7XG4gICAgbGV0IGhleEJ5dGUgPSBjLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpO1xuICAgIGlmIChoZXhCeXRlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgaGV4Qnl0ZSA9IFwiMFwiICsgaGV4Qnl0ZTtcbiAgICB9XG4gICAgcmV0dXJuIGhleEJ5dGU7XG4gIH1cblxuICBmdW5jdGlvbiBwcmVmaXhlZEVsZW1lbnRDbGFzc05hbWVzKG5kKSB7XG4gICAgY29uc3QgY2xhc3NBdHRyaWJ1dGUgPSBuZC5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKTtcbiAgICBpZiAoIWNsYXNzQXR0cmlidXRlKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsYXNzQXR0cmlidXRlXG4gICAgICAuc3BsaXQoL1xccysvZylcbiAgICAgIC5maWx0ZXIoQm9vbGVhbilcbiAgICAgIC5tYXAoKG5tKSA9PiB7XG4gICAgICAgIC8vIFRoZSBwcmVmaXggaXMgcmVxdWlyZWQgdG8gc3RvcmUgXCJfX3Byb3RvX19cIiBpbiBhIG9iamVjdC1iYXNlZCBtYXAuXG4gICAgICAgIHJldHVybiBcIiRcIiArIG5tO1xuICAgICAgfSk7XG4gIH1cblxuICBpZiAobm9kZS5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGNvbnN0IGxvd2VyQ2FzZU5hbWUgPVxuICAgIChub2RlLmxvY2FsTmFtZSAmJiBub2RlLmxvY2FsTmFtZS50b0xvd2VyQ2FzZSgpKSB8fFxuICAgIG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblxuICBjb25zdCBlbGVtZW50ID0gbm9kZTtcblxuICBjb25zdCBpZCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiaWRcIik7XG5cbiAgaWYgKG9wdGltaXplZCkge1xuICAgIGlmIChpZCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb3B0aW1pemVkOiB0cnVlLFxuICAgICAgICB2YWx1ZTogaWRTZWxlY3RvcihpZCksXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoXG4gICAgICBsb3dlckNhc2VOYW1lID09PSBcImJvZHlcIiB8fFxuICAgICAgbG93ZXJDYXNlTmFtZSA9PT0gXCJoZWFkXCIgfHxcbiAgICAgIGxvd2VyQ2FzZU5hbWUgPT09IFwiaHRtbFwiXG4gICAgKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBvcHRpbWl6ZWQ6IHRydWUsXG4gICAgICAgIHZhbHVlOiBsb3dlckNhc2VOYW1lLCAvLyBub2RlLm5vZGVOYW1lSW5Db3JyZWN0Q2FzZSgpLFxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBub2RlTmFtZSA9IGxvd2VyQ2FzZU5hbWU7IC8vIG5vZGUubm9kZU5hbWVJbkNvcnJlY3RDYXNlKCk7XG4gIGlmIChpZCkge1xuICAgIHJldHVybiB7XG4gICAgICBvcHRpbWl6ZWQ6IHRydWUsXG4gICAgICB2YWx1ZTogbm9kZU5hbWUgKyBpZFNlbGVjdG9yKGlkKSxcbiAgICB9O1xuICB9XG5cbiAgY29uc3QgcGFyZW50ID0gbm9kZS5wYXJlbnROb2RlO1xuXG4gIGlmICghcGFyZW50IHx8IHBhcmVudC5ub2RlVHlwZSA9PT0gTm9kZS5ET0NVTUVOVF9OT0RFKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9wdGltaXplZDogdHJ1ZSxcbiAgICAgIHZhbHVlOiBub2RlTmFtZSxcbiAgICB9O1xuICB9XG5cbiAgY29uc3QgcHJlZml4ZWRPd25DbGFzc05hbWVzQXJyYXlfID0gcHJlZml4ZWRFbGVtZW50Q2xhc3NOYW1lcyhlbGVtZW50KTtcblxuICBjb25zdCBwcmVmaXhlZE93bkNsYXNzTmFtZXNBcnJheSA9IFtdOyAvLyAua2V5U2V0KClcbiAgcHJlZml4ZWRPd25DbGFzc05hbWVzQXJyYXlfLmZvckVhY2goKGFyckl0ZW0pID0+IHtcbiAgICBpZiAocHJlZml4ZWRPd25DbGFzc05hbWVzQXJyYXkuaW5kZXhPZihhcnJJdGVtKSA8IDApIHtcbiAgICAgIHByZWZpeGVkT3duQ2xhc3NOYW1lc0FycmF5LnB1c2goYXJySXRlbSk7XG4gICAgfVxuICB9KTtcblxuICBsZXQgbmVlZHNDbGFzc05hbWVzID0gZmFsc2U7XG4gIGxldCBuZWVkc050aENoaWxkID0gZmFsc2U7XG4gIGxldCBvd25JbmRleCA9IC0xO1xuICBsZXQgZWxlbWVudEluZGV4ID0gLTE7XG4gIGNvbnN0IHNpYmxpbmdzID0gcGFyZW50LmNoaWxkcmVuO1xuXG4gIGZvciAoXG4gICAgbGV0IGkgPSAwO1xuICAgIChvd25JbmRleCA9PT0gLTEgfHwgIW5lZWRzTnRoQ2hpbGQpICYmIGkgPCBzaWJsaW5ncy5sZW5ndGg7XG4gICAgKytpXG4gICkge1xuICAgIGNvbnN0IHNpYmxpbmcgPSBzaWJsaW5nc1tpXTtcbiAgICBpZiAoc2libGluZy5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBlbGVtZW50SW5kZXggKz0gMTtcbiAgICBpZiAoc2libGluZyA9PT0gbm9kZSkge1xuICAgICAgb3duSW5kZXggPSBlbGVtZW50SW5kZXg7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKG5lZWRzTnRoQ2hpbGQpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIHNpYmxpbmcubm9kZU5hbWVJbkNvcnJlY3RDYXNlKClcbiAgICBjb25zdCBzaWJsaW5nTmFtZSA9XG4gICAgICAoc2libGluZy5sb2NhbE5hbWUgJiYgc2libGluZy5sb2NhbE5hbWUudG9Mb3dlckNhc2UoKSkgfHxcbiAgICAgIHNpYmxpbmcubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAoc2libGluZ05hbWUgIT09IG5vZGVOYW1lKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgbmVlZHNDbGFzc05hbWVzID0gdHJ1ZTtcblxuICAgIGNvbnN0IG93bkNsYXNzTmFtZXMgPSBbXTtcbiAgICBwcmVmaXhlZE93bkNsYXNzTmFtZXNBcnJheS5mb3JFYWNoKChhcnJJdGVtKSA9PiB7XG4gICAgICBvd25DbGFzc05hbWVzLnB1c2goYXJySXRlbSk7XG4gICAgfSk7XG4gICAgbGV0IG93bkNsYXNzTmFtZUNvdW50ID0gb3duQ2xhc3NOYW1lcy5sZW5ndGg7XG5cbiAgICBpZiAob3duQ2xhc3NOYW1lQ291bnQgPT09IDApIHtcbiAgICAgIG5lZWRzTnRoQ2hpbGQgPSB0cnVlO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IHNpYmxpbmdDbGFzc05hbWVzQXJyYXlfID0gcHJlZml4ZWRFbGVtZW50Q2xhc3NOYW1lcyhzaWJsaW5nKTtcbiAgICBjb25zdCBzaWJsaW5nQ2xhc3NOYW1lc0FycmF5ID0gW107IC8vIC5rZXlTZXQoKVxuICAgIHNpYmxpbmdDbGFzc05hbWVzQXJyYXlfLmZvckVhY2goKGFyckl0ZW0pID0+IHtcbiAgICAgIGlmIChzaWJsaW5nQ2xhc3NOYW1lc0FycmF5LmluZGV4T2YoYXJySXRlbSkgPCAwKSB7XG4gICAgICAgIHNpYmxpbmdDbGFzc05hbWVzQXJyYXkucHVzaChhcnJJdGVtKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGZvciAoY29uc3Qgc2libGluZ0NsYXNzIG9mIHNpYmxpbmdDbGFzc05hbWVzQXJyYXkpIHtcbiAgICAgIGNvbnN0IGluZCA9IG93bkNsYXNzTmFtZXMuaW5kZXhPZihzaWJsaW5nQ2xhc3MpO1xuICAgICAgaWYgKGluZCA8IDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIG93bkNsYXNzTmFtZXMuc3BsaWNlKGluZCwgMSk7IC8vIGRlbGV0ZSBvd25DbGFzc05hbWVzW3NpYmxpbmdDbGFzc107XG5cbiAgICAgIGlmICghLS1vd25DbGFzc05hbWVDb3VudCkge1xuICAgICAgICBuZWVkc050aENoaWxkID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgbGV0IHJlc3VsdCA9IG5vZGVOYW1lO1xuICBpZiAoXG4gICAgaXNUYXJnZXROb2RlICYmXG4gICAgbm9kZU5hbWUgPT09IFwiaW5wdXRcIiAmJlxuICAgIGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwidHlwZVwiKSAmJlxuICAgICFlbGVtZW50LmdldEF0dHJpYnV0ZShcImlkXCIpICYmXG4gICAgIWVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIilcbiAgKSB7XG4gICAgcmVzdWx0ICs9ICdbdHlwZT1cIicgKyBlbGVtZW50LmdldEF0dHJpYnV0ZShcInR5cGVcIikgKyAnXCJdJztcbiAgfVxuICBpZiAobmVlZHNOdGhDaGlsZCkge1xuICAgIHJlc3VsdCArPSBcIjpudGgtY2hpbGQoXCIgKyAob3duSW5kZXggKyAxKSArIFwiKVwiO1xuICB9IGVsc2UgaWYgKG5lZWRzQ2xhc3NOYW1lcykge1xuICAgIGZvciAoY29uc3QgcHJlZml4ZWROYW1lIG9mIHByZWZpeGVkT3duQ2xhc3NOYW1lc0FycmF5KSB7XG4gICAgICByZXN1bHQgKz0gXCIuXCIgKyBlc2NhcGVJZGVudGlmaWVySWZOZWVkZWQocHJlZml4ZWROYW1lLnN1YnN0cigxKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBvcHRpbWl6ZWQ6IGZhbHNlLFxuICAgIHZhbHVlOiByZXN1bHQsXG4gIH07XG59XG5cbmZ1bmN0aW9uIGxvZygpIHtcbiAgaWYgKGRlYnVnKSB7XG4gICAgbG9nTmF0aXZlLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gIH1cbn1cbiIsIi8vXG4vLyAgQ29weXJpZ2h0IDIwMjEgUmVhZGl1bSBGb3VuZGF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IHRoZSBCU0Qtc3R5bGUgbGljZW5zZVxuLy8gIGF2YWlsYWJsZSBpbiB0aGUgdG9wLWxldmVsIExJQ0VOU0UgZmlsZSBvZiB0aGUgcHJvamVjdC5cbi8vXG5cbmltcG9ydCB7IGxvZyBhcyBsb2dOYXRpdmUgfSBmcm9tIFwiLi91dGlsc1wiO1xuXG5jb25zdCBkZWJ1ZyA9IGZhbHNlO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2xpZW50UmVjdHNOb092ZXJsYXAoXG4gIHJhbmdlLFxuICBkb05vdE1lcmdlSG9yaXpvbnRhbGx5QWxpZ25lZFJlY3RzXG4pIHtcbiAgbGV0IGNsaWVudFJlY3RzID0gcmFuZ2UuZ2V0Q2xpZW50UmVjdHMoKTtcblxuICBjb25zdCB0b2xlcmFuY2UgPSAxO1xuICBjb25zdCBvcmlnaW5hbFJlY3RzID0gW107XG4gIGZvciAoY29uc3QgcmFuZ2VDbGllbnRSZWN0IG9mIGNsaWVudFJlY3RzKSB7XG4gICAgb3JpZ2luYWxSZWN0cy5wdXNoKHtcbiAgICAgIGJvdHRvbTogcmFuZ2VDbGllbnRSZWN0LmJvdHRvbSxcbiAgICAgIGhlaWdodDogcmFuZ2VDbGllbnRSZWN0LmhlaWdodCxcbiAgICAgIGxlZnQ6IHJhbmdlQ2xpZW50UmVjdC5sZWZ0LFxuICAgICAgcmlnaHQ6IHJhbmdlQ2xpZW50UmVjdC5yaWdodCxcbiAgICAgIHRvcDogcmFuZ2VDbGllbnRSZWN0LnRvcCxcbiAgICAgIHdpZHRoOiByYW5nZUNsaWVudFJlY3Qud2lkdGgsXG4gICAgfSk7XG4gIH1cbiAgY29uc3QgbWVyZ2VkUmVjdHMgPSBtZXJnZVRvdWNoaW5nUmVjdHMoXG4gICAgb3JpZ2luYWxSZWN0cyxcbiAgICB0b2xlcmFuY2UsXG4gICAgZG9Ob3RNZXJnZUhvcml6b250YWxseUFsaWduZWRSZWN0c1xuICApO1xuICBjb25zdCBub0NvbnRhaW5lZFJlY3RzID0gcmVtb3ZlQ29udGFpbmVkUmVjdHMobWVyZ2VkUmVjdHMsIHRvbGVyYW5jZSk7XG4gIGNvbnN0IG5ld1JlY3RzID0gcmVwbGFjZU92ZXJsYXBpbmdSZWN0cyhub0NvbnRhaW5lZFJlY3RzKTtcbiAgY29uc3QgbWluQXJlYSA9IDIgKiAyO1xuICBmb3IgKGxldCBqID0gbmV3UmVjdHMubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICBjb25zdCByZWN0ID0gbmV3UmVjdHNbal07XG4gICAgY29uc3QgYmlnRW5vdWdoID0gcmVjdC53aWR0aCAqIHJlY3QuaGVpZ2h0ID4gbWluQXJlYTtcbiAgICBpZiAoIWJpZ0Vub3VnaCkge1xuICAgICAgaWYgKG5ld1JlY3RzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgbG9nKFwiQ0xJRU5UIFJFQ1Q6IHJlbW92ZSBzbWFsbFwiKTtcbiAgICAgICAgbmV3UmVjdHMuc3BsaWNlKGosIDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbG9nKFwiQ0xJRU5UIFJFQ1Q6IHJlbW92ZSBzbWFsbCwgYnV0IGtlZXAgb3RoZXJ3aXNlIGVtcHR5IVwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGxvZyhgQ0xJRU5UIFJFQ1Q6IHJlZHVjZWQgJHtvcmlnaW5hbFJlY3RzLmxlbmd0aH0gLS0+ICR7bmV3UmVjdHMubGVuZ3RofWApO1xuICByZXR1cm4gbmV3UmVjdHM7XG59XG5cbmZ1bmN0aW9uIG1lcmdlVG91Y2hpbmdSZWN0cyhcbiAgcmVjdHMsXG4gIHRvbGVyYW5jZSxcbiAgZG9Ob3RNZXJnZUhvcml6b250YWxseUFsaWduZWRSZWN0c1xuKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcmVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCByZWN0cy5sZW5ndGg7IGorKykge1xuICAgICAgY29uc3QgcmVjdDEgPSByZWN0c1tpXTtcbiAgICAgIGNvbnN0IHJlY3QyID0gcmVjdHNbal07XG4gICAgICBpZiAocmVjdDEgPT09IHJlY3QyKSB7XG4gICAgICAgIGxvZyhcIm1lcmdlVG91Y2hpbmdSZWN0cyByZWN0MSA9PT0gcmVjdDIgPz8hXCIpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlY3RzTGluZVVwVmVydGljYWxseSA9XG4gICAgICAgIGFsbW9zdEVxdWFsKHJlY3QxLnRvcCwgcmVjdDIudG9wLCB0b2xlcmFuY2UpICYmXG4gICAgICAgIGFsbW9zdEVxdWFsKHJlY3QxLmJvdHRvbSwgcmVjdDIuYm90dG9tLCB0b2xlcmFuY2UpO1xuICAgICAgY29uc3QgcmVjdHNMaW5lVXBIb3Jpem9udGFsbHkgPVxuICAgICAgICBhbG1vc3RFcXVhbChyZWN0MS5sZWZ0LCByZWN0Mi5sZWZ0LCB0b2xlcmFuY2UpICYmXG4gICAgICAgIGFsbW9zdEVxdWFsKHJlY3QxLnJpZ2h0LCByZWN0Mi5yaWdodCwgdG9sZXJhbmNlKTtcbiAgICAgIGNvbnN0IGhvcml6b250YWxBbGxvd2VkID0gIWRvTm90TWVyZ2VIb3Jpem9udGFsbHlBbGlnbmVkUmVjdHM7XG4gICAgICBjb25zdCBhbGlnbmVkID1cbiAgICAgICAgKHJlY3RzTGluZVVwSG9yaXpvbnRhbGx5ICYmIGhvcml6b250YWxBbGxvd2VkKSB8fFxuICAgICAgICAocmVjdHNMaW5lVXBWZXJ0aWNhbGx5ICYmICFyZWN0c0xpbmVVcEhvcml6b250YWxseSk7XG4gICAgICBjb25zdCBjYW5NZXJnZSA9IGFsaWduZWQgJiYgcmVjdHNUb3VjaE9yT3ZlcmxhcChyZWN0MSwgcmVjdDIsIHRvbGVyYW5jZSk7XG4gICAgICBpZiAoY2FuTWVyZ2UpIHtcbiAgICAgICAgbG9nKFxuICAgICAgICAgIGBDTElFTlQgUkVDVDogbWVyZ2luZyB0d28gaW50byBvbmUsIFZFUlRJQ0FMOiAke3JlY3RzTGluZVVwVmVydGljYWxseX0gSE9SSVpPTlRBTDogJHtyZWN0c0xpbmVVcEhvcml6b250YWxseX0gKCR7ZG9Ob3RNZXJnZUhvcml6b250YWxseUFsaWduZWRSZWN0c30pYFxuICAgICAgICApO1xuICAgICAgICBjb25zdCBuZXdSZWN0cyA9IHJlY3RzLmZpbHRlcigocmVjdCkgPT4ge1xuICAgICAgICAgIHJldHVybiByZWN0ICE9PSByZWN0MSAmJiByZWN0ICE9PSByZWN0MjtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlcGxhY2VtZW50Q2xpZW50UmVjdCA9IGdldEJvdW5kaW5nUmVjdChyZWN0MSwgcmVjdDIpO1xuICAgICAgICBuZXdSZWN0cy5wdXNoKHJlcGxhY2VtZW50Q2xpZW50UmVjdCk7XG4gICAgICAgIHJldHVybiBtZXJnZVRvdWNoaW5nUmVjdHMoXG4gICAgICAgICAgbmV3UmVjdHMsXG4gICAgICAgICAgdG9sZXJhbmNlLFxuICAgICAgICAgIGRvTm90TWVyZ2VIb3Jpem9udGFsbHlBbGlnbmVkUmVjdHNcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlY3RzO1xufVxuXG5mdW5jdGlvbiBnZXRCb3VuZGluZ1JlY3QocmVjdDEsIHJlY3QyKSB7XG4gIGNvbnN0IGxlZnQgPSBNYXRoLm1pbihyZWN0MS5sZWZ0LCByZWN0Mi5sZWZ0KTtcbiAgY29uc3QgcmlnaHQgPSBNYXRoLm1heChyZWN0MS5yaWdodCwgcmVjdDIucmlnaHQpO1xuICBjb25zdCB0b3AgPSBNYXRoLm1pbihyZWN0MS50b3AsIHJlY3QyLnRvcCk7XG4gIGNvbnN0IGJvdHRvbSA9IE1hdGgubWF4KHJlY3QxLmJvdHRvbSwgcmVjdDIuYm90dG9tKTtcbiAgcmV0dXJuIHtcbiAgICBib3R0b20sXG4gICAgaGVpZ2h0OiBib3R0b20gLSB0b3AsXG4gICAgbGVmdCxcbiAgICByaWdodCxcbiAgICB0b3AsXG4gICAgd2lkdGg6IHJpZ2h0IC0gbGVmdCxcbiAgfTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlQ29udGFpbmVkUmVjdHMocmVjdHMsIHRvbGVyYW5jZSkge1xuICBjb25zdCByZWN0c1RvS2VlcCA9IG5ldyBTZXQocmVjdHMpO1xuICBmb3IgKGNvbnN0IHJlY3Qgb2YgcmVjdHMpIHtcbiAgICBjb25zdCBiaWdFbm91Z2ggPSByZWN0LndpZHRoID4gMSAmJiByZWN0LmhlaWdodCA+IDE7XG4gICAgaWYgKCFiaWdFbm91Z2gpIHtcbiAgICAgIGxvZyhcIkNMSUVOVCBSRUNUOiByZW1vdmUgdGlueVwiKTtcbiAgICAgIHJlY3RzVG9LZWVwLmRlbGV0ZShyZWN0KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHBvc3NpYmx5Q29udGFpbmluZ1JlY3Qgb2YgcmVjdHMpIHtcbiAgICAgIGlmIChyZWN0ID09PSBwb3NzaWJseUNvbnRhaW5pbmdSZWN0KSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKCFyZWN0c1RvS2VlcC5oYXMocG9zc2libHlDb250YWluaW5nUmVjdCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAocmVjdENvbnRhaW5zKHBvc3NpYmx5Q29udGFpbmluZ1JlY3QsIHJlY3QsIHRvbGVyYW5jZSkpIHtcbiAgICAgICAgbG9nKFwiQ0xJRU5UIFJFQ1Q6IHJlbW92ZSBjb250YWluZWRcIik7XG4gICAgICAgIHJlY3RzVG9LZWVwLmRlbGV0ZShyZWN0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBBcnJheS5mcm9tKHJlY3RzVG9LZWVwKTtcbn1cblxuZnVuY3Rpb24gcmVjdENvbnRhaW5zKHJlY3QxLCByZWN0MiwgdG9sZXJhbmNlKSB7XG4gIHJldHVybiAoXG4gICAgcmVjdENvbnRhaW5zUG9pbnQocmVjdDEsIHJlY3QyLmxlZnQsIHJlY3QyLnRvcCwgdG9sZXJhbmNlKSAmJlxuICAgIHJlY3RDb250YWluc1BvaW50KHJlY3QxLCByZWN0Mi5yaWdodCwgcmVjdDIudG9wLCB0b2xlcmFuY2UpICYmXG4gICAgcmVjdENvbnRhaW5zUG9pbnQocmVjdDEsIHJlY3QyLmxlZnQsIHJlY3QyLmJvdHRvbSwgdG9sZXJhbmNlKSAmJlxuICAgIHJlY3RDb250YWluc1BvaW50KHJlY3QxLCByZWN0Mi5yaWdodCwgcmVjdDIuYm90dG9tLCB0b2xlcmFuY2UpXG4gICk7XG59XG5cbmZ1bmN0aW9uIHJlY3RDb250YWluc1BvaW50KHJlY3QsIHgsIHksIHRvbGVyYW5jZSkge1xuICByZXR1cm4gKFxuICAgIChyZWN0LmxlZnQgPCB4IHx8IGFsbW9zdEVxdWFsKHJlY3QubGVmdCwgeCwgdG9sZXJhbmNlKSkgJiZcbiAgICAocmVjdC5yaWdodCA+IHggfHwgYWxtb3N0RXF1YWwocmVjdC5yaWdodCwgeCwgdG9sZXJhbmNlKSkgJiZcbiAgICAocmVjdC50b3AgPCB5IHx8IGFsbW9zdEVxdWFsKHJlY3QudG9wLCB5LCB0b2xlcmFuY2UpKSAmJlxuICAgIChyZWN0LmJvdHRvbSA+IHkgfHwgYWxtb3N0RXF1YWwocmVjdC5ib3R0b20sIHksIHRvbGVyYW5jZSkpXG4gICk7XG59XG5cbmZ1bmN0aW9uIHJlcGxhY2VPdmVybGFwaW5nUmVjdHMocmVjdHMpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByZWN0cy5sZW5ndGg7IGkrKykge1xuICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IHJlY3RzLmxlbmd0aDsgaisrKSB7XG4gICAgICBjb25zdCByZWN0MSA9IHJlY3RzW2ldO1xuICAgICAgY29uc3QgcmVjdDIgPSByZWN0c1tqXTtcbiAgICAgIGlmIChyZWN0MSA9PT0gcmVjdDIpIHtcbiAgICAgICAgbG9nKFwicmVwbGFjZU92ZXJsYXBpbmdSZWN0cyByZWN0MSA9PT0gcmVjdDIgPz8hXCIpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChyZWN0c1RvdWNoT3JPdmVybGFwKHJlY3QxLCByZWN0MiwgLTEpKSB7XG4gICAgICAgIGxldCB0b0FkZCA9IFtdO1xuICAgICAgICBsZXQgdG9SZW1vdmU7XG4gICAgICAgIGNvbnN0IHN1YnRyYWN0UmVjdHMxID0gcmVjdFN1YnRyYWN0KHJlY3QxLCByZWN0Mik7XG4gICAgICAgIGlmIChzdWJ0cmFjdFJlY3RzMS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICB0b0FkZCA9IHN1YnRyYWN0UmVjdHMxO1xuICAgICAgICAgIHRvUmVtb3ZlID0gcmVjdDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3Qgc3VidHJhY3RSZWN0czIgPSByZWN0U3VidHJhY3QocmVjdDIsIHJlY3QxKTtcbiAgICAgICAgICBpZiAoc3VidHJhY3RSZWN0czEubGVuZ3RoIDwgc3VidHJhY3RSZWN0czIubGVuZ3RoKSB7XG4gICAgICAgICAgICB0b0FkZCA9IHN1YnRyYWN0UmVjdHMxO1xuICAgICAgICAgICAgdG9SZW1vdmUgPSByZWN0MTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdG9BZGQgPSBzdWJ0cmFjdFJlY3RzMjtcbiAgICAgICAgICAgIHRvUmVtb3ZlID0gcmVjdDI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxvZyhgQ0xJRU5UIFJFQ1Q6IG92ZXJsYXAsIGN1dCBvbmUgcmVjdCBpbnRvICR7dG9BZGQubGVuZ3RofWApO1xuICAgICAgICBjb25zdCBuZXdSZWN0cyA9IHJlY3RzLmZpbHRlcigocmVjdCkgPT4ge1xuICAgICAgICAgIHJldHVybiByZWN0ICE9PSB0b1JlbW92ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KG5ld1JlY3RzLCB0b0FkZCk7XG4gICAgICAgIHJldHVybiByZXBsYWNlT3ZlcmxhcGluZ1JlY3RzKG5ld1JlY3RzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlY3RzO1xufVxuXG5mdW5jdGlvbiByZWN0U3VidHJhY3QocmVjdDEsIHJlY3QyKSB7XG4gIGNvbnN0IHJlY3RJbnRlcnNlY3RlZCA9IHJlY3RJbnRlcnNlY3QocmVjdDIsIHJlY3QxKTtcbiAgaWYgKHJlY3RJbnRlcnNlY3RlZC5oZWlnaHQgPT09IDAgfHwgcmVjdEludGVyc2VjdGVkLndpZHRoID09PSAwKSB7XG4gICAgcmV0dXJuIFtyZWN0MV07XG4gIH1cbiAgY29uc3QgcmVjdHMgPSBbXTtcbiAge1xuICAgIGNvbnN0IHJlY3RBID0ge1xuICAgICAgYm90dG9tOiByZWN0MS5ib3R0b20sXG4gICAgICBoZWlnaHQ6IDAsXG4gICAgICBsZWZ0OiByZWN0MS5sZWZ0LFxuICAgICAgcmlnaHQ6IHJlY3RJbnRlcnNlY3RlZC5sZWZ0LFxuICAgICAgdG9wOiByZWN0MS50b3AsXG4gICAgICB3aWR0aDogMCxcbiAgICB9O1xuICAgIHJlY3RBLndpZHRoID0gcmVjdEEucmlnaHQgLSByZWN0QS5sZWZ0O1xuICAgIHJlY3RBLmhlaWdodCA9IHJlY3RBLmJvdHRvbSAtIHJlY3RBLnRvcDtcbiAgICBpZiAocmVjdEEuaGVpZ2h0ICE9PSAwICYmIHJlY3RBLndpZHRoICE9PSAwKSB7XG4gICAgICByZWN0cy5wdXNoKHJlY3RBKTtcbiAgICB9XG4gIH1cbiAge1xuICAgIGNvbnN0IHJlY3RCID0ge1xuICAgICAgYm90dG9tOiByZWN0SW50ZXJzZWN0ZWQudG9wLFxuICAgICAgaGVpZ2h0OiAwLFxuICAgICAgbGVmdDogcmVjdEludGVyc2VjdGVkLmxlZnQsXG4gICAgICByaWdodDogcmVjdEludGVyc2VjdGVkLnJpZ2h0LFxuICAgICAgdG9wOiByZWN0MS50b3AsXG4gICAgICB3aWR0aDogMCxcbiAgICB9O1xuICAgIHJlY3RCLndpZHRoID0gcmVjdEIucmlnaHQgLSByZWN0Qi5sZWZ0O1xuICAgIHJlY3RCLmhlaWdodCA9IHJlY3RCLmJvdHRvbSAtIHJlY3RCLnRvcDtcbiAgICBpZiAocmVjdEIuaGVpZ2h0ICE9PSAwICYmIHJlY3RCLndpZHRoICE9PSAwKSB7XG4gICAgICByZWN0cy5wdXNoKHJlY3RCKTtcbiAgICB9XG4gIH1cbiAge1xuICAgIGNvbnN0IHJlY3RDID0ge1xuICAgICAgYm90dG9tOiByZWN0MS5ib3R0b20sXG4gICAgICBoZWlnaHQ6IDAsXG4gICAgICBsZWZ0OiByZWN0SW50ZXJzZWN0ZWQubGVmdCxcbiAgICAgIHJpZ2h0OiByZWN0SW50ZXJzZWN0ZWQucmlnaHQsXG4gICAgICB0b3A6IHJlY3RJbnRlcnNlY3RlZC5ib3R0b20sXG4gICAgICB3aWR0aDogMCxcbiAgICB9O1xuICAgIHJlY3RDLndpZHRoID0gcmVjdEMucmlnaHQgLSByZWN0Qy5sZWZ0O1xuICAgIHJlY3RDLmhlaWdodCA9IHJlY3RDLmJvdHRvbSAtIHJlY3RDLnRvcDtcbiAgICBpZiAocmVjdEMuaGVpZ2h0ICE9PSAwICYmIHJlY3RDLndpZHRoICE9PSAwKSB7XG4gICAgICByZWN0cy5wdXNoKHJlY3RDKTtcbiAgICB9XG4gIH1cbiAge1xuICAgIGNvbnN0IHJlY3REID0ge1xuICAgICAgYm90dG9tOiByZWN0MS5ib3R0b20sXG4gICAgICBoZWlnaHQ6IDAsXG4gICAgICBsZWZ0OiByZWN0SW50ZXJzZWN0ZWQucmlnaHQsXG4gICAgICByaWdodDogcmVjdDEucmlnaHQsXG4gICAgICB0b3A6IHJlY3QxLnRvcCxcbiAgICAgIHdpZHRoOiAwLFxuICAgIH07XG4gICAgcmVjdEQud2lkdGggPSByZWN0RC5yaWdodCAtIHJlY3RELmxlZnQ7XG4gICAgcmVjdEQuaGVpZ2h0ID0gcmVjdEQuYm90dG9tIC0gcmVjdEQudG9wO1xuICAgIGlmIChyZWN0RC5oZWlnaHQgIT09IDAgJiYgcmVjdEQud2lkdGggIT09IDApIHtcbiAgICAgIHJlY3RzLnB1c2gocmVjdEQpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVjdHM7XG59XG5cbmZ1bmN0aW9uIHJlY3RJbnRlcnNlY3QocmVjdDEsIHJlY3QyKSB7XG4gIGNvbnN0IG1heExlZnQgPSBNYXRoLm1heChyZWN0MS5sZWZ0LCByZWN0Mi5sZWZ0KTtcbiAgY29uc3QgbWluUmlnaHQgPSBNYXRoLm1pbihyZWN0MS5yaWdodCwgcmVjdDIucmlnaHQpO1xuICBjb25zdCBtYXhUb3AgPSBNYXRoLm1heChyZWN0MS50b3AsIHJlY3QyLnRvcCk7XG4gIGNvbnN0IG1pbkJvdHRvbSA9IE1hdGgubWluKHJlY3QxLmJvdHRvbSwgcmVjdDIuYm90dG9tKTtcbiAgcmV0dXJuIHtcbiAgICBib3R0b206IG1pbkJvdHRvbSxcbiAgICBoZWlnaHQ6IE1hdGgubWF4KDAsIG1pbkJvdHRvbSAtIG1heFRvcCksXG4gICAgbGVmdDogbWF4TGVmdCxcbiAgICByaWdodDogbWluUmlnaHQsXG4gICAgdG9wOiBtYXhUb3AsXG4gICAgd2lkdGg6IE1hdGgubWF4KDAsIG1pblJpZ2h0IC0gbWF4TGVmdCksXG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlY3RzVG91Y2hPck92ZXJsYXAocmVjdDEsIHJlY3QyLCB0b2xlcmFuY2UpIHtcbiAgcmV0dXJuIChcbiAgICAocmVjdDEubGVmdCA8IHJlY3QyLnJpZ2h0IHx8XG4gICAgICAodG9sZXJhbmNlID49IDAgJiYgYWxtb3N0RXF1YWwocmVjdDEubGVmdCwgcmVjdDIucmlnaHQsIHRvbGVyYW5jZSkpKSAmJlxuICAgIChyZWN0Mi5sZWZ0IDwgcmVjdDEucmlnaHQgfHxcbiAgICAgICh0b2xlcmFuY2UgPj0gMCAmJiBhbG1vc3RFcXVhbChyZWN0Mi5sZWZ0LCByZWN0MS5yaWdodCwgdG9sZXJhbmNlKSkpICYmXG4gICAgKHJlY3QxLnRvcCA8IHJlY3QyLmJvdHRvbSB8fFxuICAgICAgKHRvbGVyYW5jZSA+PSAwICYmIGFsbW9zdEVxdWFsKHJlY3QxLnRvcCwgcmVjdDIuYm90dG9tLCB0b2xlcmFuY2UpKSkgJiZcbiAgICAocmVjdDIudG9wIDwgcmVjdDEuYm90dG9tIHx8XG4gICAgICAodG9sZXJhbmNlID49IDAgJiYgYWxtb3N0RXF1YWwocmVjdDIudG9wLCByZWN0MS5ib3R0b20sIHRvbGVyYW5jZSkpKVxuICApO1xufVxuXG5mdW5jdGlvbiBhbG1vc3RFcXVhbChhLCBiLCB0b2xlcmFuY2UpIHtcbiAgcmV0dXJuIE1hdGguYWJzKGEgLSBiKSA8PSB0b2xlcmFuY2U7XG59XG5cbmZ1bmN0aW9uIGxvZygpIHtcbiAgaWYgKGRlYnVnKSB7XG4gICAgbG9nTmF0aXZlLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gIH1cbn1cbiIsIi8vXG4vLyAgQ29weXJpZ2h0IDIwMjEgUmVhZGl1bSBGb3VuZGF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IHRoZSBCU0Qtc3R5bGUgbGljZW5zZVxuLy8gIGF2YWlsYWJsZSBpbiB0aGUgdG9wLWxldmVsIExJQ0VOU0UgZmlsZSBvZiB0aGUgcHJvamVjdC5cbi8vXG5cbmltcG9ydCB7IGNvbnZlcnRSYW5nZUluZm8sIGxvY2F0aW9uMlJhbmdlSW5mbyB9IGZyb20gXCIuL3NlbGVjdGlvblwiO1xuaW1wb3J0IHsgZ2V0Q2xpZW50UmVjdHNOb092ZXJsYXAgfSBmcm9tIFwiLi9yZWN0XCI7XG5pbXBvcnQgeyBpc1Njcm9sbE1vZGVFbmFibGVkLCBsb2csIGxvZ0V4Y2VwdGlvbiB9IGZyb20gXCIuL3V0aWxzXCI7XG5pbXBvcnQgeyBUZXh0UXVvdGVBbmNob3IgfSBmcm9tIFwiLi92ZW5kb3IvaHlwb3RoZXNpcy9hbmNob3JpbmcvdHlwZXNcIjtcblxuY29uc3QgZGVidWcgPSBmYWxzZTtcblxuY29uc3QgSURfSElHSExJR0hUU19DT05UQUlORVIgPSBcIlIyX0lEX0hJR0hMSUdIVFNfQ09OVEFJTkVSXCI7XG5jb25zdCBDTEFTU19ISUdITElHSFRfQ09OVEFJTkVSID0gXCJSMl9DTEFTU19ISUdITElHSFRfQ09OVEFJTkVSXCI7XG5jb25zdCBDTEFTU19ISUdITElHSFRfQVJFQSA9IFwiUjJfQ0xBU1NfSElHSExJR0hUX0FSRUFcIjtcbmNvbnN0IENMQVNTX0hJR0hMSUdIVF9CT1VORElOR19BUkVBID0gXCJSMl9DTEFTU19ISUdITElHSFRfQk9VTkRJTkdfQVJFQVwiO1xuXG5jb25zdCBfaGlnaGxpZ2h0cyA9IFtdO1xubGV0IF9oaWdobGlnaHRzQ29udGFpbmVyO1xuXG5jb25zdCBkZWZhdWx0QmFja2dyb3VuZE9wYWNpdHkgPSAwLjM7XG5cbmNvbnN0IGRlZmF1bHRCYWNrZ3JvdW5kQ29sb3IgPSB7XG4gIGJsdWU6IDEwMCxcbiAgZ3JlZW46IDUwLFxuICByZWQ6IDIzMCxcbn07XG5cbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKFxuICBcImxvYWRcIixcbiAgZnVuY3Rpb24gKCkge1xuICAgIC8vIG9uIHBhZ2UgbG9hZFxuICAgIGNvbnN0IGJvZHkgPSBkb2N1bWVudC5ib2R5O1xuICAgIHZhciBsYXN0U2l6ZSA9IHsgd2lkdGg6IDAsIGhlaWdodDogMCB9O1xuICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKCgpID0+IHtcbiAgICAgIGxvZyhib2R5LmNsaWVudFdpZHRoLCBib2R5LmNsaWVudEhlaWdodCk7XG4gICAgICBpZiAoXG4gICAgICAgIGxhc3RTaXplLndpZHRoID09PSBib2R5LmNsaWVudFdpZHRoICYmXG4gICAgICAgIGxhc3RTaXplLmhlaWdodCA9PT0gYm9keS5jbGllbnRIZWlnaHRcbiAgICAgICkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsYXN0U2l6ZSA9IHtcbiAgICAgICAgd2lkdGg6IGJvZHkuY2xpZW50V2lkdGgsXG4gICAgICAgIGhlaWdodDogYm9keS5jbGllbnRIZWlnaHQsXG4gICAgICB9O1xuICAgICAgcmVzZXRIaWdobGlnaHRzKCk7XG4gICAgfSk7XG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZShib2R5KTtcbiAgfSxcbiAgZmFsc2Vcbik7XG5cbmV4cG9ydCBmdW5jdGlvbiByZWN0Rm9ySGlnaGxpZ2h0V2l0aElEKGlkKSB7XG4gIGNvbnN0IGNsaWVudFJlY3RzID0gZnJhbWVGb3JIaWdobGlnaHRXaXRoSUQoaWQpO1xuXG4gIHJldHVybiB7XG4gICAgc2NyZWVuV2lkdGg6IHdpbmRvdy5vdXRlcldpZHRoLFxuICAgIHNjcmVlbkhlaWdodDogd2luZG93Lm91dGVySGVpZ2h0LFxuICAgIGxlZnQ6IGNsaWVudFJlY3RzWzBdLmxlZnQsXG4gICAgd2lkdGg6IGNsaWVudFJlY3RzWzBdLndpZHRoLFxuICAgIHRvcDogY2xpZW50UmVjdHNbMF0udG9wLFxuICAgIGhlaWdodDogY2xpZW50UmVjdHNbMF0uaGVpZ2h0LFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2xlYXJIaWdobGlnaHRzKCkge1xuICBoaWRlQWxsSGlnaGxpZ2h0cygpO1xuICBfaGlnaGxpZ2h0cy5zcGxpY2UoMCwgX2hpZ2hsaWdodHMubGVuZ3RoKTtcbn1cblxuZnVuY3Rpb24gaGlkZUFsbEhpZ2hsaWdodHMoKSB7XG4gIGlmIChfaGlnaGxpZ2h0c0NvbnRhaW5lcikge1xuICAgIF9oaWdobGlnaHRzQ29udGFpbmVyLnJlbW92ZSgpO1xuICAgIF9oaWdobGlnaHRzQ29udGFpbmVyID0gbnVsbDtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNldEhpZ2hsaWdodHMoKSB7XG4gIGhpZGVBbGxIaWdobGlnaHRzKCk7XG5cbiAgbGV0IGkgPSBfaGlnaGxpZ2h0cy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBsZXQgaGlnaGxpZ2h0ID0gX2hpZ2hsaWdodHNbaV07XG4gICAgaWYgKGhpZ2hsaWdodC50cmFuc2llbnQpIHtcbiAgICAgIF9oaWdobGlnaHRzLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3JlYXRlSGlnaGxpZ2h0RE9NKGhpZ2hsaWdodCk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoaWdobGlnaHQobG9jYXRvcikge1xuICBsZXQgdGV4dCA9IGxvY2F0b3IudGV4dDtcbiAgaWYgKCF0ZXh0IHx8ICF0ZXh0LmhpZ2hsaWdodCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRyeSB7XG4gICAgbGV0IGFuY2hvciA9IG5ldyBUZXh0UXVvdGVBbmNob3IoZG9jdW1lbnQuYm9keSwgdGV4dC5oaWdobGlnaHQsIHtcbiAgICAgIHByZWZpeDogdGV4dC5iZWZvcmUsXG4gICAgICBzdWZmaXg6IHRleHQuYWZ0ZXIsXG4gICAgfSk7XG4gICAgYW5jaG9yLnRvUmFuZ2UoKTtcbiAgICBoaWdobGlnaHRSYW5nZShhbmNob3IudG9SYW5nZSgpKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGxvZ0V4Y2VwdGlvbihlKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaGlnaGxpZ2h0UmFuZ2UocmFuZ2UpIHtcbiAgLy8gRklYTUU6IFVzZSB1c2VyLXByb3ZpZGVkIElELlxuICBsZXQgaWQgPSBcIlIyX0hJR0hMSUdIVF9cIiArIERhdGUubm93KCk7XG5cbiAgZGVzdHJveUhpZ2hsaWdodChpZCk7XG5cbiAgY29uc3QgaGlnaGxpZ2h0ID0ge1xuICAgIGNvbG9yOiBkZWZhdWx0QmFja2dyb3VuZENvbG9yLFxuICAgIGlkLFxuICAgIHBvaW50ZXJJbnRlcmFjdGlvbjogdHJ1ZSxcbiAgICByYW5nZTogcmFuZ2UsXG4gICAgdHJhbnNpZW50OiB0cnVlLFxuICB9O1xuICBfaGlnaGxpZ2h0cy5wdXNoKGhpZ2hsaWdodCk7XG4gIGNyZWF0ZUhpZ2hsaWdodERPTShoaWdobGlnaHQpO1xuXG4gIHJldHVybiBoaWdobGlnaHQ7XG59XG5cbmZ1bmN0aW9uIGRlc3Ryb3lIaWdobGlnaHQoaWQpIHtcbiAgbGV0IGkgPSAtMTtcbiAgbGV0IF9kb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudDtcbiAgY29uc3QgaGlnaGxpZ2h0ID0gX2hpZ2hsaWdodHMuZmluZCgoaCwgaikgPT4ge1xuICAgIGkgPSBqO1xuICAgIHJldHVybiBoLmlkID09PSBpZDtcbiAgfSk7XG4gIGlmIChoaWdobGlnaHQgJiYgaSA+PSAwICYmIGkgPCBfaGlnaGxpZ2h0cy5sZW5ndGgpIHtcbiAgICBfaGlnaGxpZ2h0cy5zcGxpY2UoaSwgMSk7XG4gIH1cbiAgY29uc3QgaGlnaGxpZ2h0Q29udGFpbmVyID0gX2RvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKTtcbiAgaWYgKGhpZ2hsaWdodENvbnRhaW5lcikge1xuICAgIGhpZ2hsaWdodENvbnRhaW5lci5yZW1vdmUoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVIaWdobGlnaHRET00oaGlnaGxpZ2h0KSB7XG4gIGlmICghaGlnaGxpZ2h0LnJhbmdlKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIGNvbnN0IHNjcm9sbEVsZW1lbnQgPSBkb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50O1xuXG4gIGNvbnN0IHBhZ2luYXRlZCA9ICFpc1Njcm9sbE1vZGVFbmFibGVkKCk7XG4gIGNvbnN0IGhpZ2hsaWdodHNDb250YWluZXIgPSBlbnN1cmVDb250YWluZXIod2luZG93KTtcbiAgY29uc3QgaGlnaGxpZ2h0UGFyZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcblxuICBoaWdobGlnaHRQYXJlbnQuc2V0QXR0cmlidXRlKFwiaWRcIiwgaGlnaGxpZ2h0LmlkKTtcbiAgaGlnaGxpZ2h0UGFyZW50LnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIENMQVNTX0hJR0hMSUdIVF9DT05UQUlORVIpO1xuXG4gIGhpZ2hsaWdodFBhcmVudC5zdHlsZS5zZXRQcm9wZXJ0eShcInBvaW50ZXItZXZlbnRzXCIsIFwibm9uZVwiKTtcbiAgaWYgKGhpZ2hsaWdodC5wb2ludGVySW50ZXJhY3Rpb24pIHtcbiAgICBoaWdobGlnaHRQYXJlbnQuc2V0QXR0cmlidXRlKFwiZGF0YS1jbGlja1wiLCBcIjFcIik7XG4gIH1cblxuICBjb25zdCBib2R5UmVjdCA9IGRvY3VtZW50LmJvZHkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIGNvbnN0IGRyYXdVbmRlcmxpbmUgPSBmYWxzZTtcbiAgY29uc3QgZHJhd1N0cmlrZVRocm91Z2ggPSBmYWxzZTtcbiAgY29uc3QgZG9Ob3RNZXJnZUhvcml6b250YWxseUFsaWduZWRSZWN0cyA9IGRyYXdVbmRlcmxpbmUgfHwgZHJhd1N0cmlrZVRocm91Z2g7XG4gIGNvbnN0IGNsaWVudFJlY3RzID0gZ2V0Q2xpZW50UmVjdHNOb092ZXJsYXAoXG4gICAgaGlnaGxpZ2h0LnJhbmdlLFxuICAgIGRvTm90TWVyZ2VIb3Jpem9udGFsbHlBbGlnbmVkUmVjdHNcbiAgKTtcbiAgY29uc3Qgcm91bmRlZENvcm5lciA9IDM7XG4gIGNvbnN0IHVuZGVybGluZVRoaWNrbmVzcyA9IDI7XG4gIGNvbnN0IHN0cmlrZVRocm91Z2hMaW5lVGhpY2tuZXNzID0gMztcbiAgY29uc3Qgb3BhY2l0eSA9IGRlZmF1bHRCYWNrZ3JvdW5kT3BhY2l0eTtcbiAgbGV0IGV4dHJhID0gXCJcIjtcblxuICBsZXQgeE9mZnNldCA9IHBhZ2luYXRlZCA/IC1zY3JvbGxFbGVtZW50LnNjcm9sbExlZnQgOiBib2R5UmVjdC5sZWZ0O1xuICBsZXQgeU9mZnNldCA9IHBhZ2luYXRlZCA/IC1zY3JvbGxFbGVtZW50LnNjcm9sbFRvcCA6IGJvZHlSZWN0LnRvcDtcblxuICBmb3IgKGNvbnN0IGNsaWVudFJlY3Qgb2YgY2xpZW50UmVjdHMpIHtcbiAgICBjb25zdCBoaWdobGlnaHRBcmVhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcblxuICAgIGhpZ2hsaWdodEFyZWEuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgQ0xBU1NfSElHSExJR0hUX0FSRUEpO1xuXG4gICAgaWYgKGRlYnVnKSB7XG4gICAgICBjb25zdCByZ2IgPSBNYXRoLnJvdW5kKDB4ZmZmZmZmICogTWF0aC5yYW5kb20oKSk7XG4gICAgICBjb25zdCByID0gcmdiID4+IDE2O1xuICAgICAgY29uc3QgZyA9IChyZ2IgPj4gOCkgJiAyNTU7XG4gICAgICBjb25zdCBiID0gcmdiICYgMjU1O1xuICAgICAgZXh0cmEgPSBgb3V0bGluZS1jb2xvcjogcmdiKCR7cn0sICR7Z30sICR7Yn0pOyBvdXRsaW5lLXN0eWxlOiBzb2xpZDsgb3V0bGluZS13aWR0aDogMXB4OyBvdXRsaW5lLW9mZnNldDogLTFweDtgO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZHJhd1VuZGVybGluZSkge1xuICAgICAgICBleHRyYSArPSBgYm9yZGVyLWJvdHRvbTogJHt1bmRlcmxpbmVUaGlja25lc3N9cHggc29saWQgcmdiYSgke2hpZ2hsaWdodC5jb2xvci5yZWR9LCAke2hpZ2hsaWdodC5jb2xvci5ncmVlbn0sICR7aGlnaGxpZ2h0LmNvbG9yLmJsdWV9LCAke29wYWNpdHl9KSAhaW1wb3J0YW50YDtcbiAgICAgIH1cbiAgICB9XG4gICAgaGlnaGxpZ2h0QXJlYS5zZXRBdHRyaWJ1dGUoXG4gICAgICBcInN0eWxlXCIsXG4gICAgICBgYm9yZGVyLXJhZGl1czogJHtyb3VuZGVkQ29ybmVyfXB4ICFpbXBvcnRhbnQ7IGJhY2tncm91bmQtY29sb3I6IHJnYmEoJHtoaWdobGlnaHQuY29sb3IucmVkfSwgJHtoaWdobGlnaHQuY29sb3IuZ3JlZW59LCAke2hpZ2hsaWdodC5jb2xvci5ibHVlfSwgJHtvcGFjaXR5fSkgIWltcG9ydGFudDsgJHtleHRyYX1gXG4gICAgKTtcbiAgICBoaWdobGlnaHRBcmVhLnN0eWxlLnNldFByb3BlcnR5KFwicG9pbnRlci1ldmVudHNcIiwgXCJub25lXCIpO1xuICAgIGhpZ2hsaWdodEFyZWEuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgaGlnaGxpZ2h0QXJlYS5zY2FsZSA9IDE7XG4gICAgLypcbiAgICAgICAgIGhpZ2hsaWdodEFyZWEucmVjdCA9IHtcbiAgICAgICAgIGhlaWdodDogY2xpZW50UmVjdC5oZWlnaHQsXG4gICAgICAgICBsZWZ0OiBjbGllbnRSZWN0LmxlZnQgLSB4T2Zmc2V0LFxuICAgICAgICAgdG9wOiBjbGllbnRSZWN0LnRvcCAtIHlPZmZzZXQsXG4gICAgICAgICB3aWR0aDogY2xpZW50UmVjdC53aWR0aCxcbiAgICAgICAgIH07XG4gICAgICAgICAqL1xuICAgIGhpZ2hsaWdodEFyZWEucmVjdCA9IHtcbiAgICAgIGhlaWdodDogY2xpZW50UmVjdC5oZWlnaHQsXG4gICAgICBsZWZ0OiBjbGllbnRSZWN0LmxlZnQgLSB4T2Zmc2V0LFxuICAgICAgdG9wOiBjbGllbnRSZWN0LnRvcCAtIHlPZmZzZXQsXG4gICAgICB3aWR0aDogY2xpZW50UmVjdC53aWR0aCxcbiAgICB9O1xuXG4gICAgaGlnaGxpZ2h0QXJlYS5zdHlsZS53aWR0aCA9IGAke2hpZ2hsaWdodEFyZWEucmVjdC53aWR0aH1weGA7XG4gICAgaGlnaGxpZ2h0QXJlYS5zdHlsZS5oZWlnaHQgPSBgJHtoaWdobGlnaHRBcmVhLnJlY3QuaGVpZ2h0fXB4YDtcbiAgICBoaWdobGlnaHRBcmVhLnN0eWxlLmxlZnQgPSBgJHtoaWdobGlnaHRBcmVhLnJlY3QubGVmdH1weGA7XG4gICAgaGlnaGxpZ2h0QXJlYS5zdHlsZS50b3AgPSBgJHtoaWdobGlnaHRBcmVhLnJlY3QudG9wfXB4YDtcbiAgICBoaWdobGlnaHRQYXJlbnQuYXBwZW5kKGhpZ2hsaWdodEFyZWEpO1xuICAgIGlmICghZGVidWcgJiYgZHJhd1N0cmlrZVRocm91Z2gpIHtcbiAgICAgIC8vaWYgKGRyYXdTdHJpa2VUaHJvdWdoKSB7XG4gICAgICBjb25zdCBoaWdobGlnaHRBcmVhTGluZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICBoaWdobGlnaHRBcmVhTGluZS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBDTEFTU19ISUdITElHSFRfQVJFQSk7XG5cbiAgICAgIGhpZ2hsaWdodEFyZWFMaW5lLnNldEF0dHJpYnV0ZShcbiAgICAgICAgXCJzdHlsZVwiLFxuICAgICAgICBgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgke2hpZ2hsaWdodC5jb2xvci5yZWR9LCAke2hpZ2hsaWdodC5jb2xvci5ncmVlbn0sICR7aGlnaGxpZ2h0LmNvbG9yLmJsdWV9LCAke29wYWNpdHl9KSAhaW1wb3J0YW50O2BcbiAgICAgICk7XG4gICAgICBoaWdobGlnaHRBcmVhTGluZS5zdHlsZS5zZXRQcm9wZXJ0eShcInBvaW50ZXItZXZlbnRzXCIsIFwibm9uZVwiKTtcbiAgICAgIGhpZ2hsaWdodEFyZWFMaW5lLnN0eWxlLnBvc2l0aW9uID0gcGFnaW5hdGVkID8gXCJmaXhlZFwiIDogXCJhYnNvbHV0ZVwiO1xuICAgICAgaGlnaGxpZ2h0QXJlYUxpbmUuc2NhbGUgPSAxO1xuICAgICAgLypcbiAgICAgICAgICAgICBoaWdobGlnaHRBcmVhTGluZS5yZWN0ID0ge1xuICAgICAgICAgICAgIGhlaWdodDogY2xpZW50UmVjdC5oZWlnaHQsXG4gICAgICAgICAgICAgbGVmdDogY2xpZW50UmVjdC5sZWZ0IC0geE9mZnNldCxcbiAgICAgICAgICAgICB0b3A6IGNsaWVudFJlY3QudG9wIC0geU9mZnNldCxcbiAgICAgICAgICAgICB3aWR0aDogY2xpZW50UmVjdC53aWR0aCxcbiAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICovXG5cbiAgICAgIGhpZ2hsaWdodEFyZWFMaW5lLnJlY3QgPSB7XG4gICAgICAgIGhlaWdodDogY2xpZW50UmVjdC5oZWlnaHQsXG4gICAgICAgIGxlZnQ6IGNsaWVudFJlY3QubGVmdCAtIHhPZmZzZXQsXG4gICAgICAgIHRvcDogY2xpZW50UmVjdC50b3AgLSB5T2Zmc2V0LFxuICAgICAgICB3aWR0aDogY2xpZW50UmVjdC53aWR0aCxcbiAgICAgIH07XG5cbiAgICAgIGhpZ2hsaWdodEFyZWFMaW5lLnN0eWxlLndpZHRoID0gYCR7aGlnaGxpZ2h0QXJlYUxpbmUucmVjdC53aWR0aH1weGA7XG4gICAgICBoaWdobGlnaHRBcmVhTGluZS5zdHlsZS5oZWlnaHQgPSBgJHtzdHJpa2VUaHJvdWdoTGluZVRoaWNrbmVzc31weGA7XG4gICAgICBoaWdobGlnaHRBcmVhTGluZS5zdHlsZS5sZWZ0ID0gYCR7aGlnaGxpZ2h0QXJlYUxpbmUucmVjdC5sZWZ0fXB4YDtcbiAgICAgIGhpZ2hsaWdodEFyZWFMaW5lLnN0eWxlLnRvcCA9IGAke1xuICAgICAgICBoaWdobGlnaHRBcmVhTGluZS5yZWN0LnRvcCArXG4gICAgICAgIGhpZ2hsaWdodEFyZWFMaW5lLnJlY3QuaGVpZ2h0IC8gMiAtXG4gICAgICAgIHN0cmlrZVRocm91Z2hMaW5lVGhpY2tuZXNzIC8gMlxuICAgICAgfXB4YDtcbiAgICAgIGhpZ2hsaWdodFBhcmVudC5hcHBlbmQoaGlnaGxpZ2h0QXJlYUxpbmUpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGhpZ2hsaWdodEJvdW5kaW5nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgaGlnaGxpZ2h0Qm91bmRpbmcuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgQ0xBU1NfSElHSExJR0hUX0JPVU5ESU5HX0FSRUEpO1xuXG4gIGhpZ2hsaWdodEJvdW5kaW5nLnN0eWxlLnNldFByb3BlcnR5KFwicG9pbnRlci1ldmVudHNcIiwgXCJub25lXCIpO1xuICBoaWdobGlnaHRCb3VuZGluZy5zdHlsZS5wb3NpdGlvbiA9IHBhZ2luYXRlZCA/IFwiZml4ZWRcIiA6IFwiYWJzb2x1dGVcIjtcbiAgaGlnaGxpZ2h0Qm91bmRpbmcuc2NhbGUgPSAxO1xuXG4gIGlmIChkZWJ1Zykge1xuICAgIGhpZ2hsaWdodEJvdW5kaW5nLnNldEF0dHJpYnV0ZShcbiAgICAgIFwic3R5bGVcIixcbiAgICAgIGBvdXRsaW5lLWNvbG9yOiBtYWdlbnRhOyBvdXRsaW5lLXN0eWxlOiBzb2xpZDsgb3V0bGluZS13aWR0aDogMXB4OyBvdXRsaW5lLW9mZnNldDogLTFweDtgXG4gICAgKTtcbiAgfVxuXG4gIGNvbnN0IHJhbmdlQm91bmRpbmdDbGllbnRSZWN0ID0gaGlnaGxpZ2h0LnJhbmdlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICBoaWdobGlnaHRCb3VuZGluZy5yZWN0ID0ge1xuICAgIGhlaWdodDogcmFuZ2VCb3VuZGluZ0NsaWVudFJlY3QuaGVpZ2h0LFxuICAgIGxlZnQ6IHJhbmdlQm91bmRpbmdDbGllbnRSZWN0LmxlZnQgLSB4T2Zmc2V0LFxuICAgIHRvcDogcmFuZ2VCb3VuZGluZ0NsaWVudFJlY3QudG9wIC0geU9mZnNldCxcbiAgICB3aWR0aDogcmFuZ2VCb3VuZGluZ0NsaWVudFJlY3Qud2lkdGgsXG4gIH07XG5cbiAgaGlnaGxpZ2h0Qm91bmRpbmcuc3R5bGUud2lkdGggPSBgJHtoaWdobGlnaHRCb3VuZGluZy5yZWN0LndpZHRofXB4YDtcbiAgaGlnaGxpZ2h0Qm91bmRpbmcuc3R5bGUuaGVpZ2h0ID0gYCR7aGlnaGxpZ2h0Qm91bmRpbmcucmVjdC5oZWlnaHR9cHhgO1xuICBoaWdobGlnaHRCb3VuZGluZy5zdHlsZS5sZWZ0ID0gYCR7aGlnaGxpZ2h0Qm91bmRpbmcucmVjdC5sZWZ0fXB4YDtcbiAgaGlnaGxpZ2h0Qm91bmRpbmcuc3R5bGUudG9wID0gYCR7aGlnaGxpZ2h0Qm91bmRpbmcucmVjdC50b3B9cHhgO1xuXG4gIGhpZ2hsaWdodFBhcmVudC5hcHBlbmQoaGlnaGxpZ2h0Qm91bmRpbmcpO1xuICBoaWdobGlnaHRzQ29udGFpbmVyLmFwcGVuZChoaWdobGlnaHRQYXJlbnQpO1xuXG4gIHJldHVybiBoaWdobGlnaHRQYXJlbnQ7XG59XG5cbmZ1bmN0aW9uIGVuc3VyZUNvbnRhaW5lcih3aW4pIHtcbiAgY29uc3QgZG9jdW1lbnQgPSB3aW4uZG9jdW1lbnQ7XG5cbiAgaWYgKCFfaGlnaGxpZ2h0c0NvbnRhaW5lcikge1xuICAgIF9oaWdobGlnaHRzQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBfaGlnaGxpZ2h0c0NvbnRhaW5lci5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBJRF9ISUdITElHSFRTX0NPTlRBSU5FUik7XG5cbiAgICBfaGlnaGxpZ2h0c0NvbnRhaW5lci5zdHlsZS5zZXRQcm9wZXJ0eShcInBvaW50ZXItZXZlbnRzXCIsIFwibm9uZVwiKTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZChfaGlnaGxpZ2h0c0NvbnRhaW5lcik7XG4gIH1cblxuICByZXR1cm4gX2hpZ2hsaWdodHNDb250YWluZXI7XG59XG5cbmZ1bmN0aW9uIGZyYW1lRm9ySGlnaGxpZ2h0V2l0aElEKGlkKSB7XG4gIGNvbnN0IGhpZ2hsaWdodCA9IGhpZ2hsaWdodFdpdGhJRChpZCk7XG4gIGlmICghaGlnaGxpZ2h0KSByZXR1cm47XG5cbiAgaWYgKCFoaWdobGlnaHQucmFuZ2UpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgY29uc3QgZHJhd1VuZGVybGluZSA9IGZhbHNlO1xuICBjb25zdCBkcmF3U3RyaWtlVGhyb3VnaCA9IGZhbHNlO1xuICBjb25zdCBkb05vdE1lcmdlSG9yaXpvbnRhbGx5QWxpZ25lZFJlY3RzID0gZHJhd1VuZGVybGluZSB8fCBkcmF3U3RyaWtlVGhyb3VnaDtcbiAgcmV0dXJuIGdldENsaWVudFJlY3RzTm9PdmVybGFwKFxuICAgIGhpZ2hsaWdodC5yYW5nZSxcbiAgICBkb05vdE1lcmdlSG9yaXpvbnRhbGx5QWxpZ25lZFJlY3RzXG4gICk7XG59XG5cbmZ1bmN0aW9uIGhpZ2hsaWdodFdpdGhJRChpZCkge1xuICByZXR1cm4gX2hpZ2hsaWdodHMuZmluZCgoaCkgPT4ge1xuICAgIHJldHVybiBoLmlkID09PSBpZDtcbiAgfSk7XG59XG4iLCIvL1xuLy8gIENvcHlyaWdodCAyMDIxIFJlYWRpdW0gRm91bmRhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSB0aGUgQlNELXN0eWxlIGxpY2Vuc2Vcbi8vICBhdmFpbGFibGUgaW4gdGhlIHRvcC1sZXZlbCBMSUNFTlNFIGZpbGUgb2YgdGhlIHByb2plY3QuXG4vL1xuXG5pbXBvcnQgeyBnZXRDbGllbnRSZWN0c05vT3ZlcmxhcCB9IGZyb20gXCIuL3JlY3RcIjtcbmltcG9ydCB7IGlzU2Nyb2xsTW9kZUVuYWJsZWQsIGxvZywgcmFuZ2VGcm9tTG9jYXRvciB9IGZyb20gXCIuL3V0aWxzXCI7XG5cbmNvbnN0IGRlYnVnID0gZmFsc2U7XG5cbmNvbnN0IGRlZmF1bHRCYWNrZ3JvdW5kT3BhY2l0eSA9IDAuMztcblxuY29uc3QgZGVmYXVsdEJhY2tncm91bmRDb2xvciA9IHtcbiAgYmx1ZTogMTAwLFxuICBncmVlbjogNTAsXG4gIHJlZDogMjMwLFxufTtcblxubGV0IGdyb3VwcyA9IG5ldyBNYXAoKTtcbnZhciBsYXN0R3JvdXBJZCA9IDA7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXREZWNvcmF0aW9ucyhncm91cElkZW50aWZpZXIpIHtcbiAgdmFyIGdyb3VwID0gZ3JvdXBzLmdldChncm91cElkZW50aWZpZXIpO1xuICBpZiAoIWdyb3VwKSB7XG4gICAgbGV0IGlkID0gXCJyMi1kZWNvcmF0aW9uLVwiICsgbGFzdEdyb3VwSWQrKztcbiAgICBncm91cCA9IERlY29yYXRpb25Hcm91cChpZCk7XG4gICAgZ3JvdXBzLnNldChncm91cElkZW50aWZpZXIsIGdyb3VwKTtcbiAgfVxuICByZXR1cm4gZ3JvdXA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBEZWNvcmF0aW9uR3JvdXAoZ3JvdXBJZCkge1xuICB2YXIgaXRlbXMgPSBbXTtcbiAgdmFyIGxhc3RJdGVtSWQgPSAwO1xuICB2YXIgY29udGFpbmVyID0gbnVsbDtcblxuICBmdW5jdGlvbiBhZGQoZGVjb3JhdGlvbikge1xuICAgIGxldCBpZCA9IGdyb3VwSWQgKyBcIi1cIiArIGxhc3RJdGVtSWQrKztcblxuICAgIGxldCByYW5nZSA9IHJhbmdlRnJvbUxvY2F0b3IoZGVjb3JhdGlvbi5sb2NhdG9yKTtcbiAgICBpZiAoIXJhbmdlKSB7XG4gICAgICBsb2coXCJDYW4ndCBsb2NhdGUgRE9NIHJhbmdlIGZvciBkZWNvcmF0aW9uXCIsIGRlY29yYXRpb24pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBpdGVtID0geyBpZCwgZGVjb3JhdGlvbiwgcmFuZ2UgfTtcbiAgICBpdGVtcy5wdXNoKGl0ZW0pO1xuICAgIGxheW91dChpdGVtKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZShkZWNvcmF0aW9uSWRlbnRpZmllcikge1xuICAgIGxldCBpbmRleCA9IGl0ZW1zLmZpbmRJbmRleChcbiAgICAgIChpKSA9PiBpLmRlY29yYXRpb24uaWRlbnRpZmllciA9PT0gZGVjb3JhdGlvbklkZW50aWZpZXJcbiAgICApO1xuICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgaXRlbSA9IGl0ZW1zW2luZGV4XTtcbiAgICBpdGVtcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIGxldCBpdGVtQ29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaXRlbS5pZCk7XG4gICAgaWYgKGl0ZW1Db250YWluZXIpIHtcbiAgICAgIGl0ZW1Db250YWluZXIucmVtb3ZlKCk7XG4gICAgICBpdGVtQ29udGFpbmVyID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGUoZGVjb3JhdGlvbikge1xuICAgIHJlbW92ZShkZWNvcmF0aW9uLmlkZW50aWZpZXIpO1xuICAgIGFkZChkZWNvcmF0aW9uKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIGNsZWFyQ29udGFpbmVyKCk7XG4gICAgaXRlbXMgPSBbXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlcXVlc3RMYXlvdXQoKSB7XG4gICAgY2xlYXJDb250YWluZXIoKTtcbiAgICBpdGVtcy5mb3JFYWNoKChpdGVtKSA9PiBsYXlvdXQoaXRlbSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gbGF5b3V0KGl0ZW0pIHtcbiAgICBsZXQgc2Nyb2xsRWxlbWVudCA9IGRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnQ7XG4gICAgbGV0IGdyb3VwQ29udGFpbmVyID0gcmVxdWlyZUNvbnRhaW5lcigpO1xuICAgIGxldCBwYWdpbmF0ZWQgPSAhaXNTY3JvbGxNb2RlRW5hYmxlZCgpO1xuXG4gICAgbGV0IGl0ZW1Db250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGl0ZW1Db250YWluZXIuc2V0QXR0cmlidXRlKFwiaWRcIiwgaXRlbS5pZCk7XG4gICAgaXRlbUNvbnRhaW5lci5zdHlsZS5zZXRQcm9wZXJ0eShcInBvaW50ZXItZXZlbnRzXCIsIFwibm9uZVwiKTtcbiAgICBpZiAoaXRlbS5wb2ludGVySW50ZXJhY3Rpb24pIHtcbiAgICAgIGl0ZW1Db250YWluZXIuc2V0QXR0cmlidXRlKFwiZGF0YS1jbGlja1wiLCBcIjFcIik7XG4gICAgfVxuXG4gICAgbGV0IGJvZHlSZWN0ID0gZG9jdW1lbnQuYm9keS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBsZXQgZG9Ob3RNZXJnZUhvcml6b250YWxseUFsaWduZWRSZWN0cyA9IGZhbHNlO1xuICAgIGxldCBjbGllbnRSZWN0cyA9IGdldENsaWVudFJlY3RzTm9PdmVybGFwKFxuICAgICAgaXRlbS5yYW5nZSxcbiAgICAgIGRvTm90TWVyZ2VIb3Jpem9udGFsbHlBbGlnbmVkUmVjdHNcbiAgICApO1xuICAgIGxldCByb3VuZGVkQ29ybmVyID0gMztcbiAgICBsZXQgY29sb3IgPSBkZWZhdWx0QmFja2dyb3VuZENvbG9yO1xuICAgIGxldCBvcGFjaXR5ID0gZGVmYXVsdEJhY2tncm91bmRPcGFjaXR5O1xuICAgIGxldCBleHRyYSA9IFwiXCI7XG5cbiAgICBsZXQgeE9mZnNldCA9IHBhZ2luYXRlZCA/IC1zY3JvbGxFbGVtZW50LnNjcm9sbExlZnQgOiBib2R5UmVjdC5sZWZ0O1xuICAgIGxldCB5T2Zmc2V0ID0gcGFnaW5hdGVkID8gLXNjcm9sbEVsZW1lbnQuc2Nyb2xsVG9wIDogYm9keVJlY3QudG9wO1xuXG4gICAgZm9yIChsZXQgY2xpZW50UmVjdCBvZiBjbGllbnRSZWN0cykge1xuICAgICAgY29uc3QgaXRlbUFyZWEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgaWYgKGRlYnVnKSB7XG4gICAgICAgIGNvbnN0IHJnYiA9IE1hdGgucm91bmQoMHhmZmZmZmYgKiBNYXRoLnJhbmRvbSgpKTtcbiAgICAgICAgY29uc3QgciA9IHJnYiA+PiAxNjtcbiAgICAgICAgY29uc3QgZyA9IChyZ2IgPj4gOCkgJiAyNTU7XG4gICAgICAgIGNvbnN0IGIgPSByZ2IgJiAyNTU7XG4gICAgICAgIGV4dHJhID0gYG91dGxpbmUtY29sb3I6IHJnYigke3J9LCAke2d9LCAke2J9KTsgb3V0bGluZS1zdHlsZTogc29saWQ7IG91dGxpbmUtd2lkdGg6IDFweDsgb3V0bGluZS1vZmZzZXQ6IC0xcHg7YDtcbiAgICAgIH1cbiAgICAgIGl0ZW1BcmVhLnNldEF0dHJpYnV0ZShcbiAgICAgICAgXCJzdHlsZVwiLFxuICAgICAgICBgYm9yZGVyLXJhZGl1czogJHtyb3VuZGVkQ29ybmVyfXB4ICFpbXBvcnRhbnQ7IGJhY2tncm91bmQtY29sb3I6IHJnYmEoJHtjb2xvci5yZWR9LCAke2NvbG9yLmdyZWVufSwgJHtjb2xvci5ibHVlfSwgJHtvcGFjaXR5fSkgIWltcG9ydGFudDsgJHtleHRyYX1gXG4gICAgICApO1xuICAgICAgaXRlbUFyZWEuc3R5bGUuc2V0UHJvcGVydHkoXCJwb2ludGVyLWV2ZW50c1wiLCBcIm5vbmVcIik7XG4gICAgICBpdGVtQXJlYS5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICAgIGl0ZW1BcmVhLnNjYWxlID0gMTtcbiAgICAgIGl0ZW1BcmVhLnJlY3QgPSB7XG4gICAgICAgIGhlaWdodDogY2xpZW50UmVjdC5oZWlnaHQsXG4gICAgICAgIGxlZnQ6IGNsaWVudFJlY3QubGVmdCAtIHhPZmZzZXQsXG4gICAgICAgIHRvcDogY2xpZW50UmVjdC50b3AgLSB5T2Zmc2V0LFxuICAgICAgICB3aWR0aDogY2xpZW50UmVjdC53aWR0aCxcbiAgICAgIH07XG5cbiAgICAgIGl0ZW1BcmVhLnN0eWxlLndpZHRoID0gYCR7aXRlbUFyZWEucmVjdC53aWR0aH1weGA7XG4gICAgICBpdGVtQXJlYS5zdHlsZS5oZWlnaHQgPSBgJHtpdGVtQXJlYS5yZWN0LmhlaWdodH1weGA7XG4gICAgICBpdGVtQXJlYS5zdHlsZS5sZWZ0ID0gYCR7aXRlbUFyZWEucmVjdC5sZWZ0fXB4YDtcbiAgICAgIGl0ZW1BcmVhLnN0eWxlLnRvcCA9IGAke2l0ZW1BcmVhLnJlY3QudG9wfXB4YDtcbiAgICAgIGl0ZW1Db250YWluZXIuYXBwZW5kKGl0ZW1BcmVhKTtcbiAgICB9XG5cbiAgICBjb25zdCBpdGVtQm91bmRpbmcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGl0ZW1Cb3VuZGluZy5zdHlsZS5zZXRQcm9wZXJ0eShcInBvaW50ZXItZXZlbnRzXCIsIFwibm9uZVwiKTtcbiAgICBpdGVtQm91bmRpbmcuc3R5bGUucG9zaXRpb24gPSBwYWdpbmF0ZWQgPyBcImZpeGVkXCIgOiBcImFic29sdXRlXCI7XG4gICAgaXRlbUJvdW5kaW5nLnNjYWxlID0gMTtcblxuICAgIGlmIChkZWJ1Zykge1xuICAgICAgaXRlbUJvdW5kaW5nLnNldEF0dHJpYnV0ZShcbiAgICAgICAgXCJzdHlsZVwiLFxuICAgICAgICBgb3V0bGluZS1jb2xvcjogbWFnZW50YTsgb3V0bGluZS1zdHlsZTogc29saWQ7IG91dGxpbmUtd2lkdGg6IDFweDsgb3V0bGluZS1vZmZzZXQ6IC0xcHg7YFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCByYW5nZUJvdW5kaW5nQ2xpZW50UmVjdCA9IGl0ZW0ucmFuZ2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgaXRlbUJvdW5kaW5nLnJlY3QgPSB7XG4gICAgICBoZWlnaHQ6IHJhbmdlQm91bmRpbmdDbGllbnRSZWN0LmhlaWdodCxcbiAgICAgIGxlZnQ6IHJhbmdlQm91bmRpbmdDbGllbnRSZWN0LmxlZnQgLSB4T2Zmc2V0LFxuICAgICAgdG9wOiByYW5nZUJvdW5kaW5nQ2xpZW50UmVjdC50b3AgLSB5T2Zmc2V0LFxuICAgICAgd2lkdGg6IHJhbmdlQm91bmRpbmdDbGllbnRSZWN0LndpZHRoLFxuICAgIH07XG5cbiAgICBpdGVtQm91bmRpbmcuc3R5bGUud2lkdGggPSBgJHtpdGVtQm91bmRpbmcucmVjdC53aWR0aH1weGA7XG4gICAgaXRlbUJvdW5kaW5nLnN0eWxlLmhlaWdodCA9IGAke2l0ZW1Cb3VuZGluZy5yZWN0LmhlaWdodH1weGA7XG4gICAgaXRlbUJvdW5kaW5nLnN0eWxlLmxlZnQgPSBgJHtpdGVtQm91bmRpbmcucmVjdC5sZWZ0fXB4YDtcbiAgICBpdGVtQm91bmRpbmcuc3R5bGUudG9wID0gYCR7aXRlbUJvdW5kaW5nLnJlY3QudG9wfXB4YDtcblxuICAgIGl0ZW1Db250YWluZXIuYXBwZW5kKGl0ZW1Cb3VuZGluZyk7XG4gICAgZ3JvdXBDb250YWluZXIuYXBwZW5kKGl0ZW1Db250YWluZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVxdWlyZUNvbnRhaW5lcigpIHtcbiAgICBpZiAoIWNvbnRhaW5lcikge1xuICAgICAgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBncm91cElkKTtcbiAgICAgIGNvbnRhaW5lci5zdHlsZS5zZXRQcm9wZXJ0eShcInBvaW50ZXItZXZlbnRzXCIsIFwibm9uZVwiKTtcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kKGNvbnRhaW5lcik7XG4gICAgfVxuICAgIHJldHVybiBjb250YWluZXI7XG4gIH1cblxuICBmdW5jdGlvbiBjbGVhckNvbnRhaW5lcigpIHtcbiAgICBpZiAoY29udGFpbmVyKSB7XG4gICAgICBjb250YWluZXIucmVtb3ZlKCk7XG4gICAgICBjb250YWluZXIgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7IGFkZCwgcmVtb3ZlLCB1cGRhdGUsIGNsZWFyLCByZXF1ZXN0TGF5b3V0IH07XG59XG5cbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKFxuICBcImxvYWRcIixcbiAgZnVuY3Rpb24gKCkge1xuICAgIC8vIG9uIHBhZ2UgbG9hZFxuICAgIGNvbnN0IGJvZHkgPSBkb2N1bWVudC5ib2R5O1xuICAgIHZhciBsYXN0U2l6ZSA9IHsgd2lkdGg6IDAsIGhlaWdodDogMCB9O1xuICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKCgpID0+IHtcbiAgICAgIGlmIChcbiAgICAgICAgbGFzdFNpemUud2lkdGggPT09IGJvZHkuY2xpZW50V2lkdGggJiZcbiAgICAgICAgbGFzdFNpemUuaGVpZ2h0ID09PSBib2R5LmNsaWVudEhlaWdodFxuICAgICAgKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxhc3RTaXplID0ge1xuICAgICAgICB3aWR0aDogYm9keS5jbGllbnRXaWR0aCxcbiAgICAgICAgaGVpZ2h0OiBib2R5LmNsaWVudEhlaWdodCxcbiAgICAgIH07XG5cbiAgICAgIGdyb3Vwcy5mb3JFYWNoKGZ1bmN0aW9uIChncm91cCkge1xuICAgICAgICBncm91cC5yZXF1ZXN0TGF5b3V0KCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBvYnNlcnZlci5vYnNlcnZlKGJvZHkpO1xuICB9LFxuICBmYWxzZVxuKTtcbiIsIi8vXG4vLyAgQ29weXJpZ2h0IDIwMjEgUmVhZGl1bSBGb3VuZGF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IHRoZSBCU0Qtc3R5bGUgbGljZW5zZVxuLy8gIGF2YWlsYWJsZSBpbiB0aGUgdG9wLWxldmVsIExJQ0VOU0UgZmlsZSBvZiB0aGUgcHJvamVjdC5cbi8vXG5cbi8vIEJhc2Ugc2NyaXB0IHVzZWQgYnkgYm90aCByZWZsb3dhYmxlIGFuZCBmaXhlZCBsYXlvdXQgcmVzb3VyY2VzLlxuXG5pbXBvcnQgXCIuL2dlc3R1cmVzXCI7XG5pbXBvcnQge1xuICByZW1vdmVQcm9wZXJ0eSxcbiAgc2Nyb2xsTGVmdCxcbiAgc2Nyb2xsUmlnaHQsXG4gIHNjcm9sbFRvSWQsXG4gIHNjcm9sbFRvUG9zaXRpb24sXG4gIHNjcm9sbFRvVGV4dCxcbiAgc2V0UHJvcGVydHksXG59IGZyb20gXCIuL3V0aWxzXCI7XG5pbXBvcnQgeyBnZXRDdXJyZW50U2VsZWN0aW9uSW5mbywgZ2V0U2VsZWN0aW9uUmVjdCB9IGZyb20gXCIuL3NlbGVjdGlvblwiO1xuaW1wb3J0IHsgY2xlYXJIaWdobGlnaHRzLCBoaWdobGlnaHQgfSBmcm9tIFwiLi9oaWdobGlnaHRcIjtcbmltcG9ydCB7IGdldERlY29yYXRpb25zIH0gZnJvbSBcIi4vZGVjb3JhdG9yXCI7XG5cbi8vIFB1YmxpYyBBUEkgdXNlZCBieSB0aGUgbmF2aWdhdG9yLlxud2luZG93LnJlYWRpdW0gPSB7XG4gIC8vIHV0aWxzXG4gIHNjcm9sbFRvSWQ6IHNjcm9sbFRvSWQsXG4gIHNjcm9sbFRvUG9zaXRpb246IHNjcm9sbFRvUG9zaXRpb24sXG4gIHNjcm9sbFRvVGV4dDogc2Nyb2xsVG9UZXh0LFxuICBzY3JvbGxMZWZ0OiBzY3JvbGxMZWZ0LFxuICBzY3JvbGxSaWdodDogc2Nyb2xsUmlnaHQsXG4gIHNldFByb3BlcnR5OiBzZXRQcm9wZXJ0eSxcbiAgcmVtb3ZlUHJvcGVydHk6IHJlbW92ZVByb3BlcnR5LFxuXG4gIC8vIGRlY29yYXRpb25cbiAgZ2V0RGVjb3JhdGlvbnM6IGdldERlY29yYXRpb25zLFxuXG4gIC8vIHNlbGVjdGlvblxuICBnZXRTZWxlY3Rpb25SZWN0OiBnZXRTZWxlY3Rpb25SZWN0LFxuICBnZXRDdXJyZW50U2VsZWN0aW9uSW5mbzogZ2V0Q3VycmVudFNlbGVjdGlvbkluZm8sXG59O1xuIiwiLy9cbi8vICBDb3B5cmlnaHQgMjAyMSBSZWFkaXVtIEZvdW5kYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgdGhlIEJTRC1zdHlsZSBsaWNlbnNlXG4vLyAgYXZhaWxhYmxlIGluIHRoZSB0b3AtbGV2ZWwgTElDRU5TRSBmaWxlIG9mIHRoZSBwcm9qZWN0LlxuLy9cblxuLy8gU2NyaXB0IHVzZWQgZm9yIGZpeGVkIGxheW91dHMgcmVzb3VyY2VzLlxuXG5pbXBvcnQgXCIuL2luZGV4XCI7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///990\n')}},__webpack_module_cache__={};function __webpack_require__(n){var t=__webpack_module_cache__[n];if(void 0!==t)return t.exports;var e=__webpack_module_cache__[n]={exports:{}};return __webpack_modules__[n](e,e.exports,__webpack_require__),e.exports}var __webpack_exports__=__webpack_require__(990)})();