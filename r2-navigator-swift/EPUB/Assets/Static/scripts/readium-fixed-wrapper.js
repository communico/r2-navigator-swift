(()=>{"use strict";var __webpack_modules__={89:(__unused_webpack_module,exports)=>{eval('var __webpack_unused_export__;\n\n/**\n * Implementation of Myers\' online approximate string matching algorithm [1],\n * with additional optimizations suggested by [2].\n *\n * This has O((k/w) * n) complexity where `n` is the length of the text, `k` is\n * the maximum number of errors allowed (always <= the pattern length) and `w`\n * is the word size. Because JS only supports bitwise operations on 32 bit\n * integers, `w` is 32.\n *\n * As far as I am aware, there aren\'t any online algorithms which are\n * significantly better for a wide range of input parameters. The problem can be\n * solved faster using "filter then verify" approaches which first filter out\n * regions of the text that cannot match using a "cheap" check and then verify\n * the remaining potential matches. The verify step requires an algorithm such\n * as this one however.\n *\n * The algorithm\'s approach is essentially to optimize the classic dynamic\n * programming solution to the problem by computing columns of the matrix in\n * word-sized chunks (ie. dealing with 32 chars of the pattern at a time) and\n * avoiding calculating regions of the matrix where the minimum error count is\n * guaranteed to exceed the input threshold.\n *\n * The paper consists of two parts, the first describes the core algorithm for\n * matching patterns <= the size of a word (implemented by `advanceBlock` here).\n * The second uses the core algorithm as part of a larger block-based algorithm\n * to handle longer patterns.\n *\n * [1] G. Myers, “A Fast Bit-Vector Algorithm for Approximate String Matching\n * Based on Dynamic Programming,” vol. 46, no. 3, pp. 395–415, 1999.\n *\n * [2] Šošić, M. (2014). An simd dynamic programming c/c++ library (Doctoral\n * dissertation, Fakultet Elektrotehnike i računarstva, Sveučilište u Zagrebu).\n */\n__webpack_unused_export__ = ({ value: true });\nfunction reverse(s) {\n    return s\n        .split("")\n        .reverse()\n        .join("");\n}\n/**\n * Given the ends of approximate matches for `pattern` in `text`, find\n * the start of the matches.\n *\n * @param findEndFn - Function for finding the end of matches in\n * text.\n * @return Matches with the `start` property set.\n */\nfunction findMatchStarts(text, pattern, matches) {\n    var patRev = reverse(pattern);\n    return matches.map(function (m) {\n        // Find start of each match by reversing the pattern and matching segment\n        // of text and searching for an approx match with the same number of\n        // errors.\n        var minStart = Math.max(0, m.end - pattern.length - m.errors);\n        var textRev = reverse(text.slice(minStart, m.end));\n        // If there are multiple possible start points, choose the one that\n        // maximizes the length of the match.\n        var start = findMatchEnds(textRev, patRev, m.errors).reduce(function (min, rm) {\n            if (m.end - rm.end < min) {\n                return m.end - rm.end;\n            }\n            return min;\n        }, m.end);\n        return {\n            start: start,\n            end: m.end,\n            errors: m.errors\n        };\n    });\n}\n/**\n * Return 1 if a number is non-zero or zero otherwise, without using\n * conditional operators.\n *\n * This should get inlined into `advanceBlock` below by the JIT.\n *\n * Adapted from https://stackoverflow.com/a/3912218/434243\n */\nfunction oneIfNotZero(n) {\n    return ((n | -n) >> 31) & 1;\n}\n/**\n * Block calculation step of the algorithm.\n *\n * From Fig 8. on p. 408 of [1], additionally optimized to replace conditional\n * checks with bitwise operations as per Section 4.2.3 of [2].\n *\n * @param ctx - The pattern context object\n * @param peq - The `peq` array for the current character (`ctx.peq.get(ch)`)\n * @param b - The block level\n * @param hIn - Horizontal input delta ∈ {1,0,-1}\n * @return Horizontal output delta ∈ {1,0,-1}\n */\nfunction advanceBlock(ctx, peq, b, hIn) {\n    var pV = ctx.P[b];\n    var mV = ctx.M[b];\n    var hInIsNegative = hIn >>> 31; // 1 if hIn < 0 or 0 otherwise.\n    var eq = peq[b] | hInIsNegative;\n    // Step 1: Compute horizontal deltas.\n    var xV = eq | mV;\n    var xH = (((eq & pV) + pV) ^ pV) | eq;\n    var pH = mV | ~(xH | pV);\n    var mH = pV & xH;\n    // Step 2: Update score (value of last row of this block).\n    var hOut = oneIfNotZero(pH & ctx.lastRowMask[b]) -\n        oneIfNotZero(mH & ctx.lastRowMask[b]);\n    // Step 3: Update vertical deltas for use when processing next char.\n    pH <<= 1;\n    mH <<= 1;\n    mH |= hInIsNegative;\n    pH |= oneIfNotZero(hIn) - hInIsNegative; // set pH[0] if hIn > 0\n    pV = mH | ~(xV | pH);\n    mV = pH & xV;\n    ctx.P[b] = pV;\n    ctx.M[b] = mV;\n    return hOut;\n}\n/**\n * Find the ends and error counts for matches of `pattern` in `text`.\n *\n * Only the matches with the lowest error count are reported. Other matches\n * with error counts <= maxErrors are discarded.\n *\n * This is the block-based search algorithm from Fig. 9 on p.410 of [1].\n */\nfunction findMatchEnds(text, pattern, maxErrors) {\n    if (pattern.length === 0) {\n        return [];\n    }\n    // Clamp error count so we can rely on the `maxErrors` and `pattern.length`\n    // rows being in the same block below.\n    maxErrors = Math.min(maxErrors, pattern.length);\n    var matches = [];\n    // Word size.\n    var w = 32;\n    // Index of maximum block level.\n    var bMax = Math.ceil(pattern.length / w) - 1;\n    // Context used across block calculations.\n    var ctx = {\n        P: new Uint32Array(bMax + 1),\n        M: new Uint32Array(bMax + 1),\n        lastRowMask: new Uint32Array(bMax + 1)\n    };\n    ctx.lastRowMask.fill(1 << 31);\n    ctx.lastRowMask[bMax] = 1 << (pattern.length - 1) % w;\n    // Dummy "peq" array for chars in the text which do not occur in the pattern.\n    var emptyPeq = new Uint32Array(bMax + 1);\n    // Map of UTF-16 character code to bit vector indicating positions in the\n    // pattern that equal that character.\n    var peq = new Map();\n    // Version of `peq` that only stores mappings for small characters. This\n    // allows faster lookups when iterating through the text because a simple\n    // array lookup can be done instead of a hash table lookup.\n    var asciiPeq = [];\n    for (var i = 0; i < 256; i++) {\n        asciiPeq.push(emptyPeq);\n    }\n    // Calculate `ctx.peq` - a map of character values to bitmasks indicating\n    // positions of that character within the pattern, where each bit represents\n    // a position in the pattern.\n    for (var c = 0; c < pattern.length; c += 1) {\n        var val = pattern.charCodeAt(c);\n        if (peq.has(val)) {\n            // Duplicate char in pattern.\n            continue;\n        }\n        var charPeq = new Uint32Array(bMax + 1);\n        peq.set(val, charPeq);\n        if (val < asciiPeq.length) {\n            asciiPeq[val] = charPeq;\n        }\n        for (var b = 0; b <= bMax; b += 1) {\n            charPeq[b] = 0;\n            // Set all the bits where the pattern matches the current char (ch).\n            // For indexes beyond the end of the pattern, always set the bit as if the\n            // pattern contained a wildcard char in that position.\n            for (var r = 0; r < w; r += 1) {\n                var idx = b * w + r;\n                if (idx >= pattern.length) {\n                    continue;\n                }\n                var match = pattern.charCodeAt(idx) === val;\n                if (match) {\n                    charPeq[b] |= 1 << r;\n                }\n            }\n        }\n    }\n    // Index of last-active block level in the column.\n    var y = Math.max(0, Math.ceil(maxErrors / w) - 1);\n    // Initialize maximum error count at bottom of each block.\n    var score = new Uint32Array(bMax + 1);\n    for (var b = 0; b <= y; b += 1) {\n        score[b] = (b + 1) * w;\n    }\n    score[bMax] = pattern.length;\n    // Initialize vertical deltas for each block.\n    for (var b = 0; b <= y; b += 1) {\n        ctx.P[b] = ~0;\n        ctx.M[b] = 0;\n    }\n    // Process each char of the text, computing the error count for `w` chars of\n    // the pattern at a time.\n    for (var j = 0; j < text.length; j += 1) {\n        // Lookup the bitmask representing the positions of the current char from\n        // the text within the pattern.\n        var charCode = text.charCodeAt(j);\n        var charPeq = void 0;\n        if (charCode < asciiPeq.length) {\n            // Fast array lookup.\n            charPeq = asciiPeq[charCode];\n        }\n        else {\n            // Slower hash table lookup.\n            charPeq = peq.get(charCode);\n            if (typeof charPeq === "undefined") {\n                charPeq = emptyPeq;\n            }\n        }\n        // Calculate error count for blocks that we definitely have to process for\n        // this column.\n        var carry = 0;\n        for (var b = 0; b <= y; b += 1) {\n            carry = advanceBlock(ctx, charPeq, b, carry);\n            score[b] += carry;\n        }\n        // Check if we also need to compute an additional block, or if we can reduce\n        // the number of blocks processed for the next column.\n        if (score[y] - carry <= maxErrors &&\n            y < bMax &&\n            (charPeq[y + 1] & 1 || carry < 0)) {\n            // Error count for bottom block is under threshold, increase the number of\n            // blocks processed for this column & next by 1.\n            y += 1;\n            ctx.P[y] = ~0;\n            ctx.M[y] = 0;\n            var maxBlockScore = y === bMax ? pattern.length % w : w;\n            score[y] =\n                score[y - 1] +\n                    maxBlockScore -\n                    carry +\n                    advanceBlock(ctx, charPeq, y, carry);\n        }\n        else {\n            // Error count for bottom block exceeds threshold, reduce the number of\n            // blocks processed for the next column.\n            while (y > 0 && score[y] >= maxErrors + w) {\n                y -= 1;\n            }\n        }\n        // If error count is under threshold, report a match.\n        if (y === bMax && score[y] <= maxErrors) {\n            if (score[y] < maxErrors) {\n                // Discard any earlier, worse matches.\n                matches.splice(0, matches.length);\n            }\n            matches.push({\n                start: -1,\n                end: j + 1,\n                errors: score[y]\n            });\n            // Because `search` only reports the matches with the lowest error count,\n            // we can "ratchet down" the max error threshold whenever a match is\n            // encountered and thereby save a small amount of work for the remainder\n            // of the text.\n            maxErrors = score[y];\n        }\n    }\n    return matches;\n}\n/**\n * Search for matches for `pattern` in `text` allowing up to `maxErrors` errors.\n *\n * Returns the start, and end positions and error counts for each lowest-cost\n * match. Only the "best" matches are returned.\n */\nfunction search(text, pattern, maxErrors) {\n    var matches = findMatchEnds(text, pattern, maxErrors);\n    return findMatchStarts(text, pattern, matches);\n}\n__webpack_unused_export__ = search;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFkaXVtLWpzLy4vbm9kZV9tb2R1bGVzL2FwcHJveC1zdHJpbmctbWF0Y2gvZGlzdC9pbmRleC5qcz83MjMwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QyxDQUFDLGNBQWMsQ0FBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsb0JBQW9CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFdBQVc7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsT0FBTztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixRQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQWUiLCJmaWxlIjoiODkuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogSW1wbGVtZW50YXRpb24gb2YgTXllcnMnIG9ubGluZSBhcHByb3hpbWF0ZSBzdHJpbmcgbWF0Y2hpbmcgYWxnb3JpdGhtIFsxXSxcbiAqIHdpdGggYWRkaXRpb25hbCBvcHRpbWl6YXRpb25zIHN1Z2dlc3RlZCBieSBbMl0uXG4gKlxuICogVGhpcyBoYXMgTygoay93KSAqIG4pIGNvbXBsZXhpdHkgd2hlcmUgYG5gIGlzIHRoZSBsZW5ndGggb2YgdGhlIHRleHQsIGBrYCBpc1xuICogdGhlIG1heGltdW0gbnVtYmVyIG9mIGVycm9ycyBhbGxvd2VkIChhbHdheXMgPD0gdGhlIHBhdHRlcm4gbGVuZ3RoKSBhbmQgYHdgXG4gKiBpcyB0aGUgd29yZCBzaXplLiBCZWNhdXNlIEpTIG9ubHkgc3VwcG9ydHMgYml0d2lzZSBvcGVyYXRpb25zIG9uIDMyIGJpdFxuICogaW50ZWdlcnMsIGB3YCBpcyAzMi5cbiAqXG4gKiBBcyBmYXIgYXMgSSBhbSBhd2FyZSwgdGhlcmUgYXJlbid0IGFueSBvbmxpbmUgYWxnb3JpdGhtcyB3aGljaCBhcmVcbiAqIHNpZ25pZmljYW50bHkgYmV0dGVyIGZvciBhIHdpZGUgcmFuZ2Ugb2YgaW5wdXQgcGFyYW1ldGVycy4gVGhlIHByb2JsZW0gY2FuIGJlXG4gKiBzb2x2ZWQgZmFzdGVyIHVzaW5nIFwiZmlsdGVyIHRoZW4gdmVyaWZ5XCIgYXBwcm9hY2hlcyB3aGljaCBmaXJzdCBmaWx0ZXIgb3V0XG4gKiByZWdpb25zIG9mIHRoZSB0ZXh0IHRoYXQgY2Fubm90IG1hdGNoIHVzaW5nIGEgXCJjaGVhcFwiIGNoZWNrIGFuZCB0aGVuIHZlcmlmeVxuICogdGhlIHJlbWFpbmluZyBwb3RlbnRpYWwgbWF0Y2hlcy4gVGhlIHZlcmlmeSBzdGVwIHJlcXVpcmVzIGFuIGFsZ29yaXRobSBzdWNoXG4gKiBhcyB0aGlzIG9uZSBob3dldmVyLlxuICpcbiAqIFRoZSBhbGdvcml0aG0ncyBhcHByb2FjaCBpcyBlc3NlbnRpYWxseSB0byBvcHRpbWl6ZSB0aGUgY2xhc3NpYyBkeW5hbWljXG4gKiBwcm9ncmFtbWluZyBzb2x1dGlvbiB0byB0aGUgcHJvYmxlbSBieSBjb21wdXRpbmcgY29sdW1ucyBvZiB0aGUgbWF0cml4IGluXG4gKiB3b3JkLXNpemVkIGNodW5rcyAoaWUuIGRlYWxpbmcgd2l0aCAzMiBjaGFycyBvZiB0aGUgcGF0dGVybiBhdCBhIHRpbWUpIGFuZFxuICogYXZvaWRpbmcgY2FsY3VsYXRpbmcgcmVnaW9ucyBvZiB0aGUgbWF0cml4IHdoZXJlIHRoZSBtaW5pbXVtIGVycm9yIGNvdW50IGlzXG4gKiBndWFyYW50ZWVkIHRvIGV4Y2VlZCB0aGUgaW5wdXQgdGhyZXNob2xkLlxuICpcbiAqIFRoZSBwYXBlciBjb25zaXN0cyBvZiB0d28gcGFydHMsIHRoZSBmaXJzdCBkZXNjcmliZXMgdGhlIGNvcmUgYWxnb3JpdGhtIGZvclxuICogbWF0Y2hpbmcgcGF0dGVybnMgPD0gdGhlIHNpemUgb2YgYSB3b3JkIChpbXBsZW1lbnRlZCBieSBgYWR2YW5jZUJsb2NrYCBoZXJlKS5cbiAqIFRoZSBzZWNvbmQgdXNlcyB0aGUgY29yZSBhbGdvcml0aG0gYXMgcGFydCBvZiBhIGxhcmdlciBibG9jay1iYXNlZCBhbGdvcml0aG1cbiAqIHRvIGhhbmRsZSBsb25nZXIgcGF0dGVybnMuXG4gKlxuICogWzFdIEcuIE15ZXJzLCDigJxBIEZhc3QgQml0LVZlY3RvciBBbGdvcml0aG0gZm9yIEFwcHJveGltYXRlIFN0cmluZyBNYXRjaGluZ1xuICogQmFzZWQgb24gRHluYW1pYyBQcm9ncmFtbWluZyzigJ0gdm9sLiA0Niwgbm8uIDMsIHBwLiAzOTXigJM0MTUsIDE5OTkuXG4gKlxuICogWzJdIMWgb8WhacSHLCBNLiAoMjAxNCkuIEFuIHNpbWQgZHluYW1pYyBwcm9ncmFtbWluZyBjL2MrKyBsaWJyYXJ5IChEb2N0b3JhbFxuICogZGlzc2VydGF0aW9uLCBGYWt1bHRldCBFbGVrdHJvdGVobmlrZSBpIHJhxI11bmFyc3R2YSwgU3ZldcSNaWxpxaF0ZSB1IFphZ3JlYnUpLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5mdW5jdGlvbiByZXZlcnNlKHMpIHtcbiAgICByZXR1cm4gc1xuICAgICAgICAuc3BsaXQoXCJcIilcbiAgICAgICAgLnJldmVyc2UoKVxuICAgICAgICAuam9pbihcIlwiKTtcbn1cbi8qKlxuICogR2l2ZW4gdGhlIGVuZHMgb2YgYXBwcm94aW1hdGUgbWF0Y2hlcyBmb3IgYHBhdHRlcm5gIGluIGB0ZXh0YCwgZmluZFxuICogdGhlIHN0YXJ0IG9mIHRoZSBtYXRjaGVzLlxuICpcbiAqIEBwYXJhbSBmaW5kRW5kRm4gLSBGdW5jdGlvbiBmb3IgZmluZGluZyB0aGUgZW5kIG9mIG1hdGNoZXMgaW5cbiAqIHRleHQuXG4gKiBAcmV0dXJuIE1hdGNoZXMgd2l0aCB0aGUgYHN0YXJ0YCBwcm9wZXJ0eSBzZXQuXG4gKi9cbmZ1bmN0aW9uIGZpbmRNYXRjaFN0YXJ0cyh0ZXh0LCBwYXR0ZXJuLCBtYXRjaGVzKSB7XG4gICAgdmFyIHBhdFJldiA9IHJldmVyc2UocGF0dGVybik7XG4gICAgcmV0dXJuIG1hdGNoZXMubWFwKGZ1bmN0aW9uIChtKSB7XG4gICAgICAgIC8vIEZpbmQgc3RhcnQgb2YgZWFjaCBtYXRjaCBieSByZXZlcnNpbmcgdGhlIHBhdHRlcm4gYW5kIG1hdGNoaW5nIHNlZ21lbnRcbiAgICAgICAgLy8gb2YgdGV4dCBhbmQgc2VhcmNoaW5nIGZvciBhbiBhcHByb3ggbWF0Y2ggd2l0aCB0aGUgc2FtZSBudW1iZXIgb2ZcbiAgICAgICAgLy8gZXJyb3JzLlxuICAgICAgICB2YXIgbWluU3RhcnQgPSBNYXRoLm1heCgwLCBtLmVuZCAtIHBhdHRlcm4ubGVuZ3RoIC0gbS5lcnJvcnMpO1xuICAgICAgICB2YXIgdGV4dFJldiA9IHJldmVyc2UodGV4dC5zbGljZShtaW5TdGFydCwgbS5lbmQpKTtcbiAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG11bHRpcGxlIHBvc3NpYmxlIHN0YXJ0IHBvaW50cywgY2hvb3NlIHRoZSBvbmUgdGhhdFxuICAgICAgICAvLyBtYXhpbWl6ZXMgdGhlIGxlbmd0aCBvZiB0aGUgbWF0Y2guXG4gICAgICAgIHZhciBzdGFydCA9IGZpbmRNYXRjaEVuZHModGV4dFJldiwgcGF0UmV2LCBtLmVycm9ycykucmVkdWNlKGZ1bmN0aW9uIChtaW4sIHJtKSB7XG4gICAgICAgICAgICBpZiAobS5lbmQgLSBybS5lbmQgPCBtaW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbS5lbmQgLSBybS5lbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWluO1xuICAgICAgICB9LCBtLmVuZCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IG0uZW5kLFxuICAgICAgICAgICAgZXJyb3JzOiBtLmVycm9yc1xuICAgICAgICB9O1xuICAgIH0pO1xufVxuLyoqXG4gKiBSZXR1cm4gMSBpZiBhIG51bWJlciBpcyBub24temVybyBvciB6ZXJvIG90aGVyd2lzZSwgd2l0aG91dCB1c2luZ1xuICogY29uZGl0aW9uYWwgb3BlcmF0b3JzLlxuICpcbiAqIFRoaXMgc2hvdWxkIGdldCBpbmxpbmVkIGludG8gYGFkdmFuY2VCbG9ja2AgYmVsb3cgYnkgdGhlIEpJVC5cbiAqXG4gKiBBZGFwdGVkIGZyb20gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM5MTIyMTgvNDM0MjQzXG4gKi9cbmZ1bmN0aW9uIG9uZUlmTm90WmVybyhuKSB7XG4gICAgcmV0dXJuICgobiB8IC1uKSA+PiAzMSkgJiAxO1xufVxuLyoqXG4gKiBCbG9jayBjYWxjdWxhdGlvbiBzdGVwIG9mIHRoZSBhbGdvcml0aG0uXG4gKlxuICogRnJvbSBGaWcgOC4gb24gcC4gNDA4IG9mIFsxXSwgYWRkaXRpb25hbGx5IG9wdGltaXplZCB0byByZXBsYWNlIGNvbmRpdGlvbmFsXG4gKiBjaGVja3Mgd2l0aCBiaXR3aXNlIG9wZXJhdGlvbnMgYXMgcGVyIFNlY3Rpb24gNC4yLjMgb2YgWzJdLlxuICpcbiAqIEBwYXJhbSBjdHggLSBUaGUgcGF0dGVybiBjb250ZXh0IG9iamVjdFxuICogQHBhcmFtIHBlcSAtIFRoZSBgcGVxYCBhcnJheSBmb3IgdGhlIGN1cnJlbnQgY2hhcmFjdGVyIChgY3R4LnBlcS5nZXQoY2gpYClcbiAqIEBwYXJhbSBiIC0gVGhlIGJsb2NrIGxldmVsXG4gKiBAcGFyYW0gaEluIC0gSG9yaXpvbnRhbCBpbnB1dCBkZWx0YSDiiIggezEsMCwtMX1cbiAqIEByZXR1cm4gSG9yaXpvbnRhbCBvdXRwdXQgZGVsdGEg4oiIIHsxLDAsLTF9XG4gKi9cbmZ1bmN0aW9uIGFkdmFuY2VCbG9jayhjdHgsIHBlcSwgYiwgaEluKSB7XG4gICAgdmFyIHBWID0gY3R4LlBbYl07XG4gICAgdmFyIG1WID0gY3R4Lk1bYl07XG4gICAgdmFyIGhJbklzTmVnYXRpdmUgPSBoSW4gPj4+IDMxOyAvLyAxIGlmIGhJbiA8IDAgb3IgMCBvdGhlcndpc2UuXG4gICAgdmFyIGVxID0gcGVxW2JdIHwgaEluSXNOZWdhdGl2ZTtcbiAgICAvLyBTdGVwIDE6IENvbXB1dGUgaG9yaXpvbnRhbCBkZWx0YXMuXG4gICAgdmFyIHhWID0gZXEgfCBtVjtcbiAgICB2YXIgeEggPSAoKChlcSAmIHBWKSArIHBWKSBeIHBWKSB8IGVxO1xuICAgIHZhciBwSCA9IG1WIHwgfih4SCB8IHBWKTtcbiAgICB2YXIgbUggPSBwViAmIHhIO1xuICAgIC8vIFN0ZXAgMjogVXBkYXRlIHNjb3JlICh2YWx1ZSBvZiBsYXN0IHJvdyBvZiB0aGlzIGJsb2NrKS5cbiAgICB2YXIgaE91dCA9IG9uZUlmTm90WmVybyhwSCAmIGN0eC5sYXN0Um93TWFza1tiXSkgLVxuICAgICAgICBvbmVJZk5vdFplcm8obUggJiBjdHgubGFzdFJvd01hc2tbYl0pO1xuICAgIC8vIFN0ZXAgMzogVXBkYXRlIHZlcnRpY2FsIGRlbHRhcyBmb3IgdXNlIHdoZW4gcHJvY2Vzc2luZyBuZXh0IGNoYXIuXG4gICAgcEggPDw9IDE7XG4gICAgbUggPDw9IDE7XG4gICAgbUggfD0gaEluSXNOZWdhdGl2ZTtcbiAgICBwSCB8PSBvbmVJZk5vdFplcm8oaEluKSAtIGhJbklzTmVnYXRpdmU7IC8vIHNldCBwSFswXSBpZiBoSW4gPiAwXG4gICAgcFYgPSBtSCB8IH4oeFYgfCBwSCk7XG4gICAgbVYgPSBwSCAmIHhWO1xuICAgIGN0eC5QW2JdID0gcFY7XG4gICAgY3R4Lk1bYl0gPSBtVjtcbiAgICByZXR1cm4gaE91dDtcbn1cbi8qKlxuICogRmluZCB0aGUgZW5kcyBhbmQgZXJyb3IgY291bnRzIGZvciBtYXRjaGVzIG9mIGBwYXR0ZXJuYCBpbiBgdGV4dGAuXG4gKlxuICogT25seSB0aGUgbWF0Y2hlcyB3aXRoIHRoZSBsb3dlc3QgZXJyb3IgY291bnQgYXJlIHJlcG9ydGVkLiBPdGhlciBtYXRjaGVzXG4gKiB3aXRoIGVycm9yIGNvdW50cyA8PSBtYXhFcnJvcnMgYXJlIGRpc2NhcmRlZC5cbiAqXG4gKiBUaGlzIGlzIHRoZSBibG9jay1iYXNlZCBzZWFyY2ggYWxnb3JpdGhtIGZyb20gRmlnLiA5IG9uIHAuNDEwIG9mIFsxXS5cbiAqL1xuZnVuY3Rpb24gZmluZE1hdGNoRW5kcyh0ZXh0LCBwYXR0ZXJuLCBtYXhFcnJvcnMpIHtcbiAgICBpZiAocGF0dGVybi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICAvLyBDbGFtcCBlcnJvciBjb3VudCBzbyB3ZSBjYW4gcmVseSBvbiB0aGUgYG1heEVycm9yc2AgYW5kIGBwYXR0ZXJuLmxlbmd0aGBcbiAgICAvLyByb3dzIGJlaW5nIGluIHRoZSBzYW1lIGJsb2NrIGJlbG93LlxuICAgIG1heEVycm9ycyA9IE1hdGgubWluKG1heEVycm9ycywgcGF0dGVybi5sZW5ndGgpO1xuICAgIHZhciBtYXRjaGVzID0gW107XG4gICAgLy8gV29yZCBzaXplLlxuICAgIHZhciB3ID0gMzI7XG4gICAgLy8gSW5kZXggb2YgbWF4aW11bSBibG9jayBsZXZlbC5cbiAgICB2YXIgYk1heCA9IE1hdGguY2VpbChwYXR0ZXJuLmxlbmd0aCAvIHcpIC0gMTtcbiAgICAvLyBDb250ZXh0IHVzZWQgYWNyb3NzIGJsb2NrIGNhbGN1bGF0aW9ucy5cbiAgICB2YXIgY3R4ID0ge1xuICAgICAgICBQOiBuZXcgVWludDMyQXJyYXkoYk1heCArIDEpLFxuICAgICAgICBNOiBuZXcgVWludDMyQXJyYXkoYk1heCArIDEpLFxuICAgICAgICBsYXN0Um93TWFzazogbmV3IFVpbnQzMkFycmF5KGJNYXggKyAxKVxuICAgIH07XG4gICAgY3R4Lmxhc3RSb3dNYXNrLmZpbGwoMSA8PCAzMSk7XG4gICAgY3R4Lmxhc3RSb3dNYXNrW2JNYXhdID0gMSA8PCAocGF0dGVybi5sZW5ndGggLSAxKSAlIHc7XG4gICAgLy8gRHVtbXkgXCJwZXFcIiBhcnJheSBmb3IgY2hhcnMgaW4gdGhlIHRleHQgd2hpY2ggZG8gbm90IG9jY3VyIGluIHRoZSBwYXR0ZXJuLlxuICAgIHZhciBlbXB0eVBlcSA9IG5ldyBVaW50MzJBcnJheShiTWF4ICsgMSk7XG4gICAgLy8gTWFwIG9mIFVURi0xNiBjaGFyYWN0ZXIgY29kZSB0byBiaXQgdmVjdG9yIGluZGljYXRpbmcgcG9zaXRpb25zIGluIHRoZVxuICAgIC8vIHBhdHRlcm4gdGhhdCBlcXVhbCB0aGF0IGNoYXJhY3Rlci5cbiAgICB2YXIgcGVxID0gbmV3IE1hcCgpO1xuICAgIC8vIFZlcnNpb24gb2YgYHBlcWAgdGhhdCBvbmx5IHN0b3JlcyBtYXBwaW5ncyBmb3Igc21hbGwgY2hhcmFjdGVycy4gVGhpc1xuICAgIC8vIGFsbG93cyBmYXN0ZXIgbG9va3VwcyB3aGVuIGl0ZXJhdGluZyB0aHJvdWdoIHRoZSB0ZXh0IGJlY2F1c2UgYSBzaW1wbGVcbiAgICAvLyBhcnJheSBsb29rdXAgY2FuIGJlIGRvbmUgaW5zdGVhZCBvZiBhIGhhc2ggdGFibGUgbG9va3VwLlxuICAgIHZhciBhc2NpaVBlcSA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcbiAgICAgICAgYXNjaWlQZXEucHVzaChlbXB0eVBlcSk7XG4gICAgfVxuICAgIC8vIENhbGN1bGF0ZSBgY3R4LnBlcWAgLSBhIG1hcCBvZiBjaGFyYWN0ZXIgdmFsdWVzIHRvIGJpdG1hc2tzIGluZGljYXRpbmdcbiAgICAvLyBwb3NpdGlvbnMgb2YgdGhhdCBjaGFyYWN0ZXIgd2l0aGluIHRoZSBwYXR0ZXJuLCB3aGVyZSBlYWNoIGJpdCByZXByZXNlbnRzXG4gICAgLy8gYSBwb3NpdGlvbiBpbiB0aGUgcGF0dGVybi5cbiAgICBmb3IgKHZhciBjID0gMDsgYyA8IHBhdHRlcm4ubGVuZ3RoOyBjICs9IDEpIHtcbiAgICAgICAgdmFyIHZhbCA9IHBhdHRlcm4uY2hhckNvZGVBdChjKTtcbiAgICAgICAgaWYgKHBlcS5oYXModmFsKSkge1xuICAgICAgICAgICAgLy8gRHVwbGljYXRlIGNoYXIgaW4gcGF0dGVybi5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjaGFyUGVxID0gbmV3IFVpbnQzMkFycmF5KGJNYXggKyAxKTtcbiAgICAgICAgcGVxLnNldCh2YWwsIGNoYXJQZXEpO1xuICAgICAgICBpZiAodmFsIDwgYXNjaWlQZXEubGVuZ3RoKSB7XG4gICAgICAgICAgICBhc2NpaVBlcVt2YWxdID0gY2hhclBlcTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBiID0gMDsgYiA8PSBiTWF4OyBiICs9IDEpIHtcbiAgICAgICAgICAgIGNoYXJQZXFbYl0gPSAwO1xuICAgICAgICAgICAgLy8gU2V0IGFsbCB0aGUgYml0cyB3aGVyZSB0aGUgcGF0dGVybiBtYXRjaGVzIHRoZSBjdXJyZW50IGNoYXIgKGNoKS5cbiAgICAgICAgICAgIC8vIEZvciBpbmRleGVzIGJleW9uZCB0aGUgZW5kIG9mIHRoZSBwYXR0ZXJuLCBhbHdheXMgc2V0IHRoZSBiaXQgYXMgaWYgdGhlXG4gICAgICAgICAgICAvLyBwYXR0ZXJuIGNvbnRhaW5lZCBhIHdpbGRjYXJkIGNoYXIgaW4gdGhhdCBwb3NpdGlvbi5cbiAgICAgICAgICAgIGZvciAodmFyIHIgPSAwOyByIDwgdzsgciArPSAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlkeCA9IGIgKiB3ICsgcjtcbiAgICAgICAgICAgICAgICBpZiAoaWR4ID49IHBhdHRlcm4ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSBwYXR0ZXJuLmNoYXJDb2RlQXQoaWR4KSA9PT0gdmFsO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICBjaGFyUGVxW2JdIHw9IDEgPDwgcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gSW5kZXggb2YgbGFzdC1hY3RpdmUgYmxvY2sgbGV2ZWwgaW4gdGhlIGNvbHVtbi5cbiAgICB2YXIgeSA9IE1hdGgubWF4KDAsIE1hdGguY2VpbChtYXhFcnJvcnMgLyB3KSAtIDEpO1xuICAgIC8vIEluaXRpYWxpemUgbWF4aW11bSBlcnJvciBjb3VudCBhdCBib3R0b20gb2YgZWFjaCBibG9jay5cbiAgICB2YXIgc2NvcmUgPSBuZXcgVWludDMyQXJyYXkoYk1heCArIDEpO1xuICAgIGZvciAodmFyIGIgPSAwOyBiIDw9IHk7IGIgKz0gMSkge1xuICAgICAgICBzY29yZVtiXSA9IChiICsgMSkgKiB3O1xuICAgIH1cbiAgICBzY29yZVtiTWF4XSA9IHBhdHRlcm4ubGVuZ3RoO1xuICAgIC8vIEluaXRpYWxpemUgdmVydGljYWwgZGVsdGFzIGZvciBlYWNoIGJsb2NrLlxuICAgIGZvciAodmFyIGIgPSAwOyBiIDw9IHk7IGIgKz0gMSkge1xuICAgICAgICBjdHguUFtiXSA9IH4wO1xuICAgICAgICBjdHguTVtiXSA9IDA7XG4gICAgfVxuICAgIC8vIFByb2Nlc3MgZWFjaCBjaGFyIG9mIHRoZSB0ZXh0LCBjb21wdXRpbmcgdGhlIGVycm9yIGNvdW50IGZvciBgd2AgY2hhcnMgb2ZcbiAgICAvLyB0aGUgcGF0dGVybiBhdCBhIHRpbWUuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCB0ZXh0Lmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgIC8vIExvb2t1cCB0aGUgYml0bWFzayByZXByZXNlbnRpbmcgdGhlIHBvc2l0aW9ucyBvZiB0aGUgY3VycmVudCBjaGFyIGZyb21cbiAgICAgICAgLy8gdGhlIHRleHQgd2l0aGluIHRoZSBwYXR0ZXJuLlxuICAgICAgICB2YXIgY2hhckNvZGUgPSB0ZXh0LmNoYXJDb2RlQXQoaik7XG4gICAgICAgIHZhciBjaGFyUGVxID0gdm9pZCAwO1xuICAgICAgICBpZiAoY2hhckNvZGUgPCBhc2NpaVBlcS5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIEZhc3QgYXJyYXkgbG9va3VwLlxuICAgICAgICAgICAgY2hhclBlcSA9IGFzY2lpUGVxW2NoYXJDb2RlXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFNsb3dlciBoYXNoIHRhYmxlIGxvb2t1cC5cbiAgICAgICAgICAgIGNoYXJQZXEgPSBwZXEuZ2V0KGNoYXJDb2RlKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2hhclBlcSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIGNoYXJQZXEgPSBlbXB0eVBlcTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBDYWxjdWxhdGUgZXJyb3IgY291bnQgZm9yIGJsb2NrcyB0aGF0IHdlIGRlZmluaXRlbHkgaGF2ZSB0byBwcm9jZXNzIGZvclxuICAgICAgICAvLyB0aGlzIGNvbHVtbi5cbiAgICAgICAgdmFyIGNhcnJ5ID0gMDtcbiAgICAgICAgZm9yICh2YXIgYiA9IDA7IGIgPD0geTsgYiArPSAxKSB7XG4gICAgICAgICAgICBjYXJyeSA9IGFkdmFuY2VCbG9jayhjdHgsIGNoYXJQZXEsIGIsIGNhcnJ5KTtcbiAgICAgICAgICAgIHNjb3JlW2JdICs9IGNhcnJ5O1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIGlmIHdlIGFsc28gbmVlZCB0byBjb21wdXRlIGFuIGFkZGl0aW9uYWwgYmxvY2ssIG9yIGlmIHdlIGNhbiByZWR1Y2VcbiAgICAgICAgLy8gdGhlIG51bWJlciBvZiBibG9ja3MgcHJvY2Vzc2VkIGZvciB0aGUgbmV4dCBjb2x1bW4uXG4gICAgICAgIGlmIChzY29yZVt5XSAtIGNhcnJ5IDw9IG1heEVycm9ycyAmJlxuICAgICAgICAgICAgeSA8IGJNYXggJiZcbiAgICAgICAgICAgIChjaGFyUGVxW3kgKyAxXSAmIDEgfHwgY2FycnkgPCAwKSkge1xuICAgICAgICAgICAgLy8gRXJyb3IgY291bnQgZm9yIGJvdHRvbSBibG9jayBpcyB1bmRlciB0aHJlc2hvbGQsIGluY3JlYXNlIHRoZSBudW1iZXIgb2ZcbiAgICAgICAgICAgIC8vIGJsb2NrcyBwcm9jZXNzZWQgZm9yIHRoaXMgY29sdW1uICYgbmV4dCBieSAxLlxuICAgICAgICAgICAgeSArPSAxO1xuICAgICAgICAgICAgY3R4LlBbeV0gPSB+MDtcbiAgICAgICAgICAgIGN0eC5NW3ldID0gMDtcbiAgICAgICAgICAgIHZhciBtYXhCbG9ja1Njb3JlID0geSA9PT0gYk1heCA/IHBhdHRlcm4ubGVuZ3RoICUgdyA6IHc7XG4gICAgICAgICAgICBzY29yZVt5XSA9XG4gICAgICAgICAgICAgICAgc2NvcmVbeSAtIDFdICtcbiAgICAgICAgICAgICAgICAgICAgbWF4QmxvY2tTY29yZSAtXG4gICAgICAgICAgICAgICAgICAgIGNhcnJ5ICtcbiAgICAgICAgICAgICAgICAgICAgYWR2YW5jZUJsb2NrKGN0eCwgY2hhclBlcSwgeSwgY2FycnkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gRXJyb3IgY291bnQgZm9yIGJvdHRvbSBibG9jayBleGNlZWRzIHRocmVzaG9sZCwgcmVkdWNlIHRoZSBudW1iZXIgb2ZcbiAgICAgICAgICAgIC8vIGJsb2NrcyBwcm9jZXNzZWQgZm9yIHRoZSBuZXh0IGNvbHVtbi5cbiAgICAgICAgICAgIHdoaWxlICh5ID4gMCAmJiBzY29yZVt5XSA+PSBtYXhFcnJvcnMgKyB3KSB7XG4gICAgICAgICAgICAgICAgeSAtPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIGVycm9yIGNvdW50IGlzIHVuZGVyIHRocmVzaG9sZCwgcmVwb3J0IGEgbWF0Y2guXG4gICAgICAgIGlmICh5ID09PSBiTWF4ICYmIHNjb3JlW3ldIDw9IG1heEVycm9ycykge1xuICAgICAgICAgICAgaWYgKHNjb3JlW3ldIDwgbWF4RXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgLy8gRGlzY2FyZCBhbnkgZWFybGllciwgd29yc2UgbWF0Y2hlcy5cbiAgICAgICAgICAgICAgICBtYXRjaGVzLnNwbGljZSgwLCBtYXRjaGVzLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYXRjaGVzLnB1c2goe1xuICAgICAgICAgICAgICAgIHN0YXJ0OiAtMSxcbiAgICAgICAgICAgICAgICBlbmQ6IGogKyAxLFxuICAgICAgICAgICAgICAgIGVycm9yczogc2NvcmVbeV1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gQmVjYXVzZSBgc2VhcmNoYCBvbmx5IHJlcG9ydHMgdGhlIG1hdGNoZXMgd2l0aCB0aGUgbG93ZXN0IGVycm9yIGNvdW50LFxuICAgICAgICAgICAgLy8gd2UgY2FuIFwicmF0Y2hldCBkb3duXCIgdGhlIG1heCBlcnJvciB0aHJlc2hvbGQgd2hlbmV2ZXIgYSBtYXRjaCBpc1xuICAgICAgICAgICAgLy8gZW5jb3VudGVyZWQgYW5kIHRoZXJlYnkgc2F2ZSBhIHNtYWxsIGFtb3VudCBvZiB3b3JrIGZvciB0aGUgcmVtYWluZGVyXG4gICAgICAgICAgICAvLyBvZiB0aGUgdGV4dC5cbiAgICAgICAgICAgIG1heEVycm9ycyA9IHNjb3JlW3ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYXRjaGVzO1xufVxuLyoqXG4gKiBTZWFyY2ggZm9yIG1hdGNoZXMgZm9yIGBwYXR0ZXJuYCBpbiBgdGV4dGAgYWxsb3dpbmcgdXAgdG8gYG1heEVycm9yc2AgZXJyb3JzLlxuICpcbiAqIFJldHVybnMgdGhlIHN0YXJ0LCBhbmQgZW5kIHBvc2l0aW9ucyBhbmQgZXJyb3IgY291bnRzIGZvciBlYWNoIGxvd2VzdC1jb3N0XG4gKiBtYXRjaC4gT25seSB0aGUgXCJiZXN0XCIgbWF0Y2hlcyBhcmUgcmV0dXJuZWQuXG4gKi9cbmZ1bmN0aW9uIHNlYXJjaCh0ZXh0LCBwYXR0ZXJuLCBtYXhFcnJvcnMpIHtcbiAgICB2YXIgbWF0Y2hlcyA9IGZpbmRNYXRjaEVuZHModGV4dCwgcGF0dGVybiwgbWF4RXJyb3JzKTtcbiAgICByZXR1cm4gZmluZE1hdGNoU3RhcnRzKHRleHQsIHBhdHRlcm4sIG1hdGNoZXMpO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gc2VhcmNoO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///89\n')},388:(__unused_webpack_module,__unused_webpack___webpack_exports__,__webpack_require__)=>{eval('\n// EXTERNAL MODULE: ./node_modules/approx-string-match/dist/index.js\nvar dist = __webpack_require__(89);\n;// CONCATENATED MODULE: ./src/vendor/hypothesis/anchoring/match-quote.js\n\n\n/**\n * @typedef {import(\'approx-string-match\').Match} StringMatch\n */\n\n/**\n * @typedef Match\n * @prop {number} start - Start offset of match in text\n * @prop {number} end - End offset of match in text\n * @prop {number} score -\n *   Score for the match between 0 and 1.0, where 1.0 indicates a perfect match\n *   for the quote and context.\n */\n\n/**\n * Find the best approximate matches for `str` in `text` allowing up to `maxErrors` errors.\n *\n * @param {string} text\n * @param {string} str\n * @param {number} maxErrors\n * @return {StringMatch[]}\n */\nfunction search(text, str, maxErrors) {\n  // Do a fast search for exact matches. The `approx-string-match` library\n  // doesn\'t currently incorporate this optimization itself.\n  let matchPos = 0;\n  let exactMatches = [];\n  while (matchPos !== -1) {\n    matchPos = text.indexOf(str, matchPos);\n    if (matchPos !== -1) {\n      exactMatches.push({\n        start: matchPos,\n        end: matchPos + str.length,\n        errors: 0,\n      });\n      matchPos += 1;\n    }\n  }\n  if (exactMatches.length > 0) {\n    return exactMatches;\n  }\n\n  // If there are no exact matches, do a more expensive search for matches\n  // with errors.\n  return approxSearch(text, str, maxErrors);\n}\n\n/**\n * Compute a score between 0 and 1.0 for the similarity between `text` and `str`.\n *\n * @param {string} text\n * @param {string} str\n */\nfunction textMatchScore(text, str) {\n  /* istanbul ignore next - `scoreMatch` will never pass an empty string */\n  if (str.length === 0 || text.length === 0) {\n    return 0.0;\n  }\n  const matches = search(text, str, str.length);\n\n  // prettier-ignore\n  return 1 - (matches[0].errors / str.length);\n}\n\n/**\n * Find the best approximate match for `quote` in `text`.\n *\n * Returns `null` if no match exceeding the minimum quality threshold was found.\n *\n * @param {string} text - Document text to search\n * @param {string} quote - String to find within `text`\n * @param {Object} context -\n *   Context in which the quote originally appeared. This is used to choose the\n *   best match.\n *   @param {string} [context.prefix] - Expected text before the quote\n *   @param {string} [context.suffix] - Expected text after the quote\n *   @param {number} [context.hint] - Expected offset of match within text\n * @return {Match|null}\n */\nfunction match_quote_matchQuote(text, quote, context = {}) {\n  if (quote.length === 0) {\n    return null;\n  }\n\n  // Choose the maximum number of errors to allow for the initial search.\n  // This choice involves a tradeoff between:\n  //\n  //  - Recall (proportion of "good" matches found)\n  //  - Precision (proportion of matches found which are "good")\n  //  - Cost of the initial search and of processing the candidate matches [1]\n  //\n  // [1] Specifically, the expected-time complexity of the initial search is\n  //     `O((maxErrors / 32) * text.length)`. See `approx-string-match` docs.\n  const maxErrors = Math.min(256, quote.length / 2);\n\n  // Find closest matches for `quote` in `text` based on edit distance.\n  const matches = search(text, quote, maxErrors);\n\n  if (matches.length === 0) {\n    return null;\n  }\n\n  /**\n   * Compute a score between 0 and 1.0 for a match candidate.\n   *\n   * @param {StringMatch} match\n   */\n  const scoreMatch = match => {\n    const quoteWeight = 50; // Similarity of matched text to quote.\n    const prefixWeight = 20; // Similarity of text before matched text to `context.prefix`.\n    const suffixWeight = 20; // Similarity of text after matched text to `context.suffix`.\n    const posWeight = 2; // Proximity to expected location. Used as a tie-breaker.\n\n    const quoteScore = 1 - match.errors / quote.length;\n\n    const prefixScore = context.prefix\n      ? textMatchScore(\n          text.slice(Math.max(0, match.start - context.prefix.length), match.start),\n          context.prefix\n        )\n      : 1.0;\n    const suffixScore = context.suffix\n      ? textMatchScore(\n          text.slice(match.end, match.end + context.suffix.length),\n          context.suffix\n        )\n      : 1.0;\n\n    let posScore = 1.0;\n    if (typeof context.hint === \'number\') {\n      const offset = Math.abs(match.start - context.hint);\n      posScore = 1.0 - offset / text.length;\n    }\n\n    const rawScore =\n      quoteWeight * quoteScore +\n      prefixWeight * prefixScore +\n      suffixWeight * suffixScore +\n      posWeight * posScore;\n    const maxScore = quoteWeight + prefixWeight + suffixWeight + posWeight;\n    const normalizedScore = rawScore / maxScore;\n\n    return normalizedScore;\n  };\n\n  // Rank matches based on similarity of actual and expected surrounding text\n  // and actual/expected offset in the document text.\n  const scoredMatches = matches.map(m => ({\n    start: m.start,\n    end: m.end,\n    score: scoreMatch(m),\n  }));\n\n  // Choose match with highest score.\n  scoredMatches.sort((a, b) => b.score - a.score);\n  return scoredMatches[0];\n}\n\n;// CONCATENATED MODULE: ./src/vendor/hypothesis/anchoring/types.js\n/**\n * This module exports a set of classes for converting between DOM `Range`\n * objects and different types of selectors. It is mostly a thin wrapper around a\n * set of anchoring libraries. It serves two main purposes:\n *\n *  1. Providing a consistent interface across different types of anchors.\n *  2. Insulating the rest of the code from API changes in the underlying anchoring\n *     libraries.\n */\n\n\n\n\n\n/**\n * @typedef {import(\'../../types/api\').RangeSelector} RangeSelector\n * @typedef {import(\'../../types/api\').TextPositionSelector} TextPositionSelector\n * @typedef {import(\'../../types/api\').TextQuoteSelector} TextQuoteSelector\n */\n\n/**\n * Converts between `RangeSelector` selectors and `Range` objects.\n */\nclass RangeAnchor {\n  /**\n   * @param {Node} root - A root element from which to anchor.\n   * @param {Range} range -  A range describing the anchor.\n   */\n  constructor(root, range) {\n    this.root = root;\n    this.range = range;\n  }\n\n  /**\n   * @param {Node} root -  A root element from which to anchor.\n   * @param {Range} range -  A range describing the anchor.\n   */\n  static fromRange(root, range) {\n    return new RangeAnchor(root, range);\n  }\n\n  /**\n   * Create an anchor from a serialized `RangeSelector` selector.\n   *\n   * @param {Element} root -  A root element from which to anchor.\n   * @param {RangeSelector} selector\n   */\n  static fromSelector(root, selector) {\n    const startContainer = nodeFromXPath(selector.startContainer, root);\n    if (!startContainer) {\n      throw new Error(\'Failed to resolve startContainer XPath\');\n    }\n\n    const endContainer = nodeFromXPath(selector.endContainer, root);\n    if (!endContainer) {\n      throw new Error(\'Failed to resolve endContainer XPath\');\n    }\n\n    const startPos = TextPosition.fromCharOffset(\n      startContainer,\n      selector.startOffset\n    );\n    const endPos = TextPosition.fromCharOffset(\n      endContainer,\n      selector.endOffset\n    );\n\n    const range = new TextRange(startPos, endPos).toRange();\n    return new RangeAnchor(root, range);\n  }\n\n  toRange() {\n    return this.range;\n  }\n\n  /**\n   * @return {RangeSelector}\n   */\n  toSelector() {\n    // "Shrink" the range so that it tightly wraps its text. This ensures more\n    // predictable output for a given text selection.\n    const normalizedRange = TextRange.fromRange(this.range).toRange();\n\n    const textRange = TextRange.fromRange(normalizedRange);\n    const startContainer = xpathFromNode(textRange.start.element, this.root);\n    const endContainer = xpathFromNode(textRange.end.element, this.root);\n\n    return {\n      type: \'RangeSelector\',\n      startContainer,\n      startOffset: textRange.start.offset,\n      endContainer,\n      endOffset: textRange.end.offset,\n    };\n  }\n}\n\n/**\n * Converts between `TextPositionSelector` selectors and `Range` objects.\n */\nclass TextPositionAnchor {\n  /**\n   * @param {Element} root\n   * @param {number} start\n   * @param {number} end\n   */\n  constructor(root, start, end) {\n    this.root = root;\n    this.start = start;\n    this.end = end;\n  }\n\n  /**\n   * @param {Element} root\n   * @param {Range} range\n   */\n  static fromRange(root, range) {\n    const textRange = TextRange.fromRange(range).relativeTo(root);\n    return new TextPositionAnchor(\n      root,\n      textRange.start.offset,\n      textRange.end.offset\n    );\n  }\n  /**\n   * @param {Element} root\n   * @param {TextPositionSelector} selector\n   */\n  static fromSelector(root, selector) {\n    return new TextPositionAnchor(root, selector.start, selector.end);\n  }\n\n  /**\n   * @return {TextPositionSelector}\n   */\n  toSelector() {\n    return {\n      type: \'TextPositionSelector\',\n      start: this.start,\n      end: this.end,\n    };\n  }\n\n  toRange() {\n    return TextRange.fromOffsets(this.root, this.start, this.end).toRange();\n  }\n}\n\n/**\n * @typedef QuoteMatchOptions\n * @prop {number} [hint] - Expected position of match in text. See `matchQuote`.\n */\n\n/**\n * Converts between `TextQuoteSelector` selectors and `Range` objects.\n */\nclass types_TextQuoteAnchor {\n  /**\n   * @param {Element} root - A root element from which to anchor.\n   * @param {string} exact\n   * @param {Object} context\n   *   @param {string} [context.prefix]\n   *   @param {string} [context.suffix]\n   */\n  constructor(root, exact, context = {}) {\n    this.root = root;\n    this.exact = exact;\n    this.context = context;\n  }\n\n  /**\n   * Create a `TextQuoteAnchor` from a range.\n   *\n   * Will throw if `range` does not contain any text nodes.\n   *\n   * @param {Element} root\n   * @param {Range} range\n   */\n  static fromRange(root, range) {\n    const text = /** @type {string} */ (root.textContent);\n    const textRange = TextRange.fromRange(range).relativeTo(root);\n\n    const start = textRange.start.offset;\n    const end = textRange.end.offset;\n\n    // Number of characters around the quote to capture as context. We currently\n    // always use a fixed amount, but it would be better if this code was aware\n    // of logical boundaries in the document (paragraph, article etc.) to avoid\n    // capturing text unrelated to the quote.\n    //\n    // In regular prose the ideal content would often be the surrounding sentence.\n    // This is a natural unit of meaning which enables displaying quotes in\n    // context even when the document is not available. We could use `Intl.Segmenter`\n    // for this when available.\n    const contextLen = 32;\n\n    return new types_TextQuoteAnchor(root, text.slice(start, end), {\n      prefix: text.slice(Math.max(0, start - contextLen), start),\n      suffix: text.slice(end, Math.min(text.length, end + contextLen)),\n    });\n  }\n\n  /**\n   * @param {Element} root\n   * @param {TextQuoteSelector} selector\n   */\n  static fromSelector(root, selector) {\n    const { prefix, suffix } = selector;\n    return new types_TextQuoteAnchor(root, selector.exact, { prefix, suffix });\n  }\n\n  /**\n   * @return {TextQuoteSelector}\n   */\n  toSelector() {\n    return {\n      type: \'TextQuoteSelector\',\n      exact: this.exact,\n      prefix: this.context.prefix,\n      suffix: this.context.suffix,\n    };\n  }\n\n  /**\n   * @param {QuoteMatchOptions} [options]\n   */\n  toRange(options = {}) {\n    return this.toPositionAnchor(options).toRange();\n  }\n\n  /**\n   * @param {QuoteMatchOptions} [options]\n   */\n  toPositionAnchor(options = {}) {\n    const text = /** @type {string} */ (this.root.textContent);\n    const match = matchQuote(text, this.exact, {\n      ...this.context,\n      hint: options.hint,\n    });\n    if (!match) {\n      throw new Error(\'Quote not found\');\n    }\n    return new TextPositionAnchor(this.root, match.start, match.end);\n  }\n}\n\n;// CONCATENATED MODULE: ./src/utils.js\n//\n//  Copyright 2021 Readium Foundation. All rights reserved.\n//  Use of this source code is governed by the BSD-style license\n//  available in the top-level LICENSE file of the project.\n//\n\n// Catch JS errors to log them in the app.\n\n\n\nwindow.addEventListener(\n  "error",\n  function (event) {\n    webkit.messageHandlers.logError.postMessage({\n      message: event.message,\n      filename: event.filename,\n      line: event.lineno,\n    });\n  },\n  false\n);\n\n// Notify native code that the page has loaded.\nwindow.addEventListener(\n  "load",\n  function () {\n    // on page load\n    window.addEventListener("orientationchange", function () {\n      orientationChanged();\n      snapCurrentPosition();\n    });\n    orientationChanged();\n  },\n  false\n);\n\nvar last_known_scrollX_position = 0;\nvar last_known_scrollY_position = 0;\nvar ticking = false;\nvar maxScreenX = 0;\n\n// Position in range [0 - 1].\nfunction update(position) {\n  var positionString = position.toString();\n  webkit.messageHandlers.progressionChanged.postMessage(positionString);\n}\n\nwindow.addEventListener("scroll", function () {\n  last_known_scrollY_position =\n    window.scrollY / document.scrollingElement.scrollHeight;\n  // Using Math.abs because for RTL books, the value will be negative.\n  last_known_scrollX_position = Math.abs(\n    window.scrollX / document.scrollingElement.scrollWidth\n  );\n\n  // Window is hidden\n  if (\n    document.scrollingElement.scrollWidth === 0 ||\n    document.scrollingElement.scrollHeight === 0\n  ) {\n    return;\n  }\n\n  if (!ticking) {\n    window.requestAnimationFrame(function () {\n      update(\n        isScrollModeEnabled()\n          ? last_known_scrollY_position\n          : last_known_scrollX_position\n      );\n      ticking = false;\n    });\n  }\n  ticking = true;\n});\n\ndocument.addEventListener(\n  "selectionchange",\n  debounce(50, function () {\n    var info = {};\n    var selection = document.getSelection();\n    if (selection && selection.rangeCount > 0) {\n      var rect = selection.getRangeAt(0).getBoundingClientRect();\n      info["text"] = selection.toString().trim();\n      info["frame"] = {\n        x: rect.left,\n        y: rect.top,\n        width: rect.width,\n        height: rect.height,\n      };\n    }\n\n    webkit.messageHandlers.selectionChanged.postMessage(info);\n  })\n);\n\nfunction orientationChanged() {\n  maxScreenX =\n    window.orientation === 0 || window.orientation == 180\n      ? screen.width\n      : screen.height;\n}\n\nfunction isScrollModeEnabled() {\n  return (\n    document.documentElement.style\n      .getPropertyValue("--USER__scroll")\n      .toString()\n      .trim() === "readium-scroll-on"\n  );\n}\n\n// Scroll to the given TagId in document and snap.\nfunction scrollToId(id) {\n  var element = document.getElementById(id);\n  if (!element) {\n    return false;\n  }\n  element.scrollIntoView();\n\n  if (!isScrollModeEnabled()) {\n    var currentOffset = window.scrollX;\n    var pageWidth = window.innerWidth;\n    // Adds half a page to make sure we don\'t snap to the previous page.\n    document.scrollingElement.scrollLeft = snapOffset(\n      currentOffset + pageWidth / 2\n    );\n  }\n  return true;\n}\n\n// Position must be in the range [0 - 1], 0-100%.\nfunction scrollToPosition(position, dir) {\n  console.log("ScrollToPosition");\n  if (position < 0 || position > 1) {\n    console.log("InvalidPosition");\n    return;\n  }\n\n  if (isScrollModeEnabled()) {\n    let offset = document.scrollingElement.scrollHeight * position;\n    document.scrollingElement.scrollTop = offset;\n    // window.scrollTo(0, offset);\n  } else {\n    var documentWidth = document.scrollingElement.scrollWidth;\n    var factor = dir == "rtl" ? -1 : 1;\n    let offset = documentWidth * position * factor;\n    document.scrollingElement.scrollLeft = snapOffset(offset);\n  }\n}\n\n// Scrolls to the first occurrence of the given text snippet.\n//\n// The expected text argument is a Locator Text object, as defined here:\n// https://readium.org/architecture/models/locators/\nfunction scrollToText(text) {\n  let range = rangeFromLocator({ text });\n  if (!range) {\n    return false;\n  }\n  scrollToRange(range);\n  return true;\n}\n\nfunction scrollToRange(range) {\n  var rect = range.getBoundingClientRect();\n  if (isScrollModeEnabled()) {\n    document.scrollingElement.scrollTop =\n      rect.top + window.scrollY - window.innerHeight / 2;\n  } else {\n    document.scrollingElement.scrollLeft = rect.left + window.scrollX;\n    snapCurrentPosition();\n  }\n}\n\n// Returns false if the page is already at the left-most scroll offset.\nfunction scrollLeft(dir) {\n  var isRTL = dir == "rtl";\n  var documentWidth = document.scrollingElement.scrollWidth;\n  var pageWidth = window.innerWidth;\n  var offset = window.scrollX - pageWidth;\n  var minOffset = isRTL ? -(documentWidth - pageWidth) : 0;\n  return scrollToOffset(Math.max(offset, minOffset));\n}\n\n// Returns false if the page is already at the right-most scroll offset.\nfunction scrollRight(dir) {\n  var isRTL = dir == "rtl";\n  var documentWidth = document.scrollingElement.scrollWidth;\n  var pageWidth = window.innerWidth;\n  var offset = window.scrollX + pageWidth;\n  var maxOffset = isRTL ? 0 : documentWidth - pageWidth;\n  return scrollToOffset(Math.min(offset, maxOffset));\n}\n\n// Scrolls to the given left offset.\n// Returns false if the page scroll position is already close enough to the given offset.\nfunction scrollToOffset(offset) {\n  var currentOffset = window.scrollX;\n  var pageWidth = window.innerWidth;\n  document.scrollingElement.scrollLeft = offset;\n  // In some case the scrollX cannot reach the position respecting to innerWidth\n  var diff = Math.abs(currentOffset - offset) / pageWidth;\n  return diff > 0.01;\n}\n\n// Snap the offset to the screen width (page width).\nfunction snapOffset(offset) {\n  var value = offset + 1;\n\n  return value - (value % maxScreenX);\n}\n\nfunction snapCurrentPosition() {\n  if (isScrollModeEnabled()) {\n    return;\n  }\n  var currentOffset = window.scrollX;\n  var currentOffsetSnapped = snapOffset(currentOffset + 1);\n\n  document.scrollingElement.scrollLeft = currentOffsetSnapped;\n}\n\nfunction rangeFromLocator(locator) {\n  let text = locator.text;\n  if (!text || !text.highlight) {\n    return null;\n  }\n  try {\n    let anchor = new TextQuoteAnchor(document.body, text.highlight, {\n      prefix: text.before,\n      suffix: text.after,\n    });\n    return anchor.toRange();\n  } catch (e) {\n    logError(e);\n    return null;\n  }\n}\n\n/// User Settings.\n\n// For setting user setting.\nfunction setProperty(key, value) {\n  var root = document.documentElement;\n\n  root.style.setProperty(key, value);\n}\n\n// For removing user setting.\nfunction removeProperty(key) {\n  var root = document.documentElement;\n\n  root.style.removeProperty(key);\n}\n\n/// Toolkit\n\nfunction debounce(delay, func) {\n  var timeout;\n  return function () {\n    var self = this;\n    var args = arguments;\n    function callback() {\n      func.apply(self, args);\n      timeout = null;\n    }\n    clearTimeout(timeout);\n    timeout = setTimeout(callback, delay);\n  };\n}\n\nfunction log() {\n  var message = Array.prototype.slice.call(arguments).join(" ");\n  webkit.messageHandlers.log.postMessage(message);\n}\n\nfunction logErrorMessage(msg) {\n  logError(new Error(msg));\n}\n\nfunction logError(e) {\n  webkit.messageHandlers.logError.postMessage({\n    message: e.message,\n  });\n}\n\n;// CONCATENATED MODULE: ./src/index-fixed-wrapper.js\n//\n//  Copyright 2021 Readium Foundation. All rights reserved.\n//  Use of this source code is governed by the BSD-style license\n//  available in the top-level LICENSE file of the project.\n//\n\n// Script used for the wrapper HTML pages of fixed layouts resources.\n\n\n\nwindow.FixedPage = function (iframeId) {\n  // Fixed dimensions for the page, extracted from the viewport meta tag.\n  var _pageSize = null;\n  // Available viewport size to fill with the resource.\n  var _viewportSize = null;\n  // Margins that should not overlap the content.\n  var _safeAreaInsets = null;\n\n  // iFrame containing the page.\n  var _iframe = document.getElementById(iframeId);\n  _iframe.addEventListener("load", loadPageSize);\n\n  // Viewport element containing the iFrame.\n  var _viewport = _iframe.closest(".viewport");\n\n  // Parses the page size from the viewport meta tag of the loaded resource.\n  function loadPageSize() {\n    var viewport = _iframe.contentWindow.document.querySelector(\n      "meta[name=viewport]"\n    );\n    if (!viewport) {\n      return;\n    }\n    var regex = /(\\w+) *= *([^\\s,]+)/g;\n    var properties = {};\n    var match;\n    while ((match = regex.exec(viewport.content))) {\n      properties[match[1]] = match[2];\n    }\n    var width = Number.parseFloat(properties.width);\n    var height = Number.parseFloat(properties.height);\n    if (width && height) {\n      _pageSize = { width: width, height: height };\n      layoutPage();\n    }\n  }\n\n  // Layouts the page iframe to center its content and scale it to fill the available viewport.\n  function layoutPage() {\n    if (!_pageSize || !_viewportSize || !_safeAreaInsets) {\n      return;\n    }\n\n    _iframe.style.width = _pageSize.width + "px";\n    _iframe.style.height = _pageSize.height + "px";\n    _iframe.style.marginTop =\n      _safeAreaInsets.top - _safeAreaInsets.bottom + "px";\n    _iframe.style.marginLeft =\n      _safeAreaInsets.left - _safeAreaInsets.right + "px";\n\n    // Calculates the zoom scale required to fit the content to the viewport.\n    var widthRatio = _viewportSize.width / _pageSize.width;\n    var heightRatio = _viewportSize.height / _pageSize.height;\n    var scale = Math.min(widthRatio, heightRatio);\n\n    // Sets the viewport of the wrapper page (this page) to scale the iframe.\n    var viewport = document.querySelector("meta[name=viewport]");\n    viewport.content = "initial-scale=" + scale + ", minimum-scale=" + scale;\n  }\n\n  return {\n    // Returns whether the page is currently loading its contents.\n    isLoading: false,\n\n    // Href of the resource currently loaded in the page.\n    href: null,\n\n    // Loads the given link ({href, url}) in the page.\n    load: function (link, completion) {\n      if (!link.href || !link.url) {\n        if (completion) {\n          completion();\n        }\n        return;\n      }\n\n      var page = this;\n      page.href = link.href;\n      page.isLoading = true;\n\n      function loaded() {\n        _iframe.removeEventListener("load", loaded);\n\n        // Waiting for the next animation frame seems to do the trick to make sure the page is fully rendered.\n        _iframe.contentWindow.requestAnimationFrame(function () {\n          page.isLoading = false;\n          if (completion) {\n            completion();\n          }\n        });\n      }\n\n      _iframe.addEventListener("load", loaded);\n      _iframe.src = link.url;\n    },\n\n    // Resets the page and empty its contents.\n    reset: function () {\n      if (!this.href) {\n        return;\n      }\n      this.href = null;\n      _pageSize = null;\n      _iframe.src = "about:blank";\n    },\n\n    // Evaluates a script in the context of the page.\n    eval: function (script) {\n      if (!this.href || this.isLoading) {\n        return;\n      }\n      log("EVAL: " + script);\n      return _iframe.contentWindow.eval(script);\n    },\n\n    // Updates the available viewport to display the resource.\n    setViewport: function (viewportSize, safeAreaInsets) {\n      _viewportSize = viewportSize;\n      _safeAreaInsets = safeAreaInsets;\n      layoutPage();\n    },\n\n    // Shows the page\'s viewport.\n    show: function () {\n      _viewport.style.display = "block";\n    },\n\n    // Hides the page\'s viewport.\n    hide: function () {\n      _viewport.style.display = "none";\n    },\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFkaXVtLWpzLy4vc3JjL3ZlbmRvci9oeXBvdGhlc2lzL2FuY2hvcmluZy9tYXRjaC1xdW90ZS5qcz9kZDZhIiwid2VicGFjazovL3JlYWRpdW0tanMvLi9zcmMvdmVuZG9yL2h5cG90aGVzaXMvYW5jaG9yaW5nL3R5cGVzLmpzPzQwMDQiLCJ3ZWJwYWNrOi8vcmVhZGl1bS1qcy8uL3NyYy91dGlscy5qcz8wMjVlIiwid2VicGFjazovL3JlYWRpdW0tanMvLi9zcmMvaW5kZXgtZml4ZWQtd3JhcHBlci5qcz83MzY0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBK0M7O0FBRS9DO0FBQ0EsYUFBYSxvQ0FBb0M7QUFDakQ7O0FBRUE7QUFDQTtBQUNBLFVBQVUsT0FBTztBQUNqQixVQUFVLE9BQU87QUFDakIsVUFBVSxPQUFPO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsWUFBWTtBQUNaO0FBQ08sU0FBUyxzQkFBVSwwQkFBMEI7QUFDcEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLDRCQUE0QjtBQUM1Qiw0QkFBNEI7QUFDNUIsd0JBQXdCOztBQUV4Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7OztBQzdKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTJDO0FBQ1k7QUFDQTs7QUFFdkQ7QUFDQSxhQUFhLHdDQUF3QztBQUNyRCxhQUFhLCtDQUErQztBQUM1RCxhQUFhLDRDQUE0QztBQUN6RDs7QUFFQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsYUFBYSxLQUFLO0FBQ2xCLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxLQUFLO0FBQ2xCLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxjQUFjO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEscUJBQXFCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsT0FBTztBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDTyxNQUFNLHFCQUFlO0FBQzVCO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0EsNEJBQTRCLE9BQU87QUFDbkM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLHFCQUFlO0FBQzlCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxrQkFBa0I7QUFDL0I7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLGVBQWUscUJBQWUsd0JBQXdCLGlCQUFpQjtBQUN2RTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLGtCQUFrQjtBQUMvQjtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBOztBQUVBO0FBQ0EsYUFBYSxrQkFBa0I7QUFDL0I7QUFDQSwrQkFBK0I7QUFDL0IsNEJBQTRCLE9BQU87QUFDbkM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDcFBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRXNFOztBQUV0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLGdDQUFnQyxPQUFPO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ087QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ087QUFDUDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQzdSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUU4Qjs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsOEJBQThCLFVBQVU7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLEdBQUc7QUFDVDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSIsImZpbGUiOiIzODguanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgYXBwcm94U2VhcmNoIGZyb20gJ2FwcHJveC1zdHJpbmctbWF0Y2gnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2FwcHJveC1zdHJpbmctbWF0Y2gnKS5NYXRjaH0gU3RyaW5nTWF0Y2hcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIE1hdGNoXG4gKiBAcHJvcCB7bnVtYmVyfSBzdGFydCAtIFN0YXJ0IG9mZnNldCBvZiBtYXRjaCBpbiB0ZXh0XG4gKiBAcHJvcCB7bnVtYmVyfSBlbmQgLSBFbmQgb2Zmc2V0IG9mIG1hdGNoIGluIHRleHRcbiAqIEBwcm9wIHtudW1iZXJ9IHNjb3JlIC1cbiAqICAgU2NvcmUgZm9yIHRoZSBtYXRjaCBiZXR3ZWVuIDAgYW5kIDEuMCwgd2hlcmUgMS4wIGluZGljYXRlcyBhIHBlcmZlY3QgbWF0Y2hcbiAqICAgZm9yIHRoZSBxdW90ZSBhbmQgY29udGV4dC5cbiAqL1xuXG4vKipcbiAqIEZpbmQgdGhlIGJlc3QgYXBwcm94aW1hdGUgbWF0Y2hlcyBmb3IgYHN0cmAgaW4gYHRleHRgIGFsbG93aW5nIHVwIHRvIGBtYXhFcnJvcnNgIGVycm9ycy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHBhcmFtIHtudW1iZXJ9IG1heEVycm9yc1xuICogQHJldHVybiB7U3RyaW5nTWF0Y2hbXX1cbiAqL1xuZnVuY3Rpb24gc2VhcmNoKHRleHQsIHN0ciwgbWF4RXJyb3JzKSB7XG4gIC8vIERvIGEgZmFzdCBzZWFyY2ggZm9yIGV4YWN0IG1hdGNoZXMuIFRoZSBgYXBwcm94LXN0cmluZy1tYXRjaGAgbGlicmFyeVxuICAvLyBkb2Vzbid0IGN1cnJlbnRseSBpbmNvcnBvcmF0ZSB0aGlzIG9wdGltaXphdGlvbiBpdHNlbGYuXG4gIGxldCBtYXRjaFBvcyA9IDA7XG4gIGxldCBleGFjdE1hdGNoZXMgPSBbXTtcbiAgd2hpbGUgKG1hdGNoUG9zICE9PSAtMSkge1xuICAgIG1hdGNoUG9zID0gdGV4dC5pbmRleE9mKHN0ciwgbWF0Y2hQb3MpO1xuICAgIGlmIChtYXRjaFBvcyAhPT0gLTEpIHtcbiAgICAgIGV4YWN0TWF0Y2hlcy5wdXNoKHtcbiAgICAgICAgc3RhcnQ6IG1hdGNoUG9zLFxuICAgICAgICBlbmQ6IG1hdGNoUG9zICsgc3RyLmxlbmd0aCxcbiAgICAgICAgZXJyb3JzOiAwLFxuICAgICAgfSk7XG4gICAgICBtYXRjaFBvcyArPSAxO1xuICAgIH1cbiAgfVxuICBpZiAoZXhhY3RNYXRjaGVzLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gZXhhY3RNYXRjaGVzO1xuICB9XG5cbiAgLy8gSWYgdGhlcmUgYXJlIG5vIGV4YWN0IG1hdGNoZXMsIGRvIGEgbW9yZSBleHBlbnNpdmUgc2VhcmNoIGZvciBtYXRjaGVzXG4gIC8vIHdpdGggZXJyb3JzLlxuICByZXR1cm4gYXBwcm94U2VhcmNoKHRleHQsIHN0ciwgbWF4RXJyb3JzKTtcbn1cblxuLyoqXG4gKiBDb21wdXRlIGEgc2NvcmUgYmV0d2VlbiAwIGFuZCAxLjAgZm9yIHRoZSBzaW1pbGFyaXR5IGJldHdlZW4gYHRleHRgIGFuZCBgc3RyYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICovXG5mdW5jdGlvbiB0ZXh0TWF0Y2hTY29yZSh0ZXh0LCBzdHIpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgLSBgc2NvcmVNYXRjaGAgd2lsbCBuZXZlciBwYXNzIGFuIGVtcHR5IHN0cmluZyAqL1xuICBpZiAoc3RyLmxlbmd0aCA9PT0gMCB8fCB0ZXh0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAwLjA7XG4gIH1cbiAgY29uc3QgbWF0Y2hlcyA9IHNlYXJjaCh0ZXh0LCBzdHIsIHN0ci5sZW5ndGgpO1xuXG4gIC8vIHByZXR0aWVyLWlnbm9yZVxuICByZXR1cm4gMSAtIChtYXRjaGVzWzBdLmVycm9ycyAvIHN0ci5sZW5ndGgpO1xufVxuXG4vKipcbiAqIEZpbmQgdGhlIGJlc3QgYXBwcm94aW1hdGUgbWF0Y2ggZm9yIGBxdW90ZWAgaW4gYHRleHRgLlxuICpcbiAqIFJldHVybnMgYG51bGxgIGlmIG5vIG1hdGNoIGV4Y2VlZGluZyB0aGUgbWluaW11bSBxdWFsaXR5IHRocmVzaG9sZCB3YXMgZm91bmQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSBEb2N1bWVudCB0ZXh0IHRvIHNlYXJjaFxuICogQHBhcmFtIHtzdHJpbmd9IHF1b3RlIC0gU3RyaW5nIHRvIGZpbmQgd2l0aGluIGB0ZXh0YFxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHQgLVxuICogICBDb250ZXh0IGluIHdoaWNoIHRoZSBxdW90ZSBvcmlnaW5hbGx5IGFwcGVhcmVkLiBUaGlzIGlzIHVzZWQgdG8gY2hvb3NlIHRoZVxuICogICBiZXN0IG1hdGNoLlxuICogICBAcGFyYW0ge3N0cmluZ30gW2NvbnRleHQucHJlZml4XSAtIEV4cGVjdGVkIHRleHQgYmVmb3JlIHRoZSBxdW90ZVxuICogICBAcGFyYW0ge3N0cmluZ30gW2NvbnRleHQuc3VmZml4XSAtIEV4cGVjdGVkIHRleHQgYWZ0ZXIgdGhlIHF1b3RlXG4gKiAgIEBwYXJhbSB7bnVtYmVyfSBbY29udGV4dC5oaW50XSAtIEV4cGVjdGVkIG9mZnNldCBvZiBtYXRjaCB3aXRoaW4gdGV4dFxuICogQHJldHVybiB7TWF0Y2h8bnVsbH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hdGNoUXVvdGUodGV4dCwgcXVvdGUsIGNvbnRleHQgPSB7fSkge1xuICBpZiAocXVvdGUubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBDaG9vc2UgdGhlIG1heGltdW0gbnVtYmVyIG9mIGVycm9ycyB0byBhbGxvdyBmb3IgdGhlIGluaXRpYWwgc2VhcmNoLlxuICAvLyBUaGlzIGNob2ljZSBpbnZvbHZlcyBhIHRyYWRlb2ZmIGJldHdlZW46XG4gIC8vXG4gIC8vICAtIFJlY2FsbCAocHJvcG9ydGlvbiBvZiBcImdvb2RcIiBtYXRjaGVzIGZvdW5kKVxuICAvLyAgLSBQcmVjaXNpb24gKHByb3BvcnRpb24gb2YgbWF0Y2hlcyBmb3VuZCB3aGljaCBhcmUgXCJnb29kXCIpXG4gIC8vICAtIENvc3Qgb2YgdGhlIGluaXRpYWwgc2VhcmNoIGFuZCBvZiBwcm9jZXNzaW5nIHRoZSBjYW5kaWRhdGUgbWF0Y2hlcyBbMV1cbiAgLy9cbiAgLy8gWzFdIFNwZWNpZmljYWxseSwgdGhlIGV4cGVjdGVkLXRpbWUgY29tcGxleGl0eSBvZiB0aGUgaW5pdGlhbCBzZWFyY2ggaXNcbiAgLy8gICAgIGBPKChtYXhFcnJvcnMgLyAzMikgKiB0ZXh0Lmxlbmd0aClgLiBTZWUgYGFwcHJveC1zdHJpbmctbWF0Y2hgIGRvY3MuXG4gIGNvbnN0IG1heEVycm9ycyA9IE1hdGgubWluKDI1NiwgcXVvdGUubGVuZ3RoIC8gMik7XG5cbiAgLy8gRmluZCBjbG9zZXN0IG1hdGNoZXMgZm9yIGBxdW90ZWAgaW4gYHRleHRgIGJhc2VkIG9uIGVkaXQgZGlzdGFuY2UuXG4gIGNvbnN0IG1hdGNoZXMgPSBzZWFyY2godGV4dCwgcXVvdGUsIG1heEVycm9ycyk7XG5cbiAgaWYgKG1hdGNoZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQ29tcHV0ZSBhIHNjb3JlIGJldHdlZW4gMCBhbmQgMS4wIGZvciBhIG1hdGNoIGNhbmRpZGF0ZS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmdNYXRjaH0gbWF0Y2hcbiAgICovXG4gIGNvbnN0IHNjb3JlTWF0Y2ggPSBtYXRjaCA9PiB7XG4gICAgY29uc3QgcXVvdGVXZWlnaHQgPSA1MDsgLy8gU2ltaWxhcml0eSBvZiBtYXRjaGVkIHRleHQgdG8gcXVvdGUuXG4gICAgY29uc3QgcHJlZml4V2VpZ2h0ID0gMjA7IC8vIFNpbWlsYXJpdHkgb2YgdGV4dCBiZWZvcmUgbWF0Y2hlZCB0ZXh0IHRvIGBjb250ZXh0LnByZWZpeGAuXG4gICAgY29uc3Qgc3VmZml4V2VpZ2h0ID0gMjA7IC8vIFNpbWlsYXJpdHkgb2YgdGV4dCBhZnRlciBtYXRjaGVkIHRleHQgdG8gYGNvbnRleHQuc3VmZml4YC5cbiAgICBjb25zdCBwb3NXZWlnaHQgPSAyOyAvLyBQcm94aW1pdHkgdG8gZXhwZWN0ZWQgbG9jYXRpb24uIFVzZWQgYXMgYSB0aWUtYnJlYWtlci5cblxuICAgIGNvbnN0IHF1b3RlU2NvcmUgPSAxIC0gbWF0Y2guZXJyb3JzIC8gcXVvdGUubGVuZ3RoO1xuXG4gICAgY29uc3QgcHJlZml4U2NvcmUgPSBjb250ZXh0LnByZWZpeFxuICAgICAgPyB0ZXh0TWF0Y2hTY29yZShcbiAgICAgICAgICB0ZXh0LnNsaWNlKE1hdGgubWF4KDAsIG1hdGNoLnN0YXJ0IC0gY29udGV4dC5wcmVmaXgubGVuZ3RoKSwgbWF0Y2guc3RhcnQpLFxuICAgICAgICAgIGNvbnRleHQucHJlZml4XG4gICAgICAgIClcbiAgICAgIDogMS4wO1xuICAgIGNvbnN0IHN1ZmZpeFNjb3JlID0gY29udGV4dC5zdWZmaXhcbiAgICAgID8gdGV4dE1hdGNoU2NvcmUoXG4gICAgICAgICAgdGV4dC5zbGljZShtYXRjaC5lbmQsIG1hdGNoLmVuZCArIGNvbnRleHQuc3VmZml4Lmxlbmd0aCksXG4gICAgICAgICAgY29udGV4dC5zdWZmaXhcbiAgICAgICAgKVxuICAgICAgOiAxLjA7XG5cbiAgICBsZXQgcG9zU2NvcmUgPSAxLjA7XG4gICAgaWYgKHR5cGVvZiBjb250ZXh0LmhpbnQgPT09ICdudW1iZXInKSB7XG4gICAgICBjb25zdCBvZmZzZXQgPSBNYXRoLmFicyhtYXRjaC5zdGFydCAtIGNvbnRleHQuaGludCk7XG4gICAgICBwb3NTY29yZSA9IDEuMCAtIG9mZnNldCAvIHRleHQubGVuZ3RoO1xuICAgIH1cblxuICAgIGNvbnN0IHJhd1Njb3JlID1cbiAgICAgIHF1b3RlV2VpZ2h0ICogcXVvdGVTY29yZSArXG4gICAgICBwcmVmaXhXZWlnaHQgKiBwcmVmaXhTY29yZSArXG4gICAgICBzdWZmaXhXZWlnaHQgKiBzdWZmaXhTY29yZSArXG4gICAgICBwb3NXZWlnaHQgKiBwb3NTY29yZTtcbiAgICBjb25zdCBtYXhTY29yZSA9IHF1b3RlV2VpZ2h0ICsgcHJlZml4V2VpZ2h0ICsgc3VmZml4V2VpZ2h0ICsgcG9zV2VpZ2h0O1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRTY29yZSA9IHJhd1Njb3JlIC8gbWF4U2NvcmU7XG5cbiAgICByZXR1cm4gbm9ybWFsaXplZFNjb3JlO1xuICB9O1xuXG4gIC8vIFJhbmsgbWF0Y2hlcyBiYXNlZCBvbiBzaW1pbGFyaXR5IG9mIGFjdHVhbCBhbmQgZXhwZWN0ZWQgc3Vycm91bmRpbmcgdGV4dFxuICAvLyBhbmQgYWN0dWFsL2V4cGVjdGVkIG9mZnNldCBpbiB0aGUgZG9jdW1lbnQgdGV4dC5cbiAgY29uc3Qgc2NvcmVkTWF0Y2hlcyA9IG1hdGNoZXMubWFwKG0gPT4gKHtcbiAgICBzdGFydDogbS5zdGFydCxcbiAgICBlbmQ6IG0uZW5kLFxuICAgIHNjb3JlOiBzY29yZU1hdGNoKG0pLFxuICB9KSk7XG5cbiAgLy8gQ2hvb3NlIG1hdGNoIHdpdGggaGlnaGVzdCBzY29yZS5cbiAgc2NvcmVkTWF0Y2hlcy5zb3J0KChhLCBiKSA9PiBiLnNjb3JlIC0gYS5zY29yZSk7XG4gIHJldHVybiBzY29yZWRNYXRjaGVzWzBdO1xufVxuIiwiLyoqXG4gKiBUaGlzIG1vZHVsZSBleHBvcnRzIGEgc2V0IG9mIGNsYXNzZXMgZm9yIGNvbnZlcnRpbmcgYmV0d2VlbiBET00gYFJhbmdlYFxuICogb2JqZWN0cyBhbmQgZGlmZmVyZW50IHR5cGVzIG9mIHNlbGVjdG9ycy4gSXQgaXMgbW9zdGx5IGEgdGhpbiB3cmFwcGVyIGFyb3VuZCBhXG4gKiBzZXQgb2YgYW5jaG9yaW5nIGxpYnJhcmllcy4gSXQgc2VydmVzIHR3byBtYWluIHB1cnBvc2VzOlxuICpcbiAqICAxLiBQcm92aWRpbmcgYSBjb25zaXN0ZW50IGludGVyZmFjZSBhY3Jvc3MgZGlmZmVyZW50IHR5cGVzIG9mIGFuY2hvcnMuXG4gKiAgMi4gSW5zdWxhdGluZyB0aGUgcmVzdCBvZiB0aGUgY29kZSBmcm9tIEFQSSBjaGFuZ2VzIGluIHRoZSB1bmRlcmx5aW5nIGFuY2hvcmluZ1xuICogICAgIGxpYnJhcmllcy5cbiAqL1xuXG5pbXBvcnQgeyBtYXRjaFF1b3RlIH0gZnJvbSAnLi9tYXRjaC1xdW90ZSc7XG5pbXBvcnQgeyBUZXh0UmFuZ2UsIFRleHRQb3NpdGlvbiB9IGZyb20gJy4vdGV4dC1yYW5nZSc7XG5pbXBvcnQgeyBub2RlRnJvbVhQYXRoLCB4cGF0aEZyb21Ob2RlIH0gZnJvbSAnLi94cGF0aCc7XG5cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnLi4vLi4vdHlwZXMvYXBpJykuUmFuZ2VTZWxlY3Rvcn0gUmFuZ2VTZWxlY3RvclxuICogQHR5cGVkZWYge2ltcG9ydCgnLi4vLi4vdHlwZXMvYXBpJykuVGV4dFBvc2l0aW9uU2VsZWN0b3J9IFRleHRQb3NpdGlvblNlbGVjdG9yXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi8uLi90eXBlcy9hcGknKS5UZXh0UXVvdGVTZWxlY3Rvcn0gVGV4dFF1b3RlU2VsZWN0b3JcbiAqL1xuXG4vKipcbiAqIENvbnZlcnRzIGJldHdlZW4gYFJhbmdlU2VsZWN0b3JgIHNlbGVjdG9ycyBhbmQgYFJhbmdlYCBvYmplY3RzLlxuICovXG5leHBvcnQgY2xhc3MgUmFuZ2VBbmNob3Ige1xuICAvKipcbiAgICogQHBhcmFtIHtOb2RlfSByb290IC0gQSByb290IGVsZW1lbnQgZnJvbSB3aGljaCB0byBhbmNob3IuXG4gICAqIEBwYXJhbSB7UmFuZ2V9IHJhbmdlIC0gIEEgcmFuZ2UgZGVzY3JpYmluZyB0aGUgYW5jaG9yLlxuICAgKi9cbiAgY29uc3RydWN0b3Iocm9vdCwgcmFuZ2UpIHtcbiAgICB0aGlzLnJvb3QgPSByb290O1xuICAgIHRoaXMucmFuZ2UgPSByYW5nZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge05vZGV9IHJvb3QgLSAgQSByb290IGVsZW1lbnQgZnJvbSB3aGljaCB0byBhbmNob3IuXG4gICAqIEBwYXJhbSB7UmFuZ2V9IHJhbmdlIC0gIEEgcmFuZ2UgZGVzY3JpYmluZyB0aGUgYW5jaG9yLlxuICAgKi9cbiAgc3RhdGljIGZyb21SYW5nZShyb290LCByYW5nZSkge1xuICAgIHJldHVybiBuZXcgUmFuZ2VBbmNob3Iocm9vdCwgcmFuZ2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBhbmNob3IgZnJvbSBhIHNlcmlhbGl6ZWQgYFJhbmdlU2VsZWN0b3JgIHNlbGVjdG9yLlxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IHJvb3QgLSAgQSByb290IGVsZW1lbnQgZnJvbSB3aGljaCB0byBhbmNob3IuXG4gICAqIEBwYXJhbSB7UmFuZ2VTZWxlY3Rvcn0gc2VsZWN0b3JcbiAgICovXG4gIHN0YXRpYyBmcm9tU2VsZWN0b3Iocm9vdCwgc2VsZWN0b3IpIHtcbiAgICBjb25zdCBzdGFydENvbnRhaW5lciA9IG5vZGVGcm9tWFBhdGgoc2VsZWN0b3Iuc3RhcnRDb250YWluZXIsIHJvb3QpO1xuICAgIGlmICghc3RhcnRDb250YWluZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHJlc29sdmUgc3RhcnRDb250YWluZXIgWFBhdGgnKTtcbiAgICB9XG5cbiAgICBjb25zdCBlbmRDb250YWluZXIgPSBub2RlRnJvbVhQYXRoKHNlbGVjdG9yLmVuZENvbnRhaW5lciwgcm9vdCk7XG4gICAgaWYgKCFlbmRDb250YWluZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHJlc29sdmUgZW5kQ29udGFpbmVyIFhQYXRoJyk7XG4gICAgfVxuXG4gICAgY29uc3Qgc3RhcnRQb3MgPSBUZXh0UG9zaXRpb24uZnJvbUNoYXJPZmZzZXQoXG4gICAgICBzdGFydENvbnRhaW5lcixcbiAgICAgIHNlbGVjdG9yLnN0YXJ0T2Zmc2V0XG4gICAgKTtcbiAgICBjb25zdCBlbmRQb3MgPSBUZXh0UG9zaXRpb24uZnJvbUNoYXJPZmZzZXQoXG4gICAgICBlbmRDb250YWluZXIsXG4gICAgICBzZWxlY3Rvci5lbmRPZmZzZXRcbiAgICApO1xuXG4gICAgY29uc3QgcmFuZ2UgPSBuZXcgVGV4dFJhbmdlKHN0YXJ0UG9zLCBlbmRQb3MpLnRvUmFuZ2UoKTtcbiAgICByZXR1cm4gbmV3IFJhbmdlQW5jaG9yKHJvb3QsIHJhbmdlKTtcbiAgfVxuXG4gIHRvUmFuZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMucmFuZ2U7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7UmFuZ2VTZWxlY3Rvcn1cbiAgICovXG4gIHRvU2VsZWN0b3IoKSB7XG4gICAgLy8gXCJTaHJpbmtcIiB0aGUgcmFuZ2Ugc28gdGhhdCBpdCB0aWdodGx5IHdyYXBzIGl0cyB0ZXh0LiBUaGlzIGVuc3VyZXMgbW9yZVxuICAgIC8vIHByZWRpY3RhYmxlIG91dHB1dCBmb3IgYSBnaXZlbiB0ZXh0IHNlbGVjdGlvbi5cbiAgICBjb25zdCBub3JtYWxpemVkUmFuZ2UgPSBUZXh0UmFuZ2UuZnJvbVJhbmdlKHRoaXMucmFuZ2UpLnRvUmFuZ2UoKTtcblxuICAgIGNvbnN0IHRleHRSYW5nZSA9IFRleHRSYW5nZS5mcm9tUmFuZ2Uobm9ybWFsaXplZFJhbmdlKTtcbiAgICBjb25zdCBzdGFydENvbnRhaW5lciA9IHhwYXRoRnJvbU5vZGUodGV4dFJhbmdlLnN0YXJ0LmVsZW1lbnQsIHRoaXMucm9vdCk7XG4gICAgY29uc3QgZW5kQ29udGFpbmVyID0geHBhdGhGcm9tTm9kZSh0ZXh0UmFuZ2UuZW5kLmVsZW1lbnQsIHRoaXMucm9vdCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ1JhbmdlU2VsZWN0b3InLFxuICAgICAgc3RhcnRDb250YWluZXIsXG4gICAgICBzdGFydE9mZnNldDogdGV4dFJhbmdlLnN0YXJ0Lm9mZnNldCxcbiAgICAgIGVuZENvbnRhaW5lcixcbiAgICAgIGVuZE9mZnNldDogdGV4dFJhbmdlLmVuZC5vZmZzZXQsXG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIENvbnZlcnRzIGJldHdlZW4gYFRleHRQb3NpdGlvblNlbGVjdG9yYCBzZWxlY3RvcnMgYW5kIGBSYW5nZWAgb2JqZWN0cy5cbiAqL1xuZXhwb3J0IGNsYXNzIFRleHRQb3NpdGlvbkFuY2hvciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IHJvb3RcbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBlbmRcbiAgICovXG4gIGNvbnN0cnVjdG9yKHJvb3QsIHN0YXJ0LCBlbmQpIHtcbiAgICB0aGlzLnJvb3QgPSByb290O1xuICAgIHRoaXMuc3RhcnQgPSBzdGFydDtcbiAgICB0aGlzLmVuZCA9IGVuZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IHJvb3RcbiAgICogQHBhcmFtIHtSYW5nZX0gcmFuZ2VcbiAgICovXG4gIHN0YXRpYyBmcm9tUmFuZ2Uocm9vdCwgcmFuZ2UpIHtcbiAgICBjb25zdCB0ZXh0UmFuZ2UgPSBUZXh0UmFuZ2UuZnJvbVJhbmdlKHJhbmdlKS5yZWxhdGl2ZVRvKHJvb3QpO1xuICAgIHJldHVybiBuZXcgVGV4dFBvc2l0aW9uQW5jaG9yKFxuICAgICAgcm9vdCxcbiAgICAgIHRleHRSYW5nZS5zdGFydC5vZmZzZXQsXG4gICAgICB0ZXh0UmFuZ2UuZW5kLm9mZnNldFxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gcm9vdFxuICAgKiBAcGFyYW0ge1RleHRQb3NpdGlvblNlbGVjdG9yfSBzZWxlY3RvclxuICAgKi9cbiAgc3RhdGljIGZyb21TZWxlY3Rvcihyb290LCBzZWxlY3Rvcikge1xuICAgIHJldHVybiBuZXcgVGV4dFBvc2l0aW9uQW5jaG9yKHJvb3QsIHNlbGVjdG9yLnN0YXJ0LCBzZWxlY3Rvci5lbmQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge1RleHRQb3NpdGlvblNlbGVjdG9yfVxuICAgKi9cbiAgdG9TZWxlY3RvcigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ1RleHRQb3NpdGlvblNlbGVjdG9yJyxcbiAgICAgIHN0YXJ0OiB0aGlzLnN0YXJ0LFxuICAgICAgZW5kOiB0aGlzLmVuZCxcbiAgICB9O1xuICB9XG5cbiAgdG9SYW5nZSgpIHtcbiAgICByZXR1cm4gVGV4dFJhbmdlLmZyb21PZmZzZXRzKHRoaXMucm9vdCwgdGhpcy5zdGFydCwgdGhpcy5lbmQpLnRvUmFuZ2UoKTtcbiAgfVxufVxuXG4vKipcbiAqIEB0eXBlZGVmIFF1b3RlTWF0Y2hPcHRpb25zXG4gKiBAcHJvcCB7bnVtYmVyfSBbaGludF0gLSBFeHBlY3RlZCBwb3NpdGlvbiBvZiBtYXRjaCBpbiB0ZXh0LiBTZWUgYG1hdGNoUXVvdGVgLlxuICovXG5cbi8qKlxuICogQ29udmVydHMgYmV0d2VlbiBgVGV4dFF1b3RlU2VsZWN0b3JgIHNlbGVjdG9ycyBhbmQgYFJhbmdlYCBvYmplY3RzLlxuICovXG5leHBvcnQgY2xhc3MgVGV4dFF1b3RlQW5jaG9yIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gcm9vdCAtIEEgcm9vdCBlbGVtZW50IGZyb20gd2hpY2ggdG8gYW5jaG9yLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXhhY3RcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiAgICogICBAcGFyYW0ge3N0cmluZ30gW2NvbnRleHQucHJlZml4XVxuICAgKiAgIEBwYXJhbSB7c3RyaW5nfSBbY29udGV4dC5zdWZmaXhdXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihyb290LCBleGFjdCwgY29udGV4dCA9IHt9KSB7XG4gICAgdGhpcy5yb290ID0gcm9vdDtcbiAgICB0aGlzLmV4YWN0ID0gZXhhY3Q7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBgVGV4dFF1b3RlQW5jaG9yYCBmcm9tIGEgcmFuZ2UuXG4gICAqXG4gICAqIFdpbGwgdGhyb3cgaWYgYHJhbmdlYCBkb2VzIG5vdCBjb250YWluIGFueSB0ZXh0IG5vZGVzLlxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IHJvb3RcbiAgICogQHBhcmFtIHtSYW5nZX0gcmFuZ2VcbiAgICovXG4gIHN0YXRpYyBmcm9tUmFuZ2Uocm9vdCwgcmFuZ2UpIHtcbiAgICBjb25zdCB0ZXh0ID0gLyoqIEB0eXBlIHtzdHJpbmd9ICovIChyb290LnRleHRDb250ZW50KTtcbiAgICBjb25zdCB0ZXh0UmFuZ2UgPSBUZXh0UmFuZ2UuZnJvbVJhbmdlKHJhbmdlKS5yZWxhdGl2ZVRvKHJvb3QpO1xuXG4gICAgY29uc3Qgc3RhcnQgPSB0ZXh0UmFuZ2Uuc3RhcnQub2Zmc2V0O1xuICAgIGNvbnN0IGVuZCA9IHRleHRSYW5nZS5lbmQub2Zmc2V0O1xuXG4gICAgLy8gTnVtYmVyIG9mIGNoYXJhY3RlcnMgYXJvdW5kIHRoZSBxdW90ZSB0byBjYXB0dXJlIGFzIGNvbnRleHQuIFdlIGN1cnJlbnRseVxuICAgIC8vIGFsd2F5cyB1c2UgYSBmaXhlZCBhbW91bnQsIGJ1dCBpdCB3b3VsZCBiZSBiZXR0ZXIgaWYgdGhpcyBjb2RlIHdhcyBhd2FyZVxuICAgIC8vIG9mIGxvZ2ljYWwgYm91bmRhcmllcyBpbiB0aGUgZG9jdW1lbnQgKHBhcmFncmFwaCwgYXJ0aWNsZSBldGMuKSB0byBhdm9pZFxuICAgIC8vIGNhcHR1cmluZyB0ZXh0IHVucmVsYXRlZCB0byB0aGUgcXVvdGUuXG4gICAgLy9cbiAgICAvLyBJbiByZWd1bGFyIHByb3NlIHRoZSBpZGVhbCBjb250ZW50IHdvdWxkIG9mdGVuIGJlIHRoZSBzdXJyb3VuZGluZyBzZW50ZW5jZS5cbiAgICAvLyBUaGlzIGlzIGEgbmF0dXJhbCB1bml0IG9mIG1lYW5pbmcgd2hpY2ggZW5hYmxlcyBkaXNwbGF5aW5nIHF1b3RlcyBpblxuICAgIC8vIGNvbnRleHQgZXZlbiB3aGVuIHRoZSBkb2N1bWVudCBpcyBub3QgYXZhaWxhYmxlLiBXZSBjb3VsZCB1c2UgYEludGwuU2VnbWVudGVyYFxuICAgIC8vIGZvciB0aGlzIHdoZW4gYXZhaWxhYmxlLlxuICAgIGNvbnN0IGNvbnRleHRMZW4gPSAzMjtcblxuICAgIHJldHVybiBuZXcgVGV4dFF1b3RlQW5jaG9yKHJvb3QsIHRleHQuc2xpY2Uoc3RhcnQsIGVuZCksIHtcbiAgICAgIHByZWZpeDogdGV4dC5zbGljZShNYXRoLm1heCgwLCBzdGFydCAtIGNvbnRleHRMZW4pLCBzdGFydCksXG4gICAgICBzdWZmaXg6IHRleHQuc2xpY2UoZW5kLCBNYXRoLm1pbih0ZXh0Lmxlbmd0aCwgZW5kICsgY29udGV4dExlbikpLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gcm9vdFxuICAgKiBAcGFyYW0ge1RleHRRdW90ZVNlbGVjdG9yfSBzZWxlY3RvclxuICAgKi9cbiAgc3RhdGljIGZyb21TZWxlY3Rvcihyb290LCBzZWxlY3Rvcikge1xuICAgIGNvbnN0IHsgcHJlZml4LCBzdWZmaXggfSA9IHNlbGVjdG9yO1xuICAgIHJldHVybiBuZXcgVGV4dFF1b3RlQW5jaG9yKHJvb3QsIHNlbGVjdG9yLmV4YWN0LCB7IHByZWZpeCwgc3VmZml4IH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge1RleHRRdW90ZVNlbGVjdG9yfVxuICAgKi9cbiAgdG9TZWxlY3RvcigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ1RleHRRdW90ZVNlbGVjdG9yJyxcbiAgICAgIGV4YWN0OiB0aGlzLmV4YWN0LFxuICAgICAgcHJlZml4OiB0aGlzLmNvbnRleHQucHJlZml4LFxuICAgICAgc3VmZml4OiB0aGlzLmNvbnRleHQuc3VmZml4LFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtRdW90ZU1hdGNoT3B0aW9uc30gW29wdGlvbnNdXG4gICAqL1xuICB0b1JhbmdlKG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLnRvUG9zaXRpb25BbmNob3Iob3B0aW9ucykudG9SYW5nZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7UXVvdGVNYXRjaE9wdGlvbnN9IFtvcHRpb25zXVxuICAgKi9cbiAgdG9Qb3NpdGlvbkFuY2hvcihvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB0ZXh0ID0gLyoqIEB0eXBlIHtzdHJpbmd9ICovICh0aGlzLnJvb3QudGV4dENvbnRlbnQpO1xuICAgIGNvbnN0IG1hdGNoID0gbWF0Y2hRdW90ZSh0ZXh0LCB0aGlzLmV4YWN0LCB7XG4gICAgICAuLi50aGlzLmNvbnRleHQsXG4gICAgICBoaW50OiBvcHRpb25zLmhpbnQsXG4gICAgfSk7XG4gICAgaWYgKCFtYXRjaCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdRdW90ZSBub3QgZm91bmQnKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBUZXh0UG9zaXRpb25BbmNob3IodGhpcy5yb290LCBtYXRjaC5zdGFydCwgbWF0Y2guZW5kKTtcbiAgfVxufVxuIiwiLy9cbi8vICBDb3B5cmlnaHQgMjAyMSBSZWFkaXVtIEZvdW5kYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgdGhlIEJTRC1zdHlsZSBsaWNlbnNlXG4vLyAgYXZhaWxhYmxlIGluIHRoZSB0b3AtbGV2ZWwgTElDRU5TRSBmaWxlIG9mIHRoZSBwcm9qZWN0LlxuLy9cblxuLy8gQ2F0Y2ggSlMgZXJyb3JzIHRvIGxvZyB0aGVtIGluIHRoZSBhcHAuXG5cbmltcG9ydCB7IFRleHRRdW90ZUFuY2hvciB9IGZyb20gXCIuL3ZlbmRvci9oeXBvdGhlc2lzL2FuY2hvcmluZy90eXBlc1wiO1xuXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcbiAgXCJlcnJvclwiLFxuICBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB3ZWJraXQubWVzc2FnZUhhbmRsZXJzLmxvZ0Vycm9yLnBvc3RNZXNzYWdlKHtcbiAgICAgIG1lc3NhZ2U6IGV2ZW50Lm1lc3NhZ2UsXG4gICAgICBmaWxlbmFtZTogZXZlbnQuZmlsZW5hbWUsXG4gICAgICBsaW5lOiBldmVudC5saW5lbm8sXG4gICAgfSk7XG4gIH0sXG4gIGZhbHNlXG4pO1xuXG4vLyBOb3RpZnkgbmF0aXZlIGNvZGUgdGhhdCB0aGUgcGFnZSBoYXMgbG9hZGVkLlxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXG4gIFwibG9hZFwiLFxuICBmdW5jdGlvbiAoKSB7XG4gICAgLy8gb24gcGFnZSBsb2FkXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJvcmllbnRhdGlvbmNoYW5nZVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBvcmllbnRhdGlvbkNoYW5nZWQoKTtcbiAgICAgIHNuYXBDdXJyZW50UG9zaXRpb24oKTtcbiAgICB9KTtcbiAgICBvcmllbnRhdGlvbkNoYW5nZWQoKTtcbiAgfSxcbiAgZmFsc2Vcbik7XG5cbnZhciBsYXN0X2tub3duX3Njcm9sbFhfcG9zaXRpb24gPSAwO1xudmFyIGxhc3Rfa25vd25fc2Nyb2xsWV9wb3NpdGlvbiA9IDA7XG52YXIgdGlja2luZyA9IGZhbHNlO1xudmFyIG1heFNjcmVlblggPSAwO1xuXG4vLyBQb3NpdGlvbiBpbiByYW5nZSBbMCAtIDFdLlxuZnVuY3Rpb24gdXBkYXRlKHBvc2l0aW9uKSB7XG4gIHZhciBwb3NpdGlvblN0cmluZyA9IHBvc2l0aW9uLnRvU3RyaW5nKCk7XG4gIHdlYmtpdC5tZXNzYWdlSGFuZGxlcnMucHJvZ3Jlc3Npb25DaGFuZ2VkLnBvc3RNZXNzYWdlKHBvc2l0aW9uU3RyaW5nKTtcbn1cblxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgZnVuY3Rpb24gKCkge1xuICBsYXN0X2tub3duX3Njcm9sbFlfcG9zaXRpb24gPVxuICAgIHdpbmRvdy5zY3JvbGxZIC8gZG9jdW1lbnQuc2Nyb2xsaW5nRWxlbWVudC5zY3JvbGxIZWlnaHQ7XG4gIC8vIFVzaW5nIE1hdGguYWJzIGJlY2F1c2UgZm9yIFJUTCBib29rcywgdGhlIHZhbHVlIHdpbGwgYmUgbmVnYXRpdmUuXG4gIGxhc3Rfa25vd25fc2Nyb2xsWF9wb3NpdGlvbiA9IE1hdGguYWJzKFxuICAgIHdpbmRvdy5zY3JvbGxYIC8gZG9jdW1lbnQuc2Nyb2xsaW5nRWxlbWVudC5zY3JvbGxXaWR0aFxuICApO1xuXG4gIC8vIFdpbmRvdyBpcyBoaWRkZW5cbiAgaWYgKFxuICAgIGRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnQuc2Nyb2xsV2lkdGggPT09IDAgfHxcbiAgICBkb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50LnNjcm9sbEhlaWdodCA9PT0gMFxuICApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoIXRpY2tpbmcpIHtcbiAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgIHVwZGF0ZShcbiAgICAgICAgaXNTY3JvbGxNb2RlRW5hYmxlZCgpXG4gICAgICAgICAgPyBsYXN0X2tub3duX3Njcm9sbFlfcG9zaXRpb25cbiAgICAgICAgICA6IGxhc3Rfa25vd25fc2Nyb2xsWF9wb3NpdGlvblxuICAgICAgKTtcbiAgICAgIHRpY2tpbmcgPSBmYWxzZTtcbiAgICB9KTtcbiAgfVxuICB0aWNraW5nID0gdHJ1ZTtcbn0pO1xuXG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFxuICBcInNlbGVjdGlvbmNoYW5nZVwiLFxuICBkZWJvdW5jZSg1MCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBpbmZvID0ge307XG4gICAgdmFyIHNlbGVjdGlvbiA9IGRvY3VtZW50LmdldFNlbGVjdGlvbigpO1xuICAgIGlmIChzZWxlY3Rpb24gJiYgc2VsZWN0aW9uLnJhbmdlQ291bnQgPiAwKSB7XG4gICAgICB2YXIgcmVjdCA9IHNlbGVjdGlvbi5nZXRSYW5nZUF0KDApLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgaW5mb1tcInRleHRcIl0gPSBzZWxlY3Rpb24udG9TdHJpbmcoKS50cmltKCk7XG4gICAgICBpbmZvW1wiZnJhbWVcIl0gPSB7XG4gICAgICAgIHg6IHJlY3QubGVmdCxcbiAgICAgICAgeTogcmVjdC50b3AsXG4gICAgICAgIHdpZHRoOiByZWN0LndpZHRoLFxuICAgICAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0LFxuICAgICAgfTtcbiAgICB9XG5cbiAgICB3ZWJraXQubWVzc2FnZUhhbmRsZXJzLnNlbGVjdGlvbkNoYW5nZWQucG9zdE1lc3NhZ2UoaW5mbyk7XG4gIH0pXG4pO1xuXG5mdW5jdGlvbiBvcmllbnRhdGlvbkNoYW5nZWQoKSB7XG4gIG1heFNjcmVlblggPVxuICAgIHdpbmRvdy5vcmllbnRhdGlvbiA9PT0gMCB8fCB3aW5kb3cub3JpZW50YXRpb24gPT0gMTgwXG4gICAgICA/IHNjcmVlbi53aWR0aFxuICAgICAgOiBzY3JlZW4uaGVpZ2h0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNTY3JvbGxNb2RlRW5hYmxlZCgpIHtcbiAgcmV0dXJuIChcbiAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGVcbiAgICAgIC5nZXRQcm9wZXJ0eVZhbHVlKFwiLS1VU0VSX19zY3JvbGxcIilcbiAgICAgIC50b1N0cmluZygpXG4gICAgICAudHJpbSgpID09PSBcInJlYWRpdW0tc2Nyb2xsLW9uXCJcbiAgKTtcbn1cblxuLy8gU2Nyb2xsIHRvIHRoZSBnaXZlbiBUYWdJZCBpbiBkb2N1bWVudCBhbmQgc25hcC5cbmV4cG9ydCBmdW5jdGlvbiBzY3JvbGxUb0lkKGlkKSB7XG4gIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpO1xuICBpZiAoIWVsZW1lbnQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZWxlbWVudC5zY3JvbGxJbnRvVmlldygpO1xuXG4gIGlmICghaXNTY3JvbGxNb2RlRW5hYmxlZCgpKSB7XG4gICAgdmFyIGN1cnJlbnRPZmZzZXQgPSB3aW5kb3cuc2Nyb2xsWDtcbiAgICB2YXIgcGFnZVdpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgLy8gQWRkcyBoYWxmIGEgcGFnZSB0byBtYWtlIHN1cmUgd2UgZG9uJ3Qgc25hcCB0byB0aGUgcHJldmlvdXMgcGFnZS5cbiAgICBkb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50LnNjcm9sbExlZnQgPSBzbmFwT2Zmc2V0KFxuICAgICAgY3VycmVudE9mZnNldCArIHBhZ2VXaWR0aCAvIDJcbiAgICApO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vLyBQb3NpdGlvbiBtdXN0IGJlIGluIHRoZSByYW5nZSBbMCAtIDFdLCAwLTEwMCUuXG5leHBvcnQgZnVuY3Rpb24gc2Nyb2xsVG9Qb3NpdGlvbihwb3NpdGlvbiwgZGlyKSB7XG4gIGNvbnNvbGUubG9nKFwiU2Nyb2xsVG9Qb3NpdGlvblwiKTtcbiAgaWYgKHBvc2l0aW9uIDwgMCB8fCBwb3NpdGlvbiA+IDEpIHtcbiAgICBjb25zb2xlLmxvZyhcIkludmFsaWRQb3NpdGlvblwiKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoaXNTY3JvbGxNb2RlRW5hYmxlZCgpKSB7XG4gICAgbGV0IG9mZnNldCA9IGRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnQuc2Nyb2xsSGVpZ2h0ICogcG9zaXRpb247XG4gICAgZG9jdW1lbnQuc2Nyb2xsaW5nRWxlbWVudC5zY3JvbGxUb3AgPSBvZmZzZXQ7XG4gICAgLy8gd2luZG93LnNjcm9sbFRvKDAsIG9mZnNldCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGRvY3VtZW50V2lkdGggPSBkb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50LnNjcm9sbFdpZHRoO1xuICAgIHZhciBmYWN0b3IgPSBkaXIgPT0gXCJydGxcIiA/IC0xIDogMTtcbiAgICBsZXQgb2Zmc2V0ID0gZG9jdW1lbnRXaWR0aCAqIHBvc2l0aW9uICogZmFjdG9yO1xuICAgIGRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnQuc2Nyb2xsTGVmdCA9IHNuYXBPZmZzZXQob2Zmc2V0KTtcbiAgfVxufVxuXG4vLyBTY3JvbGxzIHRvIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIHRoZSBnaXZlbiB0ZXh0IHNuaXBwZXQuXG4vL1xuLy8gVGhlIGV4cGVjdGVkIHRleHQgYXJndW1lbnQgaXMgYSBMb2NhdG9yIFRleHQgb2JqZWN0LCBhcyBkZWZpbmVkIGhlcmU6XG4vLyBodHRwczovL3JlYWRpdW0ub3JnL2FyY2hpdGVjdHVyZS9tb2RlbHMvbG9jYXRvcnMvXG5leHBvcnQgZnVuY3Rpb24gc2Nyb2xsVG9UZXh0KHRleHQpIHtcbiAgbGV0IHJhbmdlID0gcmFuZ2VGcm9tTG9jYXRvcih7IHRleHQgfSk7XG4gIGlmICghcmFuZ2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgc2Nyb2xsVG9SYW5nZShyYW5nZSk7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBzY3JvbGxUb1JhbmdlKHJhbmdlKSB7XG4gIHZhciByZWN0ID0gcmFuZ2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIGlmIChpc1Njcm9sbE1vZGVFbmFibGVkKCkpIHtcbiAgICBkb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50LnNjcm9sbFRvcCA9XG4gICAgICByZWN0LnRvcCArIHdpbmRvdy5zY3JvbGxZIC0gd2luZG93LmlubmVySGVpZ2h0IC8gMjtcbiAgfSBlbHNlIHtcbiAgICBkb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50LnNjcm9sbExlZnQgPSByZWN0LmxlZnQgKyB3aW5kb3cuc2Nyb2xsWDtcbiAgICBzbmFwQ3VycmVudFBvc2l0aW9uKCk7XG4gIH1cbn1cblxuLy8gUmV0dXJucyBmYWxzZSBpZiB0aGUgcGFnZSBpcyBhbHJlYWR5IGF0IHRoZSBsZWZ0LW1vc3Qgc2Nyb2xsIG9mZnNldC5cbmV4cG9ydCBmdW5jdGlvbiBzY3JvbGxMZWZ0KGRpcikge1xuICB2YXIgaXNSVEwgPSBkaXIgPT0gXCJydGxcIjtcbiAgdmFyIGRvY3VtZW50V2lkdGggPSBkb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50LnNjcm9sbFdpZHRoO1xuICB2YXIgcGFnZVdpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XG4gIHZhciBvZmZzZXQgPSB3aW5kb3cuc2Nyb2xsWCAtIHBhZ2VXaWR0aDtcbiAgdmFyIG1pbk9mZnNldCA9IGlzUlRMID8gLShkb2N1bWVudFdpZHRoIC0gcGFnZVdpZHRoKSA6IDA7XG4gIHJldHVybiBzY3JvbGxUb09mZnNldChNYXRoLm1heChvZmZzZXQsIG1pbk9mZnNldCkpO1xufVxuXG4vLyBSZXR1cm5zIGZhbHNlIGlmIHRoZSBwYWdlIGlzIGFscmVhZHkgYXQgdGhlIHJpZ2h0LW1vc3Qgc2Nyb2xsIG9mZnNldC5cbmV4cG9ydCBmdW5jdGlvbiBzY3JvbGxSaWdodChkaXIpIHtcbiAgdmFyIGlzUlRMID0gZGlyID09IFwicnRsXCI7XG4gIHZhciBkb2N1bWVudFdpZHRoID0gZG9jdW1lbnQuc2Nyb2xsaW5nRWxlbWVudC5zY3JvbGxXaWR0aDtcbiAgdmFyIHBhZ2VXaWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICB2YXIgb2Zmc2V0ID0gd2luZG93LnNjcm9sbFggKyBwYWdlV2lkdGg7XG4gIHZhciBtYXhPZmZzZXQgPSBpc1JUTCA/IDAgOiBkb2N1bWVudFdpZHRoIC0gcGFnZVdpZHRoO1xuICByZXR1cm4gc2Nyb2xsVG9PZmZzZXQoTWF0aC5taW4ob2Zmc2V0LCBtYXhPZmZzZXQpKTtcbn1cblxuLy8gU2Nyb2xscyB0byB0aGUgZ2l2ZW4gbGVmdCBvZmZzZXQuXG4vLyBSZXR1cm5zIGZhbHNlIGlmIHRoZSBwYWdlIHNjcm9sbCBwb3NpdGlvbiBpcyBhbHJlYWR5IGNsb3NlIGVub3VnaCB0byB0aGUgZ2l2ZW4gb2Zmc2V0LlxuZnVuY3Rpb24gc2Nyb2xsVG9PZmZzZXQob2Zmc2V0KSB7XG4gIHZhciBjdXJyZW50T2Zmc2V0ID0gd2luZG93LnNjcm9sbFg7XG4gIHZhciBwYWdlV2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgZG9jdW1lbnQuc2Nyb2xsaW5nRWxlbWVudC5zY3JvbGxMZWZ0ID0gb2Zmc2V0O1xuICAvLyBJbiBzb21lIGNhc2UgdGhlIHNjcm9sbFggY2Fubm90IHJlYWNoIHRoZSBwb3NpdGlvbiByZXNwZWN0aW5nIHRvIGlubmVyV2lkdGhcbiAgdmFyIGRpZmYgPSBNYXRoLmFicyhjdXJyZW50T2Zmc2V0IC0gb2Zmc2V0KSAvIHBhZ2VXaWR0aDtcbiAgcmV0dXJuIGRpZmYgPiAwLjAxO1xufVxuXG4vLyBTbmFwIHRoZSBvZmZzZXQgdG8gdGhlIHNjcmVlbiB3aWR0aCAocGFnZSB3aWR0aCkuXG5mdW5jdGlvbiBzbmFwT2Zmc2V0KG9mZnNldCkge1xuICB2YXIgdmFsdWUgPSBvZmZzZXQgKyAxO1xuXG4gIHJldHVybiB2YWx1ZSAtICh2YWx1ZSAlIG1heFNjcmVlblgpO1xufVxuXG5mdW5jdGlvbiBzbmFwQ3VycmVudFBvc2l0aW9uKCkge1xuICBpZiAoaXNTY3JvbGxNb2RlRW5hYmxlZCgpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBjdXJyZW50T2Zmc2V0ID0gd2luZG93LnNjcm9sbFg7XG4gIHZhciBjdXJyZW50T2Zmc2V0U25hcHBlZCA9IHNuYXBPZmZzZXQoY3VycmVudE9mZnNldCArIDEpO1xuXG4gIGRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnQuc2Nyb2xsTGVmdCA9IGN1cnJlbnRPZmZzZXRTbmFwcGVkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmFuZ2VGcm9tTG9jYXRvcihsb2NhdG9yKSB7XG4gIGxldCB0ZXh0ID0gbG9jYXRvci50ZXh0O1xuICBpZiAoIXRleHQgfHwgIXRleHQuaGlnaGxpZ2h0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdHJ5IHtcbiAgICBsZXQgYW5jaG9yID0gbmV3IFRleHRRdW90ZUFuY2hvcihkb2N1bWVudC5ib2R5LCB0ZXh0LmhpZ2hsaWdodCwge1xuICAgICAgcHJlZml4OiB0ZXh0LmJlZm9yZSxcbiAgICAgIHN1ZmZpeDogdGV4dC5hZnRlcixcbiAgICB9KTtcbiAgICByZXR1cm4gYW5jaG9yLnRvUmFuZ2UoKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGxvZ0Vycm9yKGUpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8vLyBVc2VyIFNldHRpbmdzLlxuXG4vLyBGb3Igc2V0dGluZyB1c2VyIHNldHRpbmcuXG5leHBvcnQgZnVuY3Rpb24gc2V0UHJvcGVydHkoa2V5LCB2YWx1ZSkge1xuICB2YXIgcm9vdCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuICByb290LnN0eWxlLnNldFByb3BlcnR5KGtleSwgdmFsdWUpO1xufVxuXG4vLyBGb3IgcmVtb3ZpbmcgdXNlciBzZXR0aW5nLlxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZVByb3BlcnR5KGtleSkge1xuICB2YXIgcm9vdCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuICByb290LnN0eWxlLnJlbW92ZVByb3BlcnR5KGtleSk7XG59XG5cbi8vLyBUb29sa2l0XG5cbmZ1bmN0aW9uIGRlYm91bmNlKGRlbGF5LCBmdW5jKSB7XG4gIHZhciB0aW1lb3V0O1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICBmdW5jdGlvbiBjYWxsYmFjaygpIHtcbiAgICAgIGZ1bmMuYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICB9XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGNhbGxiYWNrLCBkZWxheSk7XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsb2coKSB7XG4gIHZhciBtZXNzYWdlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKS5qb2luKFwiIFwiKTtcbiAgd2Via2l0Lm1lc3NhZ2VIYW5kbGVycy5sb2cucG9zdE1lc3NhZ2UobWVzc2FnZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsb2dFcnJvck1lc3NhZ2UobXNnKSB7XG4gIGxvZ0Vycm9yKG5ldyBFcnJvcihtc2cpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxvZ0Vycm9yKGUpIHtcbiAgd2Via2l0Lm1lc3NhZ2VIYW5kbGVycy5sb2dFcnJvci5wb3N0TWVzc2FnZSh7XG4gICAgbWVzc2FnZTogZS5tZXNzYWdlLFxuICB9KTtcbn1cbiIsIi8vXG4vLyAgQ29weXJpZ2h0IDIwMjEgUmVhZGl1bSBGb3VuZGF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IHRoZSBCU0Qtc3R5bGUgbGljZW5zZVxuLy8gIGF2YWlsYWJsZSBpbiB0aGUgdG9wLWxldmVsIExJQ0VOU0UgZmlsZSBvZiB0aGUgcHJvamVjdC5cbi8vXG5cbi8vIFNjcmlwdCB1c2VkIGZvciB0aGUgd3JhcHBlciBIVE1MIHBhZ2VzIG9mIGZpeGVkIGxheW91dHMgcmVzb3VyY2VzLlxuXG5pbXBvcnQgeyBsb2cgfSBmcm9tIFwiLi91dGlsc1wiO1xuXG53aW5kb3cuRml4ZWRQYWdlID0gZnVuY3Rpb24gKGlmcmFtZUlkKSB7XG4gIC8vIEZpeGVkIGRpbWVuc2lvbnMgZm9yIHRoZSBwYWdlLCBleHRyYWN0ZWQgZnJvbSB0aGUgdmlld3BvcnQgbWV0YSB0YWcuXG4gIHZhciBfcGFnZVNpemUgPSBudWxsO1xuICAvLyBBdmFpbGFibGUgdmlld3BvcnQgc2l6ZSB0byBmaWxsIHdpdGggdGhlIHJlc291cmNlLlxuICB2YXIgX3ZpZXdwb3J0U2l6ZSA9IG51bGw7XG4gIC8vIE1hcmdpbnMgdGhhdCBzaG91bGQgbm90IG92ZXJsYXAgdGhlIGNvbnRlbnQuXG4gIHZhciBfc2FmZUFyZWFJbnNldHMgPSBudWxsO1xuXG4gIC8vIGlGcmFtZSBjb250YWluaW5nIHRoZSBwYWdlLlxuICB2YXIgX2lmcmFtZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlmcmFtZUlkKTtcbiAgX2lmcmFtZS5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCBsb2FkUGFnZVNpemUpO1xuXG4gIC8vIFZpZXdwb3J0IGVsZW1lbnQgY29udGFpbmluZyB0aGUgaUZyYW1lLlxuICB2YXIgX3ZpZXdwb3J0ID0gX2lmcmFtZS5jbG9zZXN0KFwiLnZpZXdwb3J0XCIpO1xuXG4gIC8vIFBhcnNlcyB0aGUgcGFnZSBzaXplIGZyb20gdGhlIHZpZXdwb3J0IG1ldGEgdGFnIG9mIHRoZSBsb2FkZWQgcmVzb3VyY2UuXG4gIGZ1bmN0aW9uIGxvYWRQYWdlU2l6ZSgpIHtcbiAgICB2YXIgdmlld3BvcnQgPSBfaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcbiAgICAgIFwibWV0YVtuYW1lPXZpZXdwb3J0XVwiXG4gICAgKTtcbiAgICBpZiAoIXZpZXdwb3J0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciByZWdleCA9IC8oXFx3KykgKj0gKihbXlxccyxdKykvZztcbiAgICB2YXIgcHJvcGVydGllcyA9IHt9O1xuICAgIHZhciBtYXRjaDtcbiAgICB3aGlsZSAoKG1hdGNoID0gcmVnZXguZXhlYyh2aWV3cG9ydC5jb250ZW50KSkpIHtcbiAgICAgIHByb3BlcnRpZXNbbWF0Y2hbMV1dID0gbWF0Y2hbMl07XG4gICAgfVxuICAgIHZhciB3aWR0aCA9IE51bWJlci5wYXJzZUZsb2F0KHByb3BlcnRpZXMud2lkdGgpO1xuICAgIHZhciBoZWlnaHQgPSBOdW1iZXIucGFyc2VGbG9hdChwcm9wZXJ0aWVzLmhlaWdodCk7XG4gICAgaWYgKHdpZHRoICYmIGhlaWdodCkge1xuICAgICAgX3BhZ2VTaXplID0geyB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH07XG4gICAgICBsYXlvdXRQYWdlKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gTGF5b3V0cyB0aGUgcGFnZSBpZnJhbWUgdG8gY2VudGVyIGl0cyBjb250ZW50IGFuZCBzY2FsZSBpdCB0byBmaWxsIHRoZSBhdmFpbGFibGUgdmlld3BvcnQuXG4gIGZ1bmN0aW9uIGxheW91dFBhZ2UoKSB7XG4gICAgaWYgKCFfcGFnZVNpemUgfHwgIV92aWV3cG9ydFNpemUgfHwgIV9zYWZlQXJlYUluc2V0cykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIF9pZnJhbWUuc3R5bGUud2lkdGggPSBfcGFnZVNpemUud2lkdGggKyBcInB4XCI7XG4gICAgX2lmcmFtZS5zdHlsZS5oZWlnaHQgPSBfcGFnZVNpemUuaGVpZ2h0ICsgXCJweFwiO1xuICAgIF9pZnJhbWUuc3R5bGUubWFyZ2luVG9wID1cbiAgICAgIF9zYWZlQXJlYUluc2V0cy50b3AgLSBfc2FmZUFyZWFJbnNldHMuYm90dG9tICsgXCJweFwiO1xuICAgIF9pZnJhbWUuc3R5bGUubWFyZ2luTGVmdCA9XG4gICAgICBfc2FmZUFyZWFJbnNldHMubGVmdCAtIF9zYWZlQXJlYUluc2V0cy5yaWdodCArIFwicHhcIjtcblxuICAgIC8vIENhbGN1bGF0ZXMgdGhlIHpvb20gc2NhbGUgcmVxdWlyZWQgdG8gZml0IHRoZSBjb250ZW50IHRvIHRoZSB2aWV3cG9ydC5cbiAgICB2YXIgd2lkdGhSYXRpbyA9IF92aWV3cG9ydFNpemUud2lkdGggLyBfcGFnZVNpemUud2lkdGg7XG4gICAgdmFyIGhlaWdodFJhdGlvID0gX3ZpZXdwb3J0U2l6ZS5oZWlnaHQgLyBfcGFnZVNpemUuaGVpZ2h0O1xuICAgIHZhciBzY2FsZSA9IE1hdGgubWluKHdpZHRoUmF0aW8sIGhlaWdodFJhdGlvKTtcblxuICAgIC8vIFNldHMgdGhlIHZpZXdwb3J0IG9mIHRoZSB3cmFwcGVyIHBhZ2UgKHRoaXMgcGFnZSkgdG8gc2NhbGUgdGhlIGlmcmFtZS5cbiAgICB2YXIgdmlld3BvcnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwibWV0YVtuYW1lPXZpZXdwb3J0XVwiKTtcbiAgICB2aWV3cG9ydC5jb250ZW50ID0gXCJpbml0aWFsLXNjYWxlPVwiICsgc2NhbGUgKyBcIiwgbWluaW11bS1zY2FsZT1cIiArIHNjYWxlO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICAvLyBSZXR1cm5zIHdoZXRoZXIgdGhlIHBhZ2UgaXMgY3VycmVudGx5IGxvYWRpbmcgaXRzIGNvbnRlbnRzLlxuICAgIGlzTG9hZGluZzogZmFsc2UsXG5cbiAgICAvLyBIcmVmIG9mIHRoZSByZXNvdXJjZSBjdXJyZW50bHkgbG9hZGVkIGluIHRoZSBwYWdlLlxuICAgIGhyZWY6IG51bGwsXG5cbiAgICAvLyBMb2FkcyB0aGUgZ2l2ZW4gbGluayAoe2hyZWYsIHVybH0pIGluIHRoZSBwYWdlLlxuICAgIGxvYWQ6IGZ1bmN0aW9uIChsaW5rLCBjb21wbGV0aW9uKSB7XG4gICAgICBpZiAoIWxpbmsuaHJlZiB8fCAhbGluay51cmwpIHtcbiAgICAgICAgaWYgKGNvbXBsZXRpb24pIHtcbiAgICAgICAgICBjb21wbGV0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgcGFnZSA9IHRoaXM7XG4gICAgICBwYWdlLmhyZWYgPSBsaW5rLmhyZWY7XG4gICAgICBwYWdlLmlzTG9hZGluZyA9IHRydWU7XG5cbiAgICAgIGZ1bmN0aW9uIGxvYWRlZCgpIHtcbiAgICAgICAgX2lmcmFtZS5yZW1vdmVFdmVudExpc3RlbmVyKFwibG9hZFwiLCBsb2FkZWQpO1xuXG4gICAgICAgIC8vIFdhaXRpbmcgZm9yIHRoZSBuZXh0IGFuaW1hdGlvbiBmcmFtZSBzZWVtcyB0byBkbyB0aGUgdHJpY2sgdG8gbWFrZSBzdXJlIHRoZSBwYWdlIGlzIGZ1bGx5IHJlbmRlcmVkLlxuICAgICAgICBfaWZyYW1lLmNvbnRlbnRXaW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBwYWdlLmlzTG9hZGluZyA9IGZhbHNlO1xuICAgICAgICAgIGlmIChjb21wbGV0aW9uKSB7XG4gICAgICAgICAgICBjb21wbGV0aW9uKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgX2lmcmFtZS5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCBsb2FkZWQpO1xuICAgICAgX2lmcmFtZS5zcmMgPSBsaW5rLnVybDtcbiAgICB9LFxuXG4gICAgLy8gUmVzZXRzIHRoZSBwYWdlIGFuZCBlbXB0eSBpdHMgY29udGVudHMuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghdGhpcy5ocmVmKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuaHJlZiA9IG51bGw7XG4gICAgICBfcGFnZVNpemUgPSBudWxsO1xuICAgICAgX2lmcmFtZS5zcmMgPSBcImFib3V0OmJsYW5rXCI7XG4gICAgfSxcblxuICAgIC8vIEV2YWx1YXRlcyBhIHNjcmlwdCBpbiB0aGUgY29udGV4dCBvZiB0aGUgcGFnZS5cbiAgICBldmFsOiBmdW5jdGlvbiAoc2NyaXB0KSB7XG4gICAgICBpZiAoIXRoaXMuaHJlZiB8fCB0aGlzLmlzTG9hZGluZykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsb2coXCJFVkFMOiBcIiArIHNjcmlwdCk7XG4gICAgICByZXR1cm4gX2lmcmFtZS5jb250ZW50V2luZG93LmV2YWwoc2NyaXB0KTtcbiAgICB9LFxuXG4gICAgLy8gVXBkYXRlcyB0aGUgYXZhaWxhYmxlIHZpZXdwb3J0IHRvIGRpc3BsYXkgdGhlIHJlc291cmNlLlxuICAgIHNldFZpZXdwb3J0OiBmdW5jdGlvbiAodmlld3BvcnRTaXplLCBzYWZlQXJlYUluc2V0cykge1xuICAgICAgX3ZpZXdwb3J0U2l6ZSA9IHZpZXdwb3J0U2l6ZTtcbiAgICAgIF9zYWZlQXJlYUluc2V0cyA9IHNhZmVBcmVhSW5zZXRzO1xuICAgICAgbGF5b3V0UGFnZSgpO1xuICAgIH0sXG5cbiAgICAvLyBTaG93cyB0aGUgcGFnZSdzIHZpZXdwb3J0LlxuICAgIHNob3c6IGZ1bmN0aW9uICgpIHtcbiAgICAgIF92aWV3cG9ydC5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgIH0sXG5cbiAgICAvLyBIaWRlcyB0aGUgcGFnZSdzIHZpZXdwb3J0LlxuICAgIGhpZGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIF92aWV3cG9ydC5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgfSxcbiAgfTtcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///388\n')}},__webpack_module_cache__={};function __webpack_require__(n){var t=__webpack_module_cache__[n];if(void 0!==t)return t.exports;var g=__webpack_module_cache__[n]={exports:{}};return __webpack_modules__[n](g,g.exports,__webpack_require__),g.exports}var __webpack_exports__=__webpack_require__(388)})();