(()=>{var __webpack_modules__={89:(__unused_webpack_module,exports)=>{"use strict";eval('var __webpack_unused_export__;\n\n/**\n * Implementation of Myers\' online approximate string matching algorithm [1],\n * with additional optimizations suggested by [2].\n *\n * This has O((k/w) * n) complexity where `n` is the length of the text, `k` is\n * the maximum number of errors allowed (always <= the pattern length) and `w`\n * is the word size. Because JS only supports bitwise operations on 32 bit\n * integers, `w` is 32.\n *\n * As far as I am aware, there aren\'t any online algorithms which are\n * significantly better for a wide range of input parameters. The problem can be\n * solved faster using "filter then verify" approaches which first filter out\n * regions of the text that cannot match using a "cheap" check and then verify\n * the remaining potential matches. The verify step requires an algorithm such\n * as this one however.\n *\n * The algorithm\'s approach is essentially to optimize the classic dynamic\n * programming solution to the problem by computing columns of the matrix in\n * word-sized chunks (ie. dealing with 32 chars of the pattern at a time) and\n * avoiding calculating regions of the matrix where the minimum error count is\n * guaranteed to exceed the input threshold.\n *\n * The paper consists of two parts, the first describes the core algorithm for\n * matching patterns <= the size of a word (implemented by `advanceBlock` here).\n * The second uses the core algorithm as part of a larger block-based algorithm\n * to handle longer patterns.\n *\n * [1] G. Myers, “A Fast Bit-Vector Algorithm for Approximate String Matching\n * Based on Dynamic Programming,” vol. 46, no. 3, pp. 395–415, 1999.\n *\n * [2] Šošić, M. (2014). An simd dynamic programming c/c++ library (Doctoral\n * dissertation, Fakultet Elektrotehnike i računarstva, Sveučilište u Zagrebu).\n */\n__webpack_unused_export__ = ({ value: true });\nfunction reverse(s) {\n    return s\n        .split("")\n        .reverse()\n        .join("");\n}\n/**\n * Given the ends of approximate matches for `pattern` in `text`, find\n * the start of the matches.\n *\n * @param findEndFn - Function for finding the end of matches in\n * text.\n * @return Matches with the `start` property set.\n */\nfunction findMatchStarts(text, pattern, matches) {\n    var patRev = reverse(pattern);\n    return matches.map(function (m) {\n        // Find start of each match by reversing the pattern and matching segment\n        // of text and searching for an approx match with the same number of\n        // errors.\n        var minStart = Math.max(0, m.end - pattern.length - m.errors);\n        var textRev = reverse(text.slice(minStart, m.end));\n        // If there are multiple possible start points, choose the one that\n        // maximizes the length of the match.\n        var start = findMatchEnds(textRev, patRev, m.errors).reduce(function (min, rm) {\n            if (m.end - rm.end < min) {\n                return m.end - rm.end;\n            }\n            return min;\n        }, m.end);\n        return {\n            start: start,\n            end: m.end,\n            errors: m.errors\n        };\n    });\n}\n/**\n * Return 1 if a number is non-zero or zero otherwise, without using\n * conditional operators.\n *\n * This should get inlined into `advanceBlock` below by the JIT.\n *\n * Adapted from https://stackoverflow.com/a/3912218/434243\n */\nfunction oneIfNotZero(n) {\n    return ((n | -n) >> 31) & 1;\n}\n/**\n * Block calculation step of the algorithm.\n *\n * From Fig 8. on p. 408 of [1], additionally optimized to replace conditional\n * checks with bitwise operations as per Section 4.2.3 of [2].\n *\n * @param ctx - The pattern context object\n * @param peq - The `peq` array for the current character (`ctx.peq.get(ch)`)\n * @param b - The block level\n * @param hIn - Horizontal input delta ∈ {1,0,-1}\n * @return Horizontal output delta ∈ {1,0,-1}\n */\nfunction advanceBlock(ctx, peq, b, hIn) {\n    var pV = ctx.P[b];\n    var mV = ctx.M[b];\n    var hInIsNegative = hIn >>> 31; // 1 if hIn < 0 or 0 otherwise.\n    var eq = peq[b] | hInIsNegative;\n    // Step 1: Compute horizontal deltas.\n    var xV = eq | mV;\n    var xH = (((eq & pV) + pV) ^ pV) | eq;\n    var pH = mV | ~(xH | pV);\n    var mH = pV & xH;\n    // Step 2: Update score (value of last row of this block).\n    var hOut = oneIfNotZero(pH & ctx.lastRowMask[b]) -\n        oneIfNotZero(mH & ctx.lastRowMask[b]);\n    // Step 3: Update vertical deltas for use when processing next char.\n    pH <<= 1;\n    mH <<= 1;\n    mH |= hInIsNegative;\n    pH |= oneIfNotZero(hIn) - hInIsNegative; // set pH[0] if hIn > 0\n    pV = mH | ~(xV | pH);\n    mV = pH & xV;\n    ctx.P[b] = pV;\n    ctx.M[b] = mV;\n    return hOut;\n}\n/**\n * Find the ends and error counts for matches of `pattern` in `text`.\n *\n * Only the matches with the lowest error count are reported. Other matches\n * with error counts <= maxErrors are discarded.\n *\n * This is the block-based search algorithm from Fig. 9 on p.410 of [1].\n */\nfunction findMatchEnds(text, pattern, maxErrors) {\n    if (pattern.length === 0) {\n        return [];\n    }\n    // Clamp error count so we can rely on the `maxErrors` and `pattern.length`\n    // rows being in the same block below.\n    maxErrors = Math.min(maxErrors, pattern.length);\n    var matches = [];\n    // Word size.\n    var w = 32;\n    // Index of maximum block level.\n    var bMax = Math.ceil(pattern.length / w) - 1;\n    // Context used across block calculations.\n    var ctx = {\n        P: new Uint32Array(bMax + 1),\n        M: new Uint32Array(bMax + 1),\n        lastRowMask: new Uint32Array(bMax + 1)\n    };\n    ctx.lastRowMask.fill(1 << 31);\n    ctx.lastRowMask[bMax] = 1 << (pattern.length - 1) % w;\n    // Dummy "peq" array for chars in the text which do not occur in the pattern.\n    var emptyPeq = new Uint32Array(bMax + 1);\n    // Map of UTF-16 character code to bit vector indicating positions in the\n    // pattern that equal that character.\n    var peq = new Map();\n    // Version of `peq` that only stores mappings for small characters. This\n    // allows faster lookups when iterating through the text because a simple\n    // array lookup can be done instead of a hash table lookup.\n    var asciiPeq = [];\n    for (var i = 0; i < 256; i++) {\n        asciiPeq.push(emptyPeq);\n    }\n    // Calculate `ctx.peq` - a map of character values to bitmasks indicating\n    // positions of that character within the pattern, where each bit represents\n    // a position in the pattern.\n    for (var c = 0; c < pattern.length; c += 1) {\n        var val = pattern.charCodeAt(c);\n        if (peq.has(val)) {\n            // Duplicate char in pattern.\n            continue;\n        }\n        var charPeq = new Uint32Array(bMax + 1);\n        peq.set(val, charPeq);\n        if (val < asciiPeq.length) {\n            asciiPeq[val] = charPeq;\n        }\n        for (var b = 0; b <= bMax; b += 1) {\n            charPeq[b] = 0;\n            // Set all the bits where the pattern matches the current char (ch).\n            // For indexes beyond the end of the pattern, always set the bit as if the\n            // pattern contained a wildcard char in that position.\n            for (var r = 0; r < w; r += 1) {\n                var idx = b * w + r;\n                if (idx >= pattern.length) {\n                    continue;\n                }\n                var match = pattern.charCodeAt(idx) === val;\n                if (match) {\n                    charPeq[b] |= 1 << r;\n                }\n            }\n        }\n    }\n    // Index of last-active block level in the column.\n    var y = Math.max(0, Math.ceil(maxErrors / w) - 1);\n    // Initialize maximum error count at bottom of each block.\n    var score = new Uint32Array(bMax + 1);\n    for (var b = 0; b <= y; b += 1) {\n        score[b] = (b + 1) * w;\n    }\n    score[bMax] = pattern.length;\n    // Initialize vertical deltas for each block.\n    for (var b = 0; b <= y; b += 1) {\n        ctx.P[b] = ~0;\n        ctx.M[b] = 0;\n    }\n    // Process each char of the text, computing the error count for `w` chars of\n    // the pattern at a time.\n    for (var j = 0; j < text.length; j += 1) {\n        // Lookup the bitmask representing the positions of the current char from\n        // the text within the pattern.\n        var charCode = text.charCodeAt(j);\n        var charPeq = void 0;\n        if (charCode < asciiPeq.length) {\n            // Fast array lookup.\n            charPeq = asciiPeq[charCode];\n        }\n        else {\n            // Slower hash table lookup.\n            charPeq = peq.get(charCode);\n            if (typeof charPeq === "undefined") {\n                charPeq = emptyPeq;\n            }\n        }\n        // Calculate error count for blocks that we definitely have to process for\n        // this column.\n        var carry = 0;\n        for (var b = 0; b <= y; b += 1) {\n            carry = advanceBlock(ctx, charPeq, b, carry);\n            score[b] += carry;\n        }\n        // Check if we also need to compute an additional block, or if we can reduce\n        // the number of blocks processed for the next column.\n        if (score[y] - carry <= maxErrors &&\n            y < bMax &&\n            (charPeq[y + 1] & 1 || carry < 0)) {\n            // Error count for bottom block is under threshold, increase the number of\n            // blocks processed for this column & next by 1.\n            y += 1;\n            ctx.P[y] = ~0;\n            ctx.M[y] = 0;\n            var maxBlockScore = y === bMax ? pattern.length % w : w;\n            score[y] =\n                score[y - 1] +\n                    maxBlockScore -\n                    carry +\n                    advanceBlock(ctx, charPeq, y, carry);\n        }\n        else {\n            // Error count for bottom block exceeds threshold, reduce the number of\n            // blocks processed for the next column.\n            while (y > 0 && score[y] >= maxErrors + w) {\n                y -= 1;\n            }\n        }\n        // If error count is under threshold, report a match.\n        if (y === bMax && score[y] <= maxErrors) {\n            if (score[y] < maxErrors) {\n                // Discard any earlier, worse matches.\n                matches.splice(0, matches.length);\n            }\n            matches.push({\n                start: -1,\n                end: j + 1,\n                errors: score[y]\n            });\n            // Because `search` only reports the matches with the lowest error count,\n            // we can "ratchet down" the max error threshold whenever a match is\n            // encountered and thereby save a small amount of work for the remainder\n            // of the text.\n            maxErrors = score[y];\n        }\n    }\n    return matches;\n}\n/**\n * Search for matches for `pattern` in `text` allowing up to `maxErrors` errors.\n *\n * Returns the start, and end positions and error counts for each lowest-cost\n * match. Only the "best" matches are returned.\n */\nfunction search(text, pattern, maxErrors) {\n    var matches = findMatchEnds(text, pattern, maxErrors);\n    return findMatchStarts(text, pattern, matches);\n}\nexports.Z = search;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFkaXVtLWpzLy4vbm9kZV9tb2R1bGVzL2FwcHJveC1zdHJpbmctbWF0Y2gvZGlzdC9pbmRleC5qcz83MjMwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QyxDQUFDLGNBQWMsQ0FBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsb0JBQW9CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFdBQVc7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsT0FBTztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixRQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBZSIsImZpbGUiOiI4OS5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBJbXBsZW1lbnRhdGlvbiBvZiBNeWVycycgb25saW5lIGFwcHJveGltYXRlIHN0cmluZyBtYXRjaGluZyBhbGdvcml0aG0gWzFdLFxuICogd2l0aCBhZGRpdGlvbmFsIG9wdGltaXphdGlvbnMgc3VnZ2VzdGVkIGJ5IFsyXS5cbiAqXG4gKiBUaGlzIGhhcyBPKChrL3cpICogbikgY29tcGxleGl0eSB3aGVyZSBgbmAgaXMgdGhlIGxlbmd0aCBvZiB0aGUgdGV4dCwgYGtgIGlzXG4gKiB0aGUgbWF4aW11bSBudW1iZXIgb2YgZXJyb3JzIGFsbG93ZWQgKGFsd2F5cyA8PSB0aGUgcGF0dGVybiBsZW5ndGgpIGFuZCBgd2BcbiAqIGlzIHRoZSB3b3JkIHNpemUuIEJlY2F1c2UgSlMgb25seSBzdXBwb3J0cyBiaXR3aXNlIG9wZXJhdGlvbnMgb24gMzIgYml0XG4gKiBpbnRlZ2VycywgYHdgIGlzIDMyLlxuICpcbiAqIEFzIGZhciBhcyBJIGFtIGF3YXJlLCB0aGVyZSBhcmVuJ3QgYW55IG9ubGluZSBhbGdvcml0aG1zIHdoaWNoIGFyZVxuICogc2lnbmlmaWNhbnRseSBiZXR0ZXIgZm9yIGEgd2lkZSByYW5nZSBvZiBpbnB1dCBwYXJhbWV0ZXJzLiBUaGUgcHJvYmxlbSBjYW4gYmVcbiAqIHNvbHZlZCBmYXN0ZXIgdXNpbmcgXCJmaWx0ZXIgdGhlbiB2ZXJpZnlcIiBhcHByb2FjaGVzIHdoaWNoIGZpcnN0IGZpbHRlciBvdXRcbiAqIHJlZ2lvbnMgb2YgdGhlIHRleHQgdGhhdCBjYW5ub3QgbWF0Y2ggdXNpbmcgYSBcImNoZWFwXCIgY2hlY2sgYW5kIHRoZW4gdmVyaWZ5XG4gKiB0aGUgcmVtYWluaW5nIHBvdGVudGlhbCBtYXRjaGVzLiBUaGUgdmVyaWZ5IHN0ZXAgcmVxdWlyZXMgYW4gYWxnb3JpdGhtIHN1Y2hcbiAqIGFzIHRoaXMgb25lIGhvd2V2ZXIuXG4gKlxuICogVGhlIGFsZ29yaXRobSdzIGFwcHJvYWNoIGlzIGVzc2VudGlhbGx5IHRvIG9wdGltaXplIHRoZSBjbGFzc2ljIGR5bmFtaWNcbiAqIHByb2dyYW1taW5nIHNvbHV0aW9uIHRvIHRoZSBwcm9ibGVtIGJ5IGNvbXB1dGluZyBjb2x1bW5zIG9mIHRoZSBtYXRyaXggaW5cbiAqIHdvcmQtc2l6ZWQgY2h1bmtzIChpZS4gZGVhbGluZyB3aXRoIDMyIGNoYXJzIG9mIHRoZSBwYXR0ZXJuIGF0IGEgdGltZSkgYW5kXG4gKiBhdm9pZGluZyBjYWxjdWxhdGluZyByZWdpb25zIG9mIHRoZSBtYXRyaXggd2hlcmUgdGhlIG1pbmltdW0gZXJyb3IgY291bnQgaXNcbiAqIGd1YXJhbnRlZWQgdG8gZXhjZWVkIHRoZSBpbnB1dCB0aHJlc2hvbGQuXG4gKlxuICogVGhlIHBhcGVyIGNvbnNpc3RzIG9mIHR3byBwYXJ0cywgdGhlIGZpcnN0IGRlc2NyaWJlcyB0aGUgY29yZSBhbGdvcml0aG0gZm9yXG4gKiBtYXRjaGluZyBwYXR0ZXJucyA8PSB0aGUgc2l6ZSBvZiBhIHdvcmQgKGltcGxlbWVudGVkIGJ5IGBhZHZhbmNlQmxvY2tgIGhlcmUpLlxuICogVGhlIHNlY29uZCB1c2VzIHRoZSBjb3JlIGFsZ29yaXRobSBhcyBwYXJ0IG9mIGEgbGFyZ2VyIGJsb2NrLWJhc2VkIGFsZ29yaXRobVxuICogdG8gaGFuZGxlIGxvbmdlciBwYXR0ZXJucy5cbiAqXG4gKiBbMV0gRy4gTXllcnMsIOKAnEEgRmFzdCBCaXQtVmVjdG9yIEFsZ29yaXRobSBmb3IgQXBwcm94aW1hdGUgU3RyaW5nIE1hdGNoaW5nXG4gKiBCYXNlZCBvbiBEeW5hbWljIFByb2dyYW1taW5nLOKAnSB2b2wuIDQ2LCBuby4gMywgcHAuIDM5NeKAkzQxNSwgMTk5OS5cbiAqXG4gKiBbMl0gxaBvxaFpxIcsIE0uICgyMDE0KS4gQW4gc2ltZCBkeW5hbWljIHByb2dyYW1taW5nIGMvYysrIGxpYnJhcnkgKERvY3RvcmFsXG4gKiBkaXNzZXJ0YXRpb24sIEZha3VsdGV0IEVsZWt0cm90ZWhuaWtlIGkgcmHEjXVuYXJzdHZhLCBTdmV1xI1pbGnFoXRlIHUgWmFncmVidSkuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmZ1bmN0aW9uIHJldmVyc2Uocykge1xuICAgIHJldHVybiBzXG4gICAgICAgIC5zcGxpdChcIlwiKVxuICAgICAgICAucmV2ZXJzZSgpXG4gICAgICAgIC5qb2luKFwiXCIpO1xufVxuLyoqXG4gKiBHaXZlbiB0aGUgZW5kcyBvZiBhcHByb3hpbWF0ZSBtYXRjaGVzIGZvciBgcGF0dGVybmAgaW4gYHRleHRgLCBmaW5kXG4gKiB0aGUgc3RhcnQgb2YgdGhlIG1hdGNoZXMuXG4gKlxuICogQHBhcmFtIGZpbmRFbmRGbiAtIEZ1bmN0aW9uIGZvciBmaW5kaW5nIHRoZSBlbmQgb2YgbWF0Y2hlcyBpblxuICogdGV4dC5cbiAqIEByZXR1cm4gTWF0Y2hlcyB3aXRoIHRoZSBgc3RhcnRgIHByb3BlcnR5IHNldC5cbiAqL1xuZnVuY3Rpb24gZmluZE1hdGNoU3RhcnRzKHRleHQsIHBhdHRlcm4sIG1hdGNoZXMpIHtcbiAgICB2YXIgcGF0UmV2ID0gcmV2ZXJzZShwYXR0ZXJuKTtcbiAgICByZXR1cm4gbWF0Y2hlcy5tYXAoZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgLy8gRmluZCBzdGFydCBvZiBlYWNoIG1hdGNoIGJ5IHJldmVyc2luZyB0aGUgcGF0dGVybiBhbmQgbWF0Y2hpbmcgc2VnbWVudFxuICAgICAgICAvLyBvZiB0ZXh0IGFuZCBzZWFyY2hpbmcgZm9yIGFuIGFwcHJveCBtYXRjaCB3aXRoIHRoZSBzYW1lIG51bWJlciBvZlxuICAgICAgICAvLyBlcnJvcnMuXG4gICAgICAgIHZhciBtaW5TdGFydCA9IE1hdGgubWF4KDAsIG0uZW5kIC0gcGF0dGVybi5sZW5ndGggLSBtLmVycm9ycyk7XG4gICAgICAgIHZhciB0ZXh0UmV2ID0gcmV2ZXJzZSh0ZXh0LnNsaWNlKG1pblN0YXJ0LCBtLmVuZCkpO1xuICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbXVsdGlwbGUgcG9zc2libGUgc3RhcnQgcG9pbnRzLCBjaG9vc2UgdGhlIG9uZSB0aGF0XG4gICAgICAgIC8vIG1heGltaXplcyB0aGUgbGVuZ3RoIG9mIHRoZSBtYXRjaC5cbiAgICAgICAgdmFyIHN0YXJ0ID0gZmluZE1hdGNoRW5kcyh0ZXh0UmV2LCBwYXRSZXYsIG0uZXJyb3JzKS5yZWR1Y2UoZnVuY3Rpb24gKG1pbiwgcm0pIHtcbiAgICAgICAgICAgIGlmIChtLmVuZCAtIHJtLmVuZCA8IG1pbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBtLmVuZCAtIHJtLmVuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtaW47XG4gICAgICAgIH0sIG0uZW5kKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgIGVuZDogbS5lbmQsXG4gICAgICAgICAgICBlcnJvcnM6IG0uZXJyb3JzXG4gICAgICAgIH07XG4gICAgfSk7XG59XG4vKipcbiAqIFJldHVybiAxIGlmIGEgbnVtYmVyIGlzIG5vbi16ZXJvIG9yIHplcm8gb3RoZXJ3aXNlLCB3aXRob3V0IHVzaW5nXG4gKiBjb25kaXRpb25hbCBvcGVyYXRvcnMuXG4gKlxuICogVGhpcyBzaG91bGQgZ2V0IGlubGluZWQgaW50byBgYWR2YW5jZUJsb2NrYCBiZWxvdyBieSB0aGUgSklULlxuICpcbiAqIEFkYXB0ZWQgZnJvbSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzkxMjIxOC80MzQyNDNcbiAqL1xuZnVuY3Rpb24gb25lSWZOb3RaZXJvKG4pIHtcbiAgICByZXR1cm4gKChuIHwgLW4pID4+IDMxKSAmIDE7XG59XG4vKipcbiAqIEJsb2NrIGNhbGN1bGF0aW9uIHN0ZXAgb2YgdGhlIGFsZ29yaXRobS5cbiAqXG4gKiBGcm9tIEZpZyA4LiBvbiBwLiA0MDggb2YgWzFdLCBhZGRpdGlvbmFsbHkgb3B0aW1pemVkIHRvIHJlcGxhY2UgY29uZGl0aW9uYWxcbiAqIGNoZWNrcyB3aXRoIGJpdHdpc2Ugb3BlcmF0aW9ucyBhcyBwZXIgU2VjdGlvbiA0LjIuMyBvZiBbMl0uXG4gKlxuICogQHBhcmFtIGN0eCAtIFRoZSBwYXR0ZXJuIGNvbnRleHQgb2JqZWN0XG4gKiBAcGFyYW0gcGVxIC0gVGhlIGBwZXFgIGFycmF5IGZvciB0aGUgY3VycmVudCBjaGFyYWN0ZXIgKGBjdHgucGVxLmdldChjaClgKVxuICogQHBhcmFtIGIgLSBUaGUgYmxvY2sgbGV2ZWxcbiAqIEBwYXJhbSBoSW4gLSBIb3Jpem9udGFsIGlucHV0IGRlbHRhIOKIiCB7MSwwLC0xfVxuICogQHJldHVybiBIb3Jpem9udGFsIG91dHB1dCBkZWx0YSDiiIggezEsMCwtMX1cbiAqL1xuZnVuY3Rpb24gYWR2YW5jZUJsb2NrKGN0eCwgcGVxLCBiLCBoSW4pIHtcbiAgICB2YXIgcFYgPSBjdHguUFtiXTtcbiAgICB2YXIgbVYgPSBjdHguTVtiXTtcbiAgICB2YXIgaEluSXNOZWdhdGl2ZSA9IGhJbiA+Pj4gMzE7IC8vIDEgaWYgaEluIDwgMCBvciAwIG90aGVyd2lzZS5cbiAgICB2YXIgZXEgPSBwZXFbYl0gfCBoSW5Jc05lZ2F0aXZlO1xuICAgIC8vIFN0ZXAgMTogQ29tcHV0ZSBob3Jpem9udGFsIGRlbHRhcy5cbiAgICB2YXIgeFYgPSBlcSB8IG1WO1xuICAgIHZhciB4SCA9ICgoKGVxICYgcFYpICsgcFYpIF4gcFYpIHwgZXE7XG4gICAgdmFyIHBIID0gbVYgfCB+KHhIIHwgcFYpO1xuICAgIHZhciBtSCA9IHBWICYgeEg7XG4gICAgLy8gU3RlcCAyOiBVcGRhdGUgc2NvcmUgKHZhbHVlIG9mIGxhc3Qgcm93IG9mIHRoaXMgYmxvY2spLlxuICAgIHZhciBoT3V0ID0gb25lSWZOb3RaZXJvKHBIICYgY3R4Lmxhc3RSb3dNYXNrW2JdKSAtXG4gICAgICAgIG9uZUlmTm90WmVybyhtSCAmIGN0eC5sYXN0Um93TWFza1tiXSk7XG4gICAgLy8gU3RlcCAzOiBVcGRhdGUgdmVydGljYWwgZGVsdGFzIGZvciB1c2Ugd2hlbiBwcm9jZXNzaW5nIG5leHQgY2hhci5cbiAgICBwSCA8PD0gMTtcbiAgICBtSCA8PD0gMTtcbiAgICBtSCB8PSBoSW5Jc05lZ2F0aXZlO1xuICAgIHBIIHw9IG9uZUlmTm90WmVybyhoSW4pIC0gaEluSXNOZWdhdGl2ZTsgLy8gc2V0IHBIWzBdIGlmIGhJbiA+IDBcbiAgICBwViA9IG1IIHwgfih4ViB8IHBIKTtcbiAgICBtViA9IHBIICYgeFY7XG4gICAgY3R4LlBbYl0gPSBwVjtcbiAgICBjdHguTVtiXSA9IG1WO1xuICAgIHJldHVybiBoT3V0O1xufVxuLyoqXG4gKiBGaW5kIHRoZSBlbmRzIGFuZCBlcnJvciBjb3VudHMgZm9yIG1hdGNoZXMgb2YgYHBhdHRlcm5gIGluIGB0ZXh0YC5cbiAqXG4gKiBPbmx5IHRoZSBtYXRjaGVzIHdpdGggdGhlIGxvd2VzdCBlcnJvciBjb3VudCBhcmUgcmVwb3J0ZWQuIE90aGVyIG1hdGNoZXNcbiAqIHdpdGggZXJyb3IgY291bnRzIDw9IG1heEVycm9ycyBhcmUgZGlzY2FyZGVkLlxuICpcbiAqIFRoaXMgaXMgdGhlIGJsb2NrLWJhc2VkIHNlYXJjaCBhbGdvcml0aG0gZnJvbSBGaWcuIDkgb24gcC40MTAgb2YgWzFdLlxuICovXG5mdW5jdGlvbiBmaW5kTWF0Y2hFbmRzKHRleHQsIHBhdHRlcm4sIG1heEVycm9ycykge1xuICAgIGlmIChwYXR0ZXJuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIC8vIENsYW1wIGVycm9yIGNvdW50IHNvIHdlIGNhbiByZWx5IG9uIHRoZSBgbWF4RXJyb3JzYCBhbmQgYHBhdHRlcm4ubGVuZ3RoYFxuICAgIC8vIHJvd3MgYmVpbmcgaW4gdGhlIHNhbWUgYmxvY2sgYmVsb3cuXG4gICAgbWF4RXJyb3JzID0gTWF0aC5taW4obWF4RXJyb3JzLCBwYXR0ZXJuLmxlbmd0aCk7XG4gICAgdmFyIG1hdGNoZXMgPSBbXTtcbiAgICAvLyBXb3JkIHNpemUuXG4gICAgdmFyIHcgPSAzMjtcbiAgICAvLyBJbmRleCBvZiBtYXhpbXVtIGJsb2NrIGxldmVsLlxuICAgIHZhciBiTWF4ID0gTWF0aC5jZWlsKHBhdHRlcm4ubGVuZ3RoIC8gdykgLSAxO1xuICAgIC8vIENvbnRleHQgdXNlZCBhY3Jvc3MgYmxvY2sgY2FsY3VsYXRpb25zLlxuICAgIHZhciBjdHggPSB7XG4gICAgICAgIFA6IG5ldyBVaW50MzJBcnJheShiTWF4ICsgMSksXG4gICAgICAgIE06IG5ldyBVaW50MzJBcnJheShiTWF4ICsgMSksXG4gICAgICAgIGxhc3RSb3dNYXNrOiBuZXcgVWludDMyQXJyYXkoYk1heCArIDEpXG4gICAgfTtcbiAgICBjdHgubGFzdFJvd01hc2suZmlsbCgxIDw8IDMxKTtcbiAgICBjdHgubGFzdFJvd01hc2tbYk1heF0gPSAxIDw8IChwYXR0ZXJuLmxlbmd0aCAtIDEpICUgdztcbiAgICAvLyBEdW1teSBcInBlcVwiIGFycmF5IGZvciBjaGFycyBpbiB0aGUgdGV4dCB3aGljaCBkbyBub3Qgb2NjdXIgaW4gdGhlIHBhdHRlcm4uXG4gICAgdmFyIGVtcHR5UGVxID0gbmV3IFVpbnQzMkFycmF5KGJNYXggKyAxKTtcbiAgICAvLyBNYXAgb2YgVVRGLTE2IGNoYXJhY3RlciBjb2RlIHRvIGJpdCB2ZWN0b3IgaW5kaWNhdGluZyBwb3NpdGlvbnMgaW4gdGhlXG4gICAgLy8gcGF0dGVybiB0aGF0IGVxdWFsIHRoYXQgY2hhcmFjdGVyLlxuICAgIHZhciBwZXEgPSBuZXcgTWFwKCk7XG4gICAgLy8gVmVyc2lvbiBvZiBgcGVxYCB0aGF0IG9ubHkgc3RvcmVzIG1hcHBpbmdzIGZvciBzbWFsbCBjaGFyYWN0ZXJzLiBUaGlzXG4gICAgLy8gYWxsb3dzIGZhc3RlciBsb29rdXBzIHdoZW4gaXRlcmF0aW5nIHRocm91Z2ggdGhlIHRleHQgYmVjYXVzZSBhIHNpbXBsZVxuICAgIC8vIGFycmF5IGxvb2t1cCBjYW4gYmUgZG9uZSBpbnN0ZWFkIG9mIGEgaGFzaCB0YWJsZSBsb29rdXAuXG4gICAgdmFyIGFzY2lpUGVxID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICAgICAgICBhc2NpaVBlcS5wdXNoKGVtcHR5UGVxKTtcbiAgICB9XG4gICAgLy8gQ2FsY3VsYXRlIGBjdHgucGVxYCAtIGEgbWFwIG9mIGNoYXJhY3RlciB2YWx1ZXMgdG8gYml0bWFza3MgaW5kaWNhdGluZ1xuICAgIC8vIHBvc2l0aW9ucyBvZiB0aGF0IGNoYXJhY3RlciB3aXRoaW4gdGhlIHBhdHRlcm4sIHdoZXJlIGVhY2ggYml0IHJlcHJlc2VudHNcbiAgICAvLyBhIHBvc2l0aW9uIGluIHRoZSBwYXR0ZXJuLlxuICAgIGZvciAodmFyIGMgPSAwOyBjIDwgcGF0dGVybi5sZW5ndGg7IGMgKz0gMSkge1xuICAgICAgICB2YXIgdmFsID0gcGF0dGVybi5jaGFyQ29kZUF0KGMpO1xuICAgICAgICBpZiAocGVxLmhhcyh2YWwpKSB7XG4gICAgICAgICAgICAvLyBEdXBsaWNhdGUgY2hhciBpbiBwYXR0ZXJuLlxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNoYXJQZXEgPSBuZXcgVWludDMyQXJyYXkoYk1heCArIDEpO1xuICAgICAgICBwZXEuc2V0KHZhbCwgY2hhclBlcSk7XG4gICAgICAgIGlmICh2YWwgPCBhc2NpaVBlcS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGFzY2lpUGVxW3ZhbF0gPSBjaGFyUGVxO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGIgPSAwOyBiIDw9IGJNYXg7IGIgKz0gMSkge1xuICAgICAgICAgICAgY2hhclBlcVtiXSA9IDA7XG4gICAgICAgICAgICAvLyBTZXQgYWxsIHRoZSBiaXRzIHdoZXJlIHRoZSBwYXR0ZXJuIG1hdGNoZXMgdGhlIGN1cnJlbnQgY2hhciAoY2gpLlxuICAgICAgICAgICAgLy8gRm9yIGluZGV4ZXMgYmV5b25kIHRoZSBlbmQgb2YgdGhlIHBhdHRlcm4sIGFsd2F5cyBzZXQgdGhlIGJpdCBhcyBpZiB0aGVcbiAgICAgICAgICAgIC8vIHBhdHRlcm4gY29udGFpbmVkIGEgd2lsZGNhcmQgY2hhciBpbiB0aGF0IHBvc2l0aW9uLlxuICAgICAgICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCB3OyByICs9IDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgaWR4ID0gYiAqIHcgKyByO1xuICAgICAgICAgICAgICAgIGlmIChpZHggPj0gcGF0dGVybi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IHBhdHRlcm4uY2hhckNvZGVBdChpZHgpID09PSB2YWw7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYXJQZXFbYl0gfD0gMSA8PCByO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBJbmRleCBvZiBsYXN0LWFjdGl2ZSBibG9jayBsZXZlbCBpbiB0aGUgY29sdW1uLlxuICAgIHZhciB5ID0gTWF0aC5tYXgoMCwgTWF0aC5jZWlsKG1heEVycm9ycyAvIHcpIC0gMSk7XG4gICAgLy8gSW5pdGlhbGl6ZSBtYXhpbXVtIGVycm9yIGNvdW50IGF0IGJvdHRvbSBvZiBlYWNoIGJsb2NrLlxuICAgIHZhciBzY29yZSA9IG5ldyBVaW50MzJBcnJheShiTWF4ICsgMSk7XG4gICAgZm9yICh2YXIgYiA9IDA7IGIgPD0geTsgYiArPSAxKSB7XG4gICAgICAgIHNjb3JlW2JdID0gKGIgKyAxKSAqIHc7XG4gICAgfVxuICAgIHNjb3JlW2JNYXhdID0gcGF0dGVybi5sZW5ndGg7XG4gICAgLy8gSW5pdGlhbGl6ZSB2ZXJ0aWNhbCBkZWx0YXMgZm9yIGVhY2ggYmxvY2suXG4gICAgZm9yICh2YXIgYiA9IDA7IGIgPD0geTsgYiArPSAxKSB7XG4gICAgICAgIGN0eC5QW2JdID0gfjA7XG4gICAgICAgIGN0eC5NW2JdID0gMDtcbiAgICB9XG4gICAgLy8gUHJvY2VzcyBlYWNoIGNoYXIgb2YgdGhlIHRleHQsIGNvbXB1dGluZyB0aGUgZXJyb3IgY291bnQgZm9yIGB3YCBjaGFycyBvZlxuICAgIC8vIHRoZSBwYXR0ZXJuIGF0IGEgdGltZS5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRleHQubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgLy8gTG9va3VwIHRoZSBiaXRtYXNrIHJlcHJlc2VudGluZyB0aGUgcG9zaXRpb25zIG9mIHRoZSBjdXJyZW50IGNoYXIgZnJvbVxuICAgICAgICAvLyB0aGUgdGV4dCB3aXRoaW4gdGhlIHBhdHRlcm4uXG4gICAgICAgIHZhciBjaGFyQ29kZSA9IHRleHQuY2hhckNvZGVBdChqKTtcbiAgICAgICAgdmFyIGNoYXJQZXEgPSB2b2lkIDA7XG4gICAgICAgIGlmIChjaGFyQ29kZSA8IGFzY2lpUGVxLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gRmFzdCBhcnJheSBsb29rdXAuXG4gICAgICAgICAgICBjaGFyUGVxID0gYXNjaWlQZXFbY2hhckNvZGVdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gU2xvd2VyIGhhc2ggdGFibGUgbG9va3VwLlxuICAgICAgICAgICAgY2hhclBlcSA9IHBlcS5nZXQoY2hhckNvZGUpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjaGFyUGVxID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgY2hhclBlcSA9IGVtcHR5UGVxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIENhbGN1bGF0ZSBlcnJvciBjb3VudCBmb3IgYmxvY2tzIHRoYXQgd2UgZGVmaW5pdGVseSBoYXZlIHRvIHByb2Nlc3MgZm9yXG4gICAgICAgIC8vIHRoaXMgY29sdW1uLlxuICAgICAgICB2YXIgY2FycnkgPSAwO1xuICAgICAgICBmb3IgKHZhciBiID0gMDsgYiA8PSB5OyBiICs9IDEpIHtcbiAgICAgICAgICAgIGNhcnJ5ID0gYWR2YW5jZUJsb2NrKGN0eCwgY2hhclBlcSwgYiwgY2FycnkpO1xuICAgICAgICAgICAgc2NvcmVbYl0gKz0gY2Fycnk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgaWYgd2UgYWxzbyBuZWVkIHRvIGNvbXB1dGUgYW4gYWRkaXRpb25hbCBibG9jaywgb3IgaWYgd2UgY2FuIHJlZHVjZVxuICAgICAgICAvLyB0aGUgbnVtYmVyIG9mIGJsb2NrcyBwcm9jZXNzZWQgZm9yIHRoZSBuZXh0IGNvbHVtbi5cbiAgICAgICAgaWYgKHNjb3JlW3ldIC0gY2FycnkgPD0gbWF4RXJyb3JzICYmXG4gICAgICAgICAgICB5IDwgYk1heCAmJlxuICAgICAgICAgICAgKGNoYXJQZXFbeSArIDFdICYgMSB8fCBjYXJyeSA8IDApKSB7XG4gICAgICAgICAgICAvLyBFcnJvciBjb3VudCBmb3IgYm90dG9tIGJsb2NrIGlzIHVuZGVyIHRocmVzaG9sZCwgaW5jcmVhc2UgdGhlIG51bWJlciBvZlxuICAgICAgICAgICAgLy8gYmxvY2tzIHByb2Nlc3NlZCBmb3IgdGhpcyBjb2x1bW4gJiBuZXh0IGJ5IDEuXG4gICAgICAgICAgICB5ICs9IDE7XG4gICAgICAgICAgICBjdHguUFt5XSA9IH4wO1xuICAgICAgICAgICAgY3R4Lk1beV0gPSAwO1xuICAgICAgICAgICAgdmFyIG1heEJsb2NrU2NvcmUgPSB5ID09PSBiTWF4ID8gcGF0dGVybi5sZW5ndGggJSB3IDogdztcbiAgICAgICAgICAgIHNjb3JlW3ldID1cbiAgICAgICAgICAgICAgICBzY29yZVt5IC0gMV0gK1xuICAgICAgICAgICAgICAgICAgICBtYXhCbG9ja1Njb3JlIC1cbiAgICAgICAgICAgICAgICAgICAgY2FycnkgK1xuICAgICAgICAgICAgICAgICAgICBhZHZhbmNlQmxvY2soY3R4LCBjaGFyUGVxLCB5LCBjYXJyeSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBFcnJvciBjb3VudCBmb3IgYm90dG9tIGJsb2NrIGV4Y2VlZHMgdGhyZXNob2xkLCByZWR1Y2UgdGhlIG51bWJlciBvZlxuICAgICAgICAgICAgLy8gYmxvY2tzIHByb2Nlc3NlZCBmb3IgdGhlIG5leHQgY29sdW1uLlxuICAgICAgICAgICAgd2hpbGUgKHkgPiAwICYmIHNjb3JlW3ldID49IG1heEVycm9ycyArIHcpIHtcbiAgICAgICAgICAgICAgICB5IC09IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgZXJyb3IgY291bnQgaXMgdW5kZXIgdGhyZXNob2xkLCByZXBvcnQgYSBtYXRjaC5cbiAgICAgICAgaWYgKHkgPT09IGJNYXggJiYgc2NvcmVbeV0gPD0gbWF4RXJyb3JzKSB7XG4gICAgICAgICAgICBpZiAoc2NvcmVbeV0gPCBtYXhFcnJvcnMpIHtcbiAgICAgICAgICAgICAgICAvLyBEaXNjYXJkIGFueSBlYXJsaWVyLCB3b3JzZSBtYXRjaGVzLlxuICAgICAgICAgICAgICAgIG1hdGNoZXMuc3BsaWNlKDAsIG1hdGNoZXMubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1hdGNoZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IC0xLFxuICAgICAgICAgICAgICAgIGVuZDogaiArIDEsXG4gICAgICAgICAgICAgICAgZXJyb3JzOiBzY29yZVt5XVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBCZWNhdXNlIGBzZWFyY2hgIG9ubHkgcmVwb3J0cyB0aGUgbWF0Y2hlcyB3aXRoIHRoZSBsb3dlc3QgZXJyb3IgY291bnQsXG4gICAgICAgICAgICAvLyB3ZSBjYW4gXCJyYXRjaGV0IGRvd25cIiB0aGUgbWF4IGVycm9yIHRocmVzaG9sZCB3aGVuZXZlciBhIG1hdGNoIGlzXG4gICAgICAgICAgICAvLyBlbmNvdW50ZXJlZCBhbmQgdGhlcmVieSBzYXZlIGEgc21hbGwgYW1vdW50IG9mIHdvcmsgZm9yIHRoZSByZW1haW5kZXJcbiAgICAgICAgICAgIC8vIG9mIHRoZSB0ZXh0LlxuICAgICAgICAgICAgbWF4RXJyb3JzID0gc2NvcmVbeV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1hdGNoZXM7XG59XG4vKipcbiAqIFNlYXJjaCBmb3IgbWF0Y2hlcyBmb3IgYHBhdHRlcm5gIGluIGB0ZXh0YCBhbGxvd2luZyB1cCB0byBgbWF4RXJyb3JzYCBlcnJvcnMuXG4gKlxuICogUmV0dXJucyB0aGUgc3RhcnQsIGFuZCBlbmQgcG9zaXRpb25zIGFuZCBlcnJvciBjb3VudHMgZm9yIGVhY2ggbG93ZXN0LWNvc3RcbiAqIG1hdGNoLiBPbmx5IHRoZSBcImJlc3RcIiBtYXRjaGVzIGFyZSByZXR1cm5lZC5cbiAqL1xuZnVuY3Rpb24gc2VhcmNoKHRleHQsIHBhdHRlcm4sIG1heEVycm9ycykge1xuICAgIHZhciBtYXRjaGVzID0gZmluZE1hdGNoRW5kcyh0ZXh0LCBwYXR0ZXJuLCBtYXhFcnJvcnMpO1xuICAgIHJldHVybiBmaW5kTWF0Y2hTdGFydHModGV4dCwgcGF0dGVybiwgbWF0Y2hlcyk7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBzZWFyY2g7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///89\n')},581:()=>{eval("//\n//  Copyright 2021 Readium Foundation. All rights reserved.\n//  Use of this source code is governed by the BSD-style license\n//  available in the top-level LICENSE file of the project.\n//\n\nwindow.addEventListener('DOMContentLoaded', function(event) {\n  // If we don't set the CSS cursor property to pointer, then the click events are not triggered pre-iOS 13.\n  document.body.style.cursor = 'pointer';\n\n  document.addEventListener('click', onClick, false);\n});\n\nfunction onClick(event) {\n\n  if (!window.getSelection().isCollapsed) {\n    // There's an on-going selection, the tap will dismiss it so we don't forward it.\n    return;\n  }\n\n  // Send the tap data over the JS bridge even if it's been handled\n  // within the webview, so that it can be preserved and used\n  // by the WKNavigationDelegate if needed.\n  webkit.messageHandlers.tap.postMessage({\n    \"defaultPrevented\": event.defaultPrevented,\n    \"screenX\": event.screenX,\n    \"screenY\": event.screenY,\n    \"clientX\": event.clientX,\n    \"clientY\": event.clientY,\n    \"targetElement\": event.target.outerHTML,\n    \"interactiveElement\": nearestInteractiveElement(event.target),\n  });\n\n  // We don't want to disable the default WebView behavior as it breaks some features without bringing any value.\n//    event.stopPropagation();\n//    event.preventDefault();\n}\n\n// See. https://github.com/JayPanoz/architecture/tree/touch-handling/misc/touch-handling\nfunction nearestInteractiveElement(element) {\n  var interactiveTags = [\n    'a',\n    'audio',\n    'button',\n    'canvas',\n    'details',\n    'input',\n    'label',\n    'option',\n    'select',\n    'submit',\n    'textarea',\n    'video',\n  ]\n  if (interactiveTags.indexOf(element.nodeName.toLowerCase()) !== -1) {\n    return element.outerHTML;\n  }\n\n  // Checks whether the element is editable by the user.\n  if (element.hasAttribute('contenteditable') && element.getAttribute('contenteditable').toLowerCase() != 'false') {\n    return element.outerHTML;\n  }\n\n  // Checks parents recursively because the touch might be for example on an <em> inside a <a>.\n  if (element.parentElement) {\n    return nearestInteractiveElement(element.parentElement);\n  }\n\n  return null;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFkaXVtLWpzLy4vc3JjL2dlc3R1cmVzLmpzPzE0YzIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJmaWxlIjoiNTgxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy9cbi8vICBDb3B5cmlnaHQgMjAyMSBSZWFkaXVtIEZvdW5kYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgdGhlIEJTRC1zdHlsZSBsaWNlbnNlXG4vLyAgYXZhaWxhYmxlIGluIHRoZSB0b3AtbGV2ZWwgTElDRU5TRSBmaWxlIG9mIHRoZSBwcm9qZWN0LlxuLy9cblxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBmdW5jdGlvbihldmVudCkge1xuICAvLyBJZiB3ZSBkb24ndCBzZXQgdGhlIENTUyBjdXJzb3IgcHJvcGVydHkgdG8gcG9pbnRlciwgdGhlbiB0aGUgY2xpY2sgZXZlbnRzIGFyZSBub3QgdHJpZ2dlcmVkIHByZS1pT1MgMTMuXG4gIGRvY3VtZW50LmJvZHkuc3R5bGUuY3Vyc29yID0gJ3BvaW50ZXInO1xuXG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgb25DbGljaywgZmFsc2UpO1xufSk7XG5cbmZ1bmN0aW9uIG9uQ2xpY2soZXZlbnQpIHtcblxuICBpZiAoIXdpbmRvdy5nZXRTZWxlY3Rpb24oKS5pc0NvbGxhcHNlZCkge1xuICAgIC8vIFRoZXJlJ3MgYW4gb24tZ29pbmcgc2VsZWN0aW9uLCB0aGUgdGFwIHdpbGwgZGlzbWlzcyBpdCBzbyB3ZSBkb24ndCBmb3J3YXJkIGl0LlxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFNlbmQgdGhlIHRhcCBkYXRhIG92ZXIgdGhlIEpTIGJyaWRnZSBldmVuIGlmIGl0J3MgYmVlbiBoYW5kbGVkXG4gIC8vIHdpdGhpbiB0aGUgd2Vidmlldywgc28gdGhhdCBpdCBjYW4gYmUgcHJlc2VydmVkIGFuZCB1c2VkXG4gIC8vIGJ5IHRoZSBXS05hdmlnYXRpb25EZWxlZ2F0ZSBpZiBuZWVkZWQuXG4gIHdlYmtpdC5tZXNzYWdlSGFuZGxlcnMudGFwLnBvc3RNZXNzYWdlKHtcbiAgICBcImRlZmF1bHRQcmV2ZW50ZWRcIjogZXZlbnQuZGVmYXVsdFByZXZlbnRlZCxcbiAgICBcInNjcmVlblhcIjogZXZlbnQuc2NyZWVuWCxcbiAgICBcInNjcmVlbllcIjogZXZlbnQuc2NyZWVuWSxcbiAgICBcImNsaWVudFhcIjogZXZlbnQuY2xpZW50WCxcbiAgICBcImNsaWVudFlcIjogZXZlbnQuY2xpZW50WSxcbiAgICBcInRhcmdldEVsZW1lbnRcIjogZXZlbnQudGFyZ2V0Lm91dGVySFRNTCxcbiAgICBcImludGVyYWN0aXZlRWxlbWVudFwiOiBuZWFyZXN0SW50ZXJhY3RpdmVFbGVtZW50KGV2ZW50LnRhcmdldCksXG4gIH0pO1xuXG4gIC8vIFdlIGRvbid0IHdhbnQgdG8gZGlzYWJsZSB0aGUgZGVmYXVsdCBXZWJWaWV3IGJlaGF2aW9yIGFzIGl0IGJyZWFrcyBzb21lIGZlYXR1cmVzIHdpdGhvdXQgYnJpbmdpbmcgYW55IHZhbHVlLlxuLy8gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4vLyAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xufVxuXG4vLyBTZWUuIGh0dHBzOi8vZ2l0aHViLmNvbS9KYXlQYW5vei9hcmNoaXRlY3R1cmUvdHJlZS90b3VjaC1oYW5kbGluZy9taXNjL3RvdWNoLWhhbmRsaW5nXG5mdW5jdGlvbiBuZWFyZXN0SW50ZXJhY3RpdmVFbGVtZW50KGVsZW1lbnQpIHtcbiAgdmFyIGludGVyYWN0aXZlVGFncyA9IFtcbiAgICAnYScsXG4gICAgJ2F1ZGlvJyxcbiAgICAnYnV0dG9uJyxcbiAgICAnY2FudmFzJyxcbiAgICAnZGV0YWlscycsXG4gICAgJ2lucHV0JyxcbiAgICAnbGFiZWwnLFxuICAgICdvcHRpb24nLFxuICAgICdzZWxlY3QnLFxuICAgICdzdWJtaXQnLFxuICAgICd0ZXh0YXJlYScsXG4gICAgJ3ZpZGVvJyxcbiAgXVxuICBpZiAoaW50ZXJhY3RpdmVUYWdzLmluZGV4T2YoZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKSAhPT0gLTEpIHtcbiAgICByZXR1cm4gZWxlbWVudC5vdXRlckhUTUw7XG4gIH1cblxuICAvLyBDaGVja3Mgd2hldGhlciB0aGUgZWxlbWVudCBpcyBlZGl0YWJsZSBieSB0aGUgdXNlci5cbiAgaWYgKGVsZW1lbnQuaGFzQXR0cmlidXRlKCdjb250ZW50ZWRpdGFibGUnKSAmJiBlbGVtZW50LmdldEF0dHJpYnV0ZSgnY29udGVudGVkaXRhYmxlJykudG9Mb3dlckNhc2UoKSAhPSAnZmFsc2UnKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQub3V0ZXJIVE1MO1xuICB9XG5cbiAgLy8gQ2hlY2tzIHBhcmVudHMgcmVjdXJzaXZlbHkgYmVjYXVzZSB0aGUgdG91Y2ggbWlnaHQgYmUgZm9yIGV4YW1wbGUgb24gYW4gPGVtPiBpbnNpZGUgYSA8YT4uXG4gIGlmIChlbGVtZW50LnBhcmVudEVsZW1lbnQpIHtcbiAgICByZXR1cm4gbmVhcmVzdEludGVyYWN0aXZlRWxlbWVudChlbGVtZW50LnBhcmVudEVsZW1lbnQpO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///581\n")},332:(__unused_webpack_module,__unused_webpack___webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXTERNAL MODULE: ./src/gestures.js\nvar gestures = __webpack_require__(581);\n// EXTERNAL MODULE: ./node_modules/approx-string-match/dist/index.js\nvar dist = __webpack_require__(89);\n;// CONCATENATED MODULE: ./src/vendor/hypothesis/anchoring/match-quote.js\n\n\n/**\n * @typedef {import(\'approx-string-match\').Match} StringMatch\n */\n\n/**\n * @typedef Match\n * @prop {number} start - Start offset of match in text\n * @prop {number} end - End offset of match in text\n * @prop {number} score -\n *   Score for the match between 0 and 1.0, where 1.0 indicates a perfect match\n *   for the quote and context.\n */\n\n/**\n * Find the best approximate matches for `str` in `text` allowing up to `maxErrors` errors.\n *\n * @param {string} text\n * @param {string} str\n * @param {number} maxErrors\n * @return {StringMatch[]}\n */\nfunction search(text, str, maxErrors) {\n  // Do a fast search for exact matches. The `approx-string-match` library\n  // doesn\'t currently incorporate this optimization itself.\n  let matchPos = 0;\n  let exactMatches = [];\n  while (matchPos !== -1) {\n    matchPos = text.indexOf(str, matchPos);\n    if (matchPos !== -1) {\n      exactMatches.push({\n        start: matchPos,\n        end: matchPos + str.length,\n        errors: 0,\n      });\n      matchPos += 1;\n    }\n  }\n  if (exactMatches.length > 0) {\n    return exactMatches;\n  }\n\n  // If there are no exact matches, do a more expensive search for matches\n  // with errors.\n  return (0,dist/* default */.Z)(text, str, maxErrors);\n}\n\n/**\n * Compute a score between 0 and 1.0 for the similarity between `text` and `str`.\n *\n * @param {string} text\n * @param {string} str\n */\nfunction textMatchScore(text, str) {\n  /* istanbul ignore next - `scoreMatch` will never pass an empty string */\n  if (str.length === 0 || text.length === 0) {\n    return 0.0;\n  }\n  const matches = search(text, str, str.length);\n\n  // prettier-ignore\n  return 1 - (matches[0].errors / str.length);\n}\n\n/**\n * Find the best approximate match for `quote` in `text`.\n *\n * Returns `null` if no match exceeding the minimum quality threshold was found.\n *\n * @param {string} text - Document text to search\n * @param {string} quote - String to find within `text`\n * @param {Object} context -\n *   Context in which the quote originally appeared. This is used to choose the\n *   best match.\n *   @param {string} [context.prefix] - Expected text before the quote\n *   @param {string} [context.suffix] - Expected text after the quote\n *   @param {number} [context.hint] - Expected offset of match within text\n * @return {Match|null}\n */\nfunction matchQuote(text, quote, context = {}) {\n  if (quote.length === 0) {\n    return null;\n  }\n\n  // Choose the maximum number of errors to allow for the initial search.\n  // This choice involves a tradeoff between:\n  //\n  //  - Recall (proportion of "good" matches found)\n  //  - Precision (proportion of matches found which are "good")\n  //  - Cost of the initial search and of processing the candidate matches [1]\n  //\n  // [1] Specifically, the expected-time complexity of the initial search is\n  //     `O((maxErrors / 32) * text.length)`. See `approx-string-match` docs.\n  const maxErrors = Math.min(256, quote.length / 2);\n\n  // Find closest matches for `quote` in `text` based on edit distance.\n  const matches = search(text, quote, maxErrors);\n\n  if (matches.length === 0) {\n    return null;\n  }\n\n  /**\n   * Compute a score between 0 and 1.0 for a match candidate.\n   *\n   * @param {StringMatch} match\n   */\n  const scoreMatch = match => {\n    const quoteWeight = 50; // Similarity of matched text to quote.\n    const prefixWeight = 20; // Similarity of text before matched text to `context.prefix`.\n    const suffixWeight = 20; // Similarity of text after matched text to `context.suffix`.\n    const posWeight = 2; // Proximity to expected location. Used as a tie-breaker.\n\n    const quoteScore = 1 - match.errors / quote.length;\n\n    const prefixScore = context.prefix\n      ? textMatchScore(\n          text.slice(Math.max(0, match.start - context.prefix.length), match.start),\n          context.prefix\n        )\n      : 1.0;\n    const suffixScore = context.suffix\n      ? textMatchScore(\n          text.slice(match.end, match.end + context.suffix.length),\n          context.suffix\n        )\n      : 1.0;\n\n    let posScore = 1.0;\n    if (typeof context.hint === \'number\') {\n      const offset = Math.abs(match.start - context.hint);\n      posScore = 1.0 - offset / text.length;\n    }\n\n    const rawScore =\n      quoteWeight * quoteScore +\n      prefixWeight * prefixScore +\n      suffixWeight * suffixScore +\n      posWeight * posScore;\n    const maxScore = quoteWeight + prefixWeight + suffixWeight + posWeight;\n    const normalizedScore = rawScore / maxScore;\n\n    return normalizedScore;\n  };\n\n  // Rank matches based on similarity of actual and expected surrounding text\n  // and actual/expected offset in the document text.\n  const scoredMatches = matches.map(m => ({\n    start: m.start,\n    end: m.end,\n    score: scoreMatch(m),\n  }));\n\n  // Choose match with highest score.\n  scoredMatches.sort((a, b) => b.score - a.score);\n  return scoredMatches[0];\n}\n\n;// CONCATENATED MODULE: ./src/vendor/hypothesis/anchoring/text-range.js\n/**\n * Return the combined length of text nodes contained in `node`.\n *\n * @param {Node} node\n */\nfunction nodeTextLength(node) {\n  switch (node.nodeType) {\n    case Node.ELEMENT_NODE:\n    case Node.TEXT_NODE:\n      // nb. `textContent` excludes text in comments and processing instructions\n      // when called on a parent element, so we don\'t need to subtract that here.\n\n      return /** @type {string} */ (node.textContent).length;\n    default:\n      return 0;\n  }\n}\n\n/**\n * Return the total length of the text of all previous siblings of `node`.\n *\n * @param {Node} node\n */\nfunction previousSiblingsTextLength(node) {\n  let sibling = node.previousSibling;\n  let length = 0;\n  while (sibling) {\n    length += nodeTextLength(sibling);\n    sibling = sibling.previousSibling;\n  }\n  return length;\n}\n\n/**\n * Resolve one or more character offsets within an element to (text node, position)\n * pairs.\n *\n * @param {Element} element\n * @param {number[]} offsets - Offsets, which must be sorted in ascending order\n * @return {{ node: Text, offset: number }[]}\n */\nfunction resolveOffsets(element, ...offsets) {\n  let nextOffset = offsets.shift();\n  const nodeIter = /** @type {Document} */ (\n    element.ownerDocument\n  ).createNodeIterator(element, NodeFilter.SHOW_TEXT);\n  const results = [];\n\n  let currentNode = nodeIter.nextNode();\n  let textNode;\n  let length = 0;\n\n  // Find the text node containing the `nextOffset`th character from the start\n  // of `element`.\n  while (nextOffset !== undefined && currentNode) {\n    textNode = /** @type {Text} */ (currentNode);\n    if (length + textNode.data.length > nextOffset) {\n      results.push({ node: textNode, offset: nextOffset - length });\n      nextOffset = offsets.shift();\n    } else {\n      currentNode = nodeIter.nextNode();\n      length += textNode.data.length;\n    }\n  }\n\n  // Boundary case.\n  while (nextOffset !== undefined && textNode && length === nextOffset) {\n    results.push({ node: textNode, offset: textNode.data.length });\n    nextOffset = offsets.shift();\n  }\n\n  if (nextOffset !== undefined) {\n    throw new RangeError(\'Offset exceeds text length\');\n  }\n\n  return results;\n}\n\nlet RESOLVE_FORWARDS = 1;\nlet RESOLVE_BACKWARDS = 2;\n\n/**\n * Represents an offset within the text content of an element.\n *\n * This position can be resolved to a specific descendant node in the current\n * DOM subtree of the element using the `resolve` method.\n */\nclass text_range_TextPosition {\n  /**\n   * Construct a `TextPosition` that refers to the text position `offset` within\n   * the text content of `element`.\n   *\n   * @param {Element} element\n   * @param {number} offset\n   */\n  constructor(element, offset) {\n    if (offset < 0) {\n      throw new Error(\'Offset is invalid\');\n    }\n\n    /** Element that `offset` is relative to. */\n    this.element = element;\n\n    /** Character offset from the start of the element\'s `textContent`. */\n    this.offset = offset;\n  }\n\n  /**\n   * Return a copy of this position with offset relative to a given ancestor\n   * element.\n   *\n   * @param {Element} parent - Ancestor of `this.element`\n   * @return {TextPosition}\n   */\n  relativeTo(parent) {\n    if (!parent.contains(this.element)) {\n      throw new Error(\'Parent is not an ancestor of current element\');\n    }\n\n    let el = this.element;\n    let offset = this.offset;\n    while (el !== parent) {\n      offset += previousSiblingsTextLength(el);\n      el = /** @type {Element} */ (el.parentElement);\n    }\n\n    return new text_range_TextPosition(el, offset);\n  }\n\n  /**\n   * Resolve the position to a specific text node and offset within that node.\n   *\n   * Throws if `this.offset` exceeds the length of the element\'s text. In the\n   * case where the element has no text and `this.offset` is 0, the `direction`\n   * option determines what happens.\n   *\n   * Offsets at the boundary between two nodes are resolved to the start of the\n   * node that begins at the boundary.\n   *\n   * @param {Object} [options]\n   *   @param {RESOLVE_FORWARDS|RESOLVE_BACKWARDS} [options.direction] -\n   *     Specifies in which direction to search for the nearest text node if\n   *     `this.offset` is `0` and `this.element` has no text. If not specified\n   *     an error is thrown.\n   * @return {{ node: Text, offset: number }}\n   * @throws {RangeError}\n   */\n  resolve(options = {}) {\n    try {\n      return resolveOffsets(this.element, this.offset)[0];\n    } catch (err) {\n      if (this.offset === 0 && options.direction !== undefined) {\n        const tw = document.createTreeWalker(\n          this.element.getRootNode(),\n          NodeFilter.SHOW_TEXT\n        );\n        tw.currentNode = this.element;\n        const forwards = options.direction === RESOLVE_FORWARDS;\n        const text = /** @type {Text|null} */ (\n          forwards ? tw.nextNode() : tw.previousNode()\n        );\n        if (!text) {\n          throw err;\n        }\n        return { node: text, offset: forwards ? 0 : text.data.length };\n      } else {\n        throw err;\n      }\n    }\n  }\n\n  /**\n   * Construct a `TextPosition` that refers to the `offset`th character within\n   * `node`.\n   *\n   * @param {Node} node\n   * @param {number} offset\n   * @return {TextPosition}\n   */\n  static fromCharOffset(node, offset) {\n    switch (node.nodeType) {\n      case Node.TEXT_NODE:\n        return text_range_TextPosition.fromPoint(node, offset);\n      case Node.ELEMENT_NODE:\n        return new text_range_TextPosition(/** @type {Element} */ (node), offset);\n      default:\n        throw new Error(\'Node is not an element or text node\');\n    }\n  }\n\n  /**\n   * Construct a `TextPosition` representing the range start or end point (node, offset).\n   *\n   * @param {Node} node - Text or Element node\n   * @param {number} offset - Offset within the node.\n   * @return {TextPosition}\n   */\n  static fromPoint(node, offset) {\n    switch (node.nodeType) {\n      case Node.TEXT_NODE: {\n        if (offset < 0 || offset > /** @type {Text} */ (node).data.length) {\n          throw new Error(\'Text node offset is out of range\');\n        }\n\n        if (!node.parentElement) {\n          throw new Error(\'Text node has no parent\');\n        }\n\n        // Get the offset from the start of the parent element.\n        const textOffset = previousSiblingsTextLength(node) + offset;\n\n        return new text_range_TextPosition(node.parentElement, textOffset);\n      }\n      case Node.ELEMENT_NODE: {\n        if (offset < 0 || offset > node.childNodes.length) {\n          throw new Error(\'Child node offset is out of range\');\n        }\n\n        // Get the text length before the `offset`th child of element.\n        let textOffset = 0;\n        for (let i = 0; i < offset; i++) {\n          textOffset += nodeTextLength(node.childNodes[i]);\n        }\n\n        return new text_range_TextPosition(/** @type {Element} */ (node), textOffset);\n      }\n      default:\n        throw new Error(\'Point is not in an element or text node\');\n    }\n  }\n}\n\n/**\n * Represents a region of a document as a (start, end) pair of `TextPosition` points.\n *\n * Representing a range in this way allows for changes in the DOM content of the\n * range which don\'t affect its text content, without affecting the text content\n * of the range itself.\n */\nclass text_range_TextRange {\n  /**\n   * Construct an immutable `TextRange` from a `start` and `end` point.\n   *\n   * @param {TextPosition} start\n   * @param {TextPosition} end\n   */\n  constructor(start, end) {\n    this.start = start;\n    this.end = end;\n  }\n\n  /**\n   * Return a copy of this range with start and end positions relative to a\n   * given ancestor. See `TextPosition.relativeTo`.\n   *\n   * @param {Element} element\n   */\n  relativeTo(element) {\n    return new text_range_TextRange(\n      this.start.relativeTo(element),\n      this.end.relativeTo(element)\n    );\n  }\n\n  /**\n   * Resolve the `TextRange` to a DOM range.\n   *\n   * The resulting DOM Range will always start and end in a `Text` node.\n   * Hence `TextRange.fromRange(range).toRange()` can be used to "shrink" a\n   * range to the text it contains.\n   *\n   * May throw if the `start` or `end` positions cannot be resolved to a range.\n   *\n   * @return {Range}\n   */\n  toRange() {\n    let start;\n    let end;\n\n    if (\n      this.start.element === this.end.element &&\n      this.start.offset <= this.end.offset\n    ) {\n      // Fast path for start and end points in same element.\n      [start, end] = resolveOffsets(\n        this.start.element,\n        this.start.offset,\n        this.end.offset\n      );\n    } else {\n      start = this.start.resolve({ direction: RESOLVE_FORWARDS });\n      end = this.end.resolve({ direction: RESOLVE_BACKWARDS });\n    }\n\n    const range = new Range();\n    range.setStart(start.node, start.offset);\n    range.setEnd(end.node, end.offset);\n    return range;\n  }\n\n  /**\n   * Convert an existing DOM `Range` to a `TextRange`\n   *\n   * @param {Range} range\n   * @return {TextRange}\n   */\n  static fromRange(range) {\n    const start = text_range_TextPosition.fromPoint(\n      range.startContainer,\n      range.startOffset\n    );\n    const end = text_range_TextPosition.fromPoint(range.endContainer, range.endOffset);\n    return new text_range_TextRange(start, end);\n  }\n\n  /**\n   * Return a `TextRange` from the `start`th to `end`th characters in `root`.\n   *\n   * @param {Element} root\n   * @param {number} start\n   * @param {number} end\n   */\n  static fromOffsets(root, start, end) {\n    return new text_range_TextRange(\n      new text_range_TextPosition(root, start),\n      new text_range_TextPosition(root, end)\n    );\n  }\n}\n\n;// CONCATENATED MODULE: ./src/vendor/hypothesis/anchoring/types.js\n/**\n * This module exports a set of classes for converting between DOM `Range`\n * objects and different types of selectors. It is mostly a thin wrapper around a\n * set of anchoring libraries. It serves two main purposes:\n *\n *  1. Providing a consistent interface across different types of anchors.\n *  2. Insulating the rest of the code from API changes in the underlying anchoring\n *     libraries.\n */\n\n\n\n\n\n/**\n * @typedef {import(\'../../types/api\').RangeSelector} RangeSelector\n * @typedef {import(\'../../types/api\').TextPositionSelector} TextPositionSelector\n * @typedef {import(\'../../types/api\').TextQuoteSelector} TextQuoteSelector\n */\n\n/**\n * Converts between `RangeSelector` selectors and `Range` objects.\n */\nclass RangeAnchor {\n  /**\n   * @param {Node} root - A root element from which to anchor.\n   * @param {Range} range -  A range describing the anchor.\n   */\n  constructor(root, range) {\n    this.root = root;\n    this.range = range;\n  }\n\n  /**\n   * @param {Node} root -  A root element from which to anchor.\n   * @param {Range} range -  A range describing the anchor.\n   */\n  static fromRange(root, range) {\n    return new RangeAnchor(root, range);\n  }\n\n  /**\n   * Create an anchor from a serialized `RangeSelector` selector.\n   *\n   * @param {Element} root -  A root element from which to anchor.\n   * @param {RangeSelector} selector\n   */\n  static fromSelector(root, selector) {\n    const startContainer = nodeFromXPath(selector.startContainer, root);\n    if (!startContainer) {\n      throw new Error(\'Failed to resolve startContainer XPath\');\n    }\n\n    const endContainer = nodeFromXPath(selector.endContainer, root);\n    if (!endContainer) {\n      throw new Error(\'Failed to resolve endContainer XPath\');\n    }\n\n    const startPos = TextPosition.fromCharOffset(\n      startContainer,\n      selector.startOffset\n    );\n    const endPos = TextPosition.fromCharOffset(\n      endContainer,\n      selector.endOffset\n    );\n\n    const range = new TextRange(startPos, endPos).toRange();\n    return new RangeAnchor(root, range);\n  }\n\n  toRange() {\n    return this.range;\n  }\n\n  /**\n   * @return {RangeSelector}\n   */\n  toSelector() {\n    // "Shrink" the range so that it tightly wraps its text. This ensures more\n    // predictable output for a given text selection.\n    const normalizedRange = TextRange.fromRange(this.range).toRange();\n\n    const textRange = TextRange.fromRange(normalizedRange);\n    const startContainer = xpathFromNode(textRange.start.element, this.root);\n    const endContainer = xpathFromNode(textRange.end.element, this.root);\n\n    return {\n      type: \'RangeSelector\',\n      startContainer,\n      startOffset: textRange.start.offset,\n      endContainer,\n      endOffset: textRange.end.offset,\n    };\n  }\n}\n\n/**\n * Converts between `TextPositionSelector` selectors and `Range` objects.\n */\nclass TextPositionAnchor {\n  /**\n   * @param {Element} root\n   * @param {number} start\n   * @param {number} end\n   */\n  constructor(root, start, end) {\n    this.root = root;\n    this.start = start;\n    this.end = end;\n  }\n\n  /**\n   * @param {Element} root\n   * @param {Range} range\n   */\n  static fromRange(root, range) {\n    const textRange = text_range_TextRange.fromRange(range).relativeTo(root);\n    return new TextPositionAnchor(\n      root,\n      textRange.start.offset,\n      textRange.end.offset\n    );\n  }\n  /**\n   * @param {Element} root\n   * @param {TextPositionSelector} selector\n   */\n  static fromSelector(root, selector) {\n    return new TextPositionAnchor(root, selector.start, selector.end);\n  }\n\n  /**\n   * @return {TextPositionSelector}\n   */\n  toSelector() {\n    return {\n      type: \'TextPositionSelector\',\n      start: this.start,\n      end: this.end,\n    };\n  }\n\n  toRange() {\n    return text_range_TextRange.fromOffsets(this.root, this.start, this.end).toRange();\n  }\n}\n\n/**\n * @typedef QuoteMatchOptions\n * @prop {number} [hint] - Expected position of match in text. See `matchQuote`.\n */\n\n/**\n * Converts between `TextQuoteSelector` selectors and `Range` objects.\n */\nclass TextQuoteAnchor {\n  /**\n   * @param {Element} root - A root element from which to anchor.\n   * @param {string} exact\n   * @param {Object} context\n   *   @param {string} [context.prefix]\n   *   @param {string} [context.suffix]\n   */\n  constructor(root, exact, context = {}) {\n    this.root = root;\n    this.exact = exact;\n    this.context = context;\n  }\n\n  /**\n   * Create a `TextQuoteAnchor` from a range.\n   *\n   * Will throw if `range` does not contain any text nodes.\n   *\n   * @param {Element} root\n   * @param {Range} range\n   */\n  static fromRange(root, range) {\n    const text = /** @type {string} */ (root.textContent);\n    const textRange = text_range_TextRange.fromRange(range).relativeTo(root);\n\n    const start = textRange.start.offset;\n    const end = textRange.end.offset;\n\n    // Number of characters around the quote to capture as context. We currently\n    // always use a fixed amount, but it would be better if this code was aware\n    // of logical boundaries in the document (paragraph, article etc.) to avoid\n    // capturing text unrelated to the quote.\n    //\n    // In regular prose the ideal content would often be the surrounding sentence.\n    // This is a natural unit of meaning which enables displaying quotes in\n    // context even when the document is not available. We could use `Intl.Segmenter`\n    // for this when available.\n    const contextLen = 32;\n\n    return new TextQuoteAnchor(root, text.slice(start, end), {\n      prefix: text.slice(Math.max(0, start - contextLen), start),\n      suffix: text.slice(end, Math.min(text.length, end + contextLen)),\n    });\n  }\n\n  /**\n   * @param {Element} root\n   * @param {TextQuoteSelector} selector\n   */\n  static fromSelector(root, selector) {\n    const { prefix, suffix } = selector;\n    return new TextQuoteAnchor(root, selector.exact, { prefix, suffix });\n  }\n\n  /**\n   * @return {TextQuoteSelector}\n   */\n  toSelector() {\n    return {\n      type: \'TextQuoteSelector\',\n      exact: this.exact,\n      prefix: this.context.prefix,\n      suffix: this.context.suffix,\n    };\n  }\n\n  /**\n   * @param {QuoteMatchOptions} [options]\n   */\n  toRange(options = {}) {\n    return this.toPositionAnchor(options).toRange();\n  }\n\n  /**\n   * @param {QuoteMatchOptions} [options]\n   */\n  toPositionAnchor(options = {}) {\n    const text = /** @type {string} */ (this.root.textContent);\n    const match = matchQuote(text, this.exact, {\n      ...this.context,\n      hint: options.hint,\n    });\n    if (!match) {\n      throw new Error(\'Quote not found\');\n    }\n    return new TextPositionAnchor(this.root, match.start, match.end);\n  }\n}\n\n;// CONCATENATED MODULE: ./src/utils.js\n//\n//  Copyright 2021 Readium Foundation. All rights reserved.\n//  Use of this source code is governed by the BSD-style license\n//  available in the top-level LICENSE file of the project.\n//\n\n// Catch JS errors to log them in the app.\n\n\n\nwindow.addEventListener("error", function(event) {\n    webkit.messageHandlers.logError.postMessage({\n        "message": event.message,\n        "filename": event.filename,\n        "line": event.lineno\n    });\n}, false);\n\n// Notify native code that the page has loaded.\nwindow.addEventListener("load", function(){ // on page load\n    window.addEventListener("orientationchange", function() {\n        orientationChanged();\n        snapCurrentPosition();\n    });\n    orientationChanged();\n}, false);\n\nvar last_known_scrollX_position = 0;\nvar last_known_scrollY_position = 0;\nvar ticking = false;\nvar maxScreenX = 0;\n\n// Position in range [0 - 1].\nfunction update(position) {\n    var positionString = position.toString()\n    webkit.messageHandlers.progressionChanged.postMessage(positionString);\n}\n\nwindow.addEventListener(\'scroll\', function(e) {\n    last_known_scrollY_position = window.scrollY / document.scrollingElement.scrollHeight;\n    // Using Math.abs because for RTL books, the value will be negative.\n    last_known_scrollX_position = Math.abs(window.scrollX / document.scrollingElement.scrollWidth);\n\n    // Window is hidden\n    if (document.scrollingElement.scrollWidth === 0 || document.scrollingElement.scrollHeight === 0) {\n        return;\n    }\n\n    if (!ticking) {\n        window.requestAnimationFrame(function() {\n            update(isScrollModeEnabled() ? last_known_scrollY_position : last_known_scrollX_position);\n            ticking = false;\n        });\n    }\n    ticking = true;\n});\n\ndocument.addEventListener(\'selectionchange\', debounce(50, function() {\n    var info = {}\n    var selection = document.getSelection();\n    if (selection && selection.rangeCount > 0) {\n        var rect = selection.getRangeAt(0).getBoundingClientRect();\n        info[\'text\'] = selection.toString().trim();\n        info[\'frame\'] = {\n            \'x\': rect.left,\n            \'y\': rect.top,\n            \'width\': rect.width,\n            \'height\': rect.height\n        };\n    }\n\n    webkit.messageHandlers.selectionChanged.postMessage(info);\n}));\n\nfunction orientationChanged() {\n    maxScreenX = (window.orientation === 0 || window.orientation == 180) ? screen.width : screen.height;\n}\n\nfunction isScrollModeEnabled() {\n    return document.documentElement.style.getPropertyValue("--USER__scroll").toString().trim() === \'readium-scroll-on\';\n}\n\n// Scroll to the given TagId in document and snap.\nfunction scrollToId(id) {\n    var element = document.getElementById(id);\n    if (!element) {\n        return false;\n    }\n    element.scrollIntoView();\n\n    if (!isScrollModeEnabled()) {\n        var currentOffset = window.scrollX;\n        var pageWidth = window.innerWidth;\n        // Adds half a page to make sure we don\'t snap to the previous page.\n        document.scrollingElement.scrollLeft = snapOffset(currentOffset + (pageWidth / 2));\n    }\n    return true;\n}\n\n// Position must be in the range [0 - 1], 0-100%.\nfunction scrollToPosition(position, dir) {\n    console.log("ScrollToPosition");\n    if ((position < 0) || (position > 1)) {\n        console.log("InvalidPosition");\n        return;\n    }\n\n    if (isScrollModeEnabled()) {\n        var offset = document.scrollingElement.scrollHeight * position;\n        document.scrollingElement.scrollTop = offset;\n        // window.scrollTo(0, offset);\n    } else {\n        var documentWidth = document.scrollingElement.scrollWidth;\n        var factor = (dir == \'rtl\') ? -1 : 1;\n        var offset = documentWidth * position * factor;\n        document.scrollingElement.scrollLeft = snapOffset(offset);\n    }\n}\n\n// Scrolls to the first occurrence of the given text snippet.\n//\n// The expected text argument is a Locator Text object, as defined here:\n// https://readium.org/architecture/models/locators/\nfunction scrollToText(text) {\n    try {\n        let anchor = new TextQuoteAnchor(document.body, text.highlight, {\n            prefix: text.before,\n            suffix: text.after,\n        })\n\n        scrollToRange(anchor.toRange())\n        return true\n    } catch (e) {\n        logException(e)\n        return false\n    }\n}\n\nfunction scrollToRange(range) {\n    var rect = range.getBoundingClientRect();\n    if (isScrollModeEnabled()) {\n        document.scrollingElement.scrollTop = rect.top + window.scrollY - (window.innerHeight / 2);\n    } else {\n        document.scrollingElement.scrollLeft = rect.left + window.scrollX;\n        snapCurrentPosition();\n    }\n}\n\n// Returns false if the page is already at the left-most scroll offset.\nfunction scrollLeft(dir) {\n    var isRTL = (dir == "rtl");\n    var documentWidth = document.scrollingElement.scrollWidth;\n    var pageWidth = window.innerWidth;\n    var offset = window.scrollX - pageWidth;\n    var minOffset = isRTL ? -(documentWidth - pageWidth) : 0;\n    return scrollToOffset(Math.max(offset, minOffset));\n}\n\n// Returns false if the page is already at the right-most scroll offset.\nfunction scrollRight(dir) {\n    var isRTL = (dir == "rtl");\n    var documentWidth = document.scrollingElement.scrollWidth;\n    var pageWidth = window.innerWidth;\n    var offset = window.scrollX + pageWidth;\n    var maxOffset = isRTL ? 0 : (documentWidth - pageWidth);\n    return scrollToOffset(Math.min(offset, maxOffset));\n}\n\n// Scrolls to the given left offset.\n// Returns false if the page scroll position is already close enough to the given offset.\nfunction scrollToOffset(offset) {\n    var currentOffset = window.scrollX;\n    var pageWidth = window.innerWidth;\n    document.scrollingElement.scrollLeft = offset;\n    // In some case the scrollX cannot reach the position respecting to innerWidth\n    var diff = Math.abs(currentOffset - offset) / pageWidth;\n    return (diff > 0.01);\n}\n\n// Snap the offset to the screen width (page width).\nfunction snapOffset(offset) {\n    var value = offset + 1;\n\n    return value - (value % maxScreenX);\n}\n\nfunction snapCurrentPosition() {\n    if (isScrollModeEnabled()) {\n        return;\n    }\n    var currentOffset = window.scrollX;\n    var currentOffsetSnapped = snapOffset(currentOffset + 1);\n\n    document.scrollingElement.scrollLeft = currentOffsetSnapped;\n}\n\n/// User Settings.\n\n// For setting user setting.\nfunction setProperty(key, value) {\n    var root = document.documentElement;\n\n    root.style.setProperty(key, value);\n}\n\n// For removing user setting.\nfunction removeProperty(key) {\n    var root = document.documentElement;\n\n    root.style.removeProperty(key);\n}\n\n\n/// Toolkit\n\nfunction debounce(delay, func) {\n    var timeout;\n    return function() {\n        var self = this;\n        var args = arguments;\n        function callback() {\n            func.apply(self, args);\n            timeout = null;\n        }\n        clearTimeout(timeout);\n        timeout = setTimeout(callback, delay);\n    };\n}\n\nfunction log() {\n    var message = Array.prototype.slice.call(arguments).join(" ");\n    webkit.messageHandlers.log.postMessage(message);\n}\n\nfunction logException(e) {\n    webkit.messageHandlers.logError.postMessage({\n        "message": e.message\n    });\n}\n\n;// CONCATENATED MODULE: ./src/selection.js\n//\n//  Copyright 2021 Readium Foundation. All rights reserved.\n//  Use of this source code is governed by the BSD-style license\n//  available in the top-level LICENSE file of the project.\n//\n\n\n\nconst debug = true;\n\nfunction getSelectionRect() {\n    try {\n        let sel = window.getSelection();\n        if (!sel) {\n            return;\n        }\n        let range = sel.getRangeAt(0);\n\n        const clientRect = range.getBoundingClientRect();\n\n        return {\n            screenWidth: window.outerWidth,\n            screenHeight: window.outerHeight,\n            left: clientRect.left,\n            width: clientRect.width,\n            top: clientRect.top,\n            height: clientRect.height\n        };\n    } catch (e) {\n        logException(e)\n        return null;\n    }\n}\n\nfunction getCurrentSelectionInfo() {\n    const selection = window.getSelection();\n    if (!selection) {\n        return undefined;\n    }\n    if (selection.isCollapsed) {\n        selection_log("^^^ SELECTION COLLAPSED.");\n        return undefined;\n    }\n    const rawText = selection.toString();\n    const cleanText = rawText.trim().replace(/\\n/g, " ").replace(/\\s\\s+/g, " ");\n    if (cleanText.length === 0) {\n        selection_log("^^^ SELECTION TEXT EMPTY.");\n        return undefined;\n    }\n    if (!selection.anchorNode || !selection.focusNode) {\n        return undefined;\n    }\n    const range = selection.rangeCount === 1 ? selection.getRangeAt(0) :\n        createOrderedRange(selection.anchorNode, selection.anchorOffset, selection.focusNode, selection.focusOffset);\n    if (!range || range.collapsed) {\n        selection_log("$$$$$$$$$$$$$$$$$ CANNOT GET NON-COLLAPSED SELECTION RANGE?!");\n        return undefined;\n    }\n    const rangeInfo = convertRange(range, fullQualifiedSelector);\n    if (!rangeInfo) {\n        selection_log("^^^ SELECTION RANGE INFO FAIL?!");\n        return undefined;\n    }\n\n    return {\n        locations: rangeInfo2Location(rangeInfo),\n        text: {\n            highlight: rawText\n        }\n    };\n}\n\nfunction createOrderedRange(startNode, startOffset, endNode, endOffset) {\n    const range = new Range();\n    range.setStart(startNode, startOffset);\n    range.setEnd(endNode, endOffset);\n    if (!range.collapsed) {\n        return range;\n    }\n    selection_log(">>> createOrderedRange COLLAPSED ... RANGE REVERSE?");\n    const rangeReverse = new Range();\n    rangeReverse.setStart(endNode, endOffset);\n    rangeReverse.setEnd(startNode, startOffset);\n    if (!rangeReverse.collapsed) {\n        selection_log(">>> createOrderedRange RANGE REVERSE OK.");\n        return range;\n    }\n    selection_log(">>> createOrderedRange RANGE REVERSE ALSO COLLAPSED?!");\n    return undefined;\n}\n\nfunction convertRange(range, getCssSelector) {\n    const startIsElement = range.startContainer.nodeType === Node.ELEMENT_NODE;\n    const startContainerElement = startIsElement ?\n        range.startContainer :\n        ((range.startContainer.parentNode && range.startContainer.parentNode.nodeType === Node.ELEMENT_NODE) ?\n            range.startContainer.parentNode : undefined);\n    if (!startContainerElement) {\n        return undefined;\n    }\n    const startContainerChildTextNodeIndex = startIsElement ? -1 :\n        Array.from(startContainerElement.childNodes).indexOf(range.startContainer);\n    if (startContainerChildTextNodeIndex < -1) {\n        return undefined;\n    }\n    const startContainerElementCssSelector = getCssSelector(startContainerElement);\n\n    const endIsElement = range.endContainer.nodeType === Node.ELEMENT_NODE;\n    const endContainerElement = endIsElement ?\n        range.endContainer :\n        ((range.endContainer.parentNode && range.endContainer.parentNode.nodeType === Node.ELEMENT_NODE) ?\n            range.endContainer.parentNode : undefined);\n    if (!endContainerElement) {\n        return undefined;\n    }\n    const endContainerChildTextNodeIndex = endIsElement ? -1 :\n        Array.from(endContainerElement.childNodes).indexOf(range.endContainer);\n    if (endContainerChildTextNodeIndex < -1) {\n        return undefined;\n    }\n    const endContainerElementCssSelector = getCssSelector(endContainerElement);\n\n    const commonElementAncestor = getCommonAncestorElement(range.startContainer, range.endContainer);\n    if (!commonElementAncestor) {\n        selection_log("^^^ NO RANGE COMMON ANCESTOR?!");\n        return undefined;\n    }\n    if (range.commonAncestorContainer) {\n        const rangeCommonAncestorElement = range.commonAncestorContainer.nodeType === Node.ELEMENT_NODE ?\n            range.commonAncestorContainer : range.commonAncestorContainer.parentNode;\n        if (rangeCommonAncestorElement && rangeCommonAncestorElement.nodeType === Node.ELEMENT_NODE) {\n            if (commonElementAncestor !== rangeCommonAncestorElement) {\n                selection_log(">>>>>> COMMON ANCESTOR CONTAINER DIFF??!");\n                selection_log(getCssSelector(commonElementAncestor));\n                selection_log(getCssSelector(rangeCommonAncestorElement));\n            }\n        }\n    }\n    return {\n        endContainerChildTextNodeIndex,\n        endContainerElementCssSelector,\n        endOffset: range.endOffset,\n        startContainerChildTextNodeIndex,\n        startContainerElementCssSelector,\n        startOffset: range.startOffset,\n    };\n}\n\nfunction getCommonAncestorElement(node1, node2) {\n    if (node1.nodeType === Node.ELEMENT_NODE && node1 === node2) {\n        return node1;\n    }\n    if (node1.nodeType === Node.ELEMENT_NODE && node1.contains(node2)) {\n        return node1;\n    }\n    if (node2.nodeType === Node.ELEMENT_NODE && node2.contains(node1)) {\n        return node2;\n    }\n    const node1ElementAncestorChain = [];\n    let parent = node1.parentNode;\n    while (parent && parent.nodeType === Node.ELEMENT_NODE) {\n        node1ElementAncestorChain.push(parent);\n        parent = parent.parentNode;\n    }\n    const node2ElementAncestorChain = [];\n    parent = node2.parentNode;\n    while (parent && parent.nodeType === Node.ELEMENT_NODE) {\n        node2ElementAncestorChain.push(parent);\n        parent = parent.parentNode;\n    }\n    let commonAncestor = node1ElementAncestorChain.find((node1ElementAncestor) => {\n        return node2ElementAncestorChain.indexOf(node1ElementAncestor) >= 0;\n    });\n    if (!commonAncestor) {\n        commonAncestor = node2ElementAncestorChain.find((node2ElementAncestor) => {\n            return node1ElementAncestorChain.indexOf(node2ElementAncestor) >= 0;\n        });\n    }\n    return commonAncestor;\n}\n\nfunction selection_convertRangeInfo(document, rangeInfo) {\n    const startElement = document.querySelector(rangeInfo.startContainerElementCssSelector);\n    if (!startElement) {\n        selection_log("^^^ convertRangeInfo NO START ELEMENT CSS SELECTOR?!");\n        return undefined;\n    }\n    let startContainer = startElement;\n    if (rangeInfo.startContainerChildTextNodeIndex >= 0) {\n        if (rangeInfo.startContainerChildTextNodeIndex >= startElement.childNodes.length) {\n            selection_log("^^^ convertRangeInfo rangeInfo.startContainerChildTextNodeIndex >= startElement.childNodes.length?!");\n            return undefined;\n        }\n        startContainer = startElement.childNodes[rangeInfo.startContainerChildTextNodeIndex];\n        if (startContainer.nodeType !== Node.TEXT_NODE) {\n            selection_log("^^^ convertRangeInfo startContainer.nodeType !== Node.TEXT_NODE?!");\n            return undefined;\n        }\n    }\n    const endElement = document.querySelector(rangeInfo.endContainerElementCssSelector);\n    if (!endElement) {\n        selection_log("^^^ convertRangeInfo NO END ELEMENT CSS SELECTOR?!");\n        return undefined;\n    }\n    let endContainer = endElement;\n    if (rangeInfo.endContainerChildTextNodeIndex >= 0) {\n        if (rangeInfo.endContainerChildTextNodeIndex >= endElement.childNodes.length) {\n            selection_log("^^^ convertRangeInfo rangeInfo.endContainerChildTextNodeIndex >= endElement.childNodes.length?!");\n            return undefined;\n        }\n        endContainer = endElement.childNodes[rangeInfo.endContainerChildTextNodeIndex];\n        if (endContainer.nodeType !== Node.TEXT_NODE) {\n            selection_log("^^^ convertRangeInfo endContainer.nodeType !== Node.TEXT_NODE?!");\n            return undefined;\n        }\n    }\n    return createOrderedRange(startContainer, rangeInfo.startOffset, endContainer, rangeInfo.endOffset);\n}\n\nfunction rangeInfo2Location(rangeInfo) {\n    return {\n        cssSelector: rangeInfo.startContainerElementCssSelector,\n        domRange: {\n            start: {\n                cssSelector: rangeInfo.startContainerElementCssSelector,\n                textNodeIndex: rangeInfo.startContainerChildTextNodeIndex,\n                offset: rangeInfo.startOffset\n            },\n            end: {\n                cssSelector: rangeInfo.endContainerElementCssSelector,\n                textNodeIndex: rangeInfo.endContainerChildTextNodeIndex,\n                offset: rangeInfo.endOffset\n            }\n        }\n    }\n}\n\nfunction location2RangeInfo(location) {\n    const locations = location.locations\n    const domRange = locations.domRange\n    const start = domRange.start\n    const end = domRange.end\n\n    return {\n        endContainerChildTextNodeIndex: end.textNodeIndex,\n        endContainerElementCssSelector: end.cssSelector,\n        endOffset: end.offset,\n        startContainerChildTextNodeIndex: start.textNodeIndex,\n        startContainerElementCssSelector: start.cssSelector,\n        startOffset: start.offset\n    };\n}\n\nfunction fullQualifiedSelector(node) {\n    if (node.nodeType !== Node.ELEMENT_NODE) {\n        return (node.localName && node.localName.toLowerCase())\n            || node.nodeName.toLowerCase();\n    }\n    //return cssPath(node, justSelector);\n    return cssPath(node, true);\n}\n\nfunction cssPath(node, optimized) {\n    if (node.nodeType !== Node.ELEMENT_NODE) {\n        return "";\n    }\n\n    const steps = [];\n    let contextNode = node;\n    while (contextNode) {\n        const step = _cssPathStep(contextNode, !!optimized, contextNode === node);\n        if (!step) {\n            break; // Error - bail out early.\n        }\n        steps.push(step.value);\n        if (step.optimized) {\n            break;\n        }\n        contextNode = contextNode.parentNode;\n    }\n    steps.reverse();\n    return steps.join(" > ");\n}\n\n// https://chromium.googlesource.com/chromium/blink/+/master/Source/devtools/front_end/components/DOMPresentationUtils.js#316\nfunction _cssPathStep(node, optimized, isTargetNode) {\n\n    function idSelector(idd) {\n        return "#" + escapeIdentifierIfNeeded(idd);\n    }\n\n    function escapeIdentifierIfNeeded(ident) {\n        if (isCSSIdentifier(ident)) {\n            return ident;\n        }\n\n        const shouldEscapeFirst = /^(?:[0-9]|-[0-9-]?)/.test(ident);\n        const lastIndex = ident.length - 1;\n        return ident.replace(/./g, function (c, ii) {\n            return ((shouldEscapeFirst && ii === 0) || !isCSSIdentChar(c)) ? escapeAsciiChar(c, ii === lastIndex) : c;\n        });\n    }\n\n    function isCSSIdentifier(value) {\n        return /^-?[a-zA-Z_][a-zA-Z0-9_-]*$/.test(value);\n    }\n\n    function isCSSIdentChar(c) {\n        if (/[a-zA-Z0-9_-]/.test(c)) {\n            return true;\n        }\n        return c.charCodeAt(0) >= 0xA0;\n    }\n\n    function escapeAsciiChar(c, isLast) {\n        return "\\\\" + toHexByte(c) + (isLast ? "" : " ");\n    }\n\n    function toHexByte(c) {\n        let hexByte = c.charCodeAt(0).toString(16);\n        if (hexByte.length === 1) {\n            hexByte = "0" + hexByte;\n        }\n        return hexByte;\n    }\n\n    function prefixedElementClassNames(nd) {\n        const classAttribute = nd.getAttribute("class");\n        if (!classAttribute) {\n            return [];\n        }\n\n        return classAttribute.split(/\\s+/g).filter(Boolean).map((nm) => {\n            // The prefix is required to store "__proto__" in a object-based map.\n            return "$" + nm;\n        });\n    }\n\n    if (node.nodeType !== Node.ELEMENT_NODE) {\n        return undefined;\n    }\n    const lowerCaseName = (node.localName && node.localName.toLowerCase())\n        || node.nodeName.toLowerCase();\n\n    const element = node;\n\n    const id = element.getAttribute("id");\n\n    if (optimized) {\n        if (id) {\n            return {\n                optimized: true,\n                value: idSelector(id),\n            };\n        }\n        if (lowerCaseName === "body" || lowerCaseName === "head" || lowerCaseName === "html") {\n            return {\n                optimized: true,\n                value: lowerCaseName, // node.nodeNameInCorrectCase(),\n            };\n        }\n    }\n\n    const nodeName = lowerCaseName; // node.nodeNameInCorrectCase();\n    if (id) {\n        return {\n            optimized: true,\n            value: nodeName + idSelector(id),\n        };\n    }\n\n    const parent = node.parentNode;\n\n    if (!parent || parent.nodeType === Node.DOCUMENT_NODE) {\n        return {\n            optimized: true,\n            value: nodeName,\n        };\n    }\n\n    const prefixedOwnClassNamesArray_ = prefixedElementClassNames(element);\n\n    const prefixedOwnClassNamesArray = []; // .keySet()\n    prefixedOwnClassNamesArray_.forEach((arrItem) => {\n        if (prefixedOwnClassNamesArray.indexOf(arrItem) < 0) {\n            prefixedOwnClassNamesArray.push(arrItem);\n        }\n    });\n\n    let needsClassNames = false;\n    let needsNthChild = false;\n    let ownIndex = -1;\n    let elementIndex = -1;\n    const siblings = parent.children;\n\n    for (let i = 0; (ownIndex === -1 || !needsNthChild) && i < siblings.length; ++i) {\n        const sibling = siblings[i];\n        if (sibling.nodeType !== Node.ELEMENT_NODE) {\n            continue;\n        }\n        elementIndex += 1;\n        if (sibling === node) {\n            ownIndex = elementIndex;\n            continue;\n        }\n        if (needsNthChild) {\n            continue;\n        }\n\n        // sibling.nodeNameInCorrectCase()\n        const siblingName = (sibling.localName && sibling.localName.toLowerCase()) || sibling.nodeName.toLowerCase();\n        if (siblingName !== nodeName) {\n            continue;\n        }\n        needsClassNames = true;\n\n        const ownClassNames = [];\n        prefixedOwnClassNamesArray.forEach((arrItem) => {\n            ownClassNames.push(arrItem);\n        });\n        let ownClassNameCount = ownClassNames.length;\n\n        if (ownClassNameCount === 0) {\n            needsNthChild = true;\n            continue;\n        }\n        const siblingClassNamesArray_ = prefixedElementClassNames(sibling);\n        const siblingClassNamesArray = []; // .keySet()\n        siblingClassNamesArray_.forEach((arrItem) => {\n            if (siblingClassNamesArray.indexOf(arrItem) < 0) {\n                siblingClassNamesArray.push(arrItem);\n            }\n        });\n\n        for (const siblingClass of siblingClassNamesArray) {\n            const ind = ownClassNames.indexOf(siblingClass);\n            if (ind < 0) {\n                continue;\n            }\n\n            ownClassNames.splice(ind, 1); // delete ownClassNames[siblingClass];\n\n            if (!--ownClassNameCount) {\n                needsNthChild = true;\n                break;\n            }\n        }\n    }\n\n    let result = nodeName;\n    if (isTargetNode &&\n        nodeName === "input" &&\n        element.getAttribute("type") &&\n        !element.getAttribute("id") &&\n        !element.getAttribute("class")) {\n        result += "[type=\\"" + element.getAttribute("type") + "\\"]";\n    }\n    if (needsNthChild) {\n        result += ":nth-child(" + (ownIndex + 1) + ")";\n    } else if (needsClassNames) {\n        for (const prefixedName of prefixedOwnClassNamesArray) {\n            result += "." + escapeIdentifierIfNeeded(prefixedName.substr(1));\n        }\n    }\n\n    return {\n        optimized: false,\n        value: result,\n    };\n}\n\nfunction selection_log() {\n    if (debug) {\n        log.apply(null, arguments);\n    }\n}\n;// CONCATENATED MODULE: ./src/rect.js\n//\n//  Copyright 2021 Readium Foundation. All rights reserved.\n//  Use of this source code is governed by the BSD-style license\n//  available in the top-level LICENSE file of the project.\n//\n\n\n\nconst rect_debug = false;\n\nfunction rect_getClientRectsNoOverlap(range, doNotMergeHorizontallyAlignedRects) {\n    let clientRects = range.getClientRects();\n\n    const tolerance = 1;\n    const originalRects = [];\n    for (const rangeClientRect of clientRects) {\n        originalRects.push({\n            bottom: rangeClientRect.bottom,\n            height: rangeClientRect.height,\n            left: rangeClientRect.left,\n            right: rangeClientRect.right,\n            top: rangeClientRect.top,\n            width: rangeClientRect.width,\n        });\n    }\n    const mergedRects = mergeTouchingRects(originalRects, tolerance, doNotMergeHorizontallyAlignedRects);\n    const noContainedRects = removeContainedRects(mergedRects, tolerance);\n    const newRects = replaceOverlapingRects(noContainedRects);\n    const minArea = 2 * 2;\n    for (let j = newRects.length - 1; j >= 0; j--) {\n        const rect = newRects[j];\n        const bigEnough = (rect.width * rect.height) > minArea;\n        if (!bigEnough) {\n            if (newRects.length > 1) {\n                rect_log("CLIENT RECT: remove small");\n                newRects.splice(j, 1);\n            } else {\n                rect_log("CLIENT RECT: remove small, but keep otherwise empty!");\n                break;\n            }\n        }\n    }\n    rect_log(`CLIENT RECT: reduced ${originalRects.length} --\x3e ${newRects.length}`);\n    return newRects;\n}\n\nfunction mergeTouchingRects(rects, tolerance, doNotMergeHorizontallyAlignedRects) {\n    for (let i = 0; i < rects.length; i++) {\n        for (let j = i + 1; j < rects.length; j++) {\n            const rect1 = rects[i];\n            const rect2 = rects[j];\n            if (rect1 === rect2) {\n                rect_log("mergeTouchingRects rect1 === rect2 ??!");\n                continue;\n            }\n            const rectsLineUpVertically = almostEqual(rect1.top, rect2.top, tolerance) &&\n                almostEqual(rect1.bottom, rect2.bottom, tolerance);\n            const rectsLineUpHorizontally = almostEqual(rect1.left, rect2.left, tolerance) &&\n                almostEqual(rect1.right, rect2.right, tolerance);\n            const horizontalAllowed = !doNotMergeHorizontallyAlignedRects;\n            const aligned = (rectsLineUpHorizontally && horizontalAllowed) || (rectsLineUpVertically && !rectsLineUpHorizontally);\n            const canMerge = aligned && rectsTouchOrOverlap(rect1, rect2, tolerance);\n            if (canMerge) {\n                rect_log(`CLIENT RECT: merging two into one, VERTICAL: ${rectsLineUpVertically} HORIZONTAL: ${rectsLineUpHorizontally} (${doNotMergeHorizontallyAlignedRects})`);\n                const newRects = rects.filter((rect) => {\n                    return rect !== rect1 && rect !== rect2;\n                });\n                const replacementClientRect = getBoundingRect(rect1, rect2);\n                newRects.push(replacementClientRect);\n                return mergeTouchingRects(newRects, tolerance, doNotMergeHorizontallyAlignedRects);\n            }\n        }\n    }\n    return rects;\n}\n\nfunction getBoundingRect(rect1, rect2) {\n    const left = Math.min(rect1.left, rect2.left);\n    const right = Math.max(rect1.right, rect2.right);\n    const top = Math.min(rect1.top, rect2.top);\n    const bottom = Math.max(rect1.bottom, rect2.bottom);\n    return {\n        bottom,\n        height: bottom - top,\n        left,\n        right,\n        top,\n        width: right - left,\n    };\n}\n\nfunction removeContainedRects(rects, tolerance) {\n    const rectsToKeep = new Set(rects);\n    for (const rect of rects) {\n        const bigEnough = rect.width > 1 && rect.height > 1;\n        if (!bigEnough) {\n            rect_log("CLIENT RECT: remove tiny");\n            rectsToKeep.delete(rect);\n            continue;\n        }\n        for (const possiblyContainingRect of rects) {\n            if (rect === possiblyContainingRect) {\n                continue;\n            }\n            if (!rectsToKeep.has(possiblyContainingRect)) {\n                continue;\n            }\n            if (rectContains(possiblyContainingRect, rect, tolerance)) {\n                rect_log("CLIENT RECT: remove contained");\n                rectsToKeep.delete(rect);\n                break;\n            }\n        }\n    }\n    return Array.from(rectsToKeep);\n}\n\nfunction rectContains(rect1, rect2, tolerance) {\n    return (rectContainsPoint(rect1, rect2.left, rect2.top, tolerance) &&\n        rectContainsPoint(rect1, rect2.right, rect2.top, tolerance) &&\n        rectContainsPoint(rect1, rect2.left, rect2.bottom, tolerance) &&\n        rectContainsPoint(rect1, rect2.right, rect2.bottom, tolerance));\n}\n\nfunction rectContainsPoint(rect, x, y, tolerance) {\n    return (rect.left < x || almostEqual(rect.left, x, tolerance)) &&\n        (rect.right > x || almostEqual(rect.right, x, tolerance)) &&\n        (rect.top < y || almostEqual(rect.top, y, tolerance)) &&\n        (rect.bottom > y || almostEqual(rect.bottom, y, tolerance));\n}\n\nfunction replaceOverlapingRects(rects) {\n    for (let i = 0; i < rects.length; i++) {\n        for (let j = i + 1; j < rects.length; j++) {\n            const rect1 = rects[i];\n            const rect2 = rects[j];\n            if (rect1 === rect2) {\n                rect_log("replaceOverlapingRects rect1 === rect2 ??!");\n                continue;\n            }\n            if (rectsTouchOrOverlap(rect1, rect2, -1)) {\n                let toAdd = [];\n                let toRemove;\n                let toPreserve;\n                const subtractRects1 = rectSubtract(rect1, rect2);\n                if (subtractRects1.length === 1) {\n                    toAdd = subtractRects1;\n                    toRemove = rect1;\n                    toPreserve = rect2;\n                } else {\n                    const subtractRects2 = rectSubtract(rect2, rect1);\n                    if (subtractRects1.length < subtractRects2.length) {\n                        toAdd = subtractRects1;\n                        toRemove = rect1;\n                        toPreserve = rect2;\n                    } else {\n                        toAdd = subtractRects2;\n                        toRemove = rect2;\n                        toPreserve = rect1;\n                    }\n                }\n                rect_log(`CLIENT RECT: overlap, cut one rect into ${toAdd.length}`);\n                const newRects = rects.filter((rect) => {\n                    return rect !== toRemove;\n                });\n                Array.prototype.push.apply(newRects, toAdd);\n                return replaceOverlapingRects(newRects);\n            }\n        }\n    }\n    return rects;\n}\n\nfunction rectSubtract(rect1, rect2) {\n    const rectIntersected = rectIntersect(rect2, rect1);\n    if (rectIntersected.height === 0 || rectIntersected.width === 0) {\n        return [rect1];\n    }\n    const rects = [];\n    {\n        const rectA = {\n            bottom: rect1.bottom,\n            height: 0,\n            left: rect1.left,\n            right: rectIntersected.left,\n            top: rect1.top,\n            width: 0,\n        };\n        rectA.width = rectA.right - rectA.left;\n        rectA.height = rectA.bottom - rectA.top;\n        if (rectA.height !== 0 && rectA.width !== 0) {\n            rects.push(rectA);\n        }\n    }\n    {\n        const rectB = {\n            bottom: rectIntersected.top,\n            height: 0,\n            left: rectIntersected.left,\n            right: rectIntersected.right,\n            top: rect1.top,\n            width: 0,\n        };\n        rectB.width = rectB.right - rectB.left;\n        rectB.height = rectB.bottom - rectB.top;\n        if (rectB.height !== 0 && rectB.width !== 0) {\n            rects.push(rectB);\n        }\n    }\n    {\n        const rectC = {\n            bottom: rect1.bottom,\n            height: 0,\n            left: rectIntersected.left,\n            right: rectIntersected.right,\n            top: rectIntersected.bottom,\n            width: 0,\n        };\n        rectC.width = rectC.right - rectC.left;\n        rectC.height = rectC.bottom - rectC.top;\n        if (rectC.height !== 0 && rectC.width !== 0) {\n            rects.push(rectC);\n        }\n    }\n    {\n        const rectD = {\n            bottom: rect1.bottom,\n            height: 0,\n            left: rectIntersected.right,\n            right: rect1.right,\n            top: rect1.top,\n            width: 0,\n        };\n        rectD.width = rectD.right - rectD.left;\n        rectD.height = rectD.bottom - rectD.top;\n        if (rectD.height !== 0 && rectD.width !== 0) {\n            rects.push(rectD);\n        }\n    }\n    return rects;\n}\n\nfunction rectIntersect(rect1, rect2) {\n    const maxLeft = Math.max(rect1.left, rect2.left);\n    const minRight = Math.min(rect1.right, rect2.right);\n    const maxTop = Math.max(rect1.top, rect2.top);\n    const minBottom = Math.min(rect1.bottom, rect2.bottom);\n    return {\n        bottom: minBottom,\n        height: Math.max(0, minBottom - maxTop),\n        left: maxLeft,\n        right: minRight,\n        top: maxTop,\n        width: Math.max(0, minRight - maxLeft),\n    };\n}\n\nfunction rectsTouchOrOverlap(rect1, rect2, tolerance) {\n    return ((rect1.left < rect2.right || (tolerance >= 0 && almostEqual(rect1.left, rect2.right, tolerance))) &&\n        (rect2.left < rect1.right || (tolerance >= 0 && almostEqual(rect2.left, rect1.right, tolerance))) &&\n        (rect1.top < rect2.bottom || (tolerance >= 0 && almostEqual(rect1.top, rect2.bottom, tolerance))) &&\n        (rect2.top < rect1.bottom || (tolerance >= 0 && almostEqual(rect2.top, rect1.bottom, tolerance))));\n}\n\nfunction almostEqual(a, b, tolerance) {\n    return Math.abs(a - b) <= tolerance;\n}\n\nfunction rect_log() {\n    if (rect_debug) {\n        log.apply(null, arguments);\n    }\n}\n;// CONCATENATED MODULE: ./src/highlight.js\n//\n//  Copyright 2021 Readium Foundation. All rights reserved.\n//  Use of this source code is governed by the BSD-style license\n//  available in the top-level LICENSE file of the project.\n//\n\n\n\n\nconst highlight_debug = false;\n\nconst ID_HIGHLIGHTS_CONTAINER = "R2_ID_HIGHLIGHTS_CONTAINER";\nconst CLASS_HIGHLIGHT_CONTAINER = "R2_CLASS_HIGHLIGHT_CONTAINER";\nconst CLASS_HIGHLIGHT_AREA = "R2_CLASS_HIGHLIGHT_AREA";\nconst CLASS_HIGHLIGHT_BOUNDING_AREA = "R2_CLASS_HIGHLIGHT_BOUNDING_AREA";\n\nconst _highlights = [];\nlet _highlightsContainer;\n\nconst defaultBackgroundOpacity = 0.3;\n\nconst defaultBackgroundColor = {\n    blue: 100,\n    green: 50,\n    red: 230,\n};\n\nfunction rectForHighlightWithID(id) {\n    const clientRects = frameForHighlightWithID(id);\n\n    return {\n        screenWidth: window.outerWidth,\n        screenHeight: window.outerHeight,\n        left: clientRects[0].left,\n        width: clientRects[0].width,\n        top: clientRects[0].top,\n        height: clientRects[0].height\n    };\n}\n\nfunction destroyAllHighlights() {\n    hideAllHighlights();\n    _highlights.splice(0, _highlights.length);\n}\n\nfunction hideAllHighlights() {\n    if (_highlightsContainer) {\n        _highlightsContainer.remove();\n        _highlightsContainer = null;\n    }\n}\n\nfunction createHighlightRange(range) {\n\n    // FIXME: Use user-provided ID.\n    let id = "R2_HIGHLIGHT_" + Date.now();\n\n    destroyHighlight(id);\n\n    const highlight = {\n        color: defaultBackgroundColor,\n        id,\n        pointerInteraction: true,\n        rangeInfo: null\n    };\n    _highlights.push(highlight);\n    createHighlightFromRange(range, highlight);\n\n    return highlight;\n}\n\nfunction createHighlight(locations, color, pointerInteraction) {\n    const rangeInfo = location2RangeInfo(locations)\n\n    // FIXME: Use user-provided ID.\n    let id = "R2_HIGHLIGHT_" + Date.now();\n\n    destroyHighlight(id);\n\n    const highlight = {\n        color: color ? color : defaultBackgroundColor,\n        id,\n        pointerInteraction,\n        rangeInfo\n    };\n    _highlights.push(highlight);\n    createHighlightDom(highlight);\n\n    return highlight;\n}\n\nfunction destroyHighlight(id) {\n    let i = -1;\n    let _document = window.document\n    const highlight = _highlights.find((h, j) => {\n        i = j;\n        return h.id === id;\n    });\n    if (highlight && i >= 0 && i < _highlights.length) {\n        _highlights.splice(i, 1);\n    }\n    const highlightContainer = _document.getElementById(id);\n    if (highlightContainer) {\n        highlightContainer.remove();\n    }\n}\n\nfunction createHighlightDom(highlight) {\n    const range = selection_convertRangeInfo(document, highlight.rangeInfo);\n    return createHighlightFromRange(range, highlight)\n}\n\nfunction createHighlightFromRange(range, highlight) {\n    if (!range) {\n        return undefined;\n    }\n\n    const scale = 1 / ((window.READIUM2 && window.READIUM2.isFixedLayout) ? window.READIUM2.fxlViewportScale : 1);\n\n    const scrollElement = document.scrollingElement;\n\n    const paginated = !highlight_isScrollModeEnabled()\n    const highlightsContainer = ensureContainer(window);\n    const highlightParent = document.createElement("div");\n\n    highlightParent.setAttribute("id", highlight.id);\n    highlightParent.setAttribute("class", CLASS_HIGHLIGHT_CONTAINER);\n\n    highlightParent.style.setProperty("pointer-events", "none");\n    if (highlight.pointerInteraction) {\n        highlightParent.setAttribute("data-click", "1");\n    }\n\n    const bodyRect = document.body.getBoundingClientRect();\n    const drawUnderline = false;\n    const drawStrikeThrough = false;\n    const doNotMergeHorizontallyAlignedRects = drawUnderline || drawStrikeThrough;\n    const clientRects = rect_getClientRectsNoOverlap(range, doNotMergeHorizontallyAlignedRects);\n    const roundedCorner = 3;\n    const underlineThickness = 2;\n    const strikeThroughLineThickness = 3;\n    const opacity = defaultBackgroundOpacity;\n    let extra = "";\n\n    let xOffset;\n    let yOffset;\n\n    // if (navigator.userAgent.match(/Android/i)) {\n    xOffset = paginated ? (-scrollElement.scrollLeft) : bodyRect.left;\n    yOffset = paginated ? (-scrollElement.scrollTop) : bodyRect.top;\n    // } else if (navigator.userAgent.match(/iPhone|iPad|iPod/i)) {\n    //     xOffset = paginated ? 0 : (-scrollElement.scrollLeft);\n    //     yOffset = paginated ? 0 : (bodyRect.top);\n    //     annotationOffset = parseInt((rangeAnnotationBoundingClientRect.right/window.innerWidth) + 1);\n    // }\n\n    for (const clientRect of clientRects) {\n        const highlightArea = document.createElement("div");\n\n        highlightArea.setAttribute("class", CLASS_HIGHLIGHT_AREA);\n\n        if (highlight_debug) {\n            const rgb = Math.round(0xffffff * Math.random());\n            const r = rgb >> 16;\n            const g = rgb >> 8 & 255;\n            const b = rgb & 255;\n            extra = `outline-color: rgb(${r}, ${g}, ${b}); outline-style: solid; outline-width: 1px; outline-offset: -1px;`;\n        } else {\n            if (drawUnderline) {\n                extra += `border-bottom: ${underlineThickness * scale}px solid rgba(${highlight.color.red}, ${highlight.color.green}, ${highlight.color.blue}, ${opacity}) !important`;\n            }\n        }\n        highlightArea.setAttribute("style", `border-radius: ${roundedCorner}px !important; background-color: rgba(${highlight.color.red}, ${highlight.color.green}, ${highlight.color.blue}, ${opacity}) !important; ${extra}`);\n        highlightArea.style.setProperty("pointer-events", "none");\n        highlightArea.style.position = !paginated ? "fixed" : "absolute";\n        highlightArea.scale = scale;\n        /*\n         highlightArea.rect = {\n         height: clientRect.height,\n         left: clientRect.left - xOffset,\n         top: clientRect.top - yOffset,\n         width: clientRect.width,\n         };\n         */\n        highlightArea.rect = {\n            height: clientRect.height,\n            left: clientRect.left - xOffset,\n            top: clientRect.top - yOffset,\n            width: clientRect.width\n        };\n\n        highlightArea.style.width = `${highlightArea.rect.width * scale}px`;\n        highlightArea.style.height = `${highlightArea.rect.height * scale}px`;\n        highlightArea.style.left = `${highlightArea.rect.left * scale}px`;\n        highlightArea.style.top = `${highlightArea.rect.top * scale}px`;\n        highlightParent.append(highlightArea);\n        if (!highlight_debug && drawStrikeThrough) {\n            //if (drawStrikeThrough) {\n            const highlightAreaLine = document.createElement("div");\n            highlightAreaLine.setAttribute("class", CLASS_HIGHLIGHT_AREA);\n\n            highlightAreaLine.setAttribute("style", `background-color: rgba(${highlight.color.red}, ${highlight.color.green}, ${highlight.color.blue}, ${opacity}) !important;`);\n            highlightAreaLine.style.setProperty("pointer-events", "none");\n            highlightAreaLine.style.position = paginated ? "fixed" : "absolute";\n            highlightAreaLine.scale = scale;\n            /*\n             highlightAreaLine.rect = {\n             height: clientRect.height,\n             left: clientRect.left - xOffset,\n             top: clientRect.top - yOffset,\n             width: clientRect.width,\n             };\n             */\n\n            highlightAreaLine.rect = {\n                height: clientRect.height,\n                left: clientRect.left - xOffset,\n                top: clientRect.top - yOffset,\n                width: clientRect.width\n            };\n\n            highlightAreaLine.style.width = `${highlightAreaLine.rect.width * scale}px`;\n            highlightAreaLine.style.height = `${strikeThroughLineThickness * scale}px`;\n            highlightAreaLine.style.left = `${highlightAreaLine.rect.left * scale}px`;\n            highlightAreaLine.style.top = `${(highlightAreaLine.rect.top + (highlightAreaLine.rect.height / 2) - (strikeThroughLineThickness / 2)) * scale}px`;\n            highlightParent.append(highlightAreaLine);\n        }\n    }\n\n    const highlightBounding = document.createElement("div");\n    highlightBounding.setAttribute("class", CLASS_HIGHLIGHT_BOUNDING_AREA);\n\n    highlightBounding.style.setProperty("pointer-events", "none");\n    highlightBounding.style.position = paginated ? "fixed" : "absolute";\n    highlightBounding.scale = scale;\n\n    if (highlight_debug) {\n        highlightBounding.setAttribute("style", `outline-color: magenta; outline-style: solid; outline-width: 1px; outline-offset: -1px;`);\n    }\n\n    const rangeBoundingClientRect = range.getBoundingClientRect();\n    highlightBounding.rect = {\n        height: rangeBoundingClientRect.height,\n        left: rangeBoundingClientRect.left - xOffset,\n        top: rangeBoundingClientRect.top - yOffset,\n        width: rangeBoundingClientRect.width\n    };\n\n    highlightBounding.style.width = `${highlightBounding.rect.width * scale}px`;\n    highlightBounding.style.height = `${highlightBounding.rect.height * scale}px`;\n    highlightBounding.style.left = `${highlightBounding.rect.left * scale}px`;\n    highlightBounding.style.top = `${highlightBounding.rect.top * scale}px`;\n\n    highlightParent.append(highlightBounding);\n    highlightsContainer.append(highlightParent);\n\n    return highlightParent;\n}\n\nfunction highlight_isScrollModeEnabled() {\n    return document.documentElement.style.getPropertyValue("--USER__scroll").toString().trim() === \'readium-scroll-on\';\n}\n\nfunction ensureContainer(win) {\n    const document = win.document;\n\n    if (!_highlightsContainer) {\n        _highlightsContainer = document.createElement("div");\n        _highlightsContainer.setAttribute("id", ID_HIGHLIGHTS_CONTAINER);\n\n        _highlightsContainer.style.setProperty("pointer-events", "none");\n        document.body.append(_highlightsContainer);\n    }\n\n    return _highlightsContainer;\n}\n\nfunction frameForHighlightWithID(id) {\n    const highlight = highlightWithID(id);\n    if (!highlight)\n        return;\n\n    const document = window.document;\n    const range = convertRangeInfo(document, highlight.rangeInfo);\n    if (!range) {\n        return undefined;\n    }\n\n\n    const drawUnderline = false;\n    const drawStrikeThrough = false;\n    const doNotMergeHorizontallyAlignedRects = drawUnderline || drawStrikeThrough;\n    return getClientRectsNoOverlap(range, doNotMergeHorizontallyAlignedRects);\n}\n\nfunction highlightWithID(id) {\n    let i = -1;\n    return _highlights.find((h, j) => {\n        i = j;\n        return h.id === id;\n    })\n}\n;// CONCATENATED MODULE: ./src/index.js\n//\n//  Copyright 2021 Readium Foundation. All rights reserved.\n//  Use of this source code is governed by the BSD-style license\n//  available in the top-level LICENSE file of the project.\n//\n\n// Base script used by both reflowable and fixed layout resources.\n\n\n\n\n\n\n\n\n// Public API used by the navigator.\nwindow.readium = {\n    // utils\n    \'scrollToId\': scrollToId,\n    \'scrollToPosition\': scrollToPosition,\n    \'scrollToText\': scrollToText,\n    \'scrollLeft\': scrollLeft,\n    \'scrollRight\': scrollRight,\n    \'setProperty\': setProperty,\n    \'removeProperty\': removeProperty,\n\n    // selection\n    \'getSelectionRect\': getSelectionRect,\n    \'getCurrentSelectionInfo\': getCurrentSelectionInfo,\n\n    // highlights\n    \'createHighlight\': createHighlight,\n    \'createHighlightRange\': createHighlightRange,\n\n    // Hypothesis\' anchoring\n    \'TextQuoteAnchor\': TextQuoteAnchor,\n};\n;// CONCATENATED MODULE: ./src/index-reflowable.js\n//\n//  Copyright 2021 Readium Foundation. All rights reserved.\n//  Use of this source code is governed by the BSD-style license\n//  available in the top-level LICENSE file of the project.\n//\n\n// Script used for reflowable resources.\n\n\n\nwindow.addEventListener("load", function() {\n  // Notifies native code that the page is loaded after it is rendered.\n  // Waiting for the next animation frame seems to do the trick to make sure the page is fully rendered.\n  window.requestAnimationFrame(function() {\n    webkit.messageHandlers.spreadLoaded.postMessage({});\n  });\n\n  // Setups the `viewport` meta tag to disable zooming.\n  let meta = document.createElement("meta");\n  meta.setAttribute("name", "viewport");\n  meta.setAttribute("content", "width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no");\n  document.head.appendChild(meta);\n});\n\n// Injects Readium CSS stylesheets.\ndocument.addEventListener(\'DOMContentLoaded\', function() {\n  function createLink(name) {\n    var link = document.createElement(\'link\');\n    link.setAttribute(\'rel\', \'stylesheet\');\n    link.setAttribute(\'type\', \'text/css\');\n    link.setAttribute(\'href\', window.readiumCSSBaseURL + name + \'.css\');\n    return link;\n  }\n\n  var head = document.getElementsByTagName(\'head\')[0];\n  head.appendChild(createLink(\'ReadiumCSS-after\'));\n  head.insertBefore(createLink(\'ReadiumCSS-before\'), head.children[0]);\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFkaXVtLWpzLy4vc3JjL3ZlbmRvci9oeXBvdGhlc2lzL2FuY2hvcmluZy9tYXRjaC1xdW90ZS5qcz9kZDZhIiwid2VicGFjazovL3JlYWRpdW0tanMvLi9zcmMvdmVuZG9yL2h5cG90aGVzaXMvYW5jaG9yaW5nL3RleHQtcmFuZ2UuanM/ZmRlZSIsIndlYnBhY2s6Ly9yZWFkaXVtLWpzLy4vc3JjL3ZlbmRvci9oeXBvdGhlc2lzL2FuY2hvcmluZy90eXBlcy5qcz80MDA0Iiwid2VicGFjazovL3JlYWRpdW0tanMvLi9zcmMvdXRpbHMuanM/MDI1ZSIsIndlYnBhY2s6Ly9yZWFkaXVtLWpzLy4vc3JjL3NlbGVjdGlvbi5qcz81OWFjIiwid2VicGFjazovL3JlYWRpdW0tanMvLi9zcmMvcmVjdC5qcz80ZDVhIiwid2VicGFjazovL3JlYWRpdW0tanMvLi9zcmMvaGlnaGxpZ2h0LmpzPzhkYTgiLCJ3ZWJwYWNrOi8vcmVhZGl1bS1qcy8uL3NyYy9pbmRleC5qcz9iNjM1Iiwid2VicGFjazovL3JlYWRpdW0tanMvLi9zcmMvaW5kZXgtcmVmbG93YWJsZS5qcz8zOTI1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUErQzs7QUFFL0M7QUFDQSxhQUFhLG9DQUFvQztBQUNqRDs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCLFVBQVUsT0FBTztBQUNqQixVQUFVLE9BQU87QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVMsdUJBQVk7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FB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Qzs7QUFFRDtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EseUJBQXlCLGVBQWU7QUFDeEM7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ087QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ087QUFDUDs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7OztBQzlPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV1RDs7QUFFdkQ7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxRQUFRLFlBQVk7QUFDcEI7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsYUFBRztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGFBQUc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxhQUFHO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGFBQUc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxhQUFHO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGFBQUc7QUFDWDtBQUNBO0FBQ0EsSUFBSSxhQUFHO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUSxhQUFHO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsYUFBRztBQUNuQixnQkFBZ0IsYUFBRztBQUNuQixnQkFBZ0IsYUFBRztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRU8sU0FBUywwQkFBZ0I7QUFDaEM7QUFDQTtBQUNBLFFBQVEsYUFBRztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGFBQUc7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksYUFBRztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGFBQUc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxhQUFHO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGFBQUc7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsNERBQTREO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUNBQXlDOztBQUV6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLGFBQUc7QUFDWjtBQUNBLFFBQVEsU0FBZTtBQUN2QjtBQUNBLEM7O0FDM2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXlDOztBQUV6QyxNQUFNLFVBQUs7O0FBRUosU0FBUyw0QkFBdUI7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxRQUFRO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQUc7QUFDbkI7QUFDQSxhQUFhO0FBQ2IsZ0JBQWdCLFFBQUc7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLFFBQUcseUJBQXlCLHFCQUFxQixPQUFPLGdCQUFnQjtBQUM1RTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQywyQkFBMkIsa0JBQWtCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFHO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQUcsaURBQWlELHNCQUFzQixlQUFlLHdCQUF3QixJQUFJLG1DQUFtQztBQUN4SztBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFHO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFHO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDLDJCQUEyQixrQkFBa0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQUc7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBRyw0Q0FBNEMsYUFBYTtBQUM1RTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFNBQVMsUUFBRztBQUNaLFFBQVEsVUFBSztBQUNiLFFBQVEsU0FBZTtBQUN2QjtBQUNBLEM7O0FDaFJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWlFO0FBQ2xCOztBQUUvQyxNQUFNLGVBQUs7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTzs7QUFFUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFTztBQUNQLHNCQUFzQixrQkFBa0I7O0FBRXhDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLDBCQUFnQjtBQUNsQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLHVCQUF1Qiw2QkFBbUI7QUFDMUM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDRCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsWUFBWSxlQUFLO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxFQUFFLHNCQUFzQixvQkFBb0Isc0JBQXNCO0FBQzFILFNBQVM7QUFDVDtBQUNBLDJDQUEyQywyQkFBMkIsZ0JBQWdCLG9CQUFvQixJQUFJLHNCQUFzQixJQUFJLHFCQUFxQixJQUFJLFFBQVE7QUFDeks7QUFDQTtBQUNBLDhEQUE4RCxjQUFjLGNBQWMsMEJBQTBCLG9CQUFvQixJQUFJLHNCQUFzQixJQUFJLHFCQUFxQixJQUFJLFFBQVEsYUFBYSxHQUFHLE1BQU07QUFDN047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUMsaUNBQWlDO0FBQ3hFLHdDQUF3QyxrQ0FBa0M7QUFDMUUsc0NBQXNDLGdDQUFnQztBQUN0RSxxQ0FBcUMsK0JBQStCO0FBQ3BFO0FBQ0EsYUFBYSxlQUFLO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQSw4RUFBOEUsb0JBQW9CLElBQUksc0JBQXNCLElBQUkscUJBQXFCLElBQUksUUFBUSxhQUFhO0FBQzlLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtDQUErQyxxQ0FBcUM7QUFDcEYsZ0RBQWdELG1DQUFtQztBQUNuRiw4Q0FBOEMsb0NBQW9DO0FBQ2xGLDZDQUE2Qyw4R0FBOEc7QUFDM0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFFBQVEsZUFBSztBQUNiLHdFQUF3RSxzQkFBc0Isb0JBQW9CLHNCQUFzQjtBQUN4STs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUMscUNBQXFDO0FBQzVFLHdDQUF3QyxzQ0FBc0M7QUFDOUUsc0NBQXNDLG9DQUFvQztBQUMxRSxxQ0FBcUMsbUNBQW1DOztBQUV4RTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsU0FBUyw2QkFBbUI7QUFDNUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQzs7QUM3U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFbUI7QUFDc0c7QUFDbkQ7QUFDSjtBQUNFOzs7QUFHcEU7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFVBQVU7QUFDNUIsd0JBQXdCLGdCQUFnQjtBQUN4QyxvQkFBb0IsWUFBWTtBQUNoQyxrQkFBa0IsVUFBVTtBQUM1QixtQkFBbUIsV0FBVztBQUM5QixtQkFBbUIsV0FBVztBQUM5QixzQkFBc0IsY0FBYzs7QUFFcEM7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDLCtCQUErQix1QkFBdUI7O0FBRXREO0FBQ0EsdUJBQXVCLGVBQWU7QUFDdEMsNEJBQTRCLG9CQUFvQjs7QUFFaEQ7QUFDQSx1QkFBdUIsZUFBZTtBQUN0QyxFOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVnQjs7QUFFaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiIzMzIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgYXBwcm94U2VhcmNoIGZyb20gJ2FwcHJveC1zdHJpbmctbWF0Y2gnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2FwcHJveC1zdHJpbmctbWF0Y2gnKS5NYXRjaH0gU3RyaW5nTWF0Y2hcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIE1hdGNoXG4gKiBAcHJvcCB7bnVtYmVyfSBzdGFydCAtIFN0YXJ0IG9mZnNldCBvZiBtYXRjaCBpbiB0ZXh0XG4gKiBAcHJvcCB7bnVtYmVyfSBlbmQgLSBFbmQgb2Zmc2V0IG9mIG1hdGNoIGluIHRleHRcbiAqIEBwcm9wIHtudW1iZXJ9IHNjb3JlIC1cbiAqICAgU2NvcmUgZm9yIHRoZSBtYXRjaCBiZXR3ZWVuIDAgYW5kIDEuMCwgd2hlcmUgMS4wIGluZGljYXRlcyBhIHBlcmZlY3QgbWF0Y2hcbiAqICAgZm9yIHRoZSBxdW90ZSBhbmQgY29udGV4dC5cbiAqL1xuXG4vKipcbiAqIEZpbmQgdGhlIGJlc3QgYXBwcm94aW1hdGUgbWF0Y2hlcyBmb3IgYHN0cmAgaW4gYHRleHRgIGFsbG93aW5nIHVwIHRvIGBtYXhFcnJvcnNgIGVycm9ycy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHBhcmFtIHtudW1iZXJ9IG1heEVycm9yc1xuICogQHJldHVybiB7U3RyaW5nTWF0Y2hbXX1cbiAqL1xuZnVuY3Rpb24gc2VhcmNoKHRleHQsIHN0ciwgbWF4RXJyb3JzKSB7XG4gIC8vIERvIGEgZmFzdCBzZWFyY2ggZm9yIGV4YWN0IG1hdGNoZXMuIFRoZSBgYXBwcm94LXN0cmluZy1tYXRjaGAgbGlicmFyeVxuICAvLyBkb2Vzbid0IGN1cnJlbnRseSBpbmNvcnBvcmF0ZSB0aGlzIG9wdGltaXphdGlvbiBpdHNlbGYuXG4gIGxldCBtYXRjaFBvcyA9IDA7XG4gIGxldCBleGFjdE1hdGNoZXMgPSBbXTtcbiAgd2hpbGUgKG1hdGNoUG9zICE9PSAtMSkge1xuICAgIG1hdGNoUG9zID0gdGV4dC5pbmRleE9mKHN0ciwgbWF0Y2hQb3MpO1xuICAgIGlmIChtYXRjaFBvcyAhPT0gLTEpIHtcbiAgICAgIGV4YWN0TWF0Y2hlcy5wdXNoKHtcbiAgICAgICAgc3RhcnQ6IG1hdGNoUG9zLFxuICAgICAgICBlbmQ6IG1hdGNoUG9zICsgc3RyLmxlbmd0aCxcbiAgICAgICAgZXJyb3JzOiAwLFxuICAgICAgfSk7XG4gICAgICBtYXRjaFBvcyArPSAxO1xuICAgIH1cbiAgfVxuICBpZiAoZXhhY3RNYXRjaGVzLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gZXhhY3RNYXRjaGVzO1xuICB9XG5cbiAgLy8gSWYgdGhlcmUgYXJlIG5vIGV4YWN0IG1hdGNoZXMsIGRvIGEgbW9yZSBleHBlbnNpdmUgc2VhcmNoIGZvciBtYXRjaGVzXG4gIC8vIHdpdGggZXJyb3JzLlxuICByZXR1cm4gYXBwcm94U2VhcmNoKHRleHQsIHN0ciwgbWF4RXJyb3JzKTtcbn1cblxuLyoqXG4gKiBDb21wdXRlIGEgc2NvcmUgYmV0d2VlbiAwIGFuZCAxLjAgZm9yIHRoZSBzaW1pbGFyaXR5IGJldHdlZW4gYHRleHRgIGFuZCBgc3RyYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICovXG5mdW5jdGlvbiB0ZXh0TWF0Y2hTY29yZSh0ZXh0LCBzdHIpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgLSBgc2NvcmVNYXRjaGAgd2lsbCBuZXZlciBwYXNzIGFuIGVtcHR5IHN0cmluZyAqL1xuICBpZiAoc3RyLmxlbmd0aCA9PT0gMCB8fCB0ZXh0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAwLjA7XG4gIH1cbiAgY29uc3QgbWF0Y2hlcyA9IHNlYXJjaCh0ZXh0LCBzdHIsIHN0ci5sZW5ndGgpO1xuXG4gIC8vIHByZXR0aWVyLWlnbm9yZVxuICByZXR1cm4gMSAtIChtYXRjaGVzWzBdLmVycm9ycyAvIHN0ci5sZW5ndGgpO1xufVxuXG4vKipcbiAqIEZpbmQgdGhlIGJlc3QgYXBwcm94aW1hdGUgbWF0Y2ggZm9yIGBxdW90ZWAgaW4gYHRleHRgLlxuICpcbiAqIFJldHVybnMgYG51bGxgIGlmIG5vIG1hdGNoIGV4Y2VlZGluZyB0aGUgbWluaW11bSBxdWFsaXR5IHRocmVzaG9sZCB3YXMgZm91bmQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSBEb2N1bWVudCB0ZXh0IHRvIHNlYXJjaFxuICogQHBhcmFtIHtzdHJpbmd9IHF1b3RlIC0gU3RyaW5nIHRvIGZpbmQgd2l0aGluIGB0ZXh0YFxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHQgLVxuICogICBDb250ZXh0IGluIHdoaWNoIHRoZSBxdW90ZSBvcmlnaW5hbGx5IGFwcGVhcmVkLiBUaGlzIGlzIHVzZWQgdG8gY2hvb3NlIHRoZVxuICogICBiZXN0IG1hdGNoLlxuICogICBAcGFyYW0ge3N0cmluZ30gW2NvbnRleHQucHJlZml4XSAtIEV4cGVjdGVkIHRleHQgYmVmb3JlIHRoZSBxdW90ZVxuICogICBAcGFyYW0ge3N0cmluZ30gW2NvbnRleHQuc3VmZml4XSAtIEV4cGVjdGVkIHRleHQgYWZ0ZXIgdGhlIHF1b3RlXG4gKiAgIEBwYXJhbSB7bnVtYmVyfSBbY29udGV4dC5oaW50XSAtIEV4cGVjdGVkIG9mZnNldCBvZiBtYXRjaCB3aXRoaW4gdGV4dFxuICogQHJldHVybiB7TWF0Y2h8bnVsbH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hdGNoUXVvdGUodGV4dCwgcXVvdGUsIGNvbnRleHQgPSB7fSkge1xuICBpZiAocXVvdGUubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBDaG9vc2UgdGhlIG1heGltdW0gbnVtYmVyIG9mIGVycm9ycyB0byBhbGxvdyBmb3IgdGhlIGluaXRpYWwgc2VhcmNoLlxuICAvLyBUaGlzIGNob2ljZSBpbnZvbHZlcyBhIHRyYWRlb2ZmIGJldHdlZW46XG4gIC8vXG4gIC8vICAtIFJlY2FsbCAocHJvcG9ydGlvbiBvZiBcImdvb2RcIiBtYXRjaGVzIGZvdW5kKVxuICAvLyAgLSBQcmVjaXNpb24gKHByb3BvcnRpb24gb2YgbWF0Y2hlcyBmb3VuZCB3aGljaCBhcmUgXCJnb29kXCIpXG4gIC8vICAtIENvc3Qgb2YgdGhlIGluaXRpYWwgc2VhcmNoIGFuZCBvZiBwcm9jZXNzaW5nIHRoZSBjYW5kaWRhdGUgbWF0Y2hlcyBbMV1cbiAgLy9cbiAgLy8gWzFdIFNwZWNpZmljYWxseSwgdGhlIGV4cGVjdGVkLXRpbWUgY29tcGxleGl0eSBvZiB0aGUgaW5pdGlhbCBzZWFyY2ggaXNcbiAgLy8gICAgIGBPKChtYXhFcnJvcnMgLyAzMikgKiB0ZXh0Lmxlbmd0aClgLiBTZWUgYGFwcHJveC1zdHJpbmctbWF0Y2hgIGRvY3MuXG4gIGNvbnN0IG1heEVycm9ycyA9IE1hdGgubWluKDI1NiwgcXVvdGUubGVuZ3RoIC8gMik7XG5cbiAgLy8gRmluZCBjbG9zZXN0IG1hdGNoZXMgZm9yIGBxdW90ZWAgaW4gYHRleHRgIGJhc2VkIG9uIGVkaXQgZGlzdGFuY2UuXG4gIGNvbnN0IG1hdGNoZXMgPSBzZWFyY2godGV4dCwgcXVvdGUsIG1heEVycm9ycyk7XG5cbiAgaWYgKG1hdGNoZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQ29tcHV0ZSBhIHNjb3JlIGJldHdlZW4gMCBhbmQgMS4wIGZvciBhIG1hdGNoIGNhbmRpZGF0ZS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmdNYXRjaH0gbWF0Y2hcbiAgICovXG4gIGNvbnN0IHNjb3JlTWF0Y2ggPSBtYXRjaCA9PiB7XG4gICAgY29uc3QgcXVvdGVXZWlnaHQgPSA1MDsgLy8gU2ltaWxhcml0eSBvZiBtYXRjaGVkIHRleHQgdG8gcXVvdGUuXG4gICAgY29uc3QgcHJlZml4V2VpZ2h0ID0gMjA7IC8vIFNpbWlsYXJpdHkgb2YgdGV4dCBiZWZvcmUgbWF0Y2hlZCB0ZXh0IHRvIGBjb250ZXh0LnByZWZpeGAuXG4gICAgY29uc3Qgc3VmZml4V2VpZ2h0ID0gMjA7IC8vIFNpbWlsYXJpdHkgb2YgdGV4dCBhZnRlciBtYXRjaGVkIHRleHQgdG8gYGNvbnRleHQuc3VmZml4YC5cbiAgICBjb25zdCBwb3NXZWlnaHQgPSAyOyAvLyBQcm94aW1pdHkgdG8gZXhwZWN0ZWQgbG9jYXRpb24uIFVzZWQgYXMgYSB0aWUtYnJlYWtlci5cblxuICAgIGNvbnN0IHF1b3RlU2NvcmUgPSAxIC0gbWF0Y2guZXJyb3JzIC8gcXVvdGUubGVuZ3RoO1xuXG4gICAgY29uc3QgcHJlZml4U2NvcmUgPSBjb250ZXh0LnByZWZpeFxuICAgICAgPyB0ZXh0TWF0Y2hTY29yZShcbiAgICAgICAgICB0ZXh0LnNsaWNlKE1hdGgubWF4KDAsIG1hdGNoLnN0YXJ0IC0gY29udGV4dC5wcmVmaXgubGVuZ3RoKSwgbWF0Y2guc3RhcnQpLFxuICAgICAgICAgIGNvbnRleHQucHJlZml4XG4gICAgICAgIClcbiAgICAgIDogMS4wO1xuICAgIGNvbnN0IHN1ZmZpeFNjb3JlID0gY29udGV4dC5zdWZmaXhcbiAgICAgID8gdGV4dE1hdGNoU2NvcmUoXG4gICAgICAgICAgdGV4dC5zbGljZShtYXRjaC5lbmQsIG1hdGNoLmVuZCArIGNvbnRleHQuc3VmZml4Lmxlbmd0aCksXG4gICAgICAgICAgY29udGV4dC5zdWZmaXhcbiAgICAgICAgKVxuICAgICAgOiAxLjA7XG5cbiAgICBsZXQgcG9zU2NvcmUgPSAxLjA7XG4gICAgaWYgKHR5cGVvZiBjb250ZXh0LmhpbnQgPT09ICdudW1iZXInKSB7XG4gICAgICBjb25zdCBvZmZzZXQgPSBNYXRoLmFicyhtYXRjaC5zdGFydCAtIGNvbnRleHQuaGludCk7XG4gICAgICBwb3NTY29yZSA9IDEuMCAtIG9mZnNldCAvIHRleHQubGVuZ3RoO1xuICAgIH1cblxuICAgIGNvbnN0IHJhd1Njb3JlID1cbiAgICAgIHF1b3RlV2VpZ2h0ICogcXVvdGVTY29yZSArXG4gICAgICBwcmVmaXhXZWlnaHQgKiBwcmVmaXhTY29yZSArXG4gICAgICBzdWZmaXhXZWlnaHQgKiBzdWZmaXhTY29yZSArXG4gICAgICBwb3NXZWlnaHQgKiBwb3NTY29yZTtcbiAgICBjb25zdCBtYXhTY29yZSA9IHF1b3RlV2VpZ2h0ICsgcHJlZml4V2VpZ2h0ICsgc3VmZml4V2VpZ2h0ICsgcG9zV2VpZ2h0O1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRTY29yZSA9IHJhd1Njb3JlIC8gbWF4U2NvcmU7XG5cbiAgICByZXR1cm4gbm9ybWFsaXplZFNjb3JlO1xuICB9O1xuXG4gIC8vIFJhbmsgbWF0Y2hlcyBiYXNlZCBvbiBzaW1pbGFyaXR5IG9mIGFjdHVhbCBhbmQgZXhwZWN0ZWQgc3Vycm91bmRpbmcgdGV4dFxuICAvLyBhbmQgYWN0dWFsL2V4cGVjdGVkIG9mZnNldCBpbiB0aGUgZG9jdW1lbnQgdGV4dC5cbiAgY29uc3Qgc2NvcmVkTWF0Y2hlcyA9IG1hdGNoZXMubWFwKG0gPT4gKHtcbiAgICBzdGFydDogbS5zdGFydCxcbiAgICBlbmQ6IG0uZW5kLFxuICAgIHNjb3JlOiBzY29yZU1hdGNoKG0pLFxuICB9KSk7XG5cbiAgLy8gQ2hvb3NlIG1hdGNoIHdpdGggaGlnaGVzdCBzY29yZS5cbiAgc2NvcmVkTWF0Y2hlcy5zb3J0KChhLCBiKSA9PiBiLnNjb3JlIC0gYS5zY29yZSk7XG4gIHJldHVybiBzY29yZWRNYXRjaGVzWzBdO1xufVxuIiwiLyoqXG4gKiBSZXR1cm4gdGhlIGNvbWJpbmVkIGxlbmd0aCBvZiB0ZXh0IG5vZGVzIGNvbnRhaW5lZCBpbiBgbm9kZWAuXG4gKlxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKi9cbmZ1bmN0aW9uIG5vZGVUZXh0TGVuZ3RoKG5vZGUpIHtcbiAgc3dpdGNoIChub2RlLm5vZGVUeXBlKSB7XG4gICAgY2FzZSBOb2RlLkVMRU1FTlRfTk9ERTpcbiAgICBjYXNlIE5vZGUuVEVYVF9OT0RFOlxuICAgICAgLy8gbmIuIGB0ZXh0Q29udGVudGAgZXhjbHVkZXMgdGV4dCBpbiBjb21tZW50cyBhbmQgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbnNcbiAgICAgIC8vIHdoZW4gY2FsbGVkIG9uIGEgcGFyZW50IGVsZW1lbnQsIHNvIHdlIGRvbid0IG5lZWQgdG8gc3VidHJhY3QgdGhhdCBoZXJlLlxuXG4gICAgICByZXR1cm4gLyoqIEB0eXBlIHtzdHJpbmd9ICovIChub2RlLnRleHRDb250ZW50KS5sZW5ndGg7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAwO1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSB0b3RhbCBsZW5ndGggb2YgdGhlIHRleHQgb2YgYWxsIHByZXZpb3VzIHNpYmxpbmdzIG9mIGBub2RlYC5cbiAqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAqL1xuZnVuY3Rpb24gcHJldmlvdXNTaWJsaW5nc1RleHRMZW5ndGgobm9kZSkge1xuICBsZXQgc2libGluZyA9IG5vZGUucHJldmlvdXNTaWJsaW5nO1xuICBsZXQgbGVuZ3RoID0gMDtcbiAgd2hpbGUgKHNpYmxpbmcpIHtcbiAgICBsZW5ndGggKz0gbm9kZVRleHRMZW5ndGgoc2libGluZyk7XG4gICAgc2libGluZyA9IHNpYmxpbmcucHJldmlvdXNTaWJsaW5nO1xuICB9XG4gIHJldHVybiBsZW5ndGg7XG59XG5cbi8qKlxuICogUmVzb2x2ZSBvbmUgb3IgbW9yZSBjaGFyYWN0ZXIgb2Zmc2V0cyB3aXRoaW4gYW4gZWxlbWVudCB0byAodGV4dCBub2RlLCBwb3NpdGlvbilcbiAqIHBhaXJzLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtudW1iZXJbXX0gb2Zmc2V0cyAtIE9mZnNldHMsIHdoaWNoIG11c3QgYmUgc29ydGVkIGluIGFzY2VuZGluZyBvcmRlclxuICogQHJldHVybiB7eyBub2RlOiBUZXh0LCBvZmZzZXQ6IG51bWJlciB9W119XG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVPZmZzZXRzKGVsZW1lbnQsIC4uLm9mZnNldHMpIHtcbiAgbGV0IG5leHRPZmZzZXQgPSBvZmZzZXRzLnNoaWZ0KCk7XG4gIGNvbnN0IG5vZGVJdGVyID0gLyoqIEB0eXBlIHtEb2N1bWVudH0gKi8gKFxuICAgIGVsZW1lbnQub3duZXJEb2N1bWVudFxuICApLmNyZWF0ZU5vZGVJdGVyYXRvcihlbGVtZW50LCBOb2RlRmlsdGVyLlNIT1dfVEVYVCk7XG4gIGNvbnN0IHJlc3VsdHMgPSBbXTtcblxuICBsZXQgY3VycmVudE5vZGUgPSBub2RlSXRlci5uZXh0Tm9kZSgpO1xuICBsZXQgdGV4dE5vZGU7XG4gIGxldCBsZW5ndGggPSAwO1xuXG4gIC8vIEZpbmQgdGhlIHRleHQgbm9kZSBjb250YWluaW5nIHRoZSBgbmV4dE9mZnNldGB0aCBjaGFyYWN0ZXIgZnJvbSB0aGUgc3RhcnRcbiAgLy8gb2YgYGVsZW1lbnRgLlxuICB3aGlsZSAobmV4dE9mZnNldCAhPT0gdW5kZWZpbmVkICYmIGN1cnJlbnROb2RlKSB7XG4gICAgdGV4dE5vZGUgPSAvKiogQHR5cGUge1RleHR9ICovIChjdXJyZW50Tm9kZSk7XG4gICAgaWYgKGxlbmd0aCArIHRleHROb2RlLmRhdGEubGVuZ3RoID4gbmV4dE9mZnNldCkge1xuICAgICAgcmVzdWx0cy5wdXNoKHsgbm9kZTogdGV4dE5vZGUsIG9mZnNldDogbmV4dE9mZnNldCAtIGxlbmd0aCB9KTtcbiAgICAgIG5leHRPZmZzZXQgPSBvZmZzZXRzLnNoaWZ0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnROb2RlID0gbm9kZUl0ZXIubmV4dE5vZGUoKTtcbiAgICAgIGxlbmd0aCArPSB0ZXh0Tm9kZS5kYXRhLmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICAvLyBCb3VuZGFyeSBjYXNlLlxuICB3aGlsZSAobmV4dE9mZnNldCAhPT0gdW5kZWZpbmVkICYmIHRleHROb2RlICYmIGxlbmd0aCA9PT0gbmV4dE9mZnNldCkge1xuICAgIHJlc3VsdHMucHVzaCh7IG5vZGU6IHRleHROb2RlLCBvZmZzZXQ6IHRleHROb2RlLmRhdGEubGVuZ3RoIH0pO1xuICAgIG5leHRPZmZzZXQgPSBvZmZzZXRzLnNoaWZ0KCk7XG4gIH1cblxuICBpZiAobmV4dE9mZnNldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ09mZnNldCBleGNlZWRzIHRleHQgbGVuZ3RoJyk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0cztcbn1cblxuZXhwb3J0IGxldCBSRVNPTFZFX0ZPUldBUkRTID0gMTtcbmV4cG9ydCBsZXQgUkVTT0xWRV9CQUNLV0FSRFMgPSAyO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYW4gb2Zmc2V0IHdpdGhpbiB0aGUgdGV4dCBjb250ZW50IG9mIGFuIGVsZW1lbnQuXG4gKlxuICogVGhpcyBwb3NpdGlvbiBjYW4gYmUgcmVzb2x2ZWQgdG8gYSBzcGVjaWZpYyBkZXNjZW5kYW50IG5vZGUgaW4gdGhlIGN1cnJlbnRcbiAqIERPTSBzdWJ0cmVlIG9mIHRoZSBlbGVtZW50IHVzaW5nIHRoZSBgcmVzb2x2ZWAgbWV0aG9kLlxuICovXG5leHBvcnQgY2xhc3MgVGV4dFBvc2l0aW9uIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIGBUZXh0UG9zaXRpb25gIHRoYXQgcmVmZXJzIHRvIHRoZSB0ZXh0IHBvc2l0aW9uIGBvZmZzZXRgIHdpdGhpblxuICAgKiB0aGUgdGV4dCBjb250ZW50IG9mIGBlbGVtZW50YC5cbiAgICpcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICovXG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQsIG9mZnNldCkge1xuICAgIGlmIChvZmZzZXQgPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ09mZnNldCBpcyBpbnZhbGlkJyk7XG4gICAgfVxuXG4gICAgLyoqIEVsZW1lbnQgdGhhdCBgb2Zmc2V0YCBpcyByZWxhdGl2ZSB0by4gKi9cbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuXG4gICAgLyoqIENoYXJhY3RlciBvZmZzZXQgZnJvbSB0aGUgc3RhcnQgb2YgdGhlIGVsZW1lbnQncyBgdGV4dENvbnRlbnRgLiAqL1xuICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhIGNvcHkgb2YgdGhpcyBwb3NpdGlvbiB3aXRoIG9mZnNldCByZWxhdGl2ZSB0byBhIGdpdmVuIGFuY2VzdG9yXG4gICAqIGVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gcGFyZW50IC0gQW5jZXN0b3Igb2YgYHRoaXMuZWxlbWVudGBcbiAgICogQHJldHVybiB7VGV4dFBvc2l0aW9ufVxuICAgKi9cbiAgcmVsYXRpdmVUbyhwYXJlbnQpIHtcbiAgICBpZiAoIXBhcmVudC5jb250YWlucyh0aGlzLmVsZW1lbnQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhcmVudCBpcyBub3QgYW4gYW5jZXN0b3Igb2YgY3VycmVudCBlbGVtZW50Jyk7XG4gICAgfVxuXG4gICAgbGV0IGVsID0gdGhpcy5lbGVtZW50O1xuICAgIGxldCBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICB3aGlsZSAoZWwgIT09IHBhcmVudCkge1xuICAgICAgb2Zmc2V0ICs9IHByZXZpb3VzU2libGluZ3NUZXh0TGVuZ3RoKGVsKTtcbiAgICAgIGVsID0gLyoqIEB0eXBlIHtFbGVtZW50fSAqLyAoZWwucGFyZW50RWxlbWVudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBUZXh0UG9zaXRpb24oZWwsIG9mZnNldCk7XG4gIH1cblxuICAvKipcbiAgICogUmVzb2x2ZSB0aGUgcG9zaXRpb24gdG8gYSBzcGVjaWZpYyB0ZXh0IG5vZGUgYW5kIG9mZnNldCB3aXRoaW4gdGhhdCBub2RlLlxuICAgKlxuICAgKiBUaHJvd3MgaWYgYHRoaXMub2Zmc2V0YCBleGNlZWRzIHRoZSBsZW5ndGggb2YgdGhlIGVsZW1lbnQncyB0ZXh0LiBJbiB0aGVcbiAgICogY2FzZSB3aGVyZSB0aGUgZWxlbWVudCBoYXMgbm8gdGV4dCBhbmQgYHRoaXMub2Zmc2V0YCBpcyAwLCB0aGUgYGRpcmVjdGlvbmBcbiAgICogb3B0aW9uIGRldGVybWluZXMgd2hhdCBoYXBwZW5zLlxuICAgKlxuICAgKiBPZmZzZXRzIGF0IHRoZSBib3VuZGFyeSBiZXR3ZWVuIHR3byBub2RlcyBhcmUgcmVzb2x2ZWQgdG8gdGhlIHN0YXJ0IG9mIHRoZVxuICAgKiBub2RlIHRoYXQgYmVnaW5zIGF0IHRoZSBib3VuZGFyeS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgIEBwYXJhbSB7UkVTT0xWRV9GT1JXQVJEU3xSRVNPTFZFX0JBQ0tXQVJEU30gW29wdGlvbnMuZGlyZWN0aW9uXSAtXG4gICAqICAgICBTcGVjaWZpZXMgaW4gd2hpY2ggZGlyZWN0aW9uIHRvIHNlYXJjaCBmb3IgdGhlIG5lYXJlc3QgdGV4dCBub2RlIGlmXG4gICAqICAgICBgdGhpcy5vZmZzZXRgIGlzIGAwYCBhbmQgYHRoaXMuZWxlbWVudGAgaGFzIG5vIHRleHQuIElmIG5vdCBzcGVjaWZpZWRcbiAgICogICAgIGFuIGVycm9yIGlzIHRocm93bi5cbiAgICogQHJldHVybiB7eyBub2RlOiBUZXh0LCBvZmZzZXQ6IG51bWJlciB9fVxuICAgKiBAdGhyb3dzIHtSYW5nZUVycm9yfVxuICAgKi9cbiAgcmVzb2x2ZShvcHRpb25zID0ge30pIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHJlc29sdmVPZmZzZXRzKHRoaXMuZWxlbWVudCwgdGhpcy5vZmZzZXQpWzBdO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKHRoaXMub2Zmc2V0ID09PSAwICYmIG9wdGlvbnMuZGlyZWN0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgdHcgPSBkb2N1bWVudC5jcmVhdGVUcmVlV2Fsa2VyKFxuICAgICAgICAgIHRoaXMuZWxlbWVudC5nZXRSb290Tm9kZSgpLFxuICAgICAgICAgIE5vZGVGaWx0ZXIuU0hPV19URVhUXG4gICAgICAgICk7XG4gICAgICAgIHR3LmN1cnJlbnROb2RlID0gdGhpcy5lbGVtZW50O1xuICAgICAgICBjb25zdCBmb3J3YXJkcyA9IG9wdGlvbnMuZGlyZWN0aW9uID09PSBSRVNPTFZFX0ZPUldBUkRTO1xuICAgICAgICBjb25zdCB0ZXh0ID0gLyoqIEB0eXBlIHtUZXh0fG51bGx9ICovIChcbiAgICAgICAgICBmb3J3YXJkcyA/IHR3Lm5leHROb2RlKCkgOiB0dy5wcmV2aW91c05vZGUoKVxuICAgICAgICApO1xuICAgICAgICBpZiAoIXRleHQpIHtcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgbm9kZTogdGV4dCwgb2Zmc2V0OiBmb3J3YXJkcyA/IDAgOiB0ZXh0LmRhdGEubGVuZ3RoIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIGBUZXh0UG9zaXRpb25gIHRoYXQgcmVmZXJzIHRvIHRoZSBgb2Zmc2V0YHRoIGNoYXJhY3RlciB3aXRoaW5cbiAgICogYG5vZGVgLlxuICAgKlxuICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgKiBAcmV0dXJuIHtUZXh0UG9zaXRpb259XG4gICAqL1xuICBzdGF0aWMgZnJvbUNoYXJPZmZzZXQobm9kZSwgb2Zmc2V0KSB7XG4gICAgc3dpdGNoIChub2RlLm5vZGVUeXBlKSB7XG4gICAgICBjYXNlIE5vZGUuVEVYVF9OT0RFOlxuICAgICAgICByZXR1cm4gVGV4dFBvc2l0aW9uLmZyb21Qb2ludChub2RlLCBvZmZzZXQpO1xuICAgICAgY2FzZSBOb2RlLkVMRU1FTlRfTk9ERTpcbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0UG9zaXRpb24oLyoqIEB0eXBlIHtFbGVtZW50fSAqLyAobm9kZSksIG9mZnNldCk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vZGUgaXMgbm90IGFuIGVsZW1lbnQgb3IgdGV4dCBub2RlJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIGBUZXh0UG9zaXRpb25gIHJlcHJlc2VudGluZyB0aGUgcmFuZ2Ugc3RhcnQgb3IgZW5kIHBvaW50IChub2RlLCBvZmZzZXQpLlxuICAgKlxuICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgLSBUZXh0IG9yIEVsZW1lbnQgbm9kZVxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IC0gT2Zmc2V0IHdpdGhpbiB0aGUgbm9kZS5cbiAgICogQHJldHVybiB7VGV4dFBvc2l0aW9ufVxuICAgKi9cbiAgc3RhdGljIGZyb21Qb2ludChub2RlLCBvZmZzZXQpIHtcbiAgICBzd2l0Y2ggKG5vZGUubm9kZVR5cGUpIHtcbiAgICAgIGNhc2UgTm9kZS5URVhUX05PREU6IHtcbiAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ID4gLyoqIEB0eXBlIHtUZXh0fSAqLyAobm9kZSkuZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RleHQgbm9kZSBvZmZzZXQgaXMgb3V0IG9mIHJhbmdlJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW5vZGUucGFyZW50RWxlbWVudCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGV4dCBub2RlIGhhcyBubyBwYXJlbnQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdldCB0aGUgb2Zmc2V0IGZyb20gdGhlIHN0YXJ0IG9mIHRoZSBwYXJlbnQgZWxlbWVudC5cbiAgICAgICAgY29uc3QgdGV4dE9mZnNldCA9IHByZXZpb3VzU2libGluZ3NUZXh0TGVuZ3RoKG5vZGUpICsgb2Zmc2V0O1xuXG4gICAgICAgIHJldHVybiBuZXcgVGV4dFBvc2l0aW9uKG5vZGUucGFyZW50RWxlbWVudCwgdGV4dE9mZnNldCk7XG4gICAgICB9XG4gICAgICBjYXNlIE5vZGUuRUxFTUVOVF9OT0RFOiB7XG4gICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCA+IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NoaWxkIG5vZGUgb2Zmc2V0IGlzIG91dCBvZiByYW5nZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gR2V0IHRoZSB0ZXh0IGxlbmd0aCBiZWZvcmUgdGhlIGBvZmZzZXRgdGggY2hpbGQgb2YgZWxlbWVudC5cbiAgICAgICAgbGV0IHRleHRPZmZzZXQgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9mZnNldDsgaSsrKSB7XG4gICAgICAgICAgdGV4dE9mZnNldCArPSBub2RlVGV4dExlbmd0aChub2RlLmNoaWxkTm9kZXNbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0UG9zaXRpb24oLyoqIEB0eXBlIHtFbGVtZW50fSAqLyAobm9kZSksIHRleHRPZmZzZXQpO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb2ludCBpcyBub3QgaW4gYW4gZWxlbWVudCBvciB0ZXh0IG5vZGUnKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgcmVnaW9uIG9mIGEgZG9jdW1lbnQgYXMgYSAoc3RhcnQsIGVuZCkgcGFpciBvZiBgVGV4dFBvc2l0aW9uYCBwb2ludHMuXG4gKlxuICogUmVwcmVzZW50aW5nIGEgcmFuZ2UgaW4gdGhpcyB3YXkgYWxsb3dzIGZvciBjaGFuZ2VzIGluIHRoZSBET00gY29udGVudCBvZiB0aGVcbiAqIHJhbmdlIHdoaWNoIGRvbid0IGFmZmVjdCBpdHMgdGV4dCBjb250ZW50LCB3aXRob3V0IGFmZmVjdGluZyB0aGUgdGV4dCBjb250ZW50XG4gKiBvZiB0aGUgcmFuZ2UgaXRzZWxmLlxuICovXG5leHBvcnQgY2xhc3MgVGV4dFJhbmdlIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhbiBpbW11dGFibGUgYFRleHRSYW5nZWAgZnJvbSBhIGBzdGFydGAgYW5kIGBlbmRgIHBvaW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1RleHRQb3NpdGlvbn0gc3RhcnRcbiAgICogQHBhcmFtIHtUZXh0UG9zaXRpb259IGVuZFxuICAgKi9cbiAgY29uc3RydWN0b3Ioc3RhcnQsIGVuZCkge1xuICAgIHRoaXMuc3RhcnQgPSBzdGFydDtcbiAgICB0aGlzLmVuZCA9IGVuZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBjb3B5IG9mIHRoaXMgcmFuZ2Ugd2l0aCBzdGFydCBhbmQgZW5kIHBvc2l0aW9ucyByZWxhdGl2ZSB0byBhXG4gICAqIGdpdmVuIGFuY2VzdG9yLiBTZWUgYFRleHRQb3NpdGlvbi5yZWxhdGl2ZVRvYC5cbiAgICpcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gICAqL1xuICByZWxhdGl2ZVRvKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gbmV3IFRleHRSYW5nZShcbiAgICAgIHRoaXMuc3RhcnQucmVsYXRpdmVUbyhlbGVtZW50KSxcbiAgICAgIHRoaXMuZW5kLnJlbGF0aXZlVG8oZWxlbWVudClcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc29sdmUgdGhlIGBUZXh0UmFuZ2VgIHRvIGEgRE9NIHJhbmdlLlxuICAgKlxuICAgKiBUaGUgcmVzdWx0aW5nIERPTSBSYW5nZSB3aWxsIGFsd2F5cyBzdGFydCBhbmQgZW5kIGluIGEgYFRleHRgIG5vZGUuXG4gICAqIEhlbmNlIGBUZXh0UmFuZ2UuZnJvbVJhbmdlKHJhbmdlKS50b1JhbmdlKClgIGNhbiBiZSB1c2VkIHRvIFwic2hyaW5rXCIgYVxuICAgKiByYW5nZSB0byB0aGUgdGV4dCBpdCBjb250YWlucy5cbiAgICpcbiAgICogTWF5IHRocm93IGlmIHRoZSBgc3RhcnRgIG9yIGBlbmRgIHBvc2l0aW9ucyBjYW5ub3QgYmUgcmVzb2x2ZWQgdG8gYSByYW5nZS5cbiAgICpcbiAgICogQHJldHVybiB7UmFuZ2V9XG4gICAqL1xuICB0b1JhbmdlKCkge1xuICAgIGxldCBzdGFydDtcbiAgICBsZXQgZW5kO1xuXG4gICAgaWYgKFxuICAgICAgdGhpcy5zdGFydC5lbGVtZW50ID09PSB0aGlzLmVuZC5lbGVtZW50ICYmXG4gICAgICB0aGlzLnN0YXJ0Lm9mZnNldCA8PSB0aGlzLmVuZC5vZmZzZXRcbiAgICApIHtcbiAgICAgIC8vIEZhc3QgcGF0aCBmb3Igc3RhcnQgYW5kIGVuZCBwb2ludHMgaW4gc2FtZSBlbGVtZW50LlxuICAgICAgW3N0YXJ0LCBlbmRdID0gcmVzb2x2ZU9mZnNldHMoXG4gICAgICAgIHRoaXMuc3RhcnQuZWxlbWVudCxcbiAgICAgICAgdGhpcy5zdGFydC5vZmZzZXQsXG4gICAgICAgIHRoaXMuZW5kLm9mZnNldFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhcnQgPSB0aGlzLnN0YXJ0LnJlc29sdmUoeyBkaXJlY3Rpb246IFJFU09MVkVfRk9SV0FSRFMgfSk7XG4gICAgICBlbmQgPSB0aGlzLmVuZC5yZXNvbHZlKHsgZGlyZWN0aW9uOiBSRVNPTFZFX0JBQ0tXQVJEUyB9KTtcbiAgICB9XG5cbiAgICBjb25zdCByYW5nZSA9IG5ldyBSYW5nZSgpO1xuICAgIHJhbmdlLnNldFN0YXJ0KHN0YXJ0Lm5vZGUsIHN0YXJ0Lm9mZnNldCk7XG4gICAgcmFuZ2Uuc2V0RW5kKGVuZC5ub2RlLCBlbmQub2Zmc2V0KTtcbiAgICByZXR1cm4gcmFuZ2U7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCBhbiBleGlzdGluZyBET00gYFJhbmdlYCB0byBhIGBUZXh0UmFuZ2VgXG4gICAqXG4gICAqIEBwYXJhbSB7UmFuZ2V9IHJhbmdlXG4gICAqIEByZXR1cm4ge1RleHRSYW5nZX1cbiAgICovXG4gIHN0YXRpYyBmcm9tUmFuZ2UocmFuZ2UpIHtcbiAgICBjb25zdCBzdGFydCA9IFRleHRQb3NpdGlvbi5mcm9tUG9pbnQoXG4gICAgICByYW5nZS5zdGFydENvbnRhaW5lcixcbiAgICAgIHJhbmdlLnN0YXJ0T2Zmc2V0XG4gICAgKTtcbiAgICBjb25zdCBlbmQgPSBUZXh0UG9zaXRpb24uZnJvbVBvaW50KHJhbmdlLmVuZENvbnRhaW5lciwgcmFuZ2UuZW5kT2Zmc2V0KTtcbiAgICByZXR1cm4gbmV3IFRleHRSYW5nZShzdGFydCwgZW5kKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBgVGV4dFJhbmdlYCBmcm9tIHRoZSBgc3RhcnRgdGggdG8gYGVuZGB0aCBjaGFyYWN0ZXJzIGluIGByb290YC5cbiAgICpcbiAgICogQHBhcmFtIHtFbGVtZW50fSByb290XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydFxuICAgKiBAcGFyYW0ge251bWJlcn0gZW5kXG4gICAqL1xuICBzdGF0aWMgZnJvbU9mZnNldHMocm9vdCwgc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiBuZXcgVGV4dFJhbmdlKFxuICAgICAgbmV3IFRleHRQb3NpdGlvbihyb290LCBzdGFydCksXG4gICAgICBuZXcgVGV4dFBvc2l0aW9uKHJvb3QsIGVuZClcbiAgICApO1xuICB9XG59XG4iLCIvKipcbiAqIFRoaXMgbW9kdWxlIGV4cG9ydHMgYSBzZXQgb2YgY2xhc3NlcyBmb3IgY29udmVydGluZyBiZXR3ZWVuIERPTSBgUmFuZ2VgXG4gKiBvYmplY3RzIGFuZCBkaWZmZXJlbnQgdHlwZXMgb2Ygc2VsZWN0b3JzLiBJdCBpcyBtb3N0bHkgYSB0aGluIHdyYXBwZXIgYXJvdW5kIGFcbiAqIHNldCBvZiBhbmNob3JpbmcgbGlicmFyaWVzLiBJdCBzZXJ2ZXMgdHdvIG1haW4gcHVycG9zZXM6XG4gKlxuICogIDEuIFByb3ZpZGluZyBhIGNvbnNpc3RlbnQgaW50ZXJmYWNlIGFjcm9zcyBkaWZmZXJlbnQgdHlwZXMgb2YgYW5jaG9ycy5cbiAqICAyLiBJbnN1bGF0aW5nIHRoZSByZXN0IG9mIHRoZSBjb2RlIGZyb20gQVBJIGNoYW5nZXMgaW4gdGhlIHVuZGVybHlpbmcgYW5jaG9yaW5nXG4gKiAgICAgbGlicmFyaWVzLlxuICovXG5cbmltcG9ydCB7IG1hdGNoUXVvdGUgfSBmcm9tICcuL21hdGNoLXF1b3RlJztcbmltcG9ydCB7IFRleHRSYW5nZSwgVGV4dFBvc2l0aW9uIH0gZnJvbSAnLi90ZXh0LXJhbmdlJztcbmltcG9ydCB7IG5vZGVGcm9tWFBhdGgsIHhwYXRoRnJvbU5vZGUgfSBmcm9tICcuL3hwYXRoJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi8uLi90eXBlcy9hcGknKS5SYW5nZVNlbGVjdG9yfSBSYW5nZVNlbGVjdG9yXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi8uLi90eXBlcy9hcGknKS5UZXh0UG9zaXRpb25TZWxlY3Rvcn0gVGV4dFBvc2l0aW9uU2VsZWN0b3JcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4uLy4uL3R5cGVzL2FwaScpLlRleHRRdW90ZVNlbGVjdG9yfSBUZXh0UXVvdGVTZWxlY3RvclxuICovXG5cbi8qKlxuICogQ29udmVydHMgYmV0d2VlbiBgUmFuZ2VTZWxlY3RvcmAgc2VsZWN0b3JzIGFuZCBgUmFuZ2VgIG9iamVjdHMuXG4gKi9cbmV4cG9ydCBjbGFzcyBSYW5nZUFuY2hvciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge05vZGV9IHJvb3QgLSBBIHJvb3QgZWxlbWVudCBmcm9tIHdoaWNoIHRvIGFuY2hvci5cbiAgICogQHBhcmFtIHtSYW5nZX0gcmFuZ2UgLSAgQSByYW5nZSBkZXNjcmliaW5nIHRoZSBhbmNob3IuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihyb290LCByYW5nZSkge1xuICAgIHRoaXMucm9vdCA9IHJvb3Q7XG4gICAgdGhpcy5yYW5nZSA9IHJhbmdlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Tm9kZX0gcm9vdCAtICBBIHJvb3QgZWxlbWVudCBmcm9tIHdoaWNoIHRvIGFuY2hvci5cbiAgICogQHBhcmFtIHtSYW5nZX0gcmFuZ2UgLSAgQSByYW5nZSBkZXNjcmliaW5nIHRoZSBhbmNob3IuXG4gICAqL1xuICBzdGF0aWMgZnJvbVJhbmdlKHJvb3QsIHJhbmdlKSB7XG4gICAgcmV0dXJuIG5ldyBSYW5nZUFuY2hvcihyb290LCByYW5nZSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGFuY2hvciBmcm9tIGEgc2VyaWFsaXplZCBgUmFuZ2VTZWxlY3RvcmAgc2VsZWN0b3IuXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gcm9vdCAtICBBIHJvb3QgZWxlbWVudCBmcm9tIHdoaWNoIHRvIGFuY2hvci5cbiAgICogQHBhcmFtIHtSYW5nZVNlbGVjdG9yfSBzZWxlY3RvclxuICAgKi9cbiAgc3RhdGljIGZyb21TZWxlY3Rvcihyb290LCBzZWxlY3Rvcikge1xuICAgIGNvbnN0IHN0YXJ0Q29udGFpbmVyID0gbm9kZUZyb21YUGF0aChzZWxlY3Rvci5zdGFydENvbnRhaW5lciwgcm9vdCk7XG4gICAgaWYgKCFzdGFydENvbnRhaW5lcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gcmVzb2x2ZSBzdGFydENvbnRhaW5lciBYUGF0aCcpO1xuICAgIH1cblxuICAgIGNvbnN0IGVuZENvbnRhaW5lciA9IG5vZGVGcm9tWFBhdGgoc2VsZWN0b3IuZW5kQ29udGFpbmVyLCByb290KTtcbiAgICBpZiAoIWVuZENvbnRhaW5lcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gcmVzb2x2ZSBlbmRDb250YWluZXIgWFBhdGgnKTtcbiAgICB9XG5cbiAgICBjb25zdCBzdGFydFBvcyA9IFRleHRQb3NpdGlvbi5mcm9tQ2hhck9mZnNldChcbiAgICAgIHN0YXJ0Q29udGFpbmVyLFxuICAgICAgc2VsZWN0b3Iuc3RhcnRPZmZzZXRcbiAgICApO1xuICAgIGNvbnN0IGVuZFBvcyA9IFRleHRQb3NpdGlvbi5mcm9tQ2hhck9mZnNldChcbiAgICAgIGVuZENvbnRhaW5lcixcbiAgICAgIHNlbGVjdG9yLmVuZE9mZnNldFxuICAgICk7XG5cbiAgICBjb25zdCByYW5nZSA9IG5ldyBUZXh0UmFuZ2Uoc3RhcnRQb3MsIGVuZFBvcykudG9SYW5nZSgpO1xuICAgIHJldHVybiBuZXcgUmFuZ2VBbmNob3Iocm9vdCwgcmFuZ2UpO1xuICB9XG5cbiAgdG9SYW5nZSgpIHtcbiAgICByZXR1cm4gdGhpcy5yYW5nZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtSYW5nZVNlbGVjdG9yfVxuICAgKi9cbiAgdG9TZWxlY3RvcigpIHtcbiAgICAvLyBcIlNocmlua1wiIHRoZSByYW5nZSBzbyB0aGF0IGl0IHRpZ2h0bHkgd3JhcHMgaXRzIHRleHQuIFRoaXMgZW5zdXJlcyBtb3JlXG4gICAgLy8gcHJlZGljdGFibGUgb3V0cHV0IGZvciBhIGdpdmVuIHRleHQgc2VsZWN0aW9uLlxuICAgIGNvbnN0IG5vcm1hbGl6ZWRSYW5nZSA9IFRleHRSYW5nZS5mcm9tUmFuZ2UodGhpcy5yYW5nZSkudG9SYW5nZSgpO1xuXG4gICAgY29uc3QgdGV4dFJhbmdlID0gVGV4dFJhbmdlLmZyb21SYW5nZShub3JtYWxpemVkUmFuZ2UpO1xuICAgIGNvbnN0IHN0YXJ0Q29udGFpbmVyID0geHBhdGhGcm9tTm9kZSh0ZXh0UmFuZ2Uuc3RhcnQuZWxlbWVudCwgdGhpcy5yb290KTtcbiAgICBjb25zdCBlbmRDb250YWluZXIgPSB4cGF0aEZyb21Ob2RlKHRleHRSYW5nZS5lbmQuZWxlbWVudCwgdGhpcy5yb290KTtcblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnUmFuZ2VTZWxlY3RvcicsXG4gICAgICBzdGFydENvbnRhaW5lcixcbiAgICAgIHN0YXJ0T2Zmc2V0OiB0ZXh0UmFuZ2Uuc3RhcnQub2Zmc2V0LFxuICAgICAgZW5kQ29udGFpbmVyLFxuICAgICAgZW5kT2Zmc2V0OiB0ZXh0UmFuZ2UuZW5kLm9mZnNldCxcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogQ29udmVydHMgYmV0d2VlbiBgVGV4dFBvc2l0aW9uU2VsZWN0b3JgIHNlbGVjdG9ycyBhbmQgYFJhbmdlYCBvYmplY3RzLlxuICovXG5leHBvcnQgY2xhc3MgVGV4dFBvc2l0aW9uQW5jaG9yIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gcm9vdFxuICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRcbiAgICogQHBhcmFtIHtudW1iZXJ9IGVuZFxuICAgKi9cbiAgY29uc3RydWN0b3Iocm9vdCwgc3RhcnQsIGVuZCkge1xuICAgIHRoaXMucm9vdCA9IHJvb3Q7XG4gICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgIHRoaXMuZW5kID0gZW5kO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gcm9vdFxuICAgKiBAcGFyYW0ge1JhbmdlfSByYW5nZVxuICAgKi9cbiAgc3RhdGljIGZyb21SYW5nZShyb290LCByYW5nZSkge1xuICAgIGNvbnN0IHRleHRSYW5nZSA9IFRleHRSYW5nZS5mcm9tUmFuZ2UocmFuZ2UpLnJlbGF0aXZlVG8ocm9vdCk7XG4gICAgcmV0dXJuIG5ldyBUZXh0UG9zaXRpb25BbmNob3IoXG4gICAgICByb290LFxuICAgICAgdGV4dFJhbmdlLnN0YXJ0Lm9mZnNldCxcbiAgICAgIHRleHRSYW5nZS5lbmQub2Zmc2V0XG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSByb290XG4gICAqIEBwYXJhbSB7VGV4dFBvc2l0aW9uU2VsZWN0b3J9IHNlbGVjdG9yXG4gICAqL1xuICBzdGF0aWMgZnJvbVNlbGVjdG9yKHJvb3QsIHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIG5ldyBUZXh0UG9zaXRpb25BbmNob3Iocm9vdCwgc2VsZWN0b3Iuc3RhcnQsIHNlbGVjdG9yLmVuZCk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7VGV4dFBvc2l0aW9uU2VsZWN0b3J9XG4gICAqL1xuICB0b1NlbGVjdG9yKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnVGV4dFBvc2l0aW9uU2VsZWN0b3InLFxuICAgICAgc3RhcnQ6IHRoaXMuc3RhcnQsXG4gICAgICBlbmQ6IHRoaXMuZW5kLFxuICAgIH07XG4gIH1cblxuICB0b1JhbmdlKCkge1xuICAgIHJldHVybiBUZXh0UmFuZ2UuZnJvbU9mZnNldHModGhpcy5yb290LCB0aGlzLnN0YXJ0LCB0aGlzLmVuZCkudG9SYW5nZSgpO1xuICB9XG59XG5cbi8qKlxuICogQHR5cGVkZWYgUXVvdGVNYXRjaE9wdGlvbnNcbiAqIEBwcm9wIHtudW1iZXJ9IFtoaW50XSAtIEV4cGVjdGVkIHBvc2l0aW9uIG9mIG1hdGNoIGluIHRleHQuIFNlZSBgbWF0Y2hRdW90ZWAuXG4gKi9cblxuLyoqXG4gKiBDb252ZXJ0cyBiZXR3ZWVuIGBUZXh0UXVvdGVTZWxlY3RvcmAgc2VsZWN0b3JzIGFuZCBgUmFuZ2VgIG9iamVjdHMuXG4gKi9cbmV4cG9ydCBjbGFzcyBUZXh0UXVvdGVBbmNob3Ige1xuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSByb290IC0gQSByb290IGVsZW1lbnQgZnJvbSB3aGljaCB0byBhbmNob3IuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBleGFjdFxuICAgKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICAgKiAgIEBwYXJhbSB7c3RyaW5nfSBbY29udGV4dC5wcmVmaXhdXG4gICAqICAgQHBhcmFtIHtzdHJpbmd9IFtjb250ZXh0LnN1ZmZpeF1cbiAgICovXG4gIGNvbnN0cnVjdG9yKHJvb3QsIGV4YWN0LCBjb250ZXh0ID0ge30pIHtcbiAgICB0aGlzLnJvb3QgPSByb290O1xuICAgIHRoaXMuZXhhY3QgPSBleGFjdDtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGBUZXh0UXVvdGVBbmNob3JgIGZyb20gYSByYW5nZS5cbiAgICpcbiAgICogV2lsbCB0aHJvdyBpZiBgcmFuZ2VgIGRvZXMgbm90IGNvbnRhaW4gYW55IHRleHQgbm9kZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gcm9vdFxuICAgKiBAcGFyYW0ge1JhbmdlfSByYW5nZVxuICAgKi9cbiAgc3RhdGljIGZyb21SYW5nZShyb290LCByYW5nZSkge1xuICAgIGNvbnN0IHRleHQgPSAvKiogQHR5cGUge3N0cmluZ30gKi8gKHJvb3QudGV4dENvbnRlbnQpO1xuICAgIGNvbnN0IHRleHRSYW5nZSA9IFRleHRSYW5nZS5mcm9tUmFuZ2UocmFuZ2UpLnJlbGF0aXZlVG8ocm9vdCk7XG5cbiAgICBjb25zdCBzdGFydCA9IHRleHRSYW5nZS5zdGFydC5vZmZzZXQ7XG4gICAgY29uc3QgZW5kID0gdGV4dFJhbmdlLmVuZC5vZmZzZXQ7XG5cbiAgICAvLyBOdW1iZXIgb2YgY2hhcmFjdGVycyBhcm91bmQgdGhlIHF1b3RlIHRvIGNhcHR1cmUgYXMgY29udGV4dC4gV2UgY3VycmVudGx5XG4gICAgLy8gYWx3YXlzIHVzZSBhIGZpeGVkIGFtb3VudCwgYnV0IGl0IHdvdWxkIGJlIGJldHRlciBpZiB0aGlzIGNvZGUgd2FzIGF3YXJlXG4gICAgLy8gb2YgbG9naWNhbCBib3VuZGFyaWVzIGluIHRoZSBkb2N1bWVudCAocGFyYWdyYXBoLCBhcnRpY2xlIGV0Yy4pIHRvIGF2b2lkXG4gICAgLy8gY2FwdHVyaW5nIHRleHQgdW5yZWxhdGVkIHRvIHRoZSBxdW90ZS5cbiAgICAvL1xuICAgIC8vIEluIHJlZ3VsYXIgcHJvc2UgdGhlIGlkZWFsIGNvbnRlbnQgd291bGQgb2Z0ZW4gYmUgdGhlIHN1cnJvdW5kaW5nIHNlbnRlbmNlLlxuICAgIC8vIFRoaXMgaXMgYSBuYXR1cmFsIHVuaXQgb2YgbWVhbmluZyB3aGljaCBlbmFibGVzIGRpc3BsYXlpbmcgcXVvdGVzIGluXG4gICAgLy8gY29udGV4dCBldmVuIHdoZW4gdGhlIGRvY3VtZW50IGlzIG5vdCBhdmFpbGFibGUuIFdlIGNvdWxkIHVzZSBgSW50bC5TZWdtZW50ZXJgXG4gICAgLy8gZm9yIHRoaXMgd2hlbiBhdmFpbGFibGUuXG4gICAgY29uc3QgY29udGV4dExlbiA9IDMyO1xuXG4gICAgcmV0dXJuIG5ldyBUZXh0UXVvdGVBbmNob3Iocm9vdCwgdGV4dC5zbGljZShzdGFydCwgZW5kKSwge1xuICAgICAgcHJlZml4OiB0ZXh0LnNsaWNlKE1hdGgubWF4KDAsIHN0YXJ0IC0gY29udGV4dExlbiksIHN0YXJ0KSxcbiAgICAgIHN1ZmZpeDogdGV4dC5zbGljZShlbmQsIE1hdGgubWluKHRleHQubGVuZ3RoLCBlbmQgKyBjb250ZXh0TGVuKSksXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSByb290XG4gICAqIEBwYXJhbSB7VGV4dFF1b3RlU2VsZWN0b3J9IHNlbGVjdG9yXG4gICAqL1xuICBzdGF0aWMgZnJvbVNlbGVjdG9yKHJvb3QsIHNlbGVjdG9yKSB7XG4gICAgY29uc3QgeyBwcmVmaXgsIHN1ZmZpeCB9ID0gc2VsZWN0b3I7XG4gICAgcmV0dXJuIG5ldyBUZXh0UXVvdGVBbmNob3Iocm9vdCwgc2VsZWN0b3IuZXhhY3QsIHsgcHJlZml4LCBzdWZmaXggfSk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7VGV4dFF1b3RlU2VsZWN0b3J9XG4gICAqL1xuICB0b1NlbGVjdG9yKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnVGV4dFF1b3RlU2VsZWN0b3InLFxuICAgICAgZXhhY3Q6IHRoaXMuZXhhY3QsXG4gICAgICBwcmVmaXg6IHRoaXMuY29udGV4dC5wcmVmaXgsXG4gICAgICBzdWZmaXg6IHRoaXMuY29udGV4dC5zdWZmaXgsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1F1b3RlTWF0Y2hPcHRpb25zfSBbb3B0aW9uc11cbiAgICovXG4gIHRvUmFuZ2Uob3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMudG9Qb3NpdGlvbkFuY2hvcihvcHRpb25zKS50b1JhbmdlKCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtRdW90ZU1hdGNoT3B0aW9uc30gW29wdGlvbnNdXG4gICAqL1xuICB0b1Bvc2l0aW9uQW5jaG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHRleHQgPSAvKiogQHR5cGUge3N0cmluZ30gKi8gKHRoaXMucm9vdC50ZXh0Q29udGVudCk7XG4gICAgY29uc3QgbWF0Y2ggPSBtYXRjaFF1b3RlKHRleHQsIHRoaXMuZXhhY3QsIHtcbiAgICAgIC4uLnRoaXMuY29udGV4dCxcbiAgICAgIGhpbnQ6IG9wdGlvbnMuaGludCxcbiAgICB9KTtcbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1F1b3RlIG5vdCBmb3VuZCcpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRleHRQb3NpdGlvbkFuY2hvcih0aGlzLnJvb3QsIG1hdGNoLnN0YXJ0LCBtYXRjaC5lbmQpO1xuICB9XG59XG4iLCIvL1xuLy8gIENvcHlyaWdodCAyMDIxIFJlYWRpdW0gRm91bmRhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSB0aGUgQlNELXN0eWxlIGxpY2Vuc2Vcbi8vICBhdmFpbGFibGUgaW4gdGhlIHRvcC1sZXZlbCBMSUNFTlNFIGZpbGUgb2YgdGhlIHByb2plY3QuXG4vL1xuXG4vLyBDYXRjaCBKUyBlcnJvcnMgdG8gbG9nIHRoZW0gaW4gdGhlIGFwcC5cblxuaW1wb3J0IHtUZXh0UXVvdGVBbmNob3J9IGZyb20gXCIuL3ZlbmRvci9oeXBvdGhlc2lzL2FuY2hvcmluZy90eXBlc1wiO1xuXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgd2Via2l0Lm1lc3NhZ2VIYW5kbGVycy5sb2dFcnJvci5wb3N0TWVzc2FnZSh7XG4gICAgICAgIFwibWVzc2FnZVwiOiBldmVudC5tZXNzYWdlLFxuICAgICAgICBcImZpbGVuYW1lXCI6IGV2ZW50LmZpbGVuYW1lLFxuICAgICAgICBcImxpbmVcIjogZXZlbnQubGluZW5vXG4gICAgfSk7XG59LCBmYWxzZSk7XG5cbi8vIE5vdGlmeSBuYXRpdmUgY29kZSB0aGF0IHRoZSBwYWdlIGhhcyBsb2FkZWQuXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgZnVuY3Rpb24oKXsgLy8gb24gcGFnZSBsb2FkXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJvcmllbnRhdGlvbmNoYW5nZVwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgb3JpZW50YXRpb25DaGFuZ2VkKCk7XG4gICAgICAgIHNuYXBDdXJyZW50UG9zaXRpb24oKTtcbiAgICB9KTtcbiAgICBvcmllbnRhdGlvbkNoYW5nZWQoKTtcbn0sIGZhbHNlKTtcblxudmFyIGxhc3Rfa25vd25fc2Nyb2xsWF9wb3NpdGlvbiA9IDA7XG52YXIgbGFzdF9rbm93bl9zY3JvbGxZX3Bvc2l0aW9uID0gMDtcbnZhciB0aWNraW5nID0gZmFsc2U7XG52YXIgbWF4U2NyZWVuWCA9IDA7XG5cbi8vIFBvc2l0aW9uIGluIHJhbmdlIFswIC0gMV0uXG5mdW5jdGlvbiB1cGRhdGUocG9zaXRpb24pIHtcbiAgICB2YXIgcG9zaXRpb25TdHJpbmcgPSBwb3NpdGlvbi50b1N0cmluZygpXG4gICAgd2Via2l0Lm1lc3NhZ2VIYW5kbGVycy5wcm9ncmVzc2lvbkNoYW5nZWQucG9zdE1lc3NhZ2UocG9zaXRpb25TdHJpbmcpO1xufVxuXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgZnVuY3Rpb24oZSkge1xuICAgIGxhc3Rfa25vd25fc2Nyb2xsWV9wb3NpdGlvbiA9IHdpbmRvdy5zY3JvbGxZIC8gZG9jdW1lbnQuc2Nyb2xsaW5nRWxlbWVudC5zY3JvbGxIZWlnaHQ7XG4gICAgLy8gVXNpbmcgTWF0aC5hYnMgYmVjYXVzZSBmb3IgUlRMIGJvb2tzLCB0aGUgdmFsdWUgd2lsbCBiZSBuZWdhdGl2ZS5cbiAgICBsYXN0X2tub3duX3Njcm9sbFhfcG9zaXRpb24gPSBNYXRoLmFicyh3aW5kb3cuc2Nyb2xsWCAvIGRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnQuc2Nyb2xsV2lkdGgpO1xuXG4gICAgLy8gV2luZG93IGlzIGhpZGRlblxuICAgIGlmIChkb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50LnNjcm9sbFdpZHRoID09PSAwIHx8IGRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnQuc2Nyb2xsSGVpZ2h0ID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIXRpY2tpbmcpIHtcbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHVwZGF0ZShpc1Njcm9sbE1vZGVFbmFibGVkKCkgPyBsYXN0X2tub3duX3Njcm9sbFlfcG9zaXRpb24gOiBsYXN0X2tub3duX3Njcm9sbFhfcG9zaXRpb24pO1xuICAgICAgICAgICAgdGlja2luZyA9IGZhbHNlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdGlja2luZyA9IHRydWU7XG59KTtcblxuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2VsZWN0aW9uY2hhbmdlJywgZGVib3VuY2UoNTAsIGZ1bmN0aW9uKCkge1xuICAgIHZhciBpbmZvID0ge31cbiAgICB2YXIgc2VsZWN0aW9uID0gZG9jdW1lbnQuZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKHNlbGVjdGlvbiAmJiBzZWxlY3Rpb24ucmFuZ2VDb3VudCA+IDApIHtcbiAgICAgICAgdmFyIHJlY3QgPSBzZWxlY3Rpb24uZ2V0UmFuZ2VBdCgwKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgaW5mb1sndGV4dCddID0gc2VsZWN0aW9uLnRvU3RyaW5nKCkudHJpbSgpO1xuICAgICAgICBpbmZvWydmcmFtZSddID0ge1xuICAgICAgICAgICAgJ3gnOiByZWN0LmxlZnQsXG4gICAgICAgICAgICAneSc6IHJlY3QudG9wLFxuICAgICAgICAgICAgJ3dpZHRoJzogcmVjdC53aWR0aCxcbiAgICAgICAgICAgICdoZWlnaHQnOiByZWN0LmhlaWdodFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHdlYmtpdC5tZXNzYWdlSGFuZGxlcnMuc2VsZWN0aW9uQ2hhbmdlZC5wb3N0TWVzc2FnZShpbmZvKTtcbn0pKTtcblxuZnVuY3Rpb24gb3JpZW50YXRpb25DaGFuZ2VkKCkge1xuICAgIG1heFNjcmVlblggPSAod2luZG93Lm9yaWVudGF0aW9uID09PSAwIHx8IHdpbmRvdy5vcmllbnRhdGlvbiA9PSAxODApID8gc2NyZWVuLndpZHRoIDogc2NyZWVuLmhlaWdodDtcbn1cblxuZnVuY3Rpb24gaXNTY3JvbGxNb2RlRW5hYmxlZCgpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLmdldFByb3BlcnR5VmFsdWUoXCItLVVTRVJfX3Njcm9sbFwiKS50b1N0cmluZygpLnRyaW0oKSA9PT0gJ3JlYWRpdW0tc2Nyb2xsLW9uJztcbn1cblxuLy8gU2Nyb2xsIHRvIHRoZSBnaXZlbiBUYWdJZCBpbiBkb2N1bWVudCBhbmQgc25hcC5cbmV4cG9ydCBmdW5jdGlvbiBzY3JvbGxUb0lkKGlkKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCk7XG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZWxlbWVudC5zY3JvbGxJbnRvVmlldygpO1xuXG4gICAgaWYgKCFpc1Njcm9sbE1vZGVFbmFibGVkKCkpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRPZmZzZXQgPSB3aW5kb3cuc2Nyb2xsWDtcbiAgICAgICAgdmFyIHBhZ2VXaWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgICAgICAvLyBBZGRzIGhhbGYgYSBwYWdlIHRvIG1ha2Ugc3VyZSB3ZSBkb24ndCBzbmFwIHRvIHRoZSBwcmV2aW91cyBwYWdlLlxuICAgICAgICBkb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50LnNjcm9sbExlZnQgPSBzbmFwT2Zmc2V0KGN1cnJlbnRPZmZzZXQgKyAocGFnZVdpZHRoIC8gMikpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gUG9zaXRpb24gbXVzdCBiZSBpbiB0aGUgcmFuZ2UgWzAgLSAxXSwgMC0xMDAlLlxuZXhwb3J0IGZ1bmN0aW9uIHNjcm9sbFRvUG9zaXRpb24ocG9zaXRpb24sIGRpcikge1xuICAgIGNvbnNvbGUubG9nKFwiU2Nyb2xsVG9Qb3NpdGlvblwiKTtcbiAgICBpZiAoKHBvc2l0aW9uIDwgMCkgfHwgKHBvc2l0aW9uID4gMSkpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJJbnZhbGlkUG9zaXRpb25cIik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoaXNTY3JvbGxNb2RlRW5hYmxlZCgpKSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSBkb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50LnNjcm9sbEhlaWdodCAqIHBvc2l0aW9uO1xuICAgICAgICBkb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50LnNjcm9sbFRvcCA9IG9mZnNldDtcbiAgICAgICAgLy8gd2luZG93LnNjcm9sbFRvKDAsIG9mZnNldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGRvY3VtZW50V2lkdGggPSBkb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50LnNjcm9sbFdpZHRoO1xuICAgICAgICB2YXIgZmFjdG9yID0gKGRpciA9PSAncnRsJykgPyAtMSA6IDE7XG4gICAgICAgIHZhciBvZmZzZXQgPSBkb2N1bWVudFdpZHRoICogcG9zaXRpb24gKiBmYWN0b3I7XG4gICAgICAgIGRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnQuc2Nyb2xsTGVmdCA9IHNuYXBPZmZzZXQob2Zmc2V0KTtcbiAgICB9XG59XG5cbi8vIFNjcm9sbHMgdG8gdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgdGhlIGdpdmVuIHRleHQgc25pcHBldC5cbi8vXG4vLyBUaGUgZXhwZWN0ZWQgdGV4dCBhcmd1bWVudCBpcyBhIExvY2F0b3IgVGV4dCBvYmplY3QsIGFzIGRlZmluZWQgaGVyZTpcbi8vIGh0dHBzOi8vcmVhZGl1bS5vcmcvYXJjaGl0ZWN0dXJlL21vZGVscy9sb2NhdG9ycy9cbmV4cG9ydCBmdW5jdGlvbiBzY3JvbGxUb1RleHQodGV4dCkge1xuICAgIHRyeSB7XG4gICAgICAgIGxldCBhbmNob3IgPSBuZXcgVGV4dFF1b3RlQW5jaG9yKGRvY3VtZW50LmJvZHksIHRleHQuaGlnaGxpZ2h0LCB7XG4gICAgICAgICAgICBwcmVmaXg6IHRleHQuYmVmb3JlLFxuICAgICAgICAgICAgc3VmZml4OiB0ZXh0LmFmdGVyLFxuICAgICAgICB9KVxuXG4gICAgICAgIHNjcm9sbFRvUmFuZ2UoYW5jaG9yLnRvUmFuZ2UoKSlcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGxvZ0V4Y2VwdGlvbihlKVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHNjcm9sbFRvUmFuZ2UocmFuZ2UpIHtcbiAgICB2YXIgcmVjdCA9IHJhbmdlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGlmIChpc1Njcm9sbE1vZGVFbmFibGVkKCkpIHtcbiAgICAgICAgZG9jdW1lbnQuc2Nyb2xsaW5nRWxlbWVudC5zY3JvbGxUb3AgPSByZWN0LnRvcCArIHdpbmRvdy5zY3JvbGxZIC0gKHdpbmRvdy5pbm5lckhlaWdodCAvIDIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnQuc2Nyb2xsTGVmdCA9IHJlY3QubGVmdCArIHdpbmRvdy5zY3JvbGxYO1xuICAgICAgICBzbmFwQ3VycmVudFBvc2l0aW9uKCk7XG4gICAgfVxufVxuXG4vLyBSZXR1cm5zIGZhbHNlIGlmIHRoZSBwYWdlIGlzIGFscmVhZHkgYXQgdGhlIGxlZnQtbW9zdCBzY3JvbGwgb2Zmc2V0LlxuZXhwb3J0IGZ1bmN0aW9uIHNjcm9sbExlZnQoZGlyKSB7XG4gICAgdmFyIGlzUlRMID0gKGRpciA9PSBcInJ0bFwiKTtcbiAgICB2YXIgZG9jdW1lbnRXaWR0aCA9IGRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnQuc2Nyb2xsV2lkdGg7XG4gICAgdmFyIHBhZ2VXaWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgIHZhciBvZmZzZXQgPSB3aW5kb3cuc2Nyb2xsWCAtIHBhZ2VXaWR0aDtcbiAgICB2YXIgbWluT2Zmc2V0ID0gaXNSVEwgPyAtKGRvY3VtZW50V2lkdGggLSBwYWdlV2lkdGgpIDogMDtcbiAgICByZXR1cm4gc2Nyb2xsVG9PZmZzZXQoTWF0aC5tYXgob2Zmc2V0LCBtaW5PZmZzZXQpKTtcbn1cblxuLy8gUmV0dXJucyBmYWxzZSBpZiB0aGUgcGFnZSBpcyBhbHJlYWR5IGF0IHRoZSByaWdodC1tb3N0IHNjcm9sbCBvZmZzZXQuXG5leHBvcnQgZnVuY3Rpb24gc2Nyb2xsUmlnaHQoZGlyKSB7XG4gICAgdmFyIGlzUlRMID0gKGRpciA9PSBcInJ0bFwiKTtcbiAgICB2YXIgZG9jdW1lbnRXaWR0aCA9IGRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnQuc2Nyb2xsV2lkdGg7XG4gICAgdmFyIHBhZ2VXaWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgIHZhciBvZmZzZXQgPSB3aW5kb3cuc2Nyb2xsWCArIHBhZ2VXaWR0aDtcbiAgICB2YXIgbWF4T2Zmc2V0ID0gaXNSVEwgPyAwIDogKGRvY3VtZW50V2lkdGggLSBwYWdlV2lkdGgpO1xuICAgIHJldHVybiBzY3JvbGxUb09mZnNldChNYXRoLm1pbihvZmZzZXQsIG1heE9mZnNldCkpO1xufVxuXG4vLyBTY3JvbGxzIHRvIHRoZSBnaXZlbiBsZWZ0IG9mZnNldC5cbi8vIFJldHVybnMgZmFsc2UgaWYgdGhlIHBhZ2Ugc2Nyb2xsIHBvc2l0aW9uIGlzIGFscmVhZHkgY2xvc2UgZW5vdWdoIHRvIHRoZSBnaXZlbiBvZmZzZXQuXG5mdW5jdGlvbiBzY3JvbGxUb09mZnNldChvZmZzZXQpIHtcbiAgICB2YXIgY3VycmVudE9mZnNldCA9IHdpbmRvdy5zY3JvbGxYO1xuICAgIHZhciBwYWdlV2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICBkb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50LnNjcm9sbExlZnQgPSBvZmZzZXQ7XG4gICAgLy8gSW4gc29tZSBjYXNlIHRoZSBzY3JvbGxYIGNhbm5vdCByZWFjaCB0aGUgcG9zaXRpb24gcmVzcGVjdGluZyB0byBpbm5lcldpZHRoXG4gICAgdmFyIGRpZmYgPSBNYXRoLmFicyhjdXJyZW50T2Zmc2V0IC0gb2Zmc2V0KSAvIHBhZ2VXaWR0aDtcbiAgICByZXR1cm4gKGRpZmYgPiAwLjAxKTtcbn1cblxuLy8gU25hcCB0aGUgb2Zmc2V0IHRvIHRoZSBzY3JlZW4gd2lkdGggKHBhZ2Ugd2lkdGgpLlxuZnVuY3Rpb24gc25hcE9mZnNldChvZmZzZXQpIHtcbiAgICB2YXIgdmFsdWUgPSBvZmZzZXQgKyAxO1xuXG4gICAgcmV0dXJuIHZhbHVlIC0gKHZhbHVlICUgbWF4U2NyZWVuWCk7XG59XG5cbmZ1bmN0aW9uIHNuYXBDdXJyZW50UG9zaXRpb24oKSB7XG4gICAgaWYgKGlzU2Nyb2xsTW9kZUVuYWJsZWQoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBjdXJyZW50T2Zmc2V0ID0gd2luZG93LnNjcm9sbFg7XG4gICAgdmFyIGN1cnJlbnRPZmZzZXRTbmFwcGVkID0gc25hcE9mZnNldChjdXJyZW50T2Zmc2V0ICsgMSk7XG5cbiAgICBkb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50LnNjcm9sbExlZnQgPSBjdXJyZW50T2Zmc2V0U25hcHBlZDtcbn1cblxuLy8vIFVzZXIgU2V0dGluZ3MuXG5cbi8vIEZvciBzZXR0aW5nIHVzZXIgc2V0dGluZy5cbmV4cG9ydCBmdW5jdGlvbiBzZXRQcm9wZXJ0eShrZXksIHZhbHVlKSB7XG4gICAgdmFyIHJvb3QgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cbiAgICByb290LnN0eWxlLnNldFByb3BlcnR5KGtleSwgdmFsdWUpO1xufVxuXG4vLyBGb3IgcmVtb3ZpbmcgdXNlciBzZXR0aW5nLlxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZVByb3BlcnR5KGtleSkge1xuICAgIHZhciByb290ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG4gICAgcm9vdC5zdHlsZS5yZW1vdmVQcm9wZXJ0eShrZXkpO1xufVxuXG5cbi8vLyBUb29sa2l0XG5cbmZ1bmN0aW9uIGRlYm91bmNlKGRlbGF5LCBmdW5jKSB7XG4gICAgdmFyIHRpbWVvdXQ7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICBmdW5jdGlvbiBjYWxsYmFjaygpIHtcbiAgICAgICAgICAgIGZ1bmMuYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGNhbGxiYWNrLCBkZWxheSk7XG4gICAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxvZygpIHtcbiAgICB2YXIgbWVzc2FnZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykuam9pbihcIiBcIik7XG4gICAgd2Via2l0Lm1lc3NhZ2VIYW5kbGVycy5sb2cucG9zdE1lc3NhZ2UobWVzc2FnZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsb2dFeGNlcHRpb24oZSkge1xuICAgIHdlYmtpdC5tZXNzYWdlSGFuZGxlcnMubG9nRXJyb3IucG9zdE1lc3NhZ2Uoe1xuICAgICAgICBcIm1lc3NhZ2VcIjogZS5tZXNzYWdlXG4gICAgfSk7XG59XG4iLCIvL1xuLy8gIENvcHlyaWdodCAyMDIxIFJlYWRpdW0gRm91bmRhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSB0aGUgQlNELXN0eWxlIGxpY2Vuc2Vcbi8vICBhdmFpbGFibGUgaW4gdGhlIHRvcC1sZXZlbCBMSUNFTlNFIGZpbGUgb2YgdGhlIHByb2plY3QuXG4vL1xuXG5pbXBvcnQge2xvZyBhcyBsb2dOYXRpdmUsIGxvZ0V4Y2VwdGlvbn0gZnJvbSBcIi4vdXRpbHNcIjtcblxuY29uc3QgZGVidWcgPSB0cnVlO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2VsZWN0aW9uUmVjdCgpIHtcbiAgICB0cnkge1xuICAgICAgICBsZXQgc2VsID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgICAgICBpZiAoIXNlbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCByYW5nZSA9IHNlbC5nZXRSYW5nZUF0KDApO1xuXG4gICAgICAgIGNvbnN0IGNsaWVudFJlY3QgPSByYW5nZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2NyZWVuV2lkdGg6IHdpbmRvdy5vdXRlcldpZHRoLFxuICAgICAgICAgICAgc2NyZWVuSGVpZ2h0OiB3aW5kb3cub3V0ZXJIZWlnaHQsXG4gICAgICAgICAgICBsZWZ0OiBjbGllbnRSZWN0LmxlZnQsXG4gICAgICAgICAgICB3aWR0aDogY2xpZW50UmVjdC53aWR0aCxcbiAgICAgICAgICAgIHRvcDogY2xpZW50UmVjdC50b3AsXG4gICAgICAgICAgICBoZWlnaHQ6IGNsaWVudFJlY3QuaGVpZ2h0XG4gICAgICAgIH07XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBsb2dFeGNlcHRpb24oZSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q3VycmVudFNlbGVjdGlvbkluZm8oKSB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgIGlmICghc2VsZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmIChzZWxlY3Rpb24uaXNDb2xsYXBzZWQpIHtcbiAgICAgICAgbG9nKFwiXl5eIFNFTEVDVElPTiBDT0xMQVBTRUQuXCIpO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCByYXdUZXh0ID0gc2VsZWN0aW9uLnRvU3RyaW5nKCk7XG4gICAgY29uc3QgY2xlYW5UZXh0ID0gcmF3VGV4dC50cmltKCkucmVwbGFjZSgvXFxuL2csIFwiIFwiKS5yZXBsYWNlKC9cXHNcXHMrL2csIFwiIFwiKTtcbiAgICBpZiAoY2xlYW5UZXh0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBsb2coXCJeXl4gU0VMRUNUSU9OIFRFWFQgRU1QVFkuXCIpO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAoIXNlbGVjdGlvbi5hbmNob3JOb2RlIHx8ICFzZWxlY3Rpb24uZm9jdXNOb2RlKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNvbnN0IHJhbmdlID0gc2VsZWN0aW9uLnJhbmdlQ291bnQgPT09IDEgPyBzZWxlY3Rpb24uZ2V0UmFuZ2VBdCgwKSA6XG4gICAgICAgIGNyZWF0ZU9yZGVyZWRSYW5nZShzZWxlY3Rpb24uYW5jaG9yTm9kZSwgc2VsZWN0aW9uLmFuY2hvck9mZnNldCwgc2VsZWN0aW9uLmZvY3VzTm9kZSwgc2VsZWN0aW9uLmZvY3VzT2Zmc2V0KTtcbiAgICBpZiAoIXJhbmdlIHx8IHJhbmdlLmNvbGxhcHNlZCkge1xuICAgICAgICBsb2coXCIkJCQkJCQkJCQkJCQkJCQkJCBDQU5OT1QgR0VUIE5PTi1DT0xMQVBTRUQgU0VMRUNUSU9OIFJBTkdFPyFcIik7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNvbnN0IHJhbmdlSW5mbyA9IGNvbnZlcnRSYW5nZShyYW5nZSwgZnVsbFF1YWxpZmllZFNlbGVjdG9yKTtcbiAgICBpZiAoIXJhbmdlSW5mbykge1xuICAgICAgICBsb2coXCJeXl4gU0VMRUNUSU9OIFJBTkdFIElORk8gRkFJTD8hXCIpO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIGxvY2F0aW9uczogcmFuZ2VJbmZvMkxvY2F0aW9uKHJhbmdlSW5mbyksXG4gICAgICAgIHRleHQ6IHtcbiAgICAgICAgICAgIGhpZ2hsaWdodDogcmF3VGV4dFxuICAgICAgICB9XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlT3JkZXJlZFJhbmdlKHN0YXJ0Tm9kZSwgc3RhcnRPZmZzZXQsIGVuZE5vZGUsIGVuZE9mZnNldCkge1xuICAgIGNvbnN0IHJhbmdlID0gbmV3IFJhbmdlKCk7XG4gICAgcmFuZ2Uuc2V0U3RhcnQoc3RhcnROb2RlLCBzdGFydE9mZnNldCk7XG4gICAgcmFuZ2Uuc2V0RW5kKGVuZE5vZGUsIGVuZE9mZnNldCk7XG4gICAgaWYgKCFyYW5nZS5jb2xsYXBzZWQpIHtcbiAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgIH1cbiAgICBsb2coXCI+Pj4gY3JlYXRlT3JkZXJlZFJhbmdlIENPTExBUFNFRCAuLi4gUkFOR0UgUkVWRVJTRT9cIik7XG4gICAgY29uc3QgcmFuZ2VSZXZlcnNlID0gbmV3IFJhbmdlKCk7XG4gICAgcmFuZ2VSZXZlcnNlLnNldFN0YXJ0KGVuZE5vZGUsIGVuZE9mZnNldCk7XG4gICAgcmFuZ2VSZXZlcnNlLnNldEVuZChzdGFydE5vZGUsIHN0YXJ0T2Zmc2V0KTtcbiAgICBpZiAoIXJhbmdlUmV2ZXJzZS5jb2xsYXBzZWQpIHtcbiAgICAgICAgbG9nKFwiPj4+IGNyZWF0ZU9yZGVyZWRSYW5nZSBSQU5HRSBSRVZFUlNFIE9LLlwiKTtcbiAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgIH1cbiAgICBsb2coXCI+Pj4gY3JlYXRlT3JkZXJlZFJhbmdlIFJBTkdFIFJFVkVSU0UgQUxTTyBDT0xMQVBTRUQ/IVwiKTtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0UmFuZ2UocmFuZ2UsIGdldENzc1NlbGVjdG9yKSB7XG4gICAgY29uc3Qgc3RhcnRJc0VsZW1lbnQgPSByYW5nZS5zdGFydENvbnRhaW5lci5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREU7XG4gICAgY29uc3Qgc3RhcnRDb250YWluZXJFbGVtZW50ID0gc3RhcnRJc0VsZW1lbnQgP1xuICAgICAgICByYW5nZS5zdGFydENvbnRhaW5lciA6XG4gICAgICAgICgocmFuZ2Uuc3RhcnRDb250YWluZXIucGFyZW50Tm9kZSAmJiByYW5nZS5zdGFydENvbnRhaW5lci5wYXJlbnROb2RlLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkgP1xuICAgICAgICAgICAgcmFuZ2Uuc3RhcnRDb250YWluZXIucGFyZW50Tm9kZSA6IHVuZGVmaW5lZCk7XG4gICAgaWYgKCFzdGFydENvbnRhaW5lckVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3Qgc3RhcnRDb250YWluZXJDaGlsZFRleHROb2RlSW5kZXggPSBzdGFydElzRWxlbWVudCA/IC0xIDpcbiAgICAgICAgQXJyYXkuZnJvbShzdGFydENvbnRhaW5lckVsZW1lbnQuY2hpbGROb2RlcykuaW5kZXhPZihyYW5nZS5zdGFydENvbnRhaW5lcik7XG4gICAgaWYgKHN0YXJ0Q29udGFpbmVyQ2hpbGRUZXh0Tm9kZUluZGV4IDwgLTEpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3Qgc3RhcnRDb250YWluZXJFbGVtZW50Q3NzU2VsZWN0b3IgPSBnZXRDc3NTZWxlY3RvcihzdGFydENvbnRhaW5lckVsZW1lbnQpO1xuXG4gICAgY29uc3QgZW5kSXNFbGVtZW50ID0gcmFuZ2UuZW5kQ29udGFpbmVyLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERTtcbiAgICBjb25zdCBlbmRDb250YWluZXJFbGVtZW50ID0gZW5kSXNFbGVtZW50ID9cbiAgICAgICAgcmFuZ2UuZW5kQ29udGFpbmVyIDpcbiAgICAgICAgKChyYW5nZS5lbmRDb250YWluZXIucGFyZW50Tm9kZSAmJiByYW5nZS5lbmRDb250YWluZXIucGFyZW50Tm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpID9cbiAgICAgICAgICAgIHJhbmdlLmVuZENvbnRhaW5lci5wYXJlbnROb2RlIDogdW5kZWZpbmVkKTtcbiAgICBpZiAoIWVuZENvbnRhaW5lckVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3QgZW5kQ29udGFpbmVyQ2hpbGRUZXh0Tm9kZUluZGV4ID0gZW5kSXNFbGVtZW50ID8gLTEgOlxuICAgICAgICBBcnJheS5mcm9tKGVuZENvbnRhaW5lckVsZW1lbnQuY2hpbGROb2RlcykuaW5kZXhPZihyYW5nZS5lbmRDb250YWluZXIpO1xuICAgIGlmIChlbmRDb250YWluZXJDaGlsZFRleHROb2RlSW5kZXggPCAtMSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCBlbmRDb250YWluZXJFbGVtZW50Q3NzU2VsZWN0b3IgPSBnZXRDc3NTZWxlY3RvcihlbmRDb250YWluZXJFbGVtZW50KTtcblxuICAgIGNvbnN0IGNvbW1vbkVsZW1lbnRBbmNlc3RvciA9IGdldENvbW1vbkFuY2VzdG9yRWxlbWVudChyYW5nZS5zdGFydENvbnRhaW5lciwgcmFuZ2UuZW5kQ29udGFpbmVyKTtcbiAgICBpZiAoIWNvbW1vbkVsZW1lbnRBbmNlc3Rvcikge1xuICAgICAgICBsb2coXCJeXl4gTk8gUkFOR0UgQ09NTU9OIEFOQ0VTVE9SPyFcIik7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmIChyYW5nZS5jb21tb25BbmNlc3RvckNvbnRhaW5lcikge1xuICAgICAgICBjb25zdCByYW5nZUNvbW1vbkFuY2VzdG9yRWxlbWVudCA9IHJhbmdlLmNvbW1vbkFuY2VzdG9yQ29udGFpbmVyLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSA/XG4gICAgICAgICAgICByYW5nZS5jb21tb25BbmNlc3RvckNvbnRhaW5lciA6IHJhbmdlLmNvbW1vbkFuY2VzdG9yQ29udGFpbmVyLnBhcmVudE5vZGU7XG4gICAgICAgIGlmIChyYW5nZUNvbW1vbkFuY2VzdG9yRWxlbWVudCAmJiByYW5nZUNvbW1vbkFuY2VzdG9yRWxlbWVudC5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICAgIGlmIChjb21tb25FbGVtZW50QW5jZXN0b3IgIT09IHJhbmdlQ29tbW9uQW5jZXN0b3JFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgbG9nKFwiPj4+Pj4+IENPTU1PTiBBTkNFU1RPUiBDT05UQUlORVIgRElGRj8/IVwiKTtcbiAgICAgICAgICAgICAgICBsb2coZ2V0Q3NzU2VsZWN0b3IoY29tbW9uRWxlbWVudEFuY2VzdG9yKSk7XG4gICAgICAgICAgICAgICAgbG9nKGdldENzc1NlbGVjdG9yKHJhbmdlQ29tbW9uQW5jZXN0b3JFbGVtZW50KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW5kQ29udGFpbmVyQ2hpbGRUZXh0Tm9kZUluZGV4LFxuICAgICAgICBlbmRDb250YWluZXJFbGVtZW50Q3NzU2VsZWN0b3IsXG4gICAgICAgIGVuZE9mZnNldDogcmFuZ2UuZW5kT2Zmc2V0LFxuICAgICAgICBzdGFydENvbnRhaW5lckNoaWxkVGV4dE5vZGVJbmRleCxcbiAgICAgICAgc3RhcnRDb250YWluZXJFbGVtZW50Q3NzU2VsZWN0b3IsXG4gICAgICAgIHN0YXJ0T2Zmc2V0OiByYW5nZS5zdGFydE9mZnNldCxcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBnZXRDb21tb25BbmNlc3RvckVsZW1lbnQobm9kZTEsIG5vZGUyKSB7XG4gICAgaWYgKG5vZGUxLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSAmJiBub2RlMSA9PT0gbm9kZTIpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUxO1xuICAgIH1cbiAgICBpZiAobm9kZTEubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFICYmIG5vZGUxLmNvbnRhaW5zKG5vZGUyKSkge1xuICAgICAgICByZXR1cm4gbm9kZTE7XG4gICAgfVxuICAgIGlmIChub2RlMi5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUgJiYgbm9kZTIuY29udGFpbnMobm9kZTEpKSB7XG4gICAgICAgIHJldHVybiBub2RlMjtcbiAgICB9XG4gICAgY29uc3Qgbm9kZTFFbGVtZW50QW5jZXN0b3JDaGFpbiA9IFtdO1xuICAgIGxldCBwYXJlbnQgPSBub2RlMS5wYXJlbnROb2RlO1xuICAgIHdoaWxlIChwYXJlbnQgJiYgcGFyZW50Lm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICBub2RlMUVsZW1lbnRBbmNlc3RvckNoYWluLnB1c2gocGFyZW50KTtcbiAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGU7XG4gICAgfVxuICAgIGNvbnN0IG5vZGUyRWxlbWVudEFuY2VzdG9yQ2hhaW4gPSBbXTtcbiAgICBwYXJlbnQgPSBub2RlMi5wYXJlbnROb2RlO1xuICAgIHdoaWxlIChwYXJlbnQgJiYgcGFyZW50Lm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICBub2RlMkVsZW1lbnRBbmNlc3RvckNoYWluLnB1c2gocGFyZW50KTtcbiAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGU7XG4gICAgfVxuICAgIGxldCBjb21tb25BbmNlc3RvciA9IG5vZGUxRWxlbWVudEFuY2VzdG9yQ2hhaW4uZmluZCgobm9kZTFFbGVtZW50QW5jZXN0b3IpID0+IHtcbiAgICAgICAgcmV0dXJuIG5vZGUyRWxlbWVudEFuY2VzdG9yQ2hhaW4uaW5kZXhPZihub2RlMUVsZW1lbnRBbmNlc3RvcikgPj0gMDtcbiAgICB9KTtcbiAgICBpZiAoIWNvbW1vbkFuY2VzdG9yKSB7XG4gICAgICAgIGNvbW1vbkFuY2VzdG9yID0gbm9kZTJFbGVtZW50QW5jZXN0b3JDaGFpbi5maW5kKChub2RlMkVsZW1lbnRBbmNlc3RvcikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUxRWxlbWVudEFuY2VzdG9yQ2hhaW4uaW5kZXhPZihub2RlMkVsZW1lbnRBbmNlc3RvcikgPj0gMDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBjb21tb25BbmNlc3Rvcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRSYW5nZUluZm8oZG9jdW1lbnQsIHJhbmdlSW5mbykge1xuICAgIGNvbnN0IHN0YXJ0RWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IocmFuZ2VJbmZvLnN0YXJ0Q29udGFpbmVyRWxlbWVudENzc1NlbGVjdG9yKTtcbiAgICBpZiAoIXN0YXJ0RWxlbWVudCkge1xuICAgICAgICBsb2coXCJeXl4gY29udmVydFJhbmdlSW5mbyBOTyBTVEFSVCBFTEVNRU5UIENTUyBTRUxFQ1RPUj8hXCIpO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBsZXQgc3RhcnRDb250YWluZXIgPSBzdGFydEVsZW1lbnQ7XG4gICAgaWYgKHJhbmdlSW5mby5zdGFydENvbnRhaW5lckNoaWxkVGV4dE5vZGVJbmRleCA+PSAwKSB7XG4gICAgICAgIGlmIChyYW5nZUluZm8uc3RhcnRDb250YWluZXJDaGlsZFRleHROb2RlSW5kZXggPj0gc3RhcnRFbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBsb2coXCJeXl4gY29udmVydFJhbmdlSW5mbyByYW5nZUluZm8uc3RhcnRDb250YWluZXJDaGlsZFRleHROb2RlSW5kZXggPj0gc3RhcnRFbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoPyFcIik7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHN0YXJ0Q29udGFpbmVyID0gc3RhcnRFbGVtZW50LmNoaWxkTm9kZXNbcmFuZ2VJbmZvLnN0YXJ0Q29udGFpbmVyQ2hpbGRUZXh0Tm9kZUluZGV4XTtcbiAgICAgICAgaWYgKHN0YXJ0Q29udGFpbmVyLm5vZGVUeXBlICE9PSBOb2RlLlRFWFRfTk9ERSkge1xuICAgICAgICAgICAgbG9nKFwiXl5eIGNvbnZlcnRSYW5nZUluZm8gc3RhcnRDb250YWluZXIubm9kZVR5cGUgIT09IE5vZGUuVEVYVF9OT0RFPyFcIik7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGVuZEVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHJhbmdlSW5mby5lbmRDb250YWluZXJFbGVtZW50Q3NzU2VsZWN0b3IpO1xuICAgIGlmICghZW5kRWxlbWVudCkge1xuICAgICAgICBsb2coXCJeXl4gY29udmVydFJhbmdlSW5mbyBOTyBFTkQgRUxFTUVOVCBDU1MgU0VMRUNUT1I/IVwiKTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgbGV0IGVuZENvbnRhaW5lciA9IGVuZEVsZW1lbnQ7XG4gICAgaWYgKHJhbmdlSW5mby5lbmRDb250YWluZXJDaGlsZFRleHROb2RlSW5kZXggPj0gMCkge1xuICAgICAgICBpZiAocmFuZ2VJbmZvLmVuZENvbnRhaW5lckNoaWxkVGV4dE5vZGVJbmRleCA+PSBlbmRFbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBsb2coXCJeXl4gY29udmVydFJhbmdlSW5mbyByYW5nZUluZm8uZW5kQ29udGFpbmVyQ2hpbGRUZXh0Tm9kZUluZGV4ID49IGVuZEVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGg/IVwiKTtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZW5kQ29udGFpbmVyID0gZW5kRWxlbWVudC5jaGlsZE5vZGVzW3JhbmdlSW5mby5lbmRDb250YWluZXJDaGlsZFRleHROb2RlSW5kZXhdO1xuICAgICAgICBpZiAoZW5kQ29udGFpbmVyLm5vZGVUeXBlICE9PSBOb2RlLlRFWFRfTk9ERSkge1xuICAgICAgICAgICAgbG9nKFwiXl5eIGNvbnZlcnRSYW5nZUluZm8gZW5kQ29udGFpbmVyLm5vZGVUeXBlICE9PSBOb2RlLlRFWFRfTk9ERT8hXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlT3JkZXJlZFJhbmdlKHN0YXJ0Q29udGFpbmVyLCByYW5nZUluZm8uc3RhcnRPZmZzZXQsIGVuZENvbnRhaW5lciwgcmFuZ2VJbmZvLmVuZE9mZnNldCk7XG59XG5cbmZ1bmN0aW9uIHJhbmdlSW5mbzJMb2NhdGlvbihyYW5nZUluZm8pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBjc3NTZWxlY3RvcjogcmFuZ2VJbmZvLnN0YXJ0Q29udGFpbmVyRWxlbWVudENzc1NlbGVjdG9yLFxuICAgICAgICBkb21SYW5nZToge1xuICAgICAgICAgICAgc3RhcnQ6IHtcbiAgICAgICAgICAgICAgICBjc3NTZWxlY3RvcjogcmFuZ2VJbmZvLnN0YXJ0Q29udGFpbmVyRWxlbWVudENzc1NlbGVjdG9yLFxuICAgICAgICAgICAgICAgIHRleHROb2RlSW5kZXg6IHJhbmdlSW5mby5zdGFydENvbnRhaW5lckNoaWxkVGV4dE5vZGVJbmRleCxcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IHJhbmdlSW5mby5zdGFydE9mZnNldFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVuZDoge1xuICAgICAgICAgICAgICAgIGNzc1NlbGVjdG9yOiByYW5nZUluZm8uZW5kQ29udGFpbmVyRWxlbWVudENzc1NlbGVjdG9yLFxuICAgICAgICAgICAgICAgIHRleHROb2RlSW5kZXg6IHJhbmdlSW5mby5lbmRDb250YWluZXJDaGlsZFRleHROb2RlSW5kZXgsXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiByYW5nZUluZm8uZW5kT2Zmc2V0XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsb2NhdGlvbjJSYW5nZUluZm8obG9jYXRpb24pIHtcbiAgICBjb25zdCBsb2NhdGlvbnMgPSBsb2NhdGlvbi5sb2NhdGlvbnNcbiAgICBjb25zdCBkb21SYW5nZSA9IGxvY2F0aW9ucy5kb21SYW5nZVxuICAgIGNvbnN0IHN0YXJ0ID0gZG9tUmFuZ2Uuc3RhcnRcbiAgICBjb25zdCBlbmQgPSBkb21SYW5nZS5lbmRcblxuICAgIHJldHVybiB7XG4gICAgICAgIGVuZENvbnRhaW5lckNoaWxkVGV4dE5vZGVJbmRleDogZW5kLnRleHROb2RlSW5kZXgsXG4gICAgICAgIGVuZENvbnRhaW5lckVsZW1lbnRDc3NTZWxlY3RvcjogZW5kLmNzc1NlbGVjdG9yLFxuICAgICAgICBlbmRPZmZzZXQ6IGVuZC5vZmZzZXQsXG4gICAgICAgIHN0YXJ0Q29udGFpbmVyQ2hpbGRUZXh0Tm9kZUluZGV4OiBzdGFydC50ZXh0Tm9kZUluZGV4LFxuICAgICAgICBzdGFydENvbnRhaW5lckVsZW1lbnRDc3NTZWxlY3Rvcjogc3RhcnQuY3NzU2VsZWN0b3IsXG4gICAgICAgIHN0YXJ0T2Zmc2V0OiBzdGFydC5vZmZzZXRcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBmdWxsUXVhbGlmaWVkU2VsZWN0b3Iobm9kZSkge1xuICAgIGlmIChub2RlLm5vZGVUeXBlICE9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICByZXR1cm4gKG5vZGUubG9jYWxOYW1lICYmIG5vZGUubG9jYWxOYW1lLnRvTG93ZXJDYXNlKCkpXG4gICAgICAgICAgICB8fCBub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuICAgIC8vcmV0dXJuIGNzc1BhdGgobm9kZSwganVzdFNlbGVjdG9yKTtcbiAgICByZXR1cm4gY3NzUGF0aChub2RlLCB0cnVlKTtcbn1cblxuZnVuY3Rpb24gY3NzUGF0aChub2RlLCBvcHRpbWl6ZWQpIHtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuXG4gICAgY29uc3Qgc3RlcHMgPSBbXTtcbiAgICBsZXQgY29udGV4dE5vZGUgPSBub2RlO1xuICAgIHdoaWxlIChjb250ZXh0Tm9kZSkge1xuICAgICAgICBjb25zdCBzdGVwID0gX2Nzc1BhdGhTdGVwKGNvbnRleHROb2RlLCAhIW9wdGltaXplZCwgY29udGV4dE5vZGUgPT09IG5vZGUpO1xuICAgICAgICBpZiAoIXN0ZXApIHtcbiAgICAgICAgICAgIGJyZWFrOyAvLyBFcnJvciAtIGJhaWwgb3V0IGVhcmx5LlxuICAgICAgICB9XG4gICAgICAgIHN0ZXBzLnB1c2goc3RlcC52YWx1ZSk7XG4gICAgICAgIGlmIChzdGVwLm9wdGltaXplZCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dE5vZGUgPSBjb250ZXh0Tm9kZS5wYXJlbnROb2RlO1xuICAgIH1cbiAgICBzdGVwcy5yZXZlcnNlKCk7XG4gICAgcmV0dXJuIHN0ZXBzLmpvaW4oXCIgPiBcIik7XG59XG5cbi8vIGh0dHBzOi8vY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9ibGluay8rL21hc3Rlci9Tb3VyY2UvZGV2dG9vbHMvZnJvbnRfZW5kL2NvbXBvbmVudHMvRE9NUHJlc2VudGF0aW9uVXRpbHMuanMjMzE2XG5mdW5jdGlvbiBfY3NzUGF0aFN0ZXAobm9kZSwgb3B0aW1pemVkLCBpc1RhcmdldE5vZGUpIHtcblxuICAgIGZ1bmN0aW9uIGlkU2VsZWN0b3IoaWRkKSB7XG4gICAgICAgIHJldHVybiBcIiNcIiArIGVzY2FwZUlkZW50aWZpZXJJZk5lZWRlZChpZGQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVzY2FwZUlkZW50aWZpZXJJZk5lZWRlZChpZGVudCkge1xuICAgICAgICBpZiAoaXNDU1NJZGVudGlmaWVyKGlkZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIGlkZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc2hvdWxkRXNjYXBlRmlyc3QgPSAvXig/OlswLTldfC1bMC05LV0/KS8udGVzdChpZGVudCk7XG4gICAgICAgIGNvbnN0IGxhc3RJbmRleCA9IGlkZW50Lmxlbmd0aCAtIDE7XG4gICAgICAgIHJldHVybiBpZGVudC5yZXBsYWNlKC8uL2csIGZ1bmN0aW9uIChjLCBpaSkge1xuICAgICAgICAgICAgcmV0dXJuICgoc2hvdWxkRXNjYXBlRmlyc3QgJiYgaWkgPT09IDApIHx8ICFpc0NTU0lkZW50Q2hhcihjKSkgPyBlc2NhcGVBc2NpaUNoYXIoYywgaWkgPT09IGxhc3RJbmRleCkgOiBjO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0NTU0lkZW50aWZpZXIodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIC9eLT9bYS16QS1aX11bYS16QS1aMC05Xy1dKiQvLnRlc3QodmFsdWUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQ1NTSWRlbnRDaGFyKGMpIHtcbiAgICAgICAgaWYgKC9bYS16QS1aMC05Xy1dLy50ZXN0KGMpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYy5jaGFyQ29kZUF0KDApID49IDB4QTA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXNjYXBlQXNjaWlDaGFyKGMsIGlzTGFzdCkge1xuICAgICAgICByZXR1cm4gXCJcXFxcXCIgKyB0b0hleEJ5dGUoYykgKyAoaXNMYXN0ID8gXCJcIiA6IFwiIFwiKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0hleEJ5dGUoYykge1xuICAgICAgICBsZXQgaGV4Qnl0ZSA9IGMuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNik7XG4gICAgICAgIGlmIChoZXhCeXRlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgaGV4Qnl0ZSA9IFwiMFwiICsgaGV4Qnl0ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGV4Qnl0ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmVmaXhlZEVsZW1lbnRDbGFzc05hbWVzKG5kKSB7XG4gICAgICAgIGNvbnN0IGNsYXNzQXR0cmlidXRlID0gbmQuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIik7XG4gICAgICAgIGlmICghY2xhc3NBdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjbGFzc0F0dHJpYnV0ZS5zcGxpdCgvXFxzKy9nKS5maWx0ZXIoQm9vbGVhbikubWFwKChubSkgPT4ge1xuICAgICAgICAgICAgLy8gVGhlIHByZWZpeCBpcyByZXF1aXJlZCB0byBzdG9yZSBcIl9fcHJvdG9fX1wiIGluIGEgb2JqZWN0LWJhc2VkIG1hcC5cbiAgICAgICAgICAgIHJldHVybiBcIiRcIiArIG5tO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAobm9kZS5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3QgbG93ZXJDYXNlTmFtZSA9IChub2RlLmxvY2FsTmFtZSAmJiBub2RlLmxvY2FsTmFtZS50b0xvd2VyQ2FzZSgpKVxuICAgICAgICB8fCBub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgICBjb25zdCBlbGVtZW50ID0gbm9kZTtcblxuICAgIGNvbnN0IGlkID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJpZFwiKTtcblxuICAgIGlmIChvcHRpbWl6ZWQpIHtcbiAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG9wdGltaXplZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogaWRTZWxlY3RvcihpZCksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChsb3dlckNhc2VOYW1lID09PSBcImJvZHlcIiB8fCBsb3dlckNhc2VOYW1lID09PSBcImhlYWRcIiB8fCBsb3dlckNhc2VOYW1lID09PSBcImh0bWxcIikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBvcHRpbWl6ZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGxvd2VyQ2FzZU5hbWUsIC8vIG5vZGUubm9kZU5hbWVJbkNvcnJlY3RDYXNlKCksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgbm9kZU5hbWUgPSBsb3dlckNhc2VOYW1lOyAvLyBub2RlLm5vZGVOYW1lSW5Db3JyZWN0Q2FzZSgpO1xuICAgIGlmIChpZCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgb3B0aW1pemVkOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IG5vZGVOYW1lICsgaWRTZWxlY3RvcihpZCksXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgY29uc3QgcGFyZW50ID0gbm9kZS5wYXJlbnROb2RlO1xuXG4gICAgaWYgKCFwYXJlbnQgfHwgcGFyZW50Lm5vZGVUeXBlID09PSBOb2RlLkRPQ1VNRU5UX05PREUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9wdGltaXplZDogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBub2RlTmFtZSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBjb25zdCBwcmVmaXhlZE93bkNsYXNzTmFtZXNBcnJheV8gPSBwcmVmaXhlZEVsZW1lbnRDbGFzc05hbWVzKGVsZW1lbnQpO1xuXG4gICAgY29uc3QgcHJlZml4ZWRPd25DbGFzc05hbWVzQXJyYXkgPSBbXTsgLy8gLmtleVNldCgpXG4gICAgcHJlZml4ZWRPd25DbGFzc05hbWVzQXJyYXlfLmZvckVhY2goKGFyckl0ZW0pID0+IHtcbiAgICAgICAgaWYgKHByZWZpeGVkT3duQ2xhc3NOYW1lc0FycmF5LmluZGV4T2YoYXJySXRlbSkgPCAwKSB7XG4gICAgICAgICAgICBwcmVmaXhlZE93bkNsYXNzTmFtZXNBcnJheS5wdXNoKGFyckl0ZW0pO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBsZXQgbmVlZHNDbGFzc05hbWVzID0gZmFsc2U7XG4gICAgbGV0IG5lZWRzTnRoQ2hpbGQgPSBmYWxzZTtcbiAgICBsZXQgb3duSW5kZXggPSAtMTtcbiAgICBsZXQgZWxlbWVudEluZGV4ID0gLTE7XG4gICAgY29uc3Qgc2libGluZ3MgPSBwYXJlbnQuY2hpbGRyZW47XG5cbiAgICBmb3IgKGxldCBpID0gMDsgKG93bkluZGV4ID09PSAtMSB8fCAhbmVlZHNOdGhDaGlsZCkgJiYgaSA8IHNpYmxpbmdzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IHNpYmxpbmcgPSBzaWJsaW5nc1tpXTtcbiAgICAgICAgaWYgKHNpYmxpbmcubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBlbGVtZW50SW5kZXggKz0gMTtcbiAgICAgICAgaWYgKHNpYmxpbmcgPT09IG5vZGUpIHtcbiAgICAgICAgICAgIG93bkluZGV4ID0gZWxlbWVudEluZGV4O1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5lZWRzTnRoQ2hpbGQpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2libGluZy5ub2RlTmFtZUluQ29ycmVjdENhc2UoKVxuICAgICAgICBjb25zdCBzaWJsaW5nTmFtZSA9IChzaWJsaW5nLmxvY2FsTmFtZSAmJiBzaWJsaW5nLmxvY2FsTmFtZS50b0xvd2VyQ2FzZSgpKSB8fCBzaWJsaW5nLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChzaWJsaW5nTmFtZSAhPT0gbm9kZU5hbWUpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIG5lZWRzQ2xhc3NOYW1lcyA9IHRydWU7XG5cbiAgICAgICAgY29uc3Qgb3duQ2xhc3NOYW1lcyA9IFtdO1xuICAgICAgICBwcmVmaXhlZE93bkNsYXNzTmFtZXNBcnJheS5mb3JFYWNoKChhcnJJdGVtKSA9PiB7XG4gICAgICAgICAgICBvd25DbGFzc05hbWVzLnB1c2goYXJySXRlbSk7XG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgb3duQ2xhc3NOYW1lQ291bnQgPSBvd25DbGFzc05hbWVzLmxlbmd0aDtcblxuICAgICAgICBpZiAob3duQ2xhc3NOYW1lQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgIG5lZWRzTnRoQ2hpbGQgPSB0cnVlO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2libGluZ0NsYXNzTmFtZXNBcnJheV8gPSBwcmVmaXhlZEVsZW1lbnRDbGFzc05hbWVzKHNpYmxpbmcpO1xuICAgICAgICBjb25zdCBzaWJsaW5nQ2xhc3NOYW1lc0FycmF5ID0gW107IC8vIC5rZXlTZXQoKVxuICAgICAgICBzaWJsaW5nQ2xhc3NOYW1lc0FycmF5Xy5mb3JFYWNoKChhcnJJdGVtKSA9PiB7XG4gICAgICAgICAgICBpZiAoc2libGluZ0NsYXNzTmFtZXNBcnJheS5pbmRleE9mKGFyckl0ZW0pIDwgMCkge1xuICAgICAgICAgICAgICAgIHNpYmxpbmdDbGFzc05hbWVzQXJyYXkucHVzaChhcnJJdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgZm9yIChjb25zdCBzaWJsaW5nQ2xhc3Mgb2Ygc2libGluZ0NsYXNzTmFtZXNBcnJheSkge1xuICAgICAgICAgICAgY29uc3QgaW5kID0gb3duQ2xhc3NOYW1lcy5pbmRleE9mKHNpYmxpbmdDbGFzcyk7XG4gICAgICAgICAgICBpZiAoaW5kIDwgMCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvd25DbGFzc05hbWVzLnNwbGljZShpbmQsIDEpOyAvLyBkZWxldGUgb3duQ2xhc3NOYW1lc1tzaWJsaW5nQ2xhc3NdO1xuXG4gICAgICAgICAgICBpZiAoIS0tb3duQ2xhc3NOYW1lQ291bnQpIHtcbiAgICAgICAgICAgICAgICBuZWVkc050aENoaWxkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGxldCByZXN1bHQgPSBub2RlTmFtZTtcbiAgICBpZiAoaXNUYXJnZXROb2RlICYmXG4gICAgICAgIG5vZGVOYW1lID09PSBcImlucHV0XCIgJiZcbiAgICAgICAgZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpICYmXG4gICAgICAgICFlbGVtZW50LmdldEF0dHJpYnV0ZShcImlkXCIpICYmXG4gICAgICAgICFlbGVtZW50LmdldEF0dHJpYnV0ZShcImNsYXNzXCIpKSB7XG4gICAgICAgIHJlc3VsdCArPSBcIlt0eXBlPVxcXCJcIiArIGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwidHlwZVwiKSArIFwiXFxcIl1cIjtcbiAgICB9XG4gICAgaWYgKG5lZWRzTnRoQ2hpbGQpIHtcbiAgICAgICAgcmVzdWx0ICs9IFwiOm50aC1jaGlsZChcIiArIChvd25JbmRleCArIDEpICsgXCIpXCI7XG4gICAgfSBlbHNlIGlmIChuZWVkc0NsYXNzTmFtZXMpIHtcbiAgICAgICAgZm9yIChjb25zdCBwcmVmaXhlZE5hbWUgb2YgcHJlZml4ZWRPd25DbGFzc05hbWVzQXJyYXkpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBcIi5cIiArIGVzY2FwZUlkZW50aWZpZXJJZk5lZWRlZChwcmVmaXhlZE5hbWUuc3Vic3RyKDEpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIG9wdGltaXplZDogZmFsc2UsXG4gICAgICAgIHZhbHVlOiByZXN1bHQsXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gbG9nKCkge1xuICAgIGlmIChkZWJ1Zykge1xuICAgICAgICBsb2dOYXRpdmUuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9XG59IiwiLy9cbi8vICBDb3B5cmlnaHQgMjAyMSBSZWFkaXVtIEZvdW5kYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgdGhlIEJTRC1zdHlsZSBsaWNlbnNlXG4vLyAgYXZhaWxhYmxlIGluIHRoZSB0b3AtbGV2ZWwgTElDRU5TRSBmaWxlIG9mIHRoZSBwcm9qZWN0LlxuLy9cblxuaW1wb3J0IHtsb2cgYXMgbG9nTmF0aXZlfSBmcm9tIFwiLi91dGlsc1wiO1xuXG5jb25zdCBkZWJ1ZyA9IGZhbHNlO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2xpZW50UmVjdHNOb092ZXJsYXAocmFuZ2UsIGRvTm90TWVyZ2VIb3Jpem9udGFsbHlBbGlnbmVkUmVjdHMpIHtcbiAgICBsZXQgY2xpZW50UmVjdHMgPSByYW5nZS5nZXRDbGllbnRSZWN0cygpO1xuXG4gICAgY29uc3QgdG9sZXJhbmNlID0gMTtcbiAgICBjb25zdCBvcmlnaW5hbFJlY3RzID0gW107XG4gICAgZm9yIChjb25zdCByYW5nZUNsaWVudFJlY3Qgb2YgY2xpZW50UmVjdHMpIHtcbiAgICAgICAgb3JpZ2luYWxSZWN0cy5wdXNoKHtcbiAgICAgICAgICAgIGJvdHRvbTogcmFuZ2VDbGllbnRSZWN0LmJvdHRvbSxcbiAgICAgICAgICAgIGhlaWdodDogcmFuZ2VDbGllbnRSZWN0LmhlaWdodCxcbiAgICAgICAgICAgIGxlZnQ6IHJhbmdlQ2xpZW50UmVjdC5sZWZ0LFxuICAgICAgICAgICAgcmlnaHQ6IHJhbmdlQ2xpZW50UmVjdC5yaWdodCxcbiAgICAgICAgICAgIHRvcDogcmFuZ2VDbGllbnRSZWN0LnRvcCxcbiAgICAgICAgICAgIHdpZHRoOiByYW5nZUNsaWVudFJlY3Qud2lkdGgsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBtZXJnZWRSZWN0cyA9IG1lcmdlVG91Y2hpbmdSZWN0cyhvcmlnaW5hbFJlY3RzLCB0b2xlcmFuY2UsIGRvTm90TWVyZ2VIb3Jpem9udGFsbHlBbGlnbmVkUmVjdHMpO1xuICAgIGNvbnN0IG5vQ29udGFpbmVkUmVjdHMgPSByZW1vdmVDb250YWluZWRSZWN0cyhtZXJnZWRSZWN0cywgdG9sZXJhbmNlKTtcbiAgICBjb25zdCBuZXdSZWN0cyA9IHJlcGxhY2VPdmVybGFwaW5nUmVjdHMobm9Db250YWluZWRSZWN0cyk7XG4gICAgY29uc3QgbWluQXJlYSA9IDIgKiAyO1xuICAgIGZvciAobGV0IGogPSBuZXdSZWN0cy5sZW5ndGggLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgICBjb25zdCByZWN0ID0gbmV3UmVjdHNbal07XG4gICAgICAgIGNvbnN0IGJpZ0Vub3VnaCA9IChyZWN0LndpZHRoICogcmVjdC5oZWlnaHQpID4gbWluQXJlYTtcbiAgICAgICAgaWYgKCFiaWdFbm91Z2gpIHtcbiAgICAgICAgICAgIGlmIChuZXdSZWN0cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgbG9nKFwiQ0xJRU5UIFJFQ1Q6IHJlbW92ZSBzbWFsbFwiKTtcbiAgICAgICAgICAgICAgICBuZXdSZWN0cy5zcGxpY2UoaiwgMSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvZyhcIkNMSUVOVCBSRUNUOiByZW1vdmUgc21hbGwsIGJ1dCBrZWVwIG90aGVyd2lzZSBlbXB0eSFcIik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbG9nKGBDTElFTlQgUkVDVDogcmVkdWNlZCAke29yaWdpbmFsUmVjdHMubGVuZ3RofSAtLT4gJHtuZXdSZWN0cy5sZW5ndGh9YCk7XG4gICAgcmV0dXJuIG5ld1JlY3RzO1xufVxuXG5mdW5jdGlvbiBtZXJnZVRvdWNoaW5nUmVjdHMocmVjdHMsIHRvbGVyYW5jZSwgZG9Ob3RNZXJnZUhvcml6b250YWxseUFsaWduZWRSZWN0cykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZm9yIChsZXQgaiA9IGkgKyAxOyBqIDwgcmVjdHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHJlY3QxID0gcmVjdHNbaV07XG4gICAgICAgICAgICBjb25zdCByZWN0MiA9IHJlY3RzW2pdO1xuICAgICAgICAgICAgaWYgKHJlY3QxID09PSByZWN0Mikge1xuICAgICAgICAgICAgICAgIGxvZyhcIm1lcmdlVG91Y2hpbmdSZWN0cyByZWN0MSA9PT0gcmVjdDIgPz8hXCIpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVjdHNMaW5lVXBWZXJ0aWNhbGx5ID0gYWxtb3N0RXF1YWwocmVjdDEudG9wLCByZWN0Mi50b3AsIHRvbGVyYW5jZSkgJiZcbiAgICAgICAgICAgICAgICBhbG1vc3RFcXVhbChyZWN0MS5ib3R0b20sIHJlY3QyLmJvdHRvbSwgdG9sZXJhbmNlKTtcbiAgICAgICAgICAgIGNvbnN0IHJlY3RzTGluZVVwSG9yaXpvbnRhbGx5ID0gYWxtb3N0RXF1YWwocmVjdDEubGVmdCwgcmVjdDIubGVmdCwgdG9sZXJhbmNlKSAmJlxuICAgICAgICAgICAgICAgIGFsbW9zdEVxdWFsKHJlY3QxLnJpZ2h0LCByZWN0Mi5yaWdodCwgdG9sZXJhbmNlKTtcbiAgICAgICAgICAgIGNvbnN0IGhvcml6b250YWxBbGxvd2VkID0gIWRvTm90TWVyZ2VIb3Jpem9udGFsbHlBbGlnbmVkUmVjdHM7XG4gICAgICAgICAgICBjb25zdCBhbGlnbmVkID0gKHJlY3RzTGluZVVwSG9yaXpvbnRhbGx5ICYmIGhvcml6b250YWxBbGxvd2VkKSB8fCAocmVjdHNMaW5lVXBWZXJ0aWNhbGx5ICYmICFyZWN0c0xpbmVVcEhvcml6b250YWxseSk7XG4gICAgICAgICAgICBjb25zdCBjYW5NZXJnZSA9IGFsaWduZWQgJiYgcmVjdHNUb3VjaE9yT3ZlcmxhcChyZWN0MSwgcmVjdDIsIHRvbGVyYW5jZSk7XG4gICAgICAgICAgICBpZiAoY2FuTWVyZ2UpIHtcbiAgICAgICAgICAgICAgICBsb2coYENMSUVOVCBSRUNUOiBtZXJnaW5nIHR3byBpbnRvIG9uZSwgVkVSVElDQUw6ICR7cmVjdHNMaW5lVXBWZXJ0aWNhbGx5fSBIT1JJWk9OVEFMOiAke3JlY3RzTGluZVVwSG9yaXpvbnRhbGx5fSAoJHtkb05vdE1lcmdlSG9yaXpvbnRhbGx5QWxpZ25lZFJlY3RzfSlgKTtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdSZWN0cyA9IHJlY3RzLmZpbHRlcigocmVjdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVjdCAhPT0gcmVjdDEgJiYgcmVjdCAhPT0gcmVjdDI7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVwbGFjZW1lbnRDbGllbnRSZWN0ID0gZ2V0Qm91bmRpbmdSZWN0KHJlY3QxLCByZWN0Mik7XG4gICAgICAgICAgICAgICAgbmV3UmVjdHMucHVzaChyZXBsYWNlbWVudENsaWVudFJlY3QpO1xuICAgICAgICAgICAgICAgIHJldHVybiBtZXJnZVRvdWNoaW5nUmVjdHMobmV3UmVjdHMsIHRvbGVyYW5jZSwgZG9Ob3RNZXJnZUhvcml6b250YWxseUFsaWduZWRSZWN0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlY3RzO1xufVxuXG5mdW5jdGlvbiBnZXRCb3VuZGluZ1JlY3QocmVjdDEsIHJlY3QyKSB7XG4gICAgY29uc3QgbGVmdCA9IE1hdGgubWluKHJlY3QxLmxlZnQsIHJlY3QyLmxlZnQpO1xuICAgIGNvbnN0IHJpZ2h0ID0gTWF0aC5tYXgocmVjdDEucmlnaHQsIHJlY3QyLnJpZ2h0KTtcbiAgICBjb25zdCB0b3AgPSBNYXRoLm1pbihyZWN0MS50b3AsIHJlY3QyLnRvcCk7XG4gICAgY29uc3QgYm90dG9tID0gTWF0aC5tYXgocmVjdDEuYm90dG9tLCByZWN0Mi5ib3R0b20pO1xuICAgIHJldHVybiB7XG4gICAgICAgIGJvdHRvbSxcbiAgICAgICAgaGVpZ2h0OiBib3R0b20gLSB0b3AsXG4gICAgICAgIGxlZnQsXG4gICAgICAgIHJpZ2h0LFxuICAgICAgICB0b3AsXG4gICAgICAgIHdpZHRoOiByaWdodCAtIGxlZnQsXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlQ29udGFpbmVkUmVjdHMocmVjdHMsIHRvbGVyYW5jZSkge1xuICAgIGNvbnN0IHJlY3RzVG9LZWVwID0gbmV3IFNldChyZWN0cyk7XG4gICAgZm9yIChjb25zdCByZWN0IG9mIHJlY3RzKSB7XG4gICAgICAgIGNvbnN0IGJpZ0Vub3VnaCA9IHJlY3Qud2lkdGggPiAxICYmIHJlY3QuaGVpZ2h0ID4gMTtcbiAgICAgICAgaWYgKCFiaWdFbm91Z2gpIHtcbiAgICAgICAgICAgIGxvZyhcIkNMSUVOVCBSRUNUOiByZW1vdmUgdGlueVwiKTtcbiAgICAgICAgICAgIHJlY3RzVG9LZWVwLmRlbGV0ZShyZWN0KTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgcG9zc2libHlDb250YWluaW5nUmVjdCBvZiByZWN0cykge1xuICAgICAgICAgICAgaWYgKHJlY3QgPT09IHBvc3NpYmx5Q29udGFpbmluZ1JlY3QpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcmVjdHNUb0tlZXAuaGFzKHBvc3NpYmx5Q29udGFpbmluZ1JlY3QpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVjdENvbnRhaW5zKHBvc3NpYmx5Q29udGFpbmluZ1JlY3QsIHJlY3QsIHRvbGVyYW5jZSkpIHtcbiAgICAgICAgICAgICAgICBsb2coXCJDTElFTlQgUkVDVDogcmVtb3ZlIGNvbnRhaW5lZFwiKTtcbiAgICAgICAgICAgICAgICByZWN0c1RvS2VlcC5kZWxldGUocmVjdCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIEFycmF5LmZyb20ocmVjdHNUb0tlZXApO1xufVxuXG5mdW5jdGlvbiByZWN0Q29udGFpbnMocmVjdDEsIHJlY3QyLCB0b2xlcmFuY2UpIHtcbiAgICByZXR1cm4gKHJlY3RDb250YWluc1BvaW50KHJlY3QxLCByZWN0Mi5sZWZ0LCByZWN0Mi50b3AsIHRvbGVyYW5jZSkgJiZcbiAgICAgICAgcmVjdENvbnRhaW5zUG9pbnQocmVjdDEsIHJlY3QyLnJpZ2h0LCByZWN0Mi50b3AsIHRvbGVyYW5jZSkgJiZcbiAgICAgICAgcmVjdENvbnRhaW5zUG9pbnQocmVjdDEsIHJlY3QyLmxlZnQsIHJlY3QyLmJvdHRvbSwgdG9sZXJhbmNlKSAmJlxuICAgICAgICByZWN0Q29udGFpbnNQb2ludChyZWN0MSwgcmVjdDIucmlnaHQsIHJlY3QyLmJvdHRvbSwgdG9sZXJhbmNlKSk7XG59XG5cbmZ1bmN0aW9uIHJlY3RDb250YWluc1BvaW50KHJlY3QsIHgsIHksIHRvbGVyYW5jZSkge1xuICAgIHJldHVybiAocmVjdC5sZWZ0IDwgeCB8fCBhbG1vc3RFcXVhbChyZWN0LmxlZnQsIHgsIHRvbGVyYW5jZSkpICYmXG4gICAgICAgIChyZWN0LnJpZ2h0ID4geCB8fCBhbG1vc3RFcXVhbChyZWN0LnJpZ2h0LCB4LCB0b2xlcmFuY2UpKSAmJlxuICAgICAgICAocmVjdC50b3AgPCB5IHx8IGFsbW9zdEVxdWFsKHJlY3QudG9wLCB5LCB0b2xlcmFuY2UpKSAmJlxuICAgICAgICAocmVjdC5ib3R0b20gPiB5IHx8IGFsbW9zdEVxdWFsKHJlY3QuYm90dG9tLCB5LCB0b2xlcmFuY2UpKTtcbn1cblxuZnVuY3Rpb24gcmVwbGFjZU92ZXJsYXBpbmdSZWN0cyhyZWN0cykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZm9yIChsZXQgaiA9IGkgKyAxOyBqIDwgcmVjdHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHJlY3QxID0gcmVjdHNbaV07XG4gICAgICAgICAgICBjb25zdCByZWN0MiA9IHJlY3RzW2pdO1xuICAgICAgICAgICAgaWYgKHJlY3QxID09PSByZWN0Mikge1xuICAgICAgICAgICAgICAgIGxvZyhcInJlcGxhY2VPdmVybGFwaW5nUmVjdHMgcmVjdDEgPT09IHJlY3QyID8/IVwiKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZWN0c1RvdWNoT3JPdmVybGFwKHJlY3QxLCByZWN0MiwgLTEpKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRvQWRkID0gW107XG4gICAgICAgICAgICAgICAgbGV0IHRvUmVtb3ZlO1xuICAgICAgICAgICAgICAgIGxldCB0b1ByZXNlcnZlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN1YnRyYWN0UmVjdHMxID0gcmVjdFN1YnRyYWN0KHJlY3QxLCByZWN0Mik7XG4gICAgICAgICAgICAgICAgaWYgKHN1YnRyYWN0UmVjdHMxLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICB0b0FkZCA9IHN1YnRyYWN0UmVjdHMxO1xuICAgICAgICAgICAgICAgICAgICB0b1JlbW92ZSA9IHJlY3QxO1xuICAgICAgICAgICAgICAgICAgICB0b1ByZXNlcnZlID0gcmVjdDI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3VidHJhY3RSZWN0czIgPSByZWN0U3VidHJhY3QocmVjdDIsIHJlY3QxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN1YnRyYWN0UmVjdHMxLmxlbmd0aCA8IHN1YnRyYWN0UmVjdHMyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9BZGQgPSBzdWJ0cmFjdFJlY3RzMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvUmVtb3ZlID0gcmVjdDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b1ByZXNlcnZlID0gcmVjdDI7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b0FkZCA9IHN1YnRyYWN0UmVjdHMyO1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9SZW1vdmUgPSByZWN0MjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvUHJlc2VydmUgPSByZWN0MTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsb2coYENMSUVOVCBSRUNUOiBvdmVybGFwLCBjdXQgb25lIHJlY3QgaW50byAke3RvQWRkLmxlbmd0aH1gKTtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdSZWN0cyA9IHJlY3RzLmZpbHRlcigocmVjdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVjdCAhPT0gdG9SZW1vdmU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkobmV3UmVjdHMsIHRvQWRkKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVwbGFjZU92ZXJsYXBpbmdSZWN0cyhuZXdSZWN0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlY3RzO1xufVxuXG5mdW5jdGlvbiByZWN0U3VidHJhY3QocmVjdDEsIHJlY3QyKSB7XG4gICAgY29uc3QgcmVjdEludGVyc2VjdGVkID0gcmVjdEludGVyc2VjdChyZWN0MiwgcmVjdDEpO1xuICAgIGlmIChyZWN0SW50ZXJzZWN0ZWQuaGVpZ2h0ID09PSAwIHx8IHJlY3RJbnRlcnNlY3RlZC53aWR0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gW3JlY3QxXTtcbiAgICB9XG4gICAgY29uc3QgcmVjdHMgPSBbXTtcbiAgICB7XG4gICAgICAgIGNvbnN0IHJlY3RBID0ge1xuICAgICAgICAgICAgYm90dG9tOiByZWN0MS5ib3R0b20sXG4gICAgICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgICAgICBsZWZ0OiByZWN0MS5sZWZ0LFxuICAgICAgICAgICAgcmlnaHQ6IHJlY3RJbnRlcnNlY3RlZC5sZWZ0LFxuICAgICAgICAgICAgdG9wOiByZWN0MS50b3AsXG4gICAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgfTtcbiAgICAgICAgcmVjdEEud2lkdGggPSByZWN0QS5yaWdodCAtIHJlY3RBLmxlZnQ7XG4gICAgICAgIHJlY3RBLmhlaWdodCA9IHJlY3RBLmJvdHRvbSAtIHJlY3RBLnRvcDtcbiAgICAgICAgaWYgKHJlY3RBLmhlaWdodCAhPT0gMCAmJiByZWN0QS53aWR0aCAhPT0gMCkge1xuICAgICAgICAgICAgcmVjdHMucHVzaChyZWN0QSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAge1xuICAgICAgICBjb25zdCByZWN0QiA9IHtcbiAgICAgICAgICAgIGJvdHRvbTogcmVjdEludGVyc2VjdGVkLnRvcCxcbiAgICAgICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgICAgIGxlZnQ6IHJlY3RJbnRlcnNlY3RlZC5sZWZ0LFxuICAgICAgICAgICAgcmlnaHQ6IHJlY3RJbnRlcnNlY3RlZC5yaWdodCxcbiAgICAgICAgICAgIHRvcDogcmVjdDEudG9wLFxuICAgICAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgIH07XG4gICAgICAgIHJlY3RCLndpZHRoID0gcmVjdEIucmlnaHQgLSByZWN0Qi5sZWZ0O1xuICAgICAgICByZWN0Qi5oZWlnaHQgPSByZWN0Qi5ib3R0b20gLSByZWN0Qi50b3A7XG4gICAgICAgIGlmIChyZWN0Qi5oZWlnaHQgIT09IDAgJiYgcmVjdEIud2lkdGggIT09IDApIHtcbiAgICAgICAgICAgIHJlY3RzLnB1c2gocmVjdEIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHtcbiAgICAgICAgY29uc3QgcmVjdEMgPSB7XG4gICAgICAgICAgICBib3R0b206IHJlY3QxLmJvdHRvbSxcbiAgICAgICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgICAgIGxlZnQ6IHJlY3RJbnRlcnNlY3RlZC5sZWZ0LFxuICAgICAgICAgICAgcmlnaHQ6IHJlY3RJbnRlcnNlY3RlZC5yaWdodCxcbiAgICAgICAgICAgIHRvcDogcmVjdEludGVyc2VjdGVkLmJvdHRvbSxcbiAgICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICB9O1xuICAgICAgICByZWN0Qy53aWR0aCA9IHJlY3RDLnJpZ2h0IC0gcmVjdEMubGVmdDtcbiAgICAgICAgcmVjdEMuaGVpZ2h0ID0gcmVjdEMuYm90dG9tIC0gcmVjdEMudG9wO1xuICAgICAgICBpZiAocmVjdEMuaGVpZ2h0ICE9PSAwICYmIHJlY3RDLndpZHRoICE9PSAwKSB7XG4gICAgICAgICAgICByZWN0cy5wdXNoKHJlY3RDKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB7XG4gICAgICAgIGNvbnN0IHJlY3REID0ge1xuICAgICAgICAgICAgYm90dG9tOiByZWN0MS5ib3R0b20sXG4gICAgICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgICAgICBsZWZ0OiByZWN0SW50ZXJzZWN0ZWQucmlnaHQsXG4gICAgICAgICAgICByaWdodDogcmVjdDEucmlnaHQsXG4gICAgICAgICAgICB0b3A6IHJlY3QxLnRvcCxcbiAgICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICB9O1xuICAgICAgICByZWN0RC53aWR0aCA9IHJlY3RELnJpZ2h0IC0gcmVjdEQubGVmdDtcbiAgICAgICAgcmVjdEQuaGVpZ2h0ID0gcmVjdEQuYm90dG9tIC0gcmVjdEQudG9wO1xuICAgICAgICBpZiAocmVjdEQuaGVpZ2h0ICE9PSAwICYmIHJlY3RELndpZHRoICE9PSAwKSB7XG4gICAgICAgICAgICByZWN0cy5wdXNoKHJlY3REKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVjdHM7XG59XG5cbmZ1bmN0aW9uIHJlY3RJbnRlcnNlY3QocmVjdDEsIHJlY3QyKSB7XG4gICAgY29uc3QgbWF4TGVmdCA9IE1hdGgubWF4KHJlY3QxLmxlZnQsIHJlY3QyLmxlZnQpO1xuICAgIGNvbnN0IG1pblJpZ2h0ID0gTWF0aC5taW4ocmVjdDEucmlnaHQsIHJlY3QyLnJpZ2h0KTtcbiAgICBjb25zdCBtYXhUb3AgPSBNYXRoLm1heChyZWN0MS50b3AsIHJlY3QyLnRvcCk7XG4gICAgY29uc3QgbWluQm90dG9tID0gTWF0aC5taW4ocmVjdDEuYm90dG9tLCByZWN0Mi5ib3R0b20pO1xuICAgIHJldHVybiB7XG4gICAgICAgIGJvdHRvbTogbWluQm90dG9tLFxuICAgICAgICBoZWlnaHQ6IE1hdGgubWF4KDAsIG1pbkJvdHRvbSAtIG1heFRvcCksXG4gICAgICAgIGxlZnQ6IG1heExlZnQsXG4gICAgICAgIHJpZ2h0OiBtaW5SaWdodCxcbiAgICAgICAgdG9wOiBtYXhUb3AsXG4gICAgICAgIHdpZHRoOiBNYXRoLm1heCgwLCBtaW5SaWdodCAtIG1heExlZnQpLFxuICAgIH07XG59XG5cbmZ1bmN0aW9uIHJlY3RzVG91Y2hPck92ZXJsYXAocmVjdDEsIHJlY3QyLCB0b2xlcmFuY2UpIHtcbiAgICByZXR1cm4gKChyZWN0MS5sZWZ0IDwgcmVjdDIucmlnaHQgfHwgKHRvbGVyYW5jZSA+PSAwICYmIGFsbW9zdEVxdWFsKHJlY3QxLmxlZnQsIHJlY3QyLnJpZ2h0LCB0b2xlcmFuY2UpKSkgJiZcbiAgICAgICAgKHJlY3QyLmxlZnQgPCByZWN0MS5yaWdodCB8fCAodG9sZXJhbmNlID49IDAgJiYgYWxtb3N0RXF1YWwocmVjdDIubGVmdCwgcmVjdDEucmlnaHQsIHRvbGVyYW5jZSkpKSAmJlxuICAgICAgICAocmVjdDEudG9wIDwgcmVjdDIuYm90dG9tIHx8ICh0b2xlcmFuY2UgPj0gMCAmJiBhbG1vc3RFcXVhbChyZWN0MS50b3AsIHJlY3QyLmJvdHRvbSwgdG9sZXJhbmNlKSkpICYmXG4gICAgICAgIChyZWN0Mi50b3AgPCByZWN0MS5ib3R0b20gfHwgKHRvbGVyYW5jZSA+PSAwICYmIGFsbW9zdEVxdWFsKHJlY3QyLnRvcCwgcmVjdDEuYm90dG9tLCB0b2xlcmFuY2UpKSkpO1xufVxuXG5mdW5jdGlvbiBhbG1vc3RFcXVhbChhLCBiLCB0b2xlcmFuY2UpIHtcbiAgICByZXR1cm4gTWF0aC5hYnMoYSAtIGIpIDw9IHRvbGVyYW5jZTtcbn1cblxuZnVuY3Rpb24gbG9nKCkge1xuICAgIGlmIChkZWJ1Zykge1xuICAgICAgICBsb2dOYXRpdmUuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9XG59IiwiLy9cbi8vICBDb3B5cmlnaHQgMjAyMSBSZWFkaXVtIEZvdW5kYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgdGhlIEJTRC1zdHlsZSBsaWNlbnNlXG4vLyAgYXZhaWxhYmxlIGluIHRoZSB0b3AtbGV2ZWwgTElDRU5TRSBmaWxlIG9mIHRoZSBwcm9qZWN0LlxuLy9cblxuaW1wb3J0IHtjb252ZXJ0UmFuZ2VJbmZvLCBsb2NhdGlvbjJSYW5nZUluZm99IGZyb20gXCIuL3NlbGVjdGlvblwiO1xuaW1wb3J0IHtnZXRDbGllbnRSZWN0c05vT3ZlcmxhcH0gZnJvbSBcIi4vcmVjdFwiO1xuXG5jb25zdCBkZWJ1ZyA9IGZhbHNlO1xuXG5jb25zdCBJRF9ISUdITElHSFRTX0NPTlRBSU5FUiA9IFwiUjJfSURfSElHSExJR0hUU19DT05UQUlORVJcIjtcbmNvbnN0IENMQVNTX0hJR0hMSUdIVF9DT05UQUlORVIgPSBcIlIyX0NMQVNTX0hJR0hMSUdIVF9DT05UQUlORVJcIjtcbmNvbnN0IENMQVNTX0hJR0hMSUdIVF9BUkVBID0gXCJSMl9DTEFTU19ISUdITElHSFRfQVJFQVwiO1xuY29uc3QgQ0xBU1NfSElHSExJR0hUX0JPVU5ESU5HX0FSRUEgPSBcIlIyX0NMQVNTX0hJR0hMSUdIVF9CT1VORElOR19BUkVBXCI7XG5cbmNvbnN0IF9oaWdobGlnaHRzID0gW107XG5sZXQgX2hpZ2hsaWdodHNDb250YWluZXI7XG5cbmNvbnN0IGRlZmF1bHRCYWNrZ3JvdW5kT3BhY2l0eSA9IDAuMztcblxuY29uc3QgZGVmYXVsdEJhY2tncm91bmRDb2xvciA9IHtcbiAgICBibHVlOiAxMDAsXG4gICAgZ3JlZW46IDUwLFxuICAgIHJlZDogMjMwLFxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIHJlY3RGb3JIaWdobGlnaHRXaXRoSUQoaWQpIHtcbiAgICBjb25zdCBjbGllbnRSZWN0cyA9IGZyYW1lRm9ySGlnaGxpZ2h0V2l0aElEKGlkKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHNjcmVlbldpZHRoOiB3aW5kb3cub3V0ZXJXaWR0aCxcbiAgICAgICAgc2NyZWVuSGVpZ2h0OiB3aW5kb3cub3V0ZXJIZWlnaHQsXG4gICAgICAgIGxlZnQ6IGNsaWVudFJlY3RzWzBdLmxlZnQsXG4gICAgICAgIHdpZHRoOiBjbGllbnRSZWN0c1swXS53aWR0aCxcbiAgICAgICAgdG9wOiBjbGllbnRSZWN0c1swXS50b3AsXG4gICAgICAgIGhlaWdodDogY2xpZW50UmVjdHNbMF0uaGVpZ2h0XG4gICAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlc3Ryb3lBbGxIaWdobGlnaHRzKCkge1xuICAgIGhpZGVBbGxIaWdobGlnaHRzKCk7XG4gICAgX2hpZ2hsaWdodHMuc3BsaWNlKDAsIF9oaWdobGlnaHRzLmxlbmd0aCk7XG59XG5cbmZ1bmN0aW9uIGhpZGVBbGxIaWdobGlnaHRzKCkge1xuICAgIGlmIChfaGlnaGxpZ2h0c0NvbnRhaW5lcikge1xuICAgICAgICBfaGlnaGxpZ2h0c0NvbnRhaW5lci5yZW1vdmUoKTtcbiAgICAgICAgX2hpZ2hsaWdodHNDb250YWluZXIgPSBudWxsO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUhpZ2hsaWdodFJhbmdlKHJhbmdlKSB7XG5cbiAgICAvLyBGSVhNRTogVXNlIHVzZXItcHJvdmlkZWQgSUQuXG4gICAgbGV0IGlkID0gXCJSMl9ISUdITElHSFRfXCIgKyBEYXRlLm5vdygpO1xuXG4gICAgZGVzdHJveUhpZ2hsaWdodChpZCk7XG5cbiAgICBjb25zdCBoaWdobGlnaHQgPSB7XG4gICAgICAgIGNvbG9yOiBkZWZhdWx0QmFja2dyb3VuZENvbG9yLFxuICAgICAgICBpZCxcbiAgICAgICAgcG9pbnRlckludGVyYWN0aW9uOiB0cnVlLFxuICAgICAgICByYW5nZUluZm86IG51bGxcbiAgICB9O1xuICAgIF9oaWdobGlnaHRzLnB1c2goaGlnaGxpZ2h0KTtcbiAgICBjcmVhdGVIaWdobGlnaHRGcm9tUmFuZ2UocmFuZ2UsIGhpZ2hsaWdodCk7XG5cbiAgICByZXR1cm4gaGlnaGxpZ2h0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlSGlnaGxpZ2h0KGxvY2F0aW9ucywgY29sb3IsIHBvaW50ZXJJbnRlcmFjdGlvbikge1xuICAgIGNvbnN0IHJhbmdlSW5mbyA9IGxvY2F0aW9uMlJhbmdlSW5mbyhsb2NhdGlvbnMpXG5cbiAgICAvLyBGSVhNRTogVXNlIHVzZXItcHJvdmlkZWQgSUQuXG4gICAgbGV0IGlkID0gXCJSMl9ISUdITElHSFRfXCIgKyBEYXRlLm5vdygpO1xuXG4gICAgZGVzdHJveUhpZ2hsaWdodChpZCk7XG5cbiAgICBjb25zdCBoaWdobGlnaHQgPSB7XG4gICAgICAgIGNvbG9yOiBjb2xvciA/IGNvbG9yIDogZGVmYXVsdEJhY2tncm91bmRDb2xvcixcbiAgICAgICAgaWQsXG4gICAgICAgIHBvaW50ZXJJbnRlcmFjdGlvbixcbiAgICAgICAgcmFuZ2VJbmZvXG4gICAgfTtcbiAgICBfaGlnaGxpZ2h0cy5wdXNoKGhpZ2hsaWdodCk7XG4gICAgY3JlYXRlSGlnaGxpZ2h0RG9tKGhpZ2hsaWdodCk7XG5cbiAgICByZXR1cm4gaGlnaGxpZ2h0O1xufVxuXG5mdW5jdGlvbiBkZXN0cm95SGlnaGxpZ2h0KGlkKSB7XG4gICAgbGV0IGkgPSAtMTtcbiAgICBsZXQgX2RvY3VtZW50ID0gd2luZG93LmRvY3VtZW50XG4gICAgY29uc3QgaGlnaGxpZ2h0ID0gX2hpZ2hsaWdodHMuZmluZCgoaCwgaikgPT4ge1xuICAgICAgICBpID0gajtcbiAgICAgICAgcmV0dXJuIGguaWQgPT09IGlkO1xuICAgIH0pO1xuICAgIGlmIChoaWdobGlnaHQgJiYgaSA+PSAwICYmIGkgPCBfaGlnaGxpZ2h0cy5sZW5ndGgpIHtcbiAgICAgICAgX2hpZ2hsaWdodHMuc3BsaWNlKGksIDEpO1xuICAgIH1cbiAgICBjb25zdCBoaWdobGlnaHRDb250YWluZXIgPSBfZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpO1xuICAgIGlmIChoaWdobGlnaHRDb250YWluZXIpIHtcbiAgICAgICAgaGlnaGxpZ2h0Q29udGFpbmVyLnJlbW92ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlSGlnaGxpZ2h0RG9tKGhpZ2hsaWdodCkge1xuICAgIGNvbnN0IHJhbmdlID0gY29udmVydFJhbmdlSW5mbyhkb2N1bWVudCwgaGlnaGxpZ2h0LnJhbmdlSW5mbyk7XG4gICAgcmV0dXJuIGNyZWF0ZUhpZ2hsaWdodEZyb21SYW5nZShyYW5nZSwgaGlnaGxpZ2h0KVxufVxuXG5mdW5jdGlvbiBjcmVhdGVIaWdobGlnaHRGcm9tUmFuZ2UocmFuZ2UsIGhpZ2hsaWdodCkge1xuICAgIGlmICghcmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBjb25zdCBzY2FsZSA9IDEgLyAoKHdpbmRvdy5SRUFESVVNMiAmJiB3aW5kb3cuUkVBRElVTTIuaXNGaXhlZExheW91dCkgPyB3aW5kb3cuUkVBRElVTTIuZnhsVmlld3BvcnRTY2FsZSA6IDEpO1xuXG4gICAgY29uc3Qgc2Nyb2xsRWxlbWVudCA9IGRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnQ7XG5cbiAgICBjb25zdCBwYWdpbmF0ZWQgPSAhaXNTY3JvbGxNb2RlRW5hYmxlZCgpXG4gICAgY29uc3QgaGlnaGxpZ2h0c0NvbnRhaW5lciA9IGVuc3VyZUNvbnRhaW5lcih3aW5kb3cpO1xuICAgIGNvbnN0IGhpZ2hsaWdodFBhcmVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG5cbiAgICBoaWdobGlnaHRQYXJlbnQuc2V0QXR0cmlidXRlKFwiaWRcIiwgaGlnaGxpZ2h0LmlkKTtcbiAgICBoaWdobGlnaHRQYXJlbnQuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgQ0xBU1NfSElHSExJR0hUX0NPTlRBSU5FUik7XG5cbiAgICBoaWdobGlnaHRQYXJlbnQuc3R5bGUuc2V0UHJvcGVydHkoXCJwb2ludGVyLWV2ZW50c1wiLCBcIm5vbmVcIik7XG4gICAgaWYgKGhpZ2hsaWdodC5wb2ludGVySW50ZXJhY3Rpb24pIHtcbiAgICAgICAgaGlnaGxpZ2h0UGFyZW50LnNldEF0dHJpYnV0ZShcImRhdGEtY2xpY2tcIiwgXCIxXCIpO1xuICAgIH1cblxuICAgIGNvbnN0IGJvZHlSZWN0ID0gZG9jdW1lbnQuYm9keS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCBkcmF3VW5kZXJsaW5lID0gZmFsc2U7XG4gICAgY29uc3QgZHJhd1N0cmlrZVRocm91Z2ggPSBmYWxzZTtcbiAgICBjb25zdCBkb05vdE1lcmdlSG9yaXpvbnRhbGx5QWxpZ25lZFJlY3RzID0gZHJhd1VuZGVybGluZSB8fCBkcmF3U3RyaWtlVGhyb3VnaDtcbiAgICBjb25zdCBjbGllbnRSZWN0cyA9IGdldENsaWVudFJlY3RzTm9PdmVybGFwKHJhbmdlLCBkb05vdE1lcmdlSG9yaXpvbnRhbGx5QWxpZ25lZFJlY3RzKTtcbiAgICBjb25zdCByb3VuZGVkQ29ybmVyID0gMztcbiAgICBjb25zdCB1bmRlcmxpbmVUaGlja25lc3MgPSAyO1xuICAgIGNvbnN0IHN0cmlrZVRocm91Z2hMaW5lVGhpY2tuZXNzID0gMztcbiAgICBjb25zdCBvcGFjaXR5ID0gZGVmYXVsdEJhY2tncm91bmRPcGFjaXR5O1xuICAgIGxldCBleHRyYSA9IFwiXCI7XG5cbiAgICBsZXQgeE9mZnNldDtcbiAgICBsZXQgeU9mZnNldDtcblxuICAgIC8vIGlmIChuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9BbmRyb2lkL2kpKSB7XG4gICAgeE9mZnNldCA9IHBhZ2luYXRlZCA/ICgtc2Nyb2xsRWxlbWVudC5zY3JvbGxMZWZ0KSA6IGJvZHlSZWN0LmxlZnQ7XG4gICAgeU9mZnNldCA9IHBhZ2luYXRlZCA/ICgtc2Nyb2xsRWxlbWVudC5zY3JvbGxUb3ApIDogYm9keVJlY3QudG9wO1xuICAgIC8vIH0gZWxzZSBpZiAobmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvaVBob25lfGlQYWR8aVBvZC9pKSkge1xuICAgIC8vICAgICB4T2Zmc2V0ID0gcGFnaW5hdGVkID8gMCA6ICgtc2Nyb2xsRWxlbWVudC5zY3JvbGxMZWZ0KTtcbiAgICAvLyAgICAgeU9mZnNldCA9IHBhZ2luYXRlZCA/IDAgOiAoYm9keVJlY3QudG9wKTtcbiAgICAvLyAgICAgYW5ub3RhdGlvbk9mZnNldCA9IHBhcnNlSW50KChyYW5nZUFubm90YXRpb25Cb3VuZGluZ0NsaWVudFJlY3QucmlnaHQvd2luZG93LmlubmVyV2lkdGgpICsgMSk7XG4gICAgLy8gfVxuXG4gICAgZm9yIChjb25zdCBjbGllbnRSZWN0IG9mIGNsaWVudFJlY3RzKSB7XG4gICAgICAgIGNvbnN0IGhpZ2hsaWdodEFyZWEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXG4gICAgICAgIGhpZ2hsaWdodEFyZWEuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgQ0xBU1NfSElHSExJR0hUX0FSRUEpO1xuXG4gICAgICAgIGlmIChkZWJ1Zykge1xuICAgICAgICAgICAgY29uc3QgcmdiID0gTWF0aC5yb3VuZCgweGZmZmZmZiAqIE1hdGgucmFuZG9tKCkpO1xuICAgICAgICAgICAgY29uc3QgciA9IHJnYiA+PiAxNjtcbiAgICAgICAgICAgIGNvbnN0IGcgPSByZ2IgPj4gOCAmIDI1NTtcbiAgICAgICAgICAgIGNvbnN0IGIgPSByZ2IgJiAyNTU7XG4gICAgICAgICAgICBleHRyYSA9IGBvdXRsaW5lLWNvbG9yOiByZ2IoJHtyfSwgJHtnfSwgJHtifSk7IG91dGxpbmUtc3R5bGU6IHNvbGlkOyBvdXRsaW5lLXdpZHRoOiAxcHg7IG91dGxpbmUtb2Zmc2V0OiAtMXB4O2A7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoZHJhd1VuZGVybGluZSkge1xuICAgICAgICAgICAgICAgIGV4dHJhICs9IGBib3JkZXItYm90dG9tOiAke3VuZGVybGluZVRoaWNrbmVzcyAqIHNjYWxlfXB4IHNvbGlkIHJnYmEoJHtoaWdobGlnaHQuY29sb3IucmVkfSwgJHtoaWdobGlnaHQuY29sb3IuZ3JlZW59LCAke2hpZ2hsaWdodC5jb2xvci5ibHVlfSwgJHtvcGFjaXR5fSkgIWltcG9ydGFudGA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaGlnaGxpZ2h0QXJlYS5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBgYm9yZGVyLXJhZGl1czogJHtyb3VuZGVkQ29ybmVyfXB4ICFpbXBvcnRhbnQ7IGJhY2tncm91bmQtY29sb3I6IHJnYmEoJHtoaWdobGlnaHQuY29sb3IucmVkfSwgJHtoaWdobGlnaHQuY29sb3IuZ3JlZW59LCAke2hpZ2hsaWdodC5jb2xvci5ibHVlfSwgJHtvcGFjaXR5fSkgIWltcG9ydGFudDsgJHtleHRyYX1gKTtcbiAgICAgICAgaGlnaGxpZ2h0QXJlYS5zdHlsZS5zZXRQcm9wZXJ0eShcInBvaW50ZXItZXZlbnRzXCIsIFwibm9uZVwiKTtcbiAgICAgICAgaGlnaGxpZ2h0QXJlYS5zdHlsZS5wb3NpdGlvbiA9ICFwYWdpbmF0ZWQgPyBcImZpeGVkXCIgOiBcImFic29sdXRlXCI7XG4gICAgICAgIGhpZ2hsaWdodEFyZWEuc2NhbGUgPSBzY2FsZTtcbiAgICAgICAgLypcbiAgICAgICAgIGhpZ2hsaWdodEFyZWEucmVjdCA9IHtcbiAgICAgICAgIGhlaWdodDogY2xpZW50UmVjdC5oZWlnaHQsXG4gICAgICAgICBsZWZ0OiBjbGllbnRSZWN0LmxlZnQgLSB4T2Zmc2V0LFxuICAgICAgICAgdG9wOiBjbGllbnRSZWN0LnRvcCAtIHlPZmZzZXQsXG4gICAgICAgICB3aWR0aDogY2xpZW50UmVjdC53aWR0aCxcbiAgICAgICAgIH07XG4gICAgICAgICAqL1xuICAgICAgICBoaWdobGlnaHRBcmVhLnJlY3QgPSB7XG4gICAgICAgICAgICBoZWlnaHQ6IGNsaWVudFJlY3QuaGVpZ2h0LFxuICAgICAgICAgICAgbGVmdDogY2xpZW50UmVjdC5sZWZ0IC0geE9mZnNldCxcbiAgICAgICAgICAgIHRvcDogY2xpZW50UmVjdC50b3AgLSB5T2Zmc2V0LFxuICAgICAgICAgICAgd2lkdGg6IGNsaWVudFJlY3Qud2lkdGhcbiAgICAgICAgfTtcblxuICAgICAgICBoaWdobGlnaHRBcmVhLnN0eWxlLndpZHRoID0gYCR7aGlnaGxpZ2h0QXJlYS5yZWN0LndpZHRoICogc2NhbGV9cHhgO1xuICAgICAgICBoaWdobGlnaHRBcmVhLnN0eWxlLmhlaWdodCA9IGAke2hpZ2hsaWdodEFyZWEucmVjdC5oZWlnaHQgKiBzY2FsZX1weGA7XG4gICAgICAgIGhpZ2hsaWdodEFyZWEuc3R5bGUubGVmdCA9IGAke2hpZ2hsaWdodEFyZWEucmVjdC5sZWZ0ICogc2NhbGV9cHhgO1xuICAgICAgICBoaWdobGlnaHRBcmVhLnN0eWxlLnRvcCA9IGAke2hpZ2hsaWdodEFyZWEucmVjdC50b3AgKiBzY2FsZX1weGA7XG4gICAgICAgIGhpZ2hsaWdodFBhcmVudC5hcHBlbmQoaGlnaGxpZ2h0QXJlYSk7XG4gICAgICAgIGlmICghZGVidWcgJiYgZHJhd1N0cmlrZVRocm91Z2gpIHtcbiAgICAgICAgICAgIC8vaWYgKGRyYXdTdHJpa2VUaHJvdWdoKSB7XG4gICAgICAgICAgICBjb25zdCBoaWdobGlnaHRBcmVhTGluZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICBoaWdobGlnaHRBcmVhTGluZS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBDTEFTU19ISUdITElHSFRfQVJFQSk7XG5cbiAgICAgICAgICAgIGhpZ2hsaWdodEFyZWFMaW5lLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIGBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKCR7aGlnaGxpZ2h0LmNvbG9yLnJlZH0sICR7aGlnaGxpZ2h0LmNvbG9yLmdyZWVufSwgJHtoaWdobGlnaHQuY29sb3IuYmx1ZX0sICR7b3BhY2l0eX0pICFpbXBvcnRhbnQ7YCk7XG4gICAgICAgICAgICBoaWdobGlnaHRBcmVhTGluZS5zdHlsZS5zZXRQcm9wZXJ0eShcInBvaW50ZXItZXZlbnRzXCIsIFwibm9uZVwiKTtcbiAgICAgICAgICAgIGhpZ2hsaWdodEFyZWFMaW5lLnN0eWxlLnBvc2l0aW9uID0gcGFnaW5hdGVkID8gXCJmaXhlZFwiIDogXCJhYnNvbHV0ZVwiO1xuICAgICAgICAgICAgaGlnaGxpZ2h0QXJlYUxpbmUuc2NhbGUgPSBzY2FsZTtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgaGlnaGxpZ2h0QXJlYUxpbmUucmVjdCA9IHtcbiAgICAgICAgICAgICBoZWlnaHQ6IGNsaWVudFJlY3QuaGVpZ2h0LFxuICAgICAgICAgICAgIGxlZnQ6IGNsaWVudFJlY3QubGVmdCAtIHhPZmZzZXQsXG4gICAgICAgICAgICAgdG9wOiBjbGllbnRSZWN0LnRvcCAtIHlPZmZzZXQsXG4gICAgICAgICAgICAgd2lkdGg6IGNsaWVudFJlY3Qud2lkdGgsXG4gICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICBoaWdobGlnaHRBcmVhTGluZS5yZWN0ID0ge1xuICAgICAgICAgICAgICAgIGhlaWdodDogY2xpZW50UmVjdC5oZWlnaHQsXG4gICAgICAgICAgICAgICAgbGVmdDogY2xpZW50UmVjdC5sZWZ0IC0geE9mZnNldCxcbiAgICAgICAgICAgICAgICB0b3A6IGNsaWVudFJlY3QudG9wIC0geU9mZnNldCxcbiAgICAgICAgICAgICAgICB3aWR0aDogY2xpZW50UmVjdC53aWR0aFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaGlnaGxpZ2h0QXJlYUxpbmUuc3R5bGUud2lkdGggPSBgJHtoaWdobGlnaHRBcmVhTGluZS5yZWN0LndpZHRoICogc2NhbGV9cHhgO1xuICAgICAgICAgICAgaGlnaGxpZ2h0QXJlYUxpbmUuc3R5bGUuaGVpZ2h0ID0gYCR7c3RyaWtlVGhyb3VnaExpbmVUaGlja25lc3MgKiBzY2FsZX1weGA7XG4gICAgICAgICAgICBoaWdobGlnaHRBcmVhTGluZS5zdHlsZS5sZWZ0ID0gYCR7aGlnaGxpZ2h0QXJlYUxpbmUucmVjdC5sZWZ0ICogc2NhbGV9cHhgO1xuICAgICAgICAgICAgaGlnaGxpZ2h0QXJlYUxpbmUuc3R5bGUudG9wID0gYCR7KGhpZ2hsaWdodEFyZWFMaW5lLnJlY3QudG9wICsgKGhpZ2hsaWdodEFyZWFMaW5lLnJlY3QuaGVpZ2h0IC8gMikgLSAoc3RyaWtlVGhyb3VnaExpbmVUaGlja25lc3MgLyAyKSkgKiBzY2FsZX1weGA7XG4gICAgICAgICAgICBoaWdobGlnaHRQYXJlbnQuYXBwZW5kKGhpZ2hsaWdodEFyZWFMaW5lKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGhpZ2hsaWdodEJvdW5kaW5nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBoaWdobGlnaHRCb3VuZGluZy5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBDTEFTU19ISUdITElHSFRfQk9VTkRJTkdfQVJFQSk7XG5cbiAgICBoaWdobGlnaHRCb3VuZGluZy5zdHlsZS5zZXRQcm9wZXJ0eShcInBvaW50ZXItZXZlbnRzXCIsIFwibm9uZVwiKTtcbiAgICBoaWdobGlnaHRCb3VuZGluZy5zdHlsZS5wb3NpdGlvbiA9IHBhZ2luYXRlZCA/IFwiZml4ZWRcIiA6IFwiYWJzb2x1dGVcIjtcbiAgICBoaWdobGlnaHRCb3VuZGluZy5zY2FsZSA9IHNjYWxlO1xuXG4gICAgaWYgKGRlYnVnKSB7XG4gICAgICAgIGhpZ2hsaWdodEJvdW5kaW5nLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIGBvdXRsaW5lLWNvbG9yOiBtYWdlbnRhOyBvdXRsaW5lLXN0eWxlOiBzb2xpZDsgb3V0bGluZS13aWR0aDogMXB4OyBvdXRsaW5lLW9mZnNldDogLTFweDtgKTtcbiAgICB9XG5cbiAgICBjb25zdCByYW5nZUJvdW5kaW5nQ2xpZW50UmVjdCA9IHJhbmdlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGhpZ2hsaWdodEJvdW5kaW5nLnJlY3QgPSB7XG4gICAgICAgIGhlaWdodDogcmFuZ2VCb3VuZGluZ0NsaWVudFJlY3QuaGVpZ2h0LFxuICAgICAgICBsZWZ0OiByYW5nZUJvdW5kaW5nQ2xpZW50UmVjdC5sZWZ0IC0geE9mZnNldCxcbiAgICAgICAgdG9wOiByYW5nZUJvdW5kaW5nQ2xpZW50UmVjdC50b3AgLSB5T2Zmc2V0LFxuICAgICAgICB3aWR0aDogcmFuZ2VCb3VuZGluZ0NsaWVudFJlY3Qud2lkdGhcbiAgICB9O1xuXG4gICAgaGlnaGxpZ2h0Qm91bmRpbmcuc3R5bGUud2lkdGggPSBgJHtoaWdobGlnaHRCb3VuZGluZy5yZWN0LndpZHRoICogc2NhbGV9cHhgO1xuICAgIGhpZ2hsaWdodEJvdW5kaW5nLnN0eWxlLmhlaWdodCA9IGAke2hpZ2hsaWdodEJvdW5kaW5nLnJlY3QuaGVpZ2h0ICogc2NhbGV9cHhgO1xuICAgIGhpZ2hsaWdodEJvdW5kaW5nLnN0eWxlLmxlZnQgPSBgJHtoaWdobGlnaHRCb3VuZGluZy5yZWN0LmxlZnQgKiBzY2FsZX1weGA7XG4gICAgaGlnaGxpZ2h0Qm91bmRpbmcuc3R5bGUudG9wID0gYCR7aGlnaGxpZ2h0Qm91bmRpbmcucmVjdC50b3AgKiBzY2FsZX1weGA7XG5cbiAgICBoaWdobGlnaHRQYXJlbnQuYXBwZW5kKGhpZ2hsaWdodEJvdW5kaW5nKTtcbiAgICBoaWdobGlnaHRzQ29udGFpbmVyLmFwcGVuZChoaWdobGlnaHRQYXJlbnQpO1xuXG4gICAgcmV0dXJuIGhpZ2hsaWdodFBhcmVudDtcbn1cblxuZnVuY3Rpb24gaXNTY3JvbGxNb2RlRW5hYmxlZCgpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLmdldFByb3BlcnR5VmFsdWUoXCItLVVTRVJfX3Njcm9sbFwiKS50b1N0cmluZygpLnRyaW0oKSA9PT0gJ3JlYWRpdW0tc2Nyb2xsLW9uJztcbn1cblxuZnVuY3Rpb24gZW5zdXJlQ29udGFpbmVyKHdpbikge1xuICAgIGNvbnN0IGRvY3VtZW50ID0gd2luLmRvY3VtZW50O1xuXG4gICAgaWYgKCFfaGlnaGxpZ2h0c0NvbnRhaW5lcikge1xuICAgICAgICBfaGlnaGxpZ2h0c0NvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIF9oaWdobGlnaHRzQ29udGFpbmVyLnNldEF0dHJpYnV0ZShcImlkXCIsIElEX0hJR0hMSUdIVFNfQ09OVEFJTkVSKTtcblxuICAgICAgICBfaGlnaGxpZ2h0c0NvbnRhaW5lci5zdHlsZS5zZXRQcm9wZXJ0eShcInBvaW50ZXItZXZlbnRzXCIsIFwibm9uZVwiKTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmQoX2hpZ2hsaWdodHNDb250YWluZXIpO1xuICAgIH1cblxuICAgIHJldHVybiBfaGlnaGxpZ2h0c0NvbnRhaW5lcjtcbn1cblxuZnVuY3Rpb24gZnJhbWVGb3JIaWdobGlnaHRXaXRoSUQoaWQpIHtcbiAgICBjb25zdCBoaWdobGlnaHQgPSBoaWdobGlnaHRXaXRoSUQoaWQpO1xuICAgIGlmICghaGlnaGxpZ2h0KVxuICAgICAgICByZXR1cm47XG5cbiAgICBjb25zdCBkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudDtcbiAgICBjb25zdCByYW5nZSA9IGNvbnZlcnRSYW5nZUluZm8oZG9jdW1lbnQsIGhpZ2hsaWdodC5yYW5nZUluZm8pO1xuICAgIGlmICghcmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cblxuICAgIGNvbnN0IGRyYXdVbmRlcmxpbmUgPSBmYWxzZTtcbiAgICBjb25zdCBkcmF3U3RyaWtlVGhyb3VnaCA9IGZhbHNlO1xuICAgIGNvbnN0IGRvTm90TWVyZ2VIb3Jpem9udGFsbHlBbGlnbmVkUmVjdHMgPSBkcmF3VW5kZXJsaW5lIHx8IGRyYXdTdHJpa2VUaHJvdWdoO1xuICAgIHJldHVybiBnZXRDbGllbnRSZWN0c05vT3ZlcmxhcChyYW5nZSwgZG9Ob3RNZXJnZUhvcml6b250YWxseUFsaWduZWRSZWN0cyk7XG59XG5cbmZ1bmN0aW9uIGhpZ2hsaWdodFdpdGhJRChpZCkge1xuICAgIGxldCBpID0gLTE7XG4gICAgcmV0dXJuIF9oaWdobGlnaHRzLmZpbmQoKGgsIGopID0+IHtcbiAgICAgICAgaSA9IGo7XG4gICAgICAgIHJldHVybiBoLmlkID09PSBpZDtcbiAgICB9KVxufSIsIi8vXG4vLyAgQ29weXJpZ2h0IDIwMjEgUmVhZGl1bSBGb3VuZGF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IHRoZSBCU0Qtc3R5bGUgbGljZW5zZVxuLy8gIGF2YWlsYWJsZSBpbiB0aGUgdG9wLWxldmVsIExJQ0VOU0UgZmlsZSBvZiB0aGUgcHJvamVjdC5cbi8vXG5cbi8vIEJhc2Ugc2NyaXB0IHVzZWQgYnkgYm90aCByZWZsb3dhYmxlIGFuZCBmaXhlZCBsYXlvdXQgcmVzb3VyY2VzLlxuXG5pbXBvcnQgJy4vZ2VzdHVyZXMnXG5pbXBvcnQge3JlbW92ZVByb3BlcnR5LCBzY3JvbGxMZWZ0LCBzY3JvbGxSaWdodCwgc2Nyb2xsVG9JZCwgc2Nyb2xsVG9Qb3NpdGlvbiwgc2Nyb2xsVG9UZXh0LCBzZXRQcm9wZXJ0eX0gZnJvbSBcIi4vdXRpbHNcIjtcbmltcG9ydCB7Z2V0Q3VycmVudFNlbGVjdGlvbkluZm8sIGdldFNlbGVjdGlvblJlY3R9IGZyb20gXCIuL3NlbGVjdGlvblwiO1xuaW1wb3J0IHtjcmVhdGVIaWdobGlnaHQsIGNyZWF0ZUhpZ2hsaWdodFJhbmdlfSBmcm9tIFwiLi9oaWdobGlnaHRcIjtcbmltcG9ydCB7VGV4dFF1b3RlQW5jaG9yfSBmcm9tIFwiLi92ZW5kb3IvaHlwb3RoZXNpcy9hbmNob3JpbmcvdHlwZXNcIjtcblxuXG4vLyBQdWJsaWMgQVBJIHVzZWQgYnkgdGhlIG5hdmlnYXRvci5cbndpbmRvdy5yZWFkaXVtID0ge1xuICAgIC8vIHV0aWxzXG4gICAgJ3Njcm9sbFRvSWQnOiBzY3JvbGxUb0lkLFxuICAgICdzY3JvbGxUb1Bvc2l0aW9uJzogc2Nyb2xsVG9Qb3NpdGlvbixcbiAgICAnc2Nyb2xsVG9UZXh0Jzogc2Nyb2xsVG9UZXh0LFxuICAgICdzY3JvbGxMZWZ0Jzogc2Nyb2xsTGVmdCxcbiAgICAnc2Nyb2xsUmlnaHQnOiBzY3JvbGxSaWdodCxcbiAgICAnc2V0UHJvcGVydHknOiBzZXRQcm9wZXJ0eSxcbiAgICAncmVtb3ZlUHJvcGVydHknOiByZW1vdmVQcm9wZXJ0eSxcblxuICAgIC8vIHNlbGVjdGlvblxuICAgICdnZXRTZWxlY3Rpb25SZWN0JzogZ2V0U2VsZWN0aW9uUmVjdCxcbiAgICAnZ2V0Q3VycmVudFNlbGVjdGlvbkluZm8nOiBnZXRDdXJyZW50U2VsZWN0aW9uSW5mbyxcblxuICAgIC8vIGhpZ2hsaWdodHNcbiAgICAnY3JlYXRlSGlnaGxpZ2h0JzogY3JlYXRlSGlnaGxpZ2h0LFxuICAgICdjcmVhdGVIaWdobGlnaHRSYW5nZSc6IGNyZWF0ZUhpZ2hsaWdodFJhbmdlLFxuXG4gICAgLy8gSHlwb3RoZXNpcycgYW5jaG9yaW5nXG4gICAgJ1RleHRRdW90ZUFuY2hvcic6IFRleHRRdW90ZUFuY2hvcixcbn07IiwiLy9cbi8vICBDb3B5cmlnaHQgMjAyMSBSZWFkaXVtIEZvdW5kYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgdGhlIEJTRC1zdHlsZSBsaWNlbnNlXG4vLyAgYXZhaWxhYmxlIGluIHRoZSB0b3AtbGV2ZWwgTElDRU5TRSBmaWxlIG9mIHRoZSBwcm9qZWN0LlxuLy9cblxuLy8gU2NyaXB0IHVzZWQgZm9yIHJlZmxvd2FibGUgcmVzb3VyY2VzLlxuXG5pbXBvcnQgJy4vaW5kZXgnXG5cbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCBmdW5jdGlvbigpIHtcbiAgLy8gTm90aWZpZXMgbmF0aXZlIGNvZGUgdGhhdCB0aGUgcGFnZSBpcyBsb2FkZWQgYWZ0ZXIgaXQgaXMgcmVuZGVyZWQuXG4gIC8vIFdhaXRpbmcgZm9yIHRoZSBuZXh0IGFuaW1hdGlvbiBmcmFtZSBzZWVtcyB0byBkbyB0aGUgdHJpY2sgdG8gbWFrZSBzdXJlIHRoZSBwYWdlIGlzIGZ1bGx5IHJlbmRlcmVkLlxuICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCkge1xuICAgIHdlYmtpdC5tZXNzYWdlSGFuZGxlcnMuc3ByZWFkTG9hZGVkLnBvc3RNZXNzYWdlKHt9KTtcbiAgfSk7XG5cbiAgLy8gU2V0dXBzIHRoZSBgdmlld3BvcnRgIG1ldGEgdGFnIHRvIGRpc2FibGUgem9vbWluZy5cbiAgbGV0IG1ldGEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibWV0YVwiKTtcbiAgbWV0YS5zZXRBdHRyaWJ1dGUoXCJuYW1lXCIsIFwidmlld3BvcnRcIik7XG4gIG1ldGEuc2V0QXR0cmlidXRlKFwiY29udGVudFwiLCBcIndpZHRoPWRldmljZS13aWR0aCwgaW5pdGlhbC1zY2FsZT0xLjAsIG1heGltdW0tc2NhbGU9MS4wLCB1c2VyLXNjYWxhYmxlPW5vLCBzaHJpbmstdG8tZml0PW5vXCIpO1xuICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKG1ldGEpO1xufSk7XG5cbi8vIEluamVjdHMgUmVhZGl1bSBDU1Mgc3R5bGVzaGVldHMuXG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIGNyZWF0ZUxpbmsobmFtZSkge1xuICAgIHZhciBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGluaycpO1xuICAgIGxpbmsuc2V0QXR0cmlidXRlKCdyZWwnLCAnc3R5bGVzaGVldCcpO1xuICAgIGxpbmsuc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RleHQvY3NzJyk7XG4gICAgbGluay5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCB3aW5kb3cucmVhZGl1bUNTU0Jhc2VVUkwgKyBuYW1lICsgJy5jc3MnKTtcbiAgICByZXR1cm4gbGluaztcbiAgfVxuXG4gIHZhciBoZWFkID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXTtcbiAgaGVhZC5hcHBlbmRDaGlsZChjcmVhdGVMaW5rKCdSZWFkaXVtQ1NTLWFmdGVyJykpO1xuICBoZWFkLmluc2VydEJlZm9yZShjcmVhdGVMaW5rKCdSZWFkaXVtQ1NTLWJlZm9yZScpLCBoZWFkLmNoaWxkcmVuWzBdKTtcbn0pO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///332\n')}},__webpack_module_cache__={};function __webpack_require__(n){var g=__webpack_module_cache__[n];if(void 0!==g)return g.exports;var t=__webpack_module_cache__[n]={exports:{}};return __webpack_modules__[n](t,t.exports,__webpack_require__),t.exports}var __webpack_exports__=__webpack_require__(332)})();