(()=>{var __webpack_modules__={89:(__unused_webpack_module,exports)=>{"use strict";eval('var __webpack_unused_export__;\n\n/**\n * Implementation of Myers\' online approximate string matching algorithm [1],\n * with additional optimizations suggested by [2].\n *\n * This has O((k/w) * n) complexity where `n` is the length of the text, `k` is\n * the maximum number of errors allowed (always <= the pattern length) and `w`\n * is the word size. Because JS only supports bitwise operations on 32 bit\n * integers, `w` is 32.\n *\n * As far as I am aware, there aren\'t any online algorithms which are\n * significantly better for a wide range of input parameters. The problem can be\n * solved faster using "filter then verify" approaches which first filter out\n * regions of the text that cannot match using a "cheap" check and then verify\n * the remaining potential matches. The verify step requires an algorithm such\n * as this one however.\n *\n * The algorithm\'s approach is essentially to optimize the classic dynamic\n * programming solution to the problem by computing columns of the matrix in\n * word-sized chunks (ie. dealing with 32 chars of the pattern at a time) and\n * avoiding calculating regions of the matrix where the minimum error count is\n * guaranteed to exceed the input threshold.\n *\n * The paper consists of two parts, the first describes the core algorithm for\n * matching patterns <= the size of a word (implemented by `advanceBlock` here).\n * The second uses the core algorithm as part of a larger block-based algorithm\n * to handle longer patterns.\n *\n * [1] G. Myers, “A Fast Bit-Vector Algorithm for Approximate String Matching\n * Based on Dynamic Programming,” vol. 46, no. 3, pp. 395–415, 1999.\n *\n * [2] Šošić, M. (2014). An simd dynamic programming c/c++ library (Doctoral\n * dissertation, Fakultet Elektrotehnike i računarstva, Sveučilište u Zagrebu).\n */\n__webpack_unused_export__ = ({ value: true });\nfunction reverse(s) {\n    return s\n        .split("")\n        .reverse()\n        .join("");\n}\n/**\n * Given the ends of approximate matches for `pattern` in `text`, find\n * the start of the matches.\n *\n * @param findEndFn - Function for finding the end of matches in\n * text.\n * @return Matches with the `start` property set.\n */\nfunction findMatchStarts(text, pattern, matches) {\n    var patRev = reverse(pattern);\n    return matches.map(function (m) {\n        // Find start of each match by reversing the pattern and matching segment\n        // of text and searching for an approx match with the same number of\n        // errors.\n        var minStart = Math.max(0, m.end - pattern.length - m.errors);\n        var textRev = reverse(text.slice(minStart, m.end));\n        // If there are multiple possible start points, choose the one that\n        // maximizes the length of the match.\n        var start = findMatchEnds(textRev, patRev, m.errors).reduce(function (min, rm) {\n            if (m.end - rm.end < min) {\n                return m.end - rm.end;\n            }\n            return min;\n        }, m.end);\n        return {\n            start: start,\n            end: m.end,\n            errors: m.errors\n        };\n    });\n}\n/**\n * Return 1 if a number is non-zero or zero otherwise, without using\n * conditional operators.\n *\n * This should get inlined into `advanceBlock` below by the JIT.\n *\n * Adapted from https://stackoverflow.com/a/3912218/434243\n */\nfunction oneIfNotZero(n) {\n    return ((n | -n) >> 31) & 1;\n}\n/**\n * Block calculation step of the algorithm.\n *\n * From Fig 8. on p. 408 of [1], additionally optimized to replace conditional\n * checks with bitwise operations as per Section 4.2.3 of [2].\n *\n * @param ctx - The pattern context object\n * @param peq - The `peq` array for the current character (`ctx.peq.get(ch)`)\n * @param b - The block level\n * @param hIn - Horizontal input delta ∈ {1,0,-1}\n * @return Horizontal output delta ∈ {1,0,-1}\n */\nfunction advanceBlock(ctx, peq, b, hIn) {\n    var pV = ctx.P[b];\n    var mV = ctx.M[b];\n    var hInIsNegative = hIn >>> 31; // 1 if hIn < 0 or 0 otherwise.\n    var eq = peq[b] | hInIsNegative;\n    // Step 1: Compute horizontal deltas.\n    var xV = eq | mV;\n    var xH = (((eq & pV) + pV) ^ pV) | eq;\n    var pH = mV | ~(xH | pV);\n    var mH = pV & xH;\n    // Step 2: Update score (value of last row of this block).\n    var hOut = oneIfNotZero(pH & ctx.lastRowMask[b]) -\n        oneIfNotZero(mH & ctx.lastRowMask[b]);\n    // Step 3: Update vertical deltas for use when processing next char.\n    pH <<= 1;\n    mH <<= 1;\n    mH |= hInIsNegative;\n    pH |= oneIfNotZero(hIn) - hInIsNegative; // set pH[0] if hIn > 0\n    pV = mH | ~(xV | pH);\n    mV = pH & xV;\n    ctx.P[b] = pV;\n    ctx.M[b] = mV;\n    return hOut;\n}\n/**\n * Find the ends and error counts for matches of `pattern` in `text`.\n *\n * Only the matches with the lowest error count are reported. Other matches\n * with error counts <= maxErrors are discarded.\n *\n * This is the block-based search algorithm from Fig. 9 on p.410 of [1].\n */\nfunction findMatchEnds(text, pattern, maxErrors) {\n    if (pattern.length === 0) {\n        return [];\n    }\n    // Clamp error count so we can rely on the `maxErrors` and `pattern.length`\n    // rows being in the same block below.\n    maxErrors = Math.min(maxErrors, pattern.length);\n    var matches = [];\n    // Word size.\n    var w = 32;\n    // Index of maximum block level.\n    var bMax = Math.ceil(pattern.length / w) - 1;\n    // Context used across block calculations.\n    var ctx = {\n        P: new Uint32Array(bMax + 1),\n        M: new Uint32Array(bMax + 1),\n        lastRowMask: new Uint32Array(bMax + 1)\n    };\n    ctx.lastRowMask.fill(1 << 31);\n    ctx.lastRowMask[bMax] = 1 << (pattern.length - 1) % w;\n    // Dummy "peq" array for chars in the text which do not occur in the pattern.\n    var emptyPeq = new Uint32Array(bMax + 1);\n    // Map of UTF-16 character code to bit vector indicating positions in the\n    // pattern that equal that character.\n    var peq = new Map();\n    // Version of `peq` that only stores mappings for small characters. This\n    // allows faster lookups when iterating through the text because a simple\n    // array lookup can be done instead of a hash table lookup.\n    var asciiPeq = [];\n    for (var i = 0; i < 256; i++) {\n        asciiPeq.push(emptyPeq);\n    }\n    // Calculate `ctx.peq` - a map of character values to bitmasks indicating\n    // positions of that character within the pattern, where each bit represents\n    // a position in the pattern.\n    for (var c = 0; c < pattern.length; c += 1) {\n        var val = pattern.charCodeAt(c);\n        if (peq.has(val)) {\n            // Duplicate char in pattern.\n            continue;\n        }\n        var charPeq = new Uint32Array(bMax + 1);\n        peq.set(val, charPeq);\n        if (val < asciiPeq.length) {\n            asciiPeq[val] = charPeq;\n        }\n        for (var b = 0; b <= bMax; b += 1) {\n            charPeq[b] = 0;\n            // Set all the bits where the pattern matches the current char (ch).\n            // For indexes beyond the end of the pattern, always set the bit as if the\n            // pattern contained a wildcard char in that position.\n            for (var r = 0; r < w; r += 1) {\n                var idx = b * w + r;\n                if (idx >= pattern.length) {\n                    continue;\n                }\n                var match = pattern.charCodeAt(idx) === val;\n                if (match) {\n                    charPeq[b] |= 1 << r;\n                }\n            }\n        }\n    }\n    // Index of last-active block level in the column.\n    var y = Math.max(0, Math.ceil(maxErrors / w) - 1);\n    // Initialize maximum error count at bottom of each block.\n    var score = new Uint32Array(bMax + 1);\n    for (var b = 0; b <= y; b += 1) {\n        score[b] = (b + 1) * w;\n    }\n    score[bMax] = pattern.length;\n    // Initialize vertical deltas for each block.\n    for (var b = 0; b <= y; b += 1) {\n        ctx.P[b] = ~0;\n        ctx.M[b] = 0;\n    }\n    // Process each char of the text, computing the error count for `w` chars of\n    // the pattern at a time.\n    for (var j = 0; j < text.length; j += 1) {\n        // Lookup the bitmask representing the positions of the current char from\n        // the text within the pattern.\n        var charCode = text.charCodeAt(j);\n        var charPeq = void 0;\n        if (charCode < asciiPeq.length) {\n            // Fast array lookup.\n            charPeq = asciiPeq[charCode];\n        }\n        else {\n            // Slower hash table lookup.\n            charPeq = peq.get(charCode);\n            if (typeof charPeq === "undefined") {\n                charPeq = emptyPeq;\n            }\n        }\n        // Calculate error count for blocks that we definitely have to process for\n        // this column.\n        var carry = 0;\n        for (var b = 0; b <= y; b += 1) {\n            carry = advanceBlock(ctx, charPeq, b, carry);\n            score[b] += carry;\n        }\n        // Check if we also need to compute an additional block, or if we can reduce\n        // the number of blocks processed for the next column.\n        if (score[y] - carry <= maxErrors &&\n            y < bMax &&\n            (charPeq[y + 1] & 1 || carry < 0)) {\n            // Error count for bottom block is under threshold, increase the number of\n            // blocks processed for this column & next by 1.\n            y += 1;\n            ctx.P[y] = ~0;\n            ctx.M[y] = 0;\n            var maxBlockScore = y === bMax ? pattern.length % w : w;\n            score[y] =\n                score[y - 1] +\n                    maxBlockScore -\n                    carry +\n                    advanceBlock(ctx, charPeq, y, carry);\n        }\n        else {\n            // Error count for bottom block exceeds threshold, reduce the number of\n            // blocks processed for the next column.\n            while (y > 0 && score[y] >= maxErrors + w) {\n                y -= 1;\n            }\n        }\n        // If error count is under threshold, report a match.\n        if (y === bMax && score[y] <= maxErrors) {\n            if (score[y] < maxErrors) {\n                // Discard any earlier, worse matches.\n                matches.splice(0, matches.length);\n            }\n            matches.push({\n                start: -1,\n                end: j + 1,\n                errors: score[y]\n            });\n            // Because `search` only reports the matches with the lowest error count,\n            // we can "ratchet down" the max error threshold whenever a match is\n            // encountered and thereby save a small amount of work for the remainder\n            // of the text.\n            maxErrors = score[y];\n        }\n    }\n    return matches;\n}\n/**\n * Search for matches for `pattern` in `text` allowing up to `maxErrors` errors.\n *\n * Returns the start, and end positions and error counts for each lowest-cost\n * match. Only the "best" matches are returned.\n */\nfunction search(text, pattern, maxErrors) {\n    var matches = findMatchEnds(text, pattern, maxErrors);\n    return findMatchStarts(text, pattern, matches);\n}\nexports.Z = search;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFkaXVtLWpzLy4vbm9kZV9tb2R1bGVzL2FwcHJveC1zdHJpbmctbWF0Y2gvZGlzdC9pbmRleC5qcz83MjMwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QyxDQUFDLGNBQWMsQ0FBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsb0JBQW9CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFdBQVc7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsT0FBTztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixRQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBZSIsImZpbGUiOiI4OS5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBJbXBsZW1lbnRhdGlvbiBvZiBNeWVycycgb25saW5lIGFwcHJveGltYXRlIHN0cmluZyBtYXRjaGluZyBhbGdvcml0aG0gWzFdLFxuICogd2l0aCBhZGRpdGlvbmFsIG9wdGltaXphdGlvbnMgc3VnZ2VzdGVkIGJ5IFsyXS5cbiAqXG4gKiBUaGlzIGhhcyBPKChrL3cpICogbikgY29tcGxleGl0eSB3aGVyZSBgbmAgaXMgdGhlIGxlbmd0aCBvZiB0aGUgdGV4dCwgYGtgIGlzXG4gKiB0aGUgbWF4aW11bSBudW1iZXIgb2YgZXJyb3JzIGFsbG93ZWQgKGFsd2F5cyA8PSB0aGUgcGF0dGVybiBsZW5ndGgpIGFuZCBgd2BcbiAqIGlzIHRoZSB3b3JkIHNpemUuIEJlY2F1c2UgSlMgb25seSBzdXBwb3J0cyBiaXR3aXNlIG9wZXJhdGlvbnMgb24gMzIgYml0XG4gKiBpbnRlZ2VycywgYHdgIGlzIDMyLlxuICpcbiAqIEFzIGZhciBhcyBJIGFtIGF3YXJlLCB0aGVyZSBhcmVuJ3QgYW55IG9ubGluZSBhbGdvcml0aG1zIHdoaWNoIGFyZVxuICogc2lnbmlmaWNhbnRseSBiZXR0ZXIgZm9yIGEgd2lkZSByYW5nZSBvZiBpbnB1dCBwYXJhbWV0ZXJzLiBUaGUgcHJvYmxlbSBjYW4gYmVcbiAqIHNvbHZlZCBmYXN0ZXIgdXNpbmcgXCJmaWx0ZXIgdGhlbiB2ZXJpZnlcIiBhcHByb2FjaGVzIHdoaWNoIGZpcnN0IGZpbHRlciBvdXRcbiAqIHJlZ2lvbnMgb2YgdGhlIHRleHQgdGhhdCBjYW5ub3QgbWF0Y2ggdXNpbmcgYSBcImNoZWFwXCIgY2hlY2sgYW5kIHRoZW4gdmVyaWZ5XG4gKiB0aGUgcmVtYWluaW5nIHBvdGVudGlhbCBtYXRjaGVzLiBUaGUgdmVyaWZ5IHN0ZXAgcmVxdWlyZXMgYW4gYWxnb3JpdGhtIHN1Y2hcbiAqIGFzIHRoaXMgb25lIGhvd2V2ZXIuXG4gKlxuICogVGhlIGFsZ29yaXRobSdzIGFwcHJvYWNoIGlzIGVzc2VudGlhbGx5IHRvIG9wdGltaXplIHRoZSBjbGFzc2ljIGR5bmFtaWNcbiAqIHByb2dyYW1taW5nIHNvbHV0aW9uIHRvIHRoZSBwcm9ibGVtIGJ5IGNvbXB1dGluZyBjb2x1bW5zIG9mIHRoZSBtYXRyaXggaW5cbiAqIHdvcmQtc2l6ZWQgY2h1bmtzIChpZS4gZGVhbGluZyB3aXRoIDMyIGNoYXJzIG9mIHRoZSBwYXR0ZXJuIGF0IGEgdGltZSkgYW5kXG4gKiBhdm9pZGluZyBjYWxjdWxhdGluZyByZWdpb25zIG9mIHRoZSBtYXRyaXggd2hlcmUgdGhlIG1pbmltdW0gZXJyb3IgY291bnQgaXNcbiAqIGd1YXJhbnRlZWQgdG8gZXhjZWVkIHRoZSBpbnB1dCB0aHJlc2hvbGQuXG4gKlxuICogVGhlIHBhcGVyIGNvbnNpc3RzIG9mIHR3byBwYXJ0cywgdGhlIGZpcnN0IGRlc2NyaWJlcyB0aGUgY29yZSBhbGdvcml0aG0gZm9yXG4gKiBtYXRjaGluZyBwYXR0ZXJucyA8PSB0aGUgc2l6ZSBvZiBhIHdvcmQgKGltcGxlbWVudGVkIGJ5IGBhZHZhbmNlQmxvY2tgIGhlcmUpLlxuICogVGhlIHNlY29uZCB1c2VzIHRoZSBjb3JlIGFsZ29yaXRobSBhcyBwYXJ0IG9mIGEgbGFyZ2VyIGJsb2NrLWJhc2VkIGFsZ29yaXRobVxuICogdG8gaGFuZGxlIGxvbmdlciBwYXR0ZXJucy5cbiAqXG4gKiBbMV0gRy4gTXllcnMsIOKAnEEgRmFzdCBCaXQtVmVjdG9yIEFsZ29yaXRobSBmb3IgQXBwcm94aW1hdGUgU3RyaW5nIE1hdGNoaW5nXG4gKiBCYXNlZCBvbiBEeW5hbWljIFByb2dyYW1taW5nLOKAnSB2b2wuIDQ2LCBuby4gMywgcHAuIDM5NeKAkzQxNSwgMTk5OS5cbiAqXG4gKiBbMl0gxaBvxaFpxIcsIE0uICgyMDE0KS4gQW4gc2ltZCBkeW5hbWljIHByb2dyYW1taW5nIGMvYysrIGxpYnJhcnkgKERvY3RvcmFsXG4gKiBkaXNzZXJ0YXRpb24sIEZha3VsdGV0IEVsZWt0cm90ZWhuaWtlIGkgcmHEjXVuYXJzdHZhLCBTdmV1xI1pbGnFoXRlIHUgWmFncmVidSkuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmZ1bmN0aW9uIHJldmVyc2Uocykge1xuICAgIHJldHVybiBzXG4gICAgICAgIC5zcGxpdChcIlwiKVxuICAgICAgICAucmV2ZXJzZSgpXG4gICAgICAgIC5qb2luKFwiXCIpO1xufVxuLyoqXG4gKiBHaXZlbiB0aGUgZW5kcyBvZiBhcHByb3hpbWF0ZSBtYXRjaGVzIGZvciBgcGF0dGVybmAgaW4gYHRleHRgLCBmaW5kXG4gKiB0aGUgc3RhcnQgb2YgdGhlIG1hdGNoZXMuXG4gKlxuICogQHBhcmFtIGZpbmRFbmRGbiAtIEZ1bmN0aW9uIGZvciBmaW5kaW5nIHRoZSBlbmQgb2YgbWF0Y2hlcyBpblxuICogdGV4dC5cbiAqIEByZXR1cm4gTWF0Y2hlcyB3aXRoIHRoZSBgc3RhcnRgIHByb3BlcnR5IHNldC5cbiAqL1xuZnVuY3Rpb24gZmluZE1hdGNoU3RhcnRzKHRleHQsIHBhdHRlcm4sIG1hdGNoZXMpIHtcbiAgICB2YXIgcGF0UmV2ID0gcmV2ZXJzZShwYXR0ZXJuKTtcbiAgICByZXR1cm4gbWF0Y2hlcy5tYXAoZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgLy8gRmluZCBzdGFydCBvZiBlYWNoIG1hdGNoIGJ5IHJldmVyc2luZyB0aGUgcGF0dGVybiBhbmQgbWF0Y2hpbmcgc2VnbWVudFxuICAgICAgICAvLyBvZiB0ZXh0IGFuZCBzZWFyY2hpbmcgZm9yIGFuIGFwcHJveCBtYXRjaCB3aXRoIHRoZSBzYW1lIG51bWJlciBvZlxuICAgICAgICAvLyBlcnJvcnMuXG4gICAgICAgIHZhciBtaW5TdGFydCA9IE1hdGgubWF4KDAsIG0uZW5kIC0gcGF0dGVybi5sZW5ndGggLSBtLmVycm9ycyk7XG4gICAgICAgIHZhciB0ZXh0UmV2ID0gcmV2ZXJzZSh0ZXh0LnNsaWNlKG1pblN0YXJ0LCBtLmVuZCkpO1xuICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbXVsdGlwbGUgcG9zc2libGUgc3RhcnQgcG9pbnRzLCBjaG9vc2UgdGhlIG9uZSB0aGF0XG4gICAgICAgIC8vIG1heGltaXplcyB0aGUgbGVuZ3RoIG9mIHRoZSBtYXRjaC5cbiAgICAgICAgdmFyIHN0YXJ0ID0gZmluZE1hdGNoRW5kcyh0ZXh0UmV2LCBwYXRSZXYsIG0uZXJyb3JzKS5yZWR1Y2UoZnVuY3Rpb24gKG1pbiwgcm0pIHtcbiAgICAgICAgICAgIGlmIChtLmVuZCAtIHJtLmVuZCA8IG1pbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBtLmVuZCAtIHJtLmVuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtaW47XG4gICAgICAgIH0sIG0uZW5kKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgIGVuZDogbS5lbmQsXG4gICAgICAgICAgICBlcnJvcnM6IG0uZXJyb3JzXG4gICAgICAgIH07XG4gICAgfSk7XG59XG4vKipcbiAqIFJldHVybiAxIGlmIGEgbnVtYmVyIGlzIG5vbi16ZXJvIG9yIHplcm8gb3RoZXJ3aXNlLCB3aXRob3V0IHVzaW5nXG4gKiBjb25kaXRpb25hbCBvcGVyYXRvcnMuXG4gKlxuICogVGhpcyBzaG91bGQgZ2V0IGlubGluZWQgaW50byBgYWR2YW5jZUJsb2NrYCBiZWxvdyBieSB0aGUgSklULlxuICpcbiAqIEFkYXB0ZWQgZnJvbSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzkxMjIxOC80MzQyNDNcbiAqL1xuZnVuY3Rpb24gb25lSWZOb3RaZXJvKG4pIHtcbiAgICByZXR1cm4gKChuIHwgLW4pID4+IDMxKSAmIDE7XG59XG4vKipcbiAqIEJsb2NrIGNhbGN1bGF0aW9uIHN0ZXAgb2YgdGhlIGFsZ29yaXRobS5cbiAqXG4gKiBGcm9tIEZpZyA4LiBvbiBwLiA0MDggb2YgWzFdLCBhZGRpdGlvbmFsbHkgb3B0aW1pemVkIHRvIHJlcGxhY2UgY29uZGl0aW9uYWxcbiAqIGNoZWNrcyB3aXRoIGJpdHdpc2Ugb3BlcmF0aW9ucyBhcyBwZXIgU2VjdGlvbiA0LjIuMyBvZiBbMl0uXG4gKlxuICogQHBhcmFtIGN0eCAtIFRoZSBwYXR0ZXJuIGNvbnRleHQgb2JqZWN0XG4gKiBAcGFyYW0gcGVxIC0gVGhlIGBwZXFgIGFycmF5IGZvciB0aGUgY3VycmVudCBjaGFyYWN0ZXIgKGBjdHgucGVxLmdldChjaClgKVxuICogQHBhcmFtIGIgLSBUaGUgYmxvY2sgbGV2ZWxcbiAqIEBwYXJhbSBoSW4gLSBIb3Jpem9udGFsIGlucHV0IGRlbHRhIOKIiCB7MSwwLC0xfVxuICogQHJldHVybiBIb3Jpem9udGFsIG91dHB1dCBkZWx0YSDiiIggezEsMCwtMX1cbiAqL1xuZnVuY3Rpb24gYWR2YW5jZUJsb2NrKGN0eCwgcGVxLCBiLCBoSW4pIHtcbiAgICB2YXIgcFYgPSBjdHguUFtiXTtcbiAgICB2YXIgbVYgPSBjdHguTVtiXTtcbiAgICB2YXIgaEluSXNOZWdhdGl2ZSA9IGhJbiA+Pj4gMzE7IC8vIDEgaWYgaEluIDwgMCBvciAwIG90aGVyd2lzZS5cbiAgICB2YXIgZXEgPSBwZXFbYl0gfCBoSW5Jc05lZ2F0aXZlO1xuICAgIC8vIFN0ZXAgMTogQ29tcHV0ZSBob3Jpem9udGFsIGRlbHRhcy5cbiAgICB2YXIgeFYgPSBlcSB8IG1WO1xuICAgIHZhciB4SCA9ICgoKGVxICYgcFYpICsgcFYpIF4gcFYpIHwgZXE7XG4gICAgdmFyIHBIID0gbVYgfCB+KHhIIHwgcFYpO1xuICAgIHZhciBtSCA9IHBWICYgeEg7XG4gICAgLy8gU3RlcCAyOiBVcGRhdGUgc2NvcmUgKHZhbHVlIG9mIGxhc3Qgcm93IG9mIHRoaXMgYmxvY2spLlxuICAgIHZhciBoT3V0ID0gb25lSWZOb3RaZXJvKHBIICYgY3R4Lmxhc3RSb3dNYXNrW2JdKSAtXG4gICAgICAgIG9uZUlmTm90WmVybyhtSCAmIGN0eC5sYXN0Um93TWFza1tiXSk7XG4gICAgLy8gU3RlcCAzOiBVcGRhdGUgdmVydGljYWwgZGVsdGFzIGZvciB1c2Ugd2hlbiBwcm9jZXNzaW5nIG5leHQgY2hhci5cbiAgICBwSCA8PD0gMTtcbiAgICBtSCA8PD0gMTtcbiAgICBtSCB8PSBoSW5Jc05lZ2F0aXZlO1xuICAgIHBIIHw9IG9uZUlmTm90WmVybyhoSW4pIC0gaEluSXNOZWdhdGl2ZTsgLy8gc2V0IHBIWzBdIGlmIGhJbiA+IDBcbiAgICBwViA9IG1IIHwgfih4ViB8IHBIKTtcbiAgICBtViA9IHBIICYgeFY7XG4gICAgY3R4LlBbYl0gPSBwVjtcbiAgICBjdHguTVtiXSA9IG1WO1xuICAgIHJldHVybiBoT3V0O1xufVxuLyoqXG4gKiBGaW5kIHRoZSBlbmRzIGFuZCBlcnJvciBjb3VudHMgZm9yIG1hdGNoZXMgb2YgYHBhdHRlcm5gIGluIGB0ZXh0YC5cbiAqXG4gKiBPbmx5IHRoZSBtYXRjaGVzIHdpdGggdGhlIGxvd2VzdCBlcnJvciBjb3VudCBhcmUgcmVwb3J0ZWQuIE90aGVyIG1hdGNoZXNcbiAqIHdpdGggZXJyb3IgY291bnRzIDw9IG1heEVycm9ycyBhcmUgZGlzY2FyZGVkLlxuICpcbiAqIFRoaXMgaXMgdGhlIGJsb2NrLWJhc2VkIHNlYXJjaCBhbGdvcml0aG0gZnJvbSBGaWcuIDkgb24gcC40MTAgb2YgWzFdLlxuICovXG5mdW5jdGlvbiBmaW5kTWF0Y2hFbmRzKHRleHQsIHBhdHRlcm4sIG1heEVycm9ycykge1xuICAgIGlmIChwYXR0ZXJuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIC8vIENsYW1wIGVycm9yIGNvdW50IHNvIHdlIGNhbiByZWx5IG9uIHRoZSBgbWF4RXJyb3JzYCBhbmQgYHBhdHRlcm4ubGVuZ3RoYFxuICAgIC8vIHJvd3MgYmVpbmcgaW4gdGhlIHNhbWUgYmxvY2sgYmVsb3cuXG4gICAgbWF4RXJyb3JzID0gTWF0aC5taW4obWF4RXJyb3JzLCBwYXR0ZXJuLmxlbmd0aCk7XG4gICAgdmFyIG1hdGNoZXMgPSBbXTtcbiAgICAvLyBXb3JkIHNpemUuXG4gICAgdmFyIHcgPSAzMjtcbiAgICAvLyBJbmRleCBvZiBtYXhpbXVtIGJsb2NrIGxldmVsLlxuICAgIHZhciBiTWF4ID0gTWF0aC5jZWlsKHBhdHRlcm4ubGVuZ3RoIC8gdykgLSAxO1xuICAgIC8vIENvbnRleHQgdXNlZCBhY3Jvc3MgYmxvY2sgY2FsY3VsYXRpb25zLlxuICAgIHZhciBjdHggPSB7XG4gICAgICAgIFA6IG5ldyBVaW50MzJBcnJheShiTWF4ICsgMSksXG4gICAgICAgIE06IG5ldyBVaW50MzJBcnJheShiTWF4ICsgMSksXG4gICAgICAgIGxhc3RSb3dNYXNrOiBuZXcgVWludDMyQXJyYXkoYk1heCArIDEpXG4gICAgfTtcbiAgICBjdHgubGFzdFJvd01hc2suZmlsbCgxIDw8IDMxKTtcbiAgICBjdHgubGFzdFJvd01hc2tbYk1heF0gPSAxIDw8IChwYXR0ZXJuLmxlbmd0aCAtIDEpICUgdztcbiAgICAvLyBEdW1teSBcInBlcVwiIGFycmF5IGZvciBjaGFycyBpbiB0aGUgdGV4dCB3aGljaCBkbyBub3Qgb2NjdXIgaW4gdGhlIHBhdHRlcm4uXG4gICAgdmFyIGVtcHR5UGVxID0gbmV3IFVpbnQzMkFycmF5KGJNYXggKyAxKTtcbiAgICAvLyBNYXAgb2YgVVRGLTE2IGNoYXJhY3RlciBjb2RlIHRvIGJpdCB2ZWN0b3IgaW5kaWNhdGluZyBwb3NpdGlvbnMgaW4gdGhlXG4gICAgLy8gcGF0dGVybiB0aGF0IGVxdWFsIHRoYXQgY2hhcmFjdGVyLlxuICAgIHZhciBwZXEgPSBuZXcgTWFwKCk7XG4gICAgLy8gVmVyc2lvbiBvZiBgcGVxYCB0aGF0IG9ubHkgc3RvcmVzIG1hcHBpbmdzIGZvciBzbWFsbCBjaGFyYWN0ZXJzLiBUaGlzXG4gICAgLy8gYWxsb3dzIGZhc3RlciBsb29rdXBzIHdoZW4gaXRlcmF0aW5nIHRocm91Z2ggdGhlIHRleHQgYmVjYXVzZSBhIHNpbXBsZVxuICAgIC8vIGFycmF5IGxvb2t1cCBjYW4gYmUgZG9uZSBpbnN0ZWFkIG9mIGEgaGFzaCB0YWJsZSBsb29rdXAuXG4gICAgdmFyIGFzY2lpUGVxID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICAgICAgICBhc2NpaVBlcS5wdXNoKGVtcHR5UGVxKTtcbiAgICB9XG4gICAgLy8gQ2FsY3VsYXRlIGBjdHgucGVxYCAtIGEgbWFwIG9mIGNoYXJhY3RlciB2YWx1ZXMgdG8gYml0bWFza3MgaW5kaWNhdGluZ1xuICAgIC8vIHBvc2l0aW9ucyBvZiB0aGF0IGNoYXJhY3RlciB3aXRoaW4gdGhlIHBhdHRlcm4sIHdoZXJlIGVhY2ggYml0IHJlcHJlc2VudHNcbiAgICAvLyBhIHBvc2l0aW9uIGluIHRoZSBwYXR0ZXJuLlxuICAgIGZvciAodmFyIGMgPSAwOyBjIDwgcGF0dGVybi5sZW5ndGg7IGMgKz0gMSkge1xuICAgICAgICB2YXIgdmFsID0gcGF0dGVybi5jaGFyQ29kZUF0KGMpO1xuICAgICAgICBpZiAocGVxLmhhcyh2YWwpKSB7XG4gICAgICAgICAgICAvLyBEdXBsaWNhdGUgY2hhciBpbiBwYXR0ZXJuLlxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNoYXJQZXEgPSBuZXcgVWludDMyQXJyYXkoYk1heCArIDEpO1xuICAgICAgICBwZXEuc2V0KHZhbCwgY2hhclBlcSk7XG4gICAgICAgIGlmICh2YWwgPCBhc2NpaVBlcS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGFzY2lpUGVxW3ZhbF0gPSBjaGFyUGVxO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGIgPSAwOyBiIDw9IGJNYXg7IGIgKz0gMSkge1xuICAgICAgICAgICAgY2hhclBlcVtiXSA9IDA7XG4gICAgICAgICAgICAvLyBTZXQgYWxsIHRoZSBiaXRzIHdoZXJlIHRoZSBwYXR0ZXJuIG1hdGNoZXMgdGhlIGN1cnJlbnQgY2hhciAoY2gpLlxuICAgICAgICAgICAgLy8gRm9yIGluZGV4ZXMgYmV5b25kIHRoZSBlbmQgb2YgdGhlIHBhdHRlcm4sIGFsd2F5cyBzZXQgdGhlIGJpdCBhcyBpZiB0aGVcbiAgICAgICAgICAgIC8vIHBhdHRlcm4gY29udGFpbmVkIGEgd2lsZGNhcmQgY2hhciBpbiB0aGF0IHBvc2l0aW9uLlxuICAgICAgICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCB3OyByICs9IDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgaWR4ID0gYiAqIHcgKyByO1xuICAgICAgICAgICAgICAgIGlmIChpZHggPj0gcGF0dGVybi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IHBhdHRlcm4uY2hhckNvZGVBdChpZHgpID09PSB2YWw7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYXJQZXFbYl0gfD0gMSA8PCByO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBJbmRleCBvZiBsYXN0LWFjdGl2ZSBibG9jayBsZXZlbCBpbiB0aGUgY29sdW1uLlxuICAgIHZhciB5ID0gTWF0aC5tYXgoMCwgTWF0aC5jZWlsKG1heEVycm9ycyAvIHcpIC0gMSk7XG4gICAgLy8gSW5pdGlhbGl6ZSBtYXhpbXVtIGVycm9yIGNvdW50IGF0IGJvdHRvbSBvZiBlYWNoIGJsb2NrLlxuICAgIHZhciBzY29yZSA9IG5ldyBVaW50MzJBcnJheShiTWF4ICsgMSk7XG4gICAgZm9yICh2YXIgYiA9IDA7IGIgPD0geTsgYiArPSAxKSB7XG4gICAgICAgIHNjb3JlW2JdID0gKGIgKyAxKSAqIHc7XG4gICAgfVxuICAgIHNjb3JlW2JNYXhdID0gcGF0dGVybi5sZW5ndGg7XG4gICAgLy8gSW5pdGlhbGl6ZSB2ZXJ0aWNhbCBkZWx0YXMgZm9yIGVhY2ggYmxvY2suXG4gICAgZm9yICh2YXIgYiA9IDA7IGIgPD0geTsgYiArPSAxKSB7XG4gICAgICAgIGN0eC5QW2JdID0gfjA7XG4gICAgICAgIGN0eC5NW2JdID0gMDtcbiAgICB9XG4gICAgLy8gUHJvY2VzcyBlYWNoIGNoYXIgb2YgdGhlIHRleHQsIGNvbXB1dGluZyB0aGUgZXJyb3IgY291bnQgZm9yIGB3YCBjaGFycyBvZlxuICAgIC8vIHRoZSBwYXR0ZXJuIGF0IGEgdGltZS5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRleHQubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgLy8gTG9va3VwIHRoZSBiaXRtYXNrIHJlcHJlc2VudGluZyB0aGUgcG9zaXRpb25zIG9mIHRoZSBjdXJyZW50IGNoYXIgZnJvbVxuICAgICAgICAvLyB0aGUgdGV4dCB3aXRoaW4gdGhlIHBhdHRlcm4uXG4gICAgICAgIHZhciBjaGFyQ29kZSA9IHRleHQuY2hhckNvZGVBdChqKTtcbiAgICAgICAgdmFyIGNoYXJQZXEgPSB2b2lkIDA7XG4gICAgICAgIGlmIChjaGFyQ29kZSA8IGFzY2lpUGVxLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gRmFzdCBhcnJheSBsb29rdXAuXG4gICAgICAgICAgICBjaGFyUGVxID0gYXNjaWlQZXFbY2hhckNvZGVdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gU2xvd2VyIGhhc2ggdGFibGUgbG9va3VwLlxuICAgICAgICAgICAgY2hhclBlcSA9IHBlcS5nZXQoY2hhckNvZGUpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjaGFyUGVxID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgY2hhclBlcSA9IGVtcHR5UGVxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIENhbGN1bGF0ZSBlcnJvciBjb3VudCBmb3IgYmxvY2tzIHRoYXQgd2UgZGVmaW5pdGVseSBoYXZlIHRvIHByb2Nlc3MgZm9yXG4gICAgICAgIC8vIHRoaXMgY29sdW1uLlxuICAgICAgICB2YXIgY2FycnkgPSAwO1xuICAgICAgICBmb3IgKHZhciBiID0gMDsgYiA8PSB5OyBiICs9IDEpIHtcbiAgICAgICAgICAgIGNhcnJ5ID0gYWR2YW5jZUJsb2NrKGN0eCwgY2hhclBlcSwgYiwgY2FycnkpO1xuICAgICAgICAgICAgc2NvcmVbYl0gKz0gY2Fycnk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgaWYgd2UgYWxzbyBuZWVkIHRvIGNvbXB1dGUgYW4gYWRkaXRpb25hbCBibG9jaywgb3IgaWYgd2UgY2FuIHJlZHVjZVxuICAgICAgICAvLyB0aGUgbnVtYmVyIG9mIGJsb2NrcyBwcm9jZXNzZWQgZm9yIHRoZSBuZXh0IGNvbHVtbi5cbiAgICAgICAgaWYgKHNjb3JlW3ldIC0gY2FycnkgPD0gbWF4RXJyb3JzICYmXG4gICAgICAgICAgICB5IDwgYk1heCAmJlxuICAgICAgICAgICAgKGNoYXJQZXFbeSArIDFdICYgMSB8fCBjYXJyeSA8IDApKSB7XG4gICAgICAgICAgICAvLyBFcnJvciBjb3VudCBmb3IgYm90dG9tIGJsb2NrIGlzIHVuZGVyIHRocmVzaG9sZCwgaW5jcmVhc2UgdGhlIG51bWJlciBvZlxuICAgICAgICAgICAgLy8gYmxvY2tzIHByb2Nlc3NlZCBmb3IgdGhpcyBjb2x1bW4gJiBuZXh0IGJ5IDEuXG4gICAgICAgICAgICB5ICs9IDE7XG4gICAgICAgICAgICBjdHguUFt5XSA9IH4wO1xuICAgICAgICAgICAgY3R4Lk1beV0gPSAwO1xuICAgICAgICAgICAgdmFyIG1heEJsb2NrU2NvcmUgPSB5ID09PSBiTWF4ID8gcGF0dGVybi5sZW5ndGggJSB3IDogdztcbiAgICAgICAgICAgIHNjb3JlW3ldID1cbiAgICAgICAgICAgICAgICBzY29yZVt5IC0gMV0gK1xuICAgICAgICAgICAgICAgICAgICBtYXhCbG9ja1Njb3JlIC1cbiAgICAgICAgICAgICAgICAgICAgY2FycnkgK1xuICAgICAgICAgICAgICAgICAgICBhZHZhbmNlQmxvY2soY3R4LCBjaGFyUGVxLCB5LCBjYXJyeSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBFcnJvciBjb3VudCBmb3IgYm90dG9tIGJsb2NrIGV4Y2VlZHMgdGhyZXNob2xkLCByZWR1Y2UgdGhlIG51bWJlciBvZlxuICAgICAgICAgICAgLy8gYmxvY2tzIHByb2Nlc3NlZCBmb3IgdGhlIG5leHQgY29sdW1uLlxuICAgICAgICAgICAgd2hpbGUgKHkgPiAwICYmIHNjb3JlW3ldID49IG1heEVycm9ycyArIHcpIHtcbiAgICAgICAgICAgICAgICB5IC09IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgZXJyb3IgY291bnQgaXMgdW5kZXIgdGhyZXNob2xkLCByZXBvcnQgYSBtYXRjaC5cbiAgICAgICAgaWYgKHkgPT09IGJNYXggJiYgc2NvcmVbeV0gPD0gbWF4RXJyb3JzKSB7XG4gICAgICAgICAgICBpZiAoc2NvcmVbeV0gPCBtYXhFcnJvcnMpIHtcbiAgICAgICAgICAgICAgICAvLyBEaXNjYXJkIGFueSBlYXJsaWVyLCB3b3JzZSBtYXRjaGVzLlxuICAgICAgICAgICAgICAgIG1hdGNoZXMuc3BsaWNlKDAsIG1hdGNoZXMubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1hdGNoZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IC0xLFxuICAgICAgICAgICAgICAgIGVuZDogaiArIDEsXG4gICAgICAgICAgICAgICAgZXJyb3JzOiBzY29yZVt5XVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBCZWNhdXNlIGBzZWFyY2hgIG9ubHkgcmVwb3J0cyB0aGUgbWF0Y2hlcyB3aXRoIHRoZSBsb3dlc3QgZXJyb3IgY291bnQsXG4gICAgICAgICAgICAvLyB3ZSBjYW4gXCJyYXRjaGV0IGRvd25cIiB0aGUgbWF4IGVycm9yIHRocmVzaG9sZCB3aGVuZXZlciBhIG1hdGNoIGlzXG4gICAgICAgICAgICAvLyBlbmNvdW50ZXJlZCBhbmQgdGhlcmVieSBzYXZlIGEgc21hbGwgYW1vdW50IG9mIHdvcmsgZm9yIHRoZSByZW1haW5kZXJcbiAgICAgICAgICAgIC8vIG9mIHRoZSB0ZXh0LlxuICAgICAgICAgICAgbWF4RXJyb3JzID0gc2NvcmVbeV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1hdGNoZXM7XG59XG4vKipcbiAqIFNlYXJjaCBmb3IgbWF0Y2hlcyBmb3IgYHBhdHRlcm5gIGluIGB0ZXh0YCBhbGxvd2luZyB1cCB0byBgbWF4RXJyb3JzYCBlcnJvcnMuXG4gKlxuICogUmV0dXJucyB0aGUgc3RhcnQsIGFuZCBlbmQgcG9zaXRpb25zIGFuZCBlcnJvciBjb3VudHMgZm9yIGVhY2ggbG93ZXN0LWNvc3RcbiAqIG1hdGNoLiBPbmx5IHRoZSBcImJlc3RcIiBtYXRjaGVzIGFyZSByZXR1cm5lZC5cbiAqL1xuZnVuY3Rpb24gc2VhcmNoKHRleHQsIHBhdHRlcm4sIG1heEVycm9ycykge1xuICAgIHZhciBtYXRjaGVzID0gZmluZE1hdGNoRW5kcyh0ZXh0LCBwYXR0ZXJuLCBtYXhFcnJvcnMpO1xuICAgIHJldHVybiBmaW5kTWF0Y2hTdGFydHModGV4dCwgcGF0dGVybiwgbWF0Y2hlcyk7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBzZWFyY2g7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///89\n')},581:()=>{eval("//\n//  Copyright 2021 Readium Foundation. All rights reserved.\n//  Use of this source code is governed by the BSD-style license\n//  available in the top-level LICENSE file of the project.\n//\n\nwindow.addEventListener('DOMContentLoaded', function(event) {\n  // If we don't set the CSS cursor property to pointer, then the click events are not triggered pre-iOS 13.\n  document.body.style.cursor = 'pointer';\n\n  document.addEventListener('click', onClick, false);\n});\n\nfunction onClick(event) {\n\n  if (!window.getSelection().isCollapsed) {\n    // There's an on-going selection, the tap will dismiss it so we don't forward it.\n    return;\n  }\n\n  // Send the tap data over the JS bridge even if it's been handled\n  // within the webview, so that it can be preserved and used\n  // by the WKNavigationDelegate if needed.\n  webkit.messageHandlers.tap.postMessage({\n    \"defaultPrevented\": event.defaultPrevented,\n    \"screenX\": event.screenX,\n    \"screenY\": event.screenY,\n    \"clientX\": event.clientX,\n    \"clientY\": event.clientY,\n    \"targetElement\": event.target.outerHTML,\n    \"interactiveElement\": nearestInteractiveElement(event.target),\n  });\n\n  // We don't want to disable the default WebView behavior as it breaks some features without bringing any value.\n//    event.stopPropagation();\n//    event.preventDefault();\n}\n\n// See. https://github.com/JayPanoz/architecture/tree/touch-handling/misc/touch-handling\nfunction nearestInteractiveElement(element) {\n  var interactiveTags = [\n    'a',\n    'audio',\n    'button',\n    'canvas',\n    'details',\n    'input',\n    'label',\n    'option',\n    'select',\n    'submit',\n    'textarea',\n    'video',\n  ]\n  if (interactiveTags.indexOf(element.nodeName.toLowerCase()) !== -1) {\n    return element.outerHTML;\n  }\n\n  // Checks whether the element is editable by the user.\n  if (element.hasAttribute('contenteditable') && element.getAttribute('contenteditable').toLowerCase() != 'false') {\n    return element.outerHTML;\n  }\n\n  // Checks parents recursively because the touch might be for example on an <em> inside a <a>.\n  if (element.parentElement) {\n    return nearestInteractiveElement(element.parentElement);\n  }\n\n  return null;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFkaXVtLWpzLy4vc3JjL2dlc3R1cmVzLmpzPzE0YzIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJmaWxlIjoiNTgxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy9cbi8vICBDb3B5cmlnaHQgMjAyMSBSZWFkaXVtIEZvdW5kYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgdGhlIEJTRC1zdHlsZSBsaWNlbnNlXG4vLyAgYXZhaWxhYmxlIGluIHRoZSB0b3AtbGV2ZWwgTElDRU5TRSBmaWxlIG9mIHRoZSBwcm9qZWN0LlxuLy9cblxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBmdW5jdGlvbihldmVudCkge1xuICAvLyBJZiB3ZSBkb24ndCBzZXQgdGhlIENTUyBjdXJzb3IgcHJvcGVydHkgdG8gcG9pbnRlciwgdGhlbiB0aGUgY2xpY2sgZXZlbnRzIGFyZSBub3QgdHJpZ2dlcmVkIHByZS1pT1MgMTMuXG4gIGRvY3VtZW50LmJvZHkuc3R5bGUuY3Vyc29yID0gJ3BvaW50ZXInO1xuXG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgb25DbGljaywgZmFsc2UpO1xufSk7XG5cbmZ1bmN0aW9uIG9uQ2xpY2soZXZlbnQpIHtcblxuICBpZiAoIXdpbmRvdy5nZXRTZWxlY3Rpb24oKS5pc0NvbGxhcHNlZCkge1xuICAgIC8vIFRoZXJlJ3MgYW4gb24tZ29pbmcgc2VsZWN0aW9uLCB0aGUgdGFwIHdpbGwgZGlzbWlzcyBpdCBzbyB3ZSBkb24ndCBmb3J3YXJkIGl0LlxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFNlbmQgdGhlIHRhcCBkYXRhIG92ZXIgdGhlIEpTIGJyaWRnZSBldmVuIGlmIGl0J3MgYmVlbiBoYW5kbGVkXG4gIC8vIHdpdGhpbiB0aGUgd2Vidmlldywgc28gdGhhdCBpdCBjYW4gYmUgcHJlc2VydmVkIGFuZCB1c2VkXG4gIC8vIGJ5IHRoZSBXS05hdmlnYXRpb25EZWxlZ2F0ZSBpZiBuZWVkZWQuXG4gIHdlYmtpdC5tZXNzYWdlSGFuZGxlcnMudGFwLnBvc3RNZXNzYWdlKHtcbiAgICBcImRlZmF1bHRQcmV2ZW50ZWRcIjogZXZlbnQuZGVmYXVsdFByZXZlbnRlZCxcbiAgICBcInNjcmVlblhcIjogZXZlbnQuc2NyZWVuWCxcbiAgICBcInNjcmVlbllcIjogZXZlbnQuc2NyZWVuWSxcbiAgICBcImNsaWVudFhcIjogZXZlbnQuY2xpZW50WCxcbiAgICBcImNsaWVudFlcIjogZXZlbnQuY2xpZW50WSxcbiAgICBcInRhcmdldEVsZW1lbnRcIjogZXZlbnQudGFyZ2V0Lm91dGVySFRNTCxcbiAgICBcImludGVyYWN0aXZlRWxlbWVudFwiOiBuZWFyZXN0SW50ZXJhY3RpdmVFbGVtZW50KGV2ZW50LnRhcmdldCksXG4gIH0pO1xuXG4gIC8vIFdlIGRvbid0IHdhbnQgdG8gZGlzYWJsZSB0aGUgZGVmYXVsdCBXZWJWaWV3IGJlaGF2aW9yIGFzIGl0IGJyZWFrcyBzb21lIGZlYXR1cmVzIHdpdGhvdXQgYnJpbmdpbmcgYW55IHZhbHVlLlxuLy8gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4vLyAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xufVxuXG4vLyBTZWUuIGh0dHBzOi8vZ2l0aHViLmNvbS9KYXlQYW5vei9hcmNoaXRlY3R1cmUvdHJlZS90b3VjaC1oYW5kbGluZy9taXNjL3RvdWNoLWhhbmRsaW5nXG5mdW5jdGlvbiBuZWFyZXN0SW50ZXJhY3RpdmVFbGVtZW50KGVsZW1lbnQpIHtcbiAgdmFyIGludGVyYWN0aXZlVGFncyA9IFtcbiAgICAnYScsXG4gICAgJ2F1ZGlvJyxcbiAgICAnYnV0dG9uJyxcbiAgICAnY2FudmFzJyxcbiAgICAnZGV0YWlscycsXG4gICAgJ2lucHV0JyxcbiAgICAnbGFiZWwnLFxuICAgICdvcHRpb24nLFxuICAgICdzZWxlY3QnLFxuICAgICdzdWJtaXQnLFxuICAgICd0ZXh0YXJlYScsXG4gICAgJ3ZpZGVvJyxcbiAgXVxuICBpZiAoaW50ZXJhY3RpdmVUYWdzLmluZGV4T2YoZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKSAhPT0gLTEpIHtcbiAgICByZXR1cm4gZWxlbWVudC5vdXRlckhUTUw7XG4gIH1cblxuICAvLyBDaGVja3Mgd2hldGhlciB0aGUgZWxlbWVudCBpcyBlZGl0YWJsZSBieSB0aGUgdXNlci5cbiAgaWYgKGVsZW1lbnQuaGFzQXR0cmlidXRlKCdjb250ZW50ZWRpdGFibGUnKSAmJiBlbGVtZW50LmdldEF0dHJpYnV0ZSgnY29udGVudGVkaXRhYmxlJykudG9Mb3dlckNhc2UoKSAhPSAnZmFsc2UnKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQub3V0ZXJIVE1MO1xuICB9XG5cbiAgLy8gQ2hlY2tzIHBhcmVudHMgcmVjdXJzaXZlbHkgYmVjYXVzZSB0aGUgdG91Y2ggbWlnaHQgYmUgZm9yIGV4YW1wbGUgb24gYW4gPGVtPiBpbnNpZGUgYSA8YT4uXG4gIGlmIChlbGVtZW50LnBhcmVudEVsZW1lbnQpIHtcbiAgICByZXR1cm4gbmVhcmVzdEludGVyYWN0aXZlRWxlbWVudChlbGVtZW50LnBhcmVudEVsZW1lbnQpO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///581\n")},332:(__unused_webpack_module,__unused_webpack___webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXTERNAL MODULE: ./src/gestures.js\nvar gestures = __webpack_require__(581);\n// EXTERNAL MODULE: ./node_modules/approx-string-match/dist/index.js\nvar dist = __webpack_require__(89);\n;// CONCATENATED MODULE: ./src/vendor/hypothesis/anchoring/match-quote.js\n\n\n/**\n * @typedef {import(\'approx-string-match\').Match} StringMatch\n */\n\n/**\n * @typedef Match\n * @prop {number} start - Start offset of match in text\n * @prop {number} end - End offset of match in text\n * @prop {number} score -\n *   Score for the match between 0 and 1.0, where 1.0 indicates a perfect match\n *   for the quote and context.\n */\n\n/**\n * Find the best approximate matches for `str` in `text` allowing up to `maxErrors` errors.\n *\n * @param {string} text\n * @param {string} str\n * @param {number} maxErrors\n * @return {StringMatch[]}\n */\nfunction search(text, str, maxErrors) {\n  // Do a fast search for exact matches. The `approx-string-match` library\n  // doesn\'t currently incorporate this optimization itself.\n  let matchPos = 0;\n  let exactMatches = [];\n  while (matchPos !== -1) {\n    matchPos = text.indexOf(str, matchPos);\n    if (matchPos !== -1) {\n      exactMatches.push({\n        start: matchPos,\n        end: matchPos + str.length,\n        errors: 0,\n      });\n      matchPos += 1;\n    }\n  }\n  if (exactMatches.length > 0) {\n    return exactMatches;\n  }\n\n  // If there are no exact matches, do a more expensive search for matches\n  // with errors.\n  return (0,dist/* default */.Z)(text, str, maxErrors);\n}\n\n/**\n * Compute a score between 0 and 1.0 for the similarity between `text` and `str`.\n *\n * @param {string} text\n * @param {string} str\n */\nfunction textMatchScore(text, str) {\n  /* istanbul ignore next - `scoreMatch` will never pass an empty string */\n  if (str.length === 0 || text.length === 0) {\n    return 0.0;\n  }\n  const matches = search(text, str, str.length);\n\n  // prettier-ignore\n  return 1 - (matches[0].errors / str.length);\n}\n\n/**\n * Find the best approximate match for `quote` in `text`.\n *\n * Returns `null` if no match exceeding the minimum quality threshold was found.\n *\n * @param {string} text - Document text to search\n * @param {string} quote - String to find within `text`\n * @param {Object} context -\n *   Context in which the quote originally appeared. This is used to choose the\n *   best match.\n *   @param {string} [context.prefix] - Expected text before the quote\n *   @param {string} [context.suffix] - Expected text after the quote\n *   @param {number} [context.hint] - Expected offset of match within text\n * @return {Match|null}\n */\nfunction matchQuote(text, quote, context = {}) {\n  if (quote.length === 0) {\n    return null;\n  }\n\n  // Choose the maximum number of errors to allow for the initial search.\n  // This choice involves a tradeoff between:\n  //\n  //  - Recall (proportion of "good" matches found)\n  //  - Precision (proportion of matches found which are "good")\n  //  - Cost of the initial search and of processing the candidate matches [1]\n  //\n  // [1] Specifically, the expected-time complexity of the initial search is\n  //     `O((maxErrors / 32) * text.length)`. See `approx-string-match` docs.\n  const maxErrors = Math.min(256, quote.length / 2);\n\n  // Find closest matches for `quote` in `text` based on edit distance.\n  const matches = search(text, quote, maxErrors);\n\n  if (matches.length === 0) {\n    return null;\n  }\n\n  /**\n   * Compute a score between 0 and 1.0 for a match candidate.\n   *\n   * @param {StringMatch} match\n   */\n  const scoreMatch = match => {\n    const quoteWeight = 50; // Similarity of matched text to quote.\n    const prefixWeight = 20; // Similarity of text before matched text to `context.prefix`.\n    const suffixWeight = 20; // Similarity of text after matched text to `context.suffix`.\n    const posWeight = 2; // Proximity to expected location. Used as a tie-breaker.\n\n    const quoteScore = 1 - match.errors / quote.length;\n\n    const prefixScore = context.prefix\n      ? textMatchScore(\n          text.slice(Math.max(0, match.start - context.prefix.length), match.start),\n          context.prefix\n        )\n      : 1.0;\n    const suffixScore = context.suffix\n      ? textMatchScore(\n          text.slice(match.end, match.end + context.suffix.length),\n          context.suffix\n        )\n      : 1.0;\n\n    let posScore = 1.0;\n    if (typeof context.hint === \'number\') {\n      const offset = Math.abs(match.start - context.hint);\n      posScore = 1.0 - offset / text.length;\n    }\n\n    const rawScore =\n      quoteWeight * quoteScore +\n      prefixWeight * prefixScore +\n      suffixWeight * suffixScore +\n      posWeight * posScore;\n    const maxScore = quoteWeight + prefixWeight + suffixWeight + posWeight;\n    const normalizedScore = rawScore / maxScore;\n\n    return normalizedScore;\n  };\n\n  // Rank matches based on similarity of actual and expected surrounding text\n  // and actual/expected offset in the document text.\n  const scoredMatches = matches.map(m => ({\n    start: m.start,\n    end: m.end,\n    score: scoreMatch(m),\n  }));\n\n  // Choose match with highest score.\n  scoredMatches.sort((a, b) => b.score - a.score);\n  return scoredMatches[0];\n}\n\n;// CONCATENATED MODULE: ./src/vendor/hypothesis/anchoring/text-range.js\n/**\n * Return the combined length of text nodes contained in `node`.\n *\n * @param {Node} node\n */\nfunction nodeTextLength(node) {\n  switch (node.nodeType) {\n    case Node.ELEMENT_NODE:\n    case Node.TEXT_NODE:\n      // nb. `textContent` excludes text in comments and processing instructions\n      // when called on a parent element, so we don\'t need to subtract that here.\n\n      return /** @type {string} */ (node.textContent).length;\n    default:\n      return 0;\n  }\n}\n\n/**\n * Return the total length of the text of all previous siblings of `node`.\n *\n * @param {Node} node\n */\nfunction previousSiblingsTextLength(node) {\n  let sibling = node.previousSibling;\n  let length = 0;\n  while (sibling) {\n    length += nodeTextLength(sibling);\n    sibling = sibling.previousSibling;\n  }\n  return length;\n}\n\n/**\n * Resolve one or more character offsets within an element to (text node, position)\n * pairs.\n *\n * @param {Element} element\n * @param {number[]} offsets - Offsets, which must be sorted in ascending order\n * @return {{ node: Text, offset: number }[]}\n */\nfunction resolveOffsets(element, ...offsets) {\n  let nextOffset = offsets.shift();\n  const nodeIter = /** @type {Document} */ (\n    element.ownerDocument\n  ).createNodeIterator(element, NodeFilter.SHOW_TEXT);\n  const results = [];\n\n  let currentNode = nodeIter.nextNode();\n  let textNode;\n  let length = 0;\n\n  // Find the text node containing the `nextOffset`th character from the start\n  // of `element`.\n  while (nextOffset !== undefined && currentNode) {\n    textNode = /** @type {Text} */ (currentNode);\n    if (length + textNode.data.length > nextOffset) {\n      results.push({ node: textNode, offset: nextOffset - length });\n      nextOffset = offsets.shift();\n    } else {\n      currentNode = nodeIter.nextNode();\n      length += textNode.data.length;\n    }\n  }\n\n  // Boundary case.\n  while (nextOffset !== undefined && textNode && length === nextOffset) {\n    results.push({ node: textNode, offset: textNode.data.length });\n    nextOffset = offsets.shift();\n  }\n\n  if (nextOffset !== undefined) {\n    throw new RangeError(\'Offset exceeds text length\');\n  }\n\n  return results;\n}\n\nlet RESOLVE_FORWARDS = 1;\nlet RESOLVE_BACKWARDS = 2;\n\n/**\n * Represents an offset within the text content of an element.\n *\n * This position can be resolved to a specific descendant node in the current\n * DOM subtree of the element using the `resolve` method.\n */\nclass text_range_TextPosition {\n  /**\n   * Construct a `TextPosition` that refers to the text position `offset` within\n   * the text content of `element`.\n   *\n   * @param {Element} element\n   * @param {number} offset\n   */\n  constructor(element, offset) {\n    if (offset < 0) {\n      throw new Error(\'Offset is invalid\');\n    }\n\n    /** Element that `offset` is relative to. */\n    this.element = element;\n\n    /** Character offset from the start of the element\'s `textContent`. */\n    this.offset = offset;\n  }\n\n  /**\n   * Return a copy of this position with offset relative to a given ancestor\n   * element.\n   *\n   * @param {Element} parent - Ancestor of `this.element`\n   * @return {TextPosition}\n   */\n  relativeTo(parent) {\n    if (!parent.contains(this.element)) {\n      throw new Error(\'Parent is not an ancestor of current element\');\n    }\n\n    let el = this.element;\n    let offset = this.offset;\n    while (el !== parent) {\n      offset += previousSiblingsTextLength(el);\n      el = /** @type {Element} */ (el.parentElement);\n    }\n\n    return new text_range_TextPosition(el, offset);\n  }\n\n  /**\n   * Resolve the position to a specific text node and offset within that node.\n   *\n   * Throws if `this.offset` exceeds the length of the element\'s text. In the\n   * case where the element has no text and `this.offset` is 0, the `direction`\n   * option determines what happens.\n   *\n   * Offsets at the boundary between two nodes are resolved to the start of the\n   * node that begins at the boundary.\n   *\n   * @param {Object} [options]\n   *   @param {RESOLVE_FORWARDS|RESOLVE_BACKWARDS} [options.direction] -\n   *     Specifies in which direction to search for the nearest text node if\n   *     `this.offset` is `0` and `this.element` has no text. If not specified\n   *     an error is thrown.\n   * @return {{ node: Text, offset: number }}\n   * @throws {RangeError}\n   */\n  resolve(options = {}) {\n    try {\n      return resolveOffsets(this.element, this.offset)[0];\n    } catch (err) {\n      if (this.offset === 0 && options.direction !== undefined) {\n        const tw = document.createTreeWalker(\n          this.element.getRootNode(),\n          NodeFilter.SHOW_TEXT\n        );\n        tw.currentNode = this.element;\n        const forwards = options.direction === RESOLVE_FORWARDS;\n        const text = /** @type {Text|null} */ (\n          forwards ? tw.nextNode() : tw.previousNode()\n        );\n        if (!text) {\n          throw err;\n        }\n        return { node: text, offset: forwards ? 0 : text.data.length };\n      } else {\n        throw err;\n      }\n    }\n  }\n\n  /**\n   * Construct a `TextPosition` that refers to the `offset`th character within\n   * `node`.\n   *\n   * @param {Node} node\n   * @param {number} offset\n   * @return {TextPosition}\n   */\n  static fromCharOffset(node, offset) {\n    switch (node.nodeType) {\n      case Node.TEXT_NODE:\n        return text_range_TextPosition.fromPoint(node, offset);\n      case Node.ELEMENT_NODE:\n        return new text_range_TextPosition(/** @type {Element} */ (node), offset);\n      default:\n        throw new Error(\'Node is not an element or text node\');\n    }\n  }\n\n  /**\n   * Construct a `TextPosition` representing the range start or end point (node, offset).\n   *\n   * @param {Node} node - Text or Element node\n   * @param {number} offset - Offset within the node.\n   * @return {TextPosition}\n   */\n  static fromPoint(node, offset) {\n    switch (node.nodeType) {\n      case Node.TEXT_NODE: {\n        if (offset < 0 || offset > /** @type {Text} */ (node).data.length) {\n          throw new Error(\'Text node offset is out of range\');\n        }\n\n        if (!node.parentElement) {\n          throw new Error(\'Text node has no parent\');\n        }\n\n        // Get the offset from the start of the parent element.\n        const textOffset = previousSiblingsTextLength(node) + offset;\n\n        return new text_range_TextPosition(node.parentElement, textOffset);\n      }\n      case Node.ELEMENT_NODE: {\n        if (offset < 0 || offset > node.childNodes.length) {\n          throw new Error(\'Child node offset is out of range\');\n        }\n\n        // Get the text length before the `offset`th child of element.\n        let textOffset = 0;\n        for (let i = 0; i < offset; i++) {\n          textOffset += nodeTextLength(node.childNodes[i]);\n        }\n\n        return new text_range_TextPosition(/** @type {Element} */ (node), textOffset);\n      }\n      default:\n        throw new Error(\'Point is not in an element or text node\');\n    }\n  }\n}\n\n/**\n * Represents a region of a document as a (start, end) pair of `TextPosition` points.\n *\n * Representing a range in this way allows for changes in the DOM content of the\n * range which don\'t affect its text content, without affecting the text content\n * of the range itself.\n */\nclass text_range_TextRange {\n  /**\n   * Construct an immutable `TextRange` from a `start` and `end` point.\n   *\n   * @param {TextPosition} start\n   * @param {TextPosition} end\n   */\n  constructor(start, end) {\n    this.start = start;\n    this.end = end;\n  }\n\n  /**\n   * Return a copy of this range with start and end positions relative to a\n   * given ancestor. See `TextPosition.relativeTo`.\n   *\n   * @param {Element} element\n   */\n  relativeTo(element) {\n    return new text_range_TextRange(\n      this.start.relativeTo(element),\n      this.end.relativeTo(element)\n    );\n  }\n\n  /**\n   * Resolve the `TextRange` to a DOM range.\n   *\n   * The resulting DOM Range will always start and end in a `Text` node.\n   * Hence `TextRange.fromRange(range).toRange()` can be used to "shrink" a\n   * range to the text it contains.\n   *\n   * May throw if the `start` or `end` positions cannot be resolved to a range.\n   *\n   * @return {Range}\n   */\n  toRange() {\n    let start;\n    let end;\n\n    if (\n      this.start.element === this.end.element &&\n      this.start.offset <= this.end.offset\n    ) {\n      // Fast path for start and end points in same element.\n      [start, end] = resolveOffsets(\n        this.start.element,\n        this.start.offset,\n        this.end.offset\n      );\n    } else {\n      start = this.start.resolve({ direction: RESOLVE_FORWARDS });\n      end = this.end.resolve({ direction: RESOLVE_BACKWARDS });\n    }\n\n    const range = new Range();\n    range.setStart(start.node, start.offset);\n    range.setEnd(end.node, end.offset);\n    return range;\n  }\n\n  /**\n   * Convert an existing DOM `Range` to a `TextRange`\n   *\n   * @param {Range} range\n   * @return {TextRange}\n   */\n  static fromRange(range) {\n    const start = text_range_TextPosition.fromPoint(\n      range.startContainer,\n      range.startOffset\n    );\n    const end = text_range_TextPosition.fromPoint(range.endContainer, range.endOffset);\n    return new text_range_TextRange(start, end);\n  }\n\n  /**\n   * Return a `TextRange` from the `start`th to `end`th characters in `root`.\n   *\n   * @param {Element} root\n   * @param {number} start\n   * @param {number} end\n   */\n  static fromOffsets(root, start, end) {\n    return new text_range_TextRange(\n      new text_range_TextPosition(root, start),\n      new text_range_TextPosition(root, end)\n    );\n  }\n}\n\n;// CONCATENATED MODULE: ./src/vendor/hypothesis/anchoring/types.js\n/**\n * This module exports a set of classes for converting between DOM `Range`\n * objects and different types of selectors. It is mostly a thin wrapper around a\n * set of anchoring libraries. It serves two main purposes:\n *\n *  1. Providing a consistent interface across different types of anchors.\n *  2. Insulating the rest of the code from API changes in the underlying anchoring\n *     libraries.\n */\n\n\n\n\n\n/**\n * @typedef {import(\'../../types/api\').RangeSelector} RangeSelector\n * @typedef {import(\'../../types/api\').TextPositionSelector} TextPositionSelector\n * @typedef {import(\'../../types/api\').TextQuoteSelector} TextQuoteSelector\n */\n\n/**\n * Converts between `RangeSelector` selectors and `Range` objects.\n */\nclass RangeAnchor {\n  /**\n   * @param {Node} root - A root element from which to anchor.\n   * @param {Range} range -  A range describing the anchor.\n   */\n  constructor(root, range) {\n    this.root = root;\n    this.range = range;\n  }\n\n  /**\n   * @param {Node} root -  A root element from which to anchor.\n   * @param {Range} range -  A range describing the anchor.\n   */\n  static fromRange(root, range) {\n    return new RangeAnchor(root, range);\n  }\n\n  /**\n   * Create an anchor from a serialized `RangeSelector` selector.\n   *\n   * @param {Element} root -  A root element from which to anchor.\n   * @param {RangeSelector} selector\n   */\n  static fromSelector(root, selector) {\n    const startContainer = nodeFromXPath(selector.startContainer, root);\n    if (!startContainer) {\n      throw new Error(\'Failed to resolve startContainer XPath\');\n    }\n\n    const endContainer = nodeFromXPath(selector.endContainer, root);\n    if (!endContainer) {\n      throw new Error(\'Failed to resolve endContainer XPath\');\n    }\n\n    const startPos = TextPosition.fromCharOffset(\n      startContainer,\n      selector.startOffset\n    );\n    const endPos = TextPosition.fromCharOffset(\n      endContainer,\n      selector.endOffset\n    );\n\n    const range = new TextRange(startPos, endPos).toRange();\n    return new RangeAnchor(root, range);\n  }\n\n  toRange() {\n    return this.range;\n  }\n\n  /**\n   * @return {RangeSelector}\n   */\n  toSelector() {\n    // "Shrink" the range so that it tightly wraps its text. This ensures more\n    // predictable output for a given text selection.\n    const normalizedRange = TextRange.fromRange(this.range).toRange();\n\n    const textRange = TextRange.fromRange(normalizedRange);\n    const startContainer = xpathFromNode(textRange.start.element, this.root);\n    const endContainer = xpathFromNode(textRange.end.element, this.root);\n\n    return {\n      type: \'RangeSelector\',\n      startContainer,\n      startOffset: textRange.start.offset,\n      endContainer,\n      endOffset: textRange.end.offset,\n    };\n  }\n}\n\n/**\n * Converts between `TextPositionSelector` selectors and `Range` objects.\n */\nclass TextPositionAnchor {\n  /**\n   * @param {Element} root\n   * @param {number} start\n   * @param {number} end\n   */\n  constructor(root, start, end) {\n    this.root = root;\n    this.start = start;\n    this.end = end;\n  }\n\n  /**\n   * @param {Element} root\n   * @param {Range} range\n   */\n  static fromRange(root, range) {\n    const textRange = text_range_TextRange.fromRange(range).relativeTo(root);\n    return new TextPositionAnchor(\n      root,\n      textRange.start.offset,\n      textRange.end.offset\n    );\n  }\n  /**\n   * @param {Element} root\n   * @param {TextPositionSelector} selector\n   */\n  static fromSelector(root, selector) {\n    return new TextPositionAnchor(root, selector.start, selector.end);\n  }\n\n  /**\n   * @return {TextPositionSelector}\n   */\n  toSelector() {\n    return {\n      type: \'TextPositionSelector\',\n      start: this.start,\n      end: this.end,\n    };\n  }\n\n  toRange() {\n    return text_range_TextRange.fromOffsets(this.root, this.start, this.end).toRange();\n  }\n}\n\n/**\n * @typedef QuoteMatchOptions\n * @prop {number} [hint] - Expected position of match in text. See `matchQuote`.\n */\n\n/**\n * Converts between `TextQuoteSelector` selectors and `Range` objects.\n */\nclass TextQuoteAnchor {\n  /**\n   * @param {Element} root - A root element from which to anchor.\n   * @param {string} exact\n   * @param {Object} context\n   *   @param {string} [context.prefix]\n   *   @param {string} [context.suffix]\n   */\n  constructor(root, exact, context = {}) {\n    this.root = root;\n    this.exact = exact;\n    this.context = context;\n  }\n\n  /**\n   * Create a `TextQuoteAnchor` from a range.\n   *\n   * Will throw if `range` does not contain any text nodes.\n   *\n   * @param {Element} root\n   * @param {Range} range\n   */\n  static fromRange(root, range) {\n    const text = /** @type {string} */ (root.textContent);\n    const textRange = text_range_TextRange.fromRange(range).relativeTo(root);\n\n    const start = textRange.start.offset;\n    const end = textRange.end.offset;\n\n    // Number of characters around the quote to capture as context. We currently\n    // always use a fixed amount, but it would be better if this code was aware\n    // of logical boundaries in the document (paragraph, article etc.) to avoid\n    // capturing text unrelated to the quote.\n    //\n    // In regular prose the ideal content would often be the surrounding sentence.\n    // This is a natural unit of meaning which enables displaying quotes in\n    // context even when the document is not available. We could use `Intl.Segmenter`\n    // for this when available.\n    const contextLen = 32;\n\n    return new TextQuoteAnchor(root, text.slice(start, end), {\n      prefix: text.slice(Math.max(0, start - contextLen), start),\n      suffix: text.slice(end, Math.min(text.length, end + contextLen)),\n    });\n  }\n\n  /**\n   * @param {Element} root\n   * @param {TextQuoteSelector} selector\n   */\n  static fromSelector(root, selector) {\n    const { prefix, suffix } = selector;\n    return new TextQuoteAnchor(root, selector.exact, { prefix, suffix });\n  }\n\n  /**\n   * @return {TextQuoteSelector}\n   */\n  toSelector() {\n    return {\n      type: \'TextQuoteSelector\',\n      exact: this.exact,\n      prefix: this.context.prefix,\n      suffix: this.context.suffix,\n    };\n  }\n\n  /**\n   * @param {QuoteMatchOptions} [options]\n   */\n  toRange(options = {}) {\n    return this.toPositionAnchor(options).toRange();\n  }\n\n  /**\n   * @param {QuoteMatchOptions} [options]\n   */\n  toPositionAnchor(options = {}) {\n    const text = /** @type {string} */ (this.root.textContent);\n    const match = matchQuote(text, this.exact, {\n      ...this.context,\n      hint: options.hint,\n    });\n    if (!match) {\n      throw new Error(\'Quote not found\');\n    }\n    return new TextPositionAnchor(this.root, match.start, match.end);\n  }\n}\n\n;// CONCATENATED MODULE: ./src/selection.js\n//\n//  Copyright 2021 Readium Foundation. All rights reserved.\n//  Use of this source code is governed by the BSD-style license\n//  available in the top-level LICENSE file of the project.\n//\n\n\n\nconst debug = true;\n\nfunction getSelectionRect() {\n    try {\n        let sel = window.getSelection();\n        if (!sel) {\n            return;\n        }\n        let range = sel.getRangeAt(0);\n\n        const clientRect = range.getBoundingClientRect();\n\n        return {\n            screenWidth: window.outerWidth,\n            screenHeight: window.outerHeight,\n            left: clientRect.left,\n            width: clientRect.width,\n            top: clientRect.top,\n            height: clientRect.height\n        };\n    } catch (e) {\n        logException(e)\n        return null;\n    }\n}\n\nfunction getCurrentSelectionInfo() {\n    const selection = window.getSelection();\n    if (!selection) {\n        return undefined;\n    }\n    if (selection.isCollapsed) {\n        log("^^^ SELECTION COLLAPSED.");\n        return undefined;\n    }\n    const rawText = selection.toString();\n    const cleanText = rawText.trim().replace(/\\n/g, " ").replace(/\\s\\s+/g, " ");\n    if (cleanText.length === 0) {\n        log("^^^ SELECTION TEXT EMPTY.");\n        return undefined;\n    }\n    if (!selection.anchorNode || !selection.focusNode) {\n        return undefined;\n    }\n    const range = selection.rangeCount === 1 ? selection.getRangeAt(0) :\n        createOrderedRange(selection.anchorNode, selection.anchorOffset, selection.focusNode, selection.focusOffset);\n    if (!range || range.collapsed) {\n        log("$$$$$$$$$$$$$$$$$ CANNOT GET NON-COLLAPSED SELECTION RANGE?!");\n        return undefined;\n    }\n    const rangeInfo = convertRange(range, fullQualifiedSelector);\n    if (!rangeInfo) {\n        log("^^^ SELECTION RANGE INFO FAIL?!");\n        return undefined;\n    }\n\n    return {\n        locations: rangeInfo2Location(rangeInfo),\n        text: {\n            highlight: rawText\n        }\n    };\n}\n\nfunction createOrderedRange(startNode, startOffset, endNode, endOffset) {\n    const range = new Range();\n    range.setStart(startNode, startOffset);\n    range.setEnd(endNode, endOffset);\n    if (!range.collapsed) {\n        return range;\n    }\n    log(">>> createOrderedRange COLLAPSED ... RANGE REVERSE?");\n    const rangeReverse = new Range();\n    rangeReverse.setStart(endNode, endOffset);\n    rangeReverse.setEnd(startNode, startOffset);\n    if (!rangeReverse.collapsed) {\n        log(">>> createOrderedRange RANGE REVERSE OK.");\n        return range;\n    }\n    log(">>> createOrderedRange RANGE REVERSE ALSO COLLAPSED?!");\n    return undefined;\n}\n\nfunction convertRange(range, getCssSelector) {\n    const startIsElement = range.startContainer.nodeType === Node.ELEMENT_NODE;\n    const startContainerElement = startIsElement ?\n        range.startContainer :\n        ((range.startContainer.parentNode && range.startContainer.parentNode.nodeType === Node.ELEMENT_NODE) ?\n            range.startContainer.parentNode : undefined);\n    if (!startContainerElement) {\n        return undefined;\n    }\n    const startContainerChildTextNodeIndex = startIsElement ? -1 :\n        Array.from(startContainerElement.childNodes).indexOf(range.startContainer);\n    if (startContainerChildTextNodeIndex < -1) {\n        return undefined;\n    }\n    const startContainerElementCssSelector = getCssSelector(startContainerElement);\n\n    const endIsElement = range.endContainer.nodeType === Node.ELEMENT_NODE;\n    const endContainerElement = endIsElement ?\n        range.endContainer :\n        ((range.endContainer.parentNode && range.endContainer.parentNode.nodeType === Node.ELEMENT_NODE) ?\n            range.endContainer.parentNode : undefined);\n    if (!endContainerElement) {\n        return undefined;\n    }\n    const endContainerChildTextNodeIndex = endIsElement ? -1 :\n        Array.from(endContainerElement.childNodes).indexOf(range.endContainer);\n    if (endContainerChildTextNodeIndex < -1) {\n        return undefined;\n    }\n    const endContainerElementCssSelector = getCssSelector(endContainerElement);\n\n    const commonElementAncestor = getCommonAncestorElement(range.startContainer, range.endContainer);\n    if (!commonElementAncestor) {\n        log("^^^ NO RANGE COMMON ANCESTOR?!");\n        return undefined;\n    }\n    if (range.commonAncestorContainer) {\n        const rangeCommonAncestorElement = range.commonAncestorContainer.nodeType === Node.ELEMENT_NODE ?\n            range.commonAncestorContainer : range.commonAncestorContainer.parentNode;\n        if (rangeCommonAncestorElement && rangeCommonAncestorElement.nodeType === Node.ELEMENT_NODE) {\n            if (commonElementAncestor !== rangeCommonAncestorElement) {\n                log(">>>>>> COMMON ANCESTOR CONTAINER DIFF??!");\n                log(getCssSelector(commonElementAncestor));\n                log(getCssSelector(rangeCommonAncestorElement));\n            }\n        }\n    }\n    return {\n        endContainerChildTextNodeIndex,\n        endContainerElementCssSelector,\n        endOffset: range.endOffset,\n        startContainerChildTextNodeIndex,\n        startContainerElementCssSelector,\n        startOffset: range.startOffset,\n    };\n}\n\nfunction getCommonAncestorElement(node1, node2) {\n    if (node1.nodeType === Node.ELEMENT_NODE && node1 === node2) {\n        return node1;\n    }\n    if (node1.nodeType === Node.ELEMENT_NODE && node1.contains(node2)) {\n        return node1;\n    }\n    if (node2.nodeType === Node.ELEMENT_NODE && node2.contains(node1)) {\n        return node2;\n    }\n    const node1ElementAncestorChain = [];\n    let parent = node1.parentNode;\n    while (parent && parent.nodeType === Node.ELEMENT_NODE) {\n        node1ElementAncestorChain.push(parent);\n        parent = parent.parentNode;\n    }\n    const node2ElementAncestorChain = [];\n    parent = node2.parentNode;\n    while (parent && parent.nodeType === Node.ELEMENT_NODE) {\n        node2ElementAncestorChain.push(parent);\n        parent = parent.parentNode;\n    }\n    let commonAncestor = node1ElementAncestorChain.find((node1ElementAncestor) => {\n        return node2ElementAncestorChain.indexOf(node1ElementAncestor) >= 0;\n    });\n    if (!commonAncestor) {\n        commonAncestor = node2ElementAncestorChain.find((node2ElementAncestor) => {\n            return node1ElementAncestorChain.indexOf(node2ElementAncestor) >= 0;\n        });\n    }\n    return commonAncestor;\n}\n\nfunction convertRangeInfo(document, rangeInfo) {\n    const startElement = document.querySelector(rangeInfo.startContainerElementCssSelector);\n    if (!startElement) {\n        log("^^^ convertRangeInfo NO START ELEMENT CSS SELECTOR?!");\n        return undefined;\n    }\n    let startContainer = startElement;\n    if (rangeInfo.startContainerChildTextNodeIndex >= 0) {\n        if (rangeInfo.startContainerChildTextNodeIndex >= startElement.childNodes.length) {\n            log("^^^ convertRangeInfo rangeInfo.startContainerChildTextNodeIndex >= startElement.childNodes.length?!");\n            return undefined;\n        }\n        startContainer = startElement.childNodes[rangeInfo.startContainerChildTextNodeIndex];\n        if (startContainer.nodeType !== Node.TEXT_NODE) {\n            log("^^^ convertRangeInfo startContainer.nodeType !== Node.TEXT_NODE?!");\n            return undefined;\n        }\n    }\n    const endElement = document.querySelector(rangeInfo.endContainerElementCssSelector);\n    if (!endElement) {\n        log("^^^ convertRangeInfo NO END ELEMENT CSS SELECTOR?!");\n        return undefined;\n    }\n    let endContainer = endElement;\n    if (rangeInfo.endContainerChildTextNodeIndex >= 0) {\n        if (rangeInfo.endContainerChildTextNodeIndex >= endElement.childNodes.length) {\n            log("^^^ convertRangeInfo rangeInfo.endContainerChildTextNodeIndex >= endElement.childNodes.length?!");\n            return undefined;\n        }\n        endContainer = endElement.childNodes[rangeInfo.endContainerChildTextNodeIndex];\n        if (endContainer.nodeType !== Node.TEXT_NODE) {\n            log("^^^ convertRangeInfo endContainer.nodeType !== Node.TEXT_NODE?!");\n            return undefined;\n        }\n    }\n    return createOrderedRange(startContainer, rangeInfo.startOffset, endContainer, rangeInfo.endOffset);\n}\n\nfunction rangeInfo2Location(rangeInfo) {\n    return {\n        cssSelector: rangeInfo.startContainerElementCssSelector,\n        domRange: {\n            start: {\n                cssSelector: rangeInfo.startContainerElementCssSelector,\n                textNodeIndex: rangeInfo.startContainerChildTextNodeIndex,\n                offset: rangeInfo.startOffset\n            },\n            end: {\n                cssSelector: rangeInfo.endContainerElementCssSelector,\n                textNodeIndex: rangeInfo.endContainerChildTextNodeIndex,\n                offset: rangeInfo.endOffset\n            }\n        }\n    }\n}\n\nfunction location2RangeInfo(location) {\n    const locations = location.locations\n    const domRange = locations.domRange\n    const start = domRange.start\n    const end = domRange.end\n\n    return {\n        endContainerChildTextNodeIndex: end.textNodeIndex,\n        endContainerElementCssSelector: end.cssSelector,\n        endOffset: end.offset,\n        startContainerChildTextNodeIndex: start.textNodeIndex,\n        startContainerElementCssSelector: start.cssSelector,\n        startOffset: start.offset\n    };\n}\n\nfunction fullQualifiedSelector(node) {\n    if (node.nodeType !== Node.ELEMENT_NODE) {\n        return (node.localName && node.localName.toLowerCase())\n            || node.nodeName.toLowerCase();\n    }\n    //return cssPath(node, justSelector);\n    return cssPath(node, true);\n}\n\nfunction cssPath(node, optimized) {\n    if (node.nodeType !== Node.ELEMENT_NODE) {\n        return "";\n    }\n\n    const steps = [];\n    let contextNode = node;\n    while (contextNode) {\n        const step = _cssPathStep(contextNode, !!optimized, contextNode === node);\n        if (!step) {\n            break; // Error - bail out early.\n        }\n        steps.push(step.value);\n        if (step.optimized) {\n            break;\n        }\n        contextNode = contextNode.parentNode;\n    }\n    steps.reverse();\n    return steps.join(" > ");\n}\n\n// https://chromium.googlesource.com/chromium/blink/+/master/Source/devtools/front_end/components/DOMPresentationUtils.js#316\nfunction _cssPathStep(node, optimized, isTargetNode) {\n\n    function idSelector(idd) {\n        return "#" + escapeIdentifierIfNeeded(idd);\n    }\n\n    function escapeIdentifierIfNeeded(ident) {\n        if (isCSSIdentifier(ident)) {\n            return ident;\n        }\n\n        const shouldEscapeFirst = /^(?:[0-9]|-[0-9-]?)/.test(ident);\n        const lastIndex = ident.length - 1;\n        return ident.replace(/./g, function (c, ii) {\n            return ((shouldEscapeFirst && ii === 0) || !isCSSIdentChar(c)) ? escapeAsciiChar(c, ii === lastIndex) : c;\n        });\n    }\n\n    function isCSSIdentifier(value) {\n        return /^-?[a-zA-Z_][a-zA-Z0-9_-]*$/.test(value);\n    }\n\n    function isCSSIdentChar(c) {\n        if (/[a-zA-Z0-9_-]/.test(c)) {\n            return true;\n        }\n        return c.charCodeAt(0) >= 0xA0;\n    }\n\n    function escapeAsciiChar(c, isLast) {\n        return "\\\\" + toHexByte(c) + (isLast ? "" : " ");\n    }\n\n    function toHexByte(c) {\n        let hexByte = c.charCodeAt(0).toString(16);\n        if (hexByte.length === 1) {\n            hexByte = "0" + hexByte;\n        }\n        return hexByte;\n    }\n\n    function prefixedElementClassNames(nd) {\n        const classAttribute = nd.getAttribute("class");\n        if (!classAttribute) {\n            return [];\n        }\n\n        return classAttribute.split(/\\s+/g).filter(Boolean).map((nm) => {\n            // The prefix is required to store "__proto__" in a object-based map.\n            return "$" + nm;\n        });\n    }\n\n    if (node.nodeType !== Node.ELEMENT_NODE) {\n        return undefined;\n    }\n    const lowerCaseName = (node.localName && node.localName.toLowerCase())\n        || node.nodeName.toLowerCase();\n\n    const element = node;\n\n    const id = element.getAttribute("id");\n\n    if (optimized) {\n        if (id) {\n            return {\n                optimized: true,\n                value: idSelector(id),\n            };\n        }\n        if (lowerCaseName === "body" || lowerCaseName === "head" || lowerCaseName === "html") {\n            return {\n                optimized: true,\n                value: lowerCaseName, // node.nodeNameInCorrectCase(),\n            };\n        }\n    }\n\n    const nodeName = lowerCaseName; // node.nodeNameInCorrectCase();\n    if (id) {\n        return {\n            optimized: true,\n            value: nodeName + idSelector(id),\n        };\n    }\n\n    const parent = node.parentNode;\n\n    if (!parent || parent.nodeType === Node.DOCUMENT_NODE) {\n        return {\n            optimized: true,\n            value: nodeName,\n        };\n    }\n\n    const prefixedOwnClassNamesArray_ = prefixedElementClassNames(element);\n\n    const prefixedOwnClassNamesArray = []; // .keySet()\n    prefixedOwnClassNamesArray_.forEach((arrItem) => {\n        if (prefixedOwnClassNamesArray.indexOf(arrItem) < 0) {\n            prefixedOwnClassNamesArray.push(arrItem);\n        }\n    });\n\n    let needsClassNames = false;\n    let needsNthChild = false;\n    let ownIndex = -1;\n    let elementIndex = -1;\n    const siblings = parent.children;\n\n    for (let i = 0; (ownIndex === -1 || !needsNthChild) && i < siblings.length; ++i) {\n        const sibling = siblings[i];\n        if (sibling.nodeType !== Node.ELEMENT_NODE) {\n            continue;\n        }\n        elementIndex += 1;\n        if (sibling === node) {\n            ownIndex = elementIndex;\n            continue;\n        }\n        if (needsNthChild) {\n            continue;\n        }\n\n        // sibling.nodeNameInCorrectCase()\n        const siblingName = (sibling.localName && sibling.localName.toLowerCase()) || sibling.nodeName.toLowerCase();\n        if (siblingName !== nodeName) {\n            continue;\n        }\n        needsClassNames = true;\n\n        const ownClassNames = [];\n        prefixedOwnClassNamesArray.forEach((arrItem) => {\n            ownClassNames.push(arrItem);\n        });\n        let ownClassNameCount = ownClassNames.length;\n\n        if (ownClassNameCount === 0) {\n            needsNthChild = true;\n            continue;\n        }\n        const siblingClassNamesArray_ = prefixedElementClassNames(sibling);\n        const siblingClassNamesArray = []; // .keySet()\n        siblingClassNamesArray_.forEach((arrItem) => {\n            if (siblingClassNamesArray.indexOf(arrItem) < 0) {\n                siblingClassNamesArray.push(arrItem);\n            }\n        });\n\n        for (const siblingClass of siblingClassNamesArray) {\n            const ind = ownClassNames.indexOf(siblingClass);\n            if (ind < 0) {\n                continue;\n            }\n\n            ownClassNames.splice(ind, 1); // delete ownClassNames[siblingClass];\n\n            if (!--ownClassNameCount) {\n                needsNthChild = true;\n                break;\n            }\n        }\n    }\n\n    let result = nodeName;\n    if (isTargetNode &&\n        nodeName === "input" &&\n        element.getAttribute("type") &&\n        !element.getAttribute("id") &&\n        !element.getAttribute("class")) {\n        result += "[type=\\"" + element.getAttribute("type") + "\\"]";\n    }\n    if (needsNthChild) {\n        result += ":nth-child(" + (ownIndex + 1) + ")";\n    } else if (needsClassNames) {\n        for (const prefixedName of prefixedOwnClassNamesArray) {\n            result += "." + escapeIdentifierIfNeeded(prefixedName.substr(1));\n        }\n    }\n\n    return {\n        optimized: false,\n        value: result,\n    };\n}\n\nfunction log() {\n    if (debug) {\n        utils_log.apply(null, arguments);\n    }\n}\n;// CONCATENATED MODULE: ./src/rect.js\n//\n//  Copyright 2021 Readium Foundation. All rights reserved.\n//  Use of this source code is governed by the BSD-style license\n//  available in the top-level LICENSE file of the project.\n//\n\n\n\nconst rect_debug = false;\n\nfunction rect_getClientRectsNoOverlap(range, doNotMergeHorizontallyAlignedRects) {\n    let clientRects = range.getClientRects();\n\n    const tolerance = 1;\n    const originalRects = [];\n    for (const rangeClientRect of clientRects) {\n        originalRects.push({\n            bottom: rangeClientRect.bottom,\n            height: rangeClientRect.height,\n            left: rangeClientRect.left,\n            right: rangeClientRect.right,\n            top: rangeClientRect.top,\n            width: rangeClientRect.width,\n        });\n    }\n    const mergedRects = mergeTouchingRects(originalRects, tolerance, doNotMergeHorizontallyAlignedRects);\n    const noContainedRects = removeContainedRects(mergedRects, tolerance);\n    const newRects = replaceOverlapingRects(noContainedRects);\n    const minArea = 2 * 2;\n    for (let j = newRects.length - 1; j >= 0; j--) {\n        const rect = newRects[j];\n        const bigEnough = (rect.width * rect.height) > minArea;\n        if (!bigEnough) {\n            if (newRects.length > 1) {\n                rect_log("CLIENT RECT: remove small");\n                newRects.splice(j, 1);\n            } else {\n                rect_log("CLIENT RECT: remove small, but keep otherwise empty!");\n                break;\n            }\n        }\n    }\n    rect_log(`CLIENT RECT: reduced ${originalRects.length} --\x3e ${newRects.length}`);\n    return newRects;\n}\n\nfunction mergeTouchingRects(rects, tolerance, doNotMergeHorizontallyAlignedRects) {\n    for (let i = 0; i < rects.length; i++) {\n        for (let j = i + 1; j < rects.length; j++) {\n            const rect1 = rects[i];\n            const rect2 = rects[j];\n            if (rect1 === rect2) {\n                rect_log("mergeTouchingRects rect1 === rect2 ??!");\n                continue;\n            }\n            const rectsLineUpVertically = almostEqual(rect1.top, rect2.top, tolerance) &&\n                almostEqual(rect1.bottom, rect2.bottom, tolerance);\n            const rectsLineUpHorizontally = almostEqual(rect1.left, rect2.left, tolerance) &&\n                almostEqual(rect1.right, rect2.right, tolerance);\n            const horizontalAllowed = !doNotMergeHorizontallyAlignedRects;\n            const aligned = (rectsLineUpHorizontally && horizontalAllowed) || (rectsLineUpVertically && !rectsLineUpHorizontally);\n            const canMerge = aligned && rectsTouchOrOverlap(rect1, rect2, tolerance);\n            if (canMerge) {\n                rect_log(`CLIENT RECT: merging two into one, VERTICAL: ${rectsLineUpVertically} HORIZONTAL: ${rectsLineUpHorizontally} (${doNotMergeHorizontallyAlignedRects})`);\n                const newRects = rects.filter((rect) => {\n                    return rect !== rect1 && rect !== rect2;\n                });\n                const replacementClientRect = getBoundingRect(rect1, rect2);\n                newRects.push(replacementClientRect);\n                return mergeTouchingRects(newRects, tolerance, doNotMergeHorizontallyAlignedRects);\n            }\n        }\n    }\n    return rects;\n}\n\nfunction getBoundingRect(rect1, rect2) {\n    const left = Math.min(rect1.left, rect2.left);\n    const right = Math.max(rect1.right, rect2.right);\n    const top = Math.min(rect1.top, rect2.top);\n    const bottom = Math.max(rect1.bottom, rect2.bottom);\n    return {\n        bottom,\n        height: bottom - top,\n        left,\n        right,\n        top,\n        width: right - left,\n    };\n}\n\nfunction removeContainedRects(rects, tolerance) {\n    const rectsToKeep = new Set(rects);\n    for (const rect of rects) {\n        const bigEnough = rect.width > 1 && rect.height > 1;\n        if (!bigEnough) {\n            rect_log("CLIENT RECT: remove tiny");\n            rectsToKeep.delete(rect);\n            continue;\n        }\n        for (const possiblyContainingRect of rects) {\n            if (rect === possiblyContainingRect) {\n                continue;\n            }\n            if (!rectsToKeep.has(possiblyContainingRect)) {\n                continue;\n            }\n            if (rectContains(possiblyContainingRect, rect, tolerance)) {\n                rect_log("CLIENT RECT: remove contained");\n                rectsToKeep.delete(rect);\n                break;\n            }\n        }\n    }\n    return Array.from(rectsToKeep);\n}\n\nfunction rectContains(rect1, rect2, tolerance) {\n    return (rectContainsPoint(rect1, rect2.left, rect2.top, tolerance) &&\n        rectContainsPoint(rect1, rect2.right, rect2.top, tolerance) &&\n        rectContainsPoint(rect1, rect2.left, rect2.bottom, tolerance) &&\n        rectContainsPoint(rect1, rect2.right, rect2.bottom, tolerance));\n}\n\nfunction rectContainsPoint(rect, x, y, tolerance) {\n    return (rect.left < x || almostEqual(rect.left, x, tolerance)) &&\n        (rect.right > x || almostEqual(rect.right, x, tolerance)) &&\n        (rect.top < y || almostEqual(rect.top, y, tolerance)) &&\n        (rect.bottom > y || almostEqual(rect.bottom, y, tolerance));\n}\n\nfunction replaceOverlapingRects(rects) {\n    for (let i = 0; i < rects.length; i++) {\n        for (let j = i + 1; j < rects.length; j++) {\n            const rect1 = rects[i];\n            const rect2 = rects[j];\n            if (rect1 === rect2) {\n                rect_log("replaceOverlapingRects rect1 === rect2 ??!");\n                continue;\n            }\n            if (rectsTouchOrOverlap(rect1, rect2, -1)) {\n                let toAdd = [];\n                let toRemove;\n                let toPreserve;\n                const subtractRects1 = rectSubtract(rect1, rect2);\n                if (subtractRects1.length === 1) {\n                    toAdd = subtractRects1;\n                    toRemove = rect1;\n                    toPreserve = rect2;\n                } else {\n                    const subtractRects2 = rectSubtract(rect2, rect1);\n                    if (subtractRects1.length < subtractRects2.length) {\n                        toAdd = subtractRects1;\n                        toRemove = rect1;\n                        toPreserve = rect2;\n                    } else {\n                        toAdd = subtractRects2;\n                        toRemove = rect2;\n                        toPreserve = rect1;\n                    }\n                }\n                rect_log(`CLIENT RECT: overlap, cut one rect into ${toAdd.length}`);\n                const newRects = rects.filter((rect) => {\n                    return rect !== toRemove;\n                });\n                Array.prototype.push.apply(newRects, toAdd);\n                return replaceOverlapingRects(newRects);\n            }\n        }\n    }\n    return rects;\n}\n\nfunction rectSubtract(rect1, rect2) {\n    const rectIntersected = rectIntersect(rect2, rect1);\n    if (rectIntersected.height === 0 || rectIntersected.width === 0) {\n        return [rect1];\n    }\n    const rects = [];\n    {\n        const rectA = {\n            bottom: rect1.bottom,\n            height: 0,\n            left: rect1.left,\n            right: rectIntersected.left,\n            top: rect1.top,\n            width: 0,\n        };\n        rectA.width = rectA.right - rectA.left;\n        rectA.height = rectA.bottom - rectA.top;\n        if (rectA.height !== 0 && rectA.width !== 0) {\n            rects.push(rectA);\n        }\n    }\n    {\n        const rectB = {\n            bottom: rectIntersected.top,\n            height: 0,\n            left: rectIntersected.left,\n            right: rectIntersected.right,\n            top: rect1.top,\n            width: 0,\n        };\n        rectB.width = rectB.right - rectB.left;\n        rectB.height = rectB.bottom - rectB.top;\n        if (rectB.height !== 0 && rectB.width !== 0) {\n            rects.push(rectB);\n        }\n    }\n    {\n        const rectC = {\n            bottom: rect1.bottom,\n            height: 0,\n            left: rectIntersected.left,\n            right: rectIntersected.right,\n            top: rectIntersected.bottom,\n            width: 0,\n        };\n        rectC.width = rectC.right - rectC.left;\n        rectC.height = rectC.bottom - rectC.top;\n        if (rectC.height !== 0 && rectC.width !== 0) {\n            rects.push(rectC);\n        }\n    }\n    {\n        const rectD = {\n            bottom: rect1.bottom,\n            height: 0,\n            left: rectIntersected.right,\n            right: rect1.right,\n            top: rect1.top,\n            width: 0,\n        };\n        rectD.width = rectD.right - rectD.left;\n        rectD.height = rectD.bottom - rectD.top;\n        if (rectD.height !== 0 && rectD.width !== 0) {\n            rects.push(rectD);\n        }\n    }\n    return rects;\n}\n\nfunction rectIntersect(rect1, rect2) {\n    const maxLeft = Math.max(rect1.left, rect2.left);\n    const minRight = Math.min(rect1.right, rect2.right);\n    const maxTop = Math.max(rect1.top, rect2.top);\n    const minBottom = Math.min(rect1.bottom, rect2.bottom);\n    return {\n        bottom: minBottom,\n        height: Math.max(0, minBottom - maxTop),\n        left: maxLeft,\n        right: minRight,\n        top: maxTop,\n        width: Math.max(0, minRight - maxLeft),\n    };\n}\n\nfunction rectsTouchOrOverlap(rect1, rect2, tolerance) {\n    return ((rect1.left < rect2.right || (tolerance >= 0 && almostEqual(rect1.left, rect2.right, tolerance))) &&\n        (rect2.left < rect1.right || (tolerance >= 0 && almostEqual(rect2.left, rect1.right, tolerance))) &&\n        (rect1.top < rect2.bottom || (tolerance >= 0 && almostEqual(rect1.top, rect2.bottom, tolerance))) &&\n        (rect2.top < rect1.bottom || (tolerance >= 0 && almostEqual(rect2.top, rect1.bottom, tolerance))));\n}\n\nfunction almostEqual(a, b, tolerance) {\n    return Math.abs(a - b) <= tolerance;\n}\n\nfunction rect_log() {\n    if (rect_debug) {\n        utils_log.apply(null, arguments);\n    }\n}\n;// CONCATENATED MODULE: ./src/highlight.js\n//\n//  Copyright 2021 Readium Foundation. All rights reserved.\n//  Use of this source code is governed by the BSD-style license\n//  available in the top-level LICENSE file of the project.\n//\n\n\n\n\n\nconst highlight_debug = false;\n\nconst ID_HIGHLIGHTS_CONTAINER = "R2_ID_HIGHLIGHTS_CONTAINER";\nconst CLASS_HIGHLIGHT_CONTAINER = "R2_CLASS_HIGHLIGHT_CONTAINER";\nconst CLASS_HIGHLIGHT_AREA = "R2_CLASS_HIGHLIGHT_AREA";\nconst CLASS_HIGHLIGHT_BOUNDING_AREA = "R2_CLASS_HIGHLIGHT_BOUNDING_AREA";\n\nconst _highlights = [];\nlet _highlightsContainer;\n\nconst defaultBackgroundOpacity = 0.3;\n\nconst defaultBackgroundColor = {\n    blue: 100,\n    green: 50,\n    red: 230,\n};\n\nwindow.addEventListener("load", function(){ // on page load\n    const body = document.body;\n    var lastSize = { width: 0, height: 0 }\n    const observer = new ResizeObserver(() => {\n        utils_log(body.clientWidth, body.clientHeight)\n        if (lastSize.width === body.clientWidth && lastSize.height === body.clientHeight) {\n            return\n        }\n        lastSize = {\n            width: body.clientWidth,\n            height: body.clientHeight,\n        }\n        resetHighlights()\n    })\n    observer.observe(body)\n\n}, false);\n\nfunction rectForHighlightWithID(id) {\n    const clientRects = frameForHighlightWithID(id);\n\n    return {\n        screenWidth: window.outerWidth,\n        screenHeight: window.outerHeight,\n        left: clientRects[0].left,\n        width: clientRects[0].width,\n        top: clientRects[0].top,\n        height: clientRects[0].height\n    };\n}\n\nfunction destroyAllHighlights() {\n    hideAllHighlights();\n    _highlights.splice(0, _highlights.length);\n}\n\nfunction hideAllHighlights() {\n    if (_highlightsContainer) {\n        _highlightsContainer.remove();\n        _highlightsContainer = null;\n    }\n}\n\nfunction resetHighlights() {\n    hideAllHighlights()\n\n    for (const highlight of _highlights) {\n        createHighlightDOM(highlight)\n    }\n}\n\nfunction createHighlightRange(range) {\n\n    // FIXME: Use user-provided ID.\n    let id = "R2_HIGHLIGHT_" + Date.now();\n\n    destroyHighlight(id);\n\n    const highlight = {\n        color: defaultBackgroundColor,\n        id,\n        pointerInteraction: true,\n        range: range,\n    };\n    _highlights.push(highlight);\n    createHighlightDOM(highlight);\n\n    return highlight;\n}\n\nfunction createHighlight(locations, color, pointerInteraction) {\n    const rangeInfo = location2RangeInfo(locations)\n\n    // FIXME: Use user-provided ID.\n    let id = "R2_HIGHLIGHT_" + Date.now();\n\n    destroyHighlight(id);\n\n    const highlight = {\n        color: color ? color : defaultBackgroundColor,\n        id,\n        pointerInteraction,\n        range: convertRangeInfo(document, rangeInfo),\n    };\n    _highlights.push(highlight);\n    createHighlightDOM(highlight);\n\n    return highlight;\n}\n\nfunction destroyHighlight(id) {\n    let i = -1;\n    let _document = window.document\n    const highlight = _highlights.find((h, j) => {\n        i = j;\n        return h.id === id;\n    });\n    if (highlight && i >= 0 && i < _highlights.length) {\n        _highlights.splice(i, 1);\n    }\n    const highlightContainer = _document.getElementById(id);\n    if (highlightContainer) {\n        highlightContainer.remove();\n    }\n}\n\nfunction createHighlightDOM(highlight) {\n    if (!highlight.range) {\n        return undefined;\n    }\n\n    const scale = 1 / ((window.READIUM2 && window.READIUM2.isFixedLayout) ? window.READIUM2.fxlViewportScale : 1);\n\n    const scrollElement = document.scrollingElement;\n\n    const paginated = !isScrollModeEnabled()\n    const highlightsContainer = ensureContainer(window);\n    const highlightParent = document.createElement("div");\n\n    highlightParent.setAttribute("id", highlight.id);\n    highlightParent.setAttribute("class", CLASS_HIGHLIGHT_CONTAINER);\n\n    highlightParent.style.setProperty("pointer-events", "none");\n    if (highlight.pointerInteraction) {\n        highlightParent.setAttribute("data-click", "1");\n    }\n\n    const bodyRect = document.body.getBoundingClientRect();\n    const drawUnderline = false;\n    const drawStrikeThrough = false;\n    const doNotMergeHorizontallyAlignedRects = drawUnderline || drawStrikeThrough;\n    const clientRects = rect_getClientRectsNoOverlap(highlight.range, doNotMergeHorizontallyAlignedRects);\n    const roundedCorner = 3;\n    const underlineThickness = 2;\n    const strikeThroughLineThickness = 3;\n    const opacity = defaultBackgroundOpacity;\n    let extra = "";\n\n    let xOffset = paginated ? (-scrollElement.scrollLeft) : bodyRect.left;\n    let yOffset = paginated ? (-scrollElement.scrollTop) : bodyRect.top;\n\n    for (const clientRect of clientRects) {\n        const highlightArea = document.createElement("div");\n\n        highlightArea.setAttribute("class", CLASS_HIGHLIGHT_AREA);\n\n        if (highlight_debug) {\n            const rgb = Math.round(0xffffff * Math.random());\n            const r = rgb >> 16;\n            const g = rgb >> 8 & 255;\n            const b = rgb & 255;\n            extra = `outline-color: rgb(${r}, ${g}, ${b}); outline-style: solid; outline-width: 1px; outline-offset: -1px;`;\n        } else {\n            if (drawUnderline) {\n                extra += `border-bottom: ${underlineThickness * scale}px solid rgba(${highlight.color.red}, ${highlight.color.green}, ${highlight.color.blue}, ${opacity}) !important`;\n            }\n        }\n        highlightArea.setAttribute("style", `border-radius: ${roundedCorner}px !important; background-color: rgba(${highlight.color.red}, ${highlight.color.green}, ${highlight.color.blue}, ${opacity}) !important; ${extra}`);\n        highlightArea.style.setProperty("pointer-events", "none");\n        highlightArea.style.position = !paginated ? "fixed" : "absolute";\n        highlightArea.scale = scale;\n        /*\n         highlightArea.rect = {\n         height: clientRect.height,\n         left: clientRect.left - xOffset,\n         top: clientRect.top - yOffset,\n         width: clientRect.width,\n         };\n         */\n        highlightArea.rect = {\n            height: clientRect.height,\n            left: clientRect.left - xOffset,\n            top: clientRect.top - yOffset,\n            width: clientRect.width\n        };\n\n        highlightArea.style.width = `${highlightArea.rect.width * scale}px`;\n        highlightArea.style.height = `${highlightArea.rect.height * scale}px`;\n        highlightArea.style.left = `${highlightArea.rect.left * scale}px`;\n        highlightArea.style.top = `${highlightArea.rect.top * scale}px`;\n        highlightParent.append(highlightArea);\n        if (!highlight_debug && drawStrikeThrough) {\n            //if (drawStrikeThrough) {\n            const highlightAreaLine = document.createElement("div");\n            highlightAreaLine.setAttribute("class", CLASS_HIGHLIGHT_AREA);\n\n            highlightAreaLine.setAttribute("style", `background-color: rgba(${highlight.color.red}, ${highlight.color.green}, ${highlight.color.blue}, ${opacity}) !important;`);\n            highlightAreaLine.style.setProperty("pointer-events", "none");\n            highlightAreaLine.style.position = paginated ? "fixed" : "absolute";\n            highlightAreaLine.scale = scale;\n            /*\n             highlightAreaLine.rect = {\n             height: clientRect.height,\n             left: clientRect.left - xOffset,\n             top: clientRect.top - yOffset,\n             width: clientRect.width,\n             };\n             */\n\n            highlightAreaLine.rect = {\n                height: clientRect.height,\n                left: clientRect.left - xOffset,\n                top: clientRect.top - yOffset,\n                width: clientRect.width\n            };\n\n            highlightAreaLine.style.width = `${highlightAreaLine.rect.width * scale}px`;\n            highlightAreaLine.style.height = `${strikeThroughLineThickness * scale}px`;\n            highlightAreaLine.style.left = `${highlightAreaLine.rect.left * scale}px`;\n            highlightAreaLine.style.top = `${(highlightAreaLine.rect.top + (highlightAreaLine.rect.height / 2) - (strikeThroughLineThickness / 2)) * scale}px`;\n            highlightParent.append(highlightAreaLine);\n        }\n    }\n\n    const highlightBounding = document.createElement("div");\n    highlightBounding.setAttribute("class", CLASS_HIGHLIGHT_BOUNDING_AREA);\n\n    highlightBounding.style.setProperty("pointer-events", "none");\n    highlightBounding.style.position = paginated ? "fixed" : "absolute";\n    highlightBounding.scale = scale;\n\n    if (highlight_debug) {\n        highlightBounding.setAttribute("style", `outline-color: magenta; outline-style: solid; outline-width: 1px; outline-offset: -1px;`);\n    }\n\n    const rangeBoundingClientRect = highlight.range.getBoundingClientRect();\n    highlightBounding.rect = {\n        height: rangeBoundingClientRect.height,\n        left: rangeBoundingClientRect.left - xOffset,\n        top: rangeBoundingClientRect.top - yOffset,\n        width: rangeBoundingClientRect.width\n    };\n\n    highlightBounding.style.width = `${highlightBounding.rect.width * scale}px`;\n    highlightBounding.style.height = `${highlightBounding.rect.height * scale}px`;\n    highlightBounding.style.left = `${highlightBounding.rect.left * scale}px`;\n    highlightBounding.style.top = `${highlightBounding.rect.top * scale}px`;\n\n    highlightParent.append(highlightBounding);\n    highlightsContainer.append(highlightParent);\n\n    return highlightParent;\n}\n\nfunction isScrollModeEnabled() {\n    return document.documentElement.style.getPropertyValue("--USER__scroll").toString().trim() === \'readium-scroll-on\';\n}\n\nfunction ensureContainer(win) {\n    const document = win.document;\n\n    if (!_highlightsContainer) {\n        _highlightsContainer = document.createElement("div");\n        _highlightsContainer.setAttribute("id", ID_HIGHLIGHTS_CONTAINER);\n\n        _highlightsContainer.style.setProperty("pointer-events", "none");\n        document.body.append(_highlightsContainer);\n    }\n\n    return _highlightsContainer;\n}\n\nfunction frameForHighlightWithID(id) {\n    const highlight = highlightWithID(id);\n    if (!highlight)\n        return;\n\n    if (!highlight.range) {\n        return undefined;\n    }\n\n\n    const drawUnderline = false;\n    const drawStrikeThrough = false;\n    const doNotMergeHorizontallyAlignedRects = drawUnderline || drawStrikeThrough;\n    return getClientRectsNoOverlap(highlight.range, doNotMergeHorizontallyAlignedRects);\n}\n\nfunction highlightWithID(id) {\n    let i = -1;\n    return _highlights.find((h, j) => {\n        i = j;\n        return h.id === id;\n    })\n}\n;// CONCATENATED MODULE: ./src/utils.js\n//\n//  Copyright 2021 Readium Foundation. All rights reserved.\n//  Use of this source code is governed by the BSD-style license\n//  available in the top-level LICENSE file of the project.\n//\n\n// Catch JS errors to log them in the app.\n\n\n\n\nwindow.addEventListener("error", function(event) {\n    webkit.messageHandlers.logError.postMessage({\n        "message": event.message,\n        "filename": event.filename,\n        "line": event.lineno\n    });\n}, false);\n\n// Notify native code that the page has loaded.\nwindow.addEventListener("load", function(){ // on page load\n    window.addEventListener("orientationchange", function() {\n        orientationChanged();\n        snapCurrentPosition();\n    });\n    orientationChanged();\n}, false);\n\nvar last_known_scrollX_position = 0;\nvar last_known_scrollY_position = 0;\nvar ticking = false;\nvar maxScreenX = 0;\n\n// Position in range [0 - 1].\nfunction update(position) {\n    var positionString = position.toString()\n    webkit.messageHandlers.progressionChanged.postMessage(positionString);\n}\n\nwindow.addEventListener(\'scroll\', function(e) {\n    last_known_scrollY_position = window.scrollY / document.scrollingElement.scrollHeight;\n    // Using Math.abs because for RTL books, the value will be negative.\n    last_known_scrollX_position = Math.abs(window.scrollX / document.scrollingElement.scrollWidth);\n\n    // Window is hidden\n    if (document.scrollingElement.scrollWidth === 0 || document.scrollingElement.scrollHeight === 0) {\n        return;\n    }\n\n    if (!ticking) {\n        window.requestAnimationFrame(function() {\n            update(utils_isScrollModeEnabled() ? last_known_scrollY_position : last_known_scrollX_position);\n            ticking = false;\n        });\n    }\n    ticking = true;\n});\n\ndocument.addEventListener(\'selectionchange\', debounce(50, function() {\n    var info = {}\n    var selection = document.getSelection();\n    if (selection && selection.rangeCount > 0) {\n        var rect = selection.getRangeAt(0).getBoundingClientRect();\n        info[\'text\'] = selection.toString().trim();\n        info[\'frame\'] = {\n            \'x\': rect.left,\n            \'y\': rect.top,\n            \'width\': rect.width,\n            \'height\': rect.height\n        };\n    }\n\n    webkit.messageHandlers.selectionChanged.postMessage(info);\n}));\n\nfunction orientationChanged() {\n    maxScreenX = (window.orientation === 0 || window.orientation == 180) ? screen.width : screen.height;\n}\n\nfunction utils_isScrollModeEnabled() {\n    return document.documentElement.style.getPropertyValue("--USER__scroll").toString().trim() === \'readium-scroll-on\';\n}\n\n// Scroll to the given TagId in document and snap.\nfunction scrollToId(id) {\n    var element = document.getElementById(id);\n    if (!element) {\n        return false;\n    }\n    element.scrollIntoView();\n\n    if (!utils_isScrollModeEnabled()) {\n        var currentOffset = window.scrollX;\n        var pageWidth = window.innerWidth;\n        // Adds half a page to make sure we don\'t snap to the previous page.\n        document.scrollingElement.scrollLeft = snapOffset(currentOffset + (pageWidth / 2));\n    }\n    return true;\n}\n\n// Position must be in the range [0 - 1], 0-100%.\nfunction scrollToPosition(position, dir) {\n    console.log("ScrollToPosition");\n    if ((position < 0) || (position > 1)) {\n        console.log("InvalidPosition");\n        return;\n    }\n\n    if (utils_isScrollModeEnabled()) {\n        var offset = document.scrollingElement.scrollHeight * position;\n        document.scrollingElement.scrollTop = offset;\n        // window.scrollTo(0, offset);\n    } else {\n        var documentWidth = document.scrollingElement.scrollWidth;\n        var factor = (dir == \'rtl\') ? -1 : 1;\n        var offset = documentWidth * position * factor;\n        document.scrollingElement.scrollLeft = snapOffset(offset);\n    }\n}\n\n// Scrolls to the first occurrence of the given text snippet.\n//\n// The expected text argument is a Locator Text object, as defined here:\n// https://readium.org/architecture/models/locators/\nfunction scrollToText(text) {\n    try {\n        let anchor = new TextQuoteAnchor(document.body, text.highlight, {\n            prefix: text.before,\n            suffix: text.after,\n        })\n\n        scrollToRange(anchor.toRange())\n        return true\n    } catch (e) {\n        logException(e)\n        return false\n    }\n}\n\nfunction scrollToRange(range) {\n    var rect = range.getBoundingClientRect();\n    if (utils_isScrollModeEnabled()) {\n        document.scrollingElement.scrollTop = rect.top + window.scrollY - (window.innerHeight / 2);\n    } else {\n        document.scrollingElement.scrollLeft = rect.left + window.scrollX;\n        snapCurrentPosition();\n    }\n    createHighlightRange(range)\n}\n\n// Returns false if the page is already at the left-most scroll offset.\nfunction scrollLeft(dir) {\n    var isRTL = (dir == "rtl");\n    var documentWidth = document.scrollingElement.scrollWidth;\n    var pageWidth = window.innerWidth;\n    var offset = window.scrollX - pageWidth;\n    var minOffset = isRTL ? -(documentWidth - pageWidth) : 0;\n    return scrollToOffset(Math.max(offset, minOffset));\n}\n\n// Returns false if the page is already at the right-most scroll offset.\nfunction scrollRight(dir) {\n    var isRTL = (dir == "rtl");\n    var documentWidth = document.scrollingElement.scrollWidth;\n    var pageWidth = window.innerWidth;\n    var offset = window.scrollX + pageWidth;\n    var maxOffset = isRTL ? 0 : (documentWidth - pageWidth);\n    return scrollToOffset(Math.min(offset, maxOffset));\n}\n\n// Scrolls to the given left offset.\n// Returns false if the page scroll position is already close enough to the given offset.\nfunction scrollToOffset(offset) {\n    var currentOffset = window.scrollX;\n    var pageWidth = window.innerWidth;\n    document.scrollingElement.scrollLeft = offset;\n    // In some case the scrollX cannot reach the position respecting to innerWidth\n    var diff = Math.abs(currentOffset - offset) / pageWidth;\n    return (diff > 0.01);\n}\n\n// Snap the offset to the screen width (page width).\nfunction snapOffset(offset) {\n    var value = offset + 1;\n\n    return value - (value % maxScreenX);\n}\n\nfunction snapCurrentPosition() {\n    if (utils_isScrollModeEnabled()) {\n        return;\n    }\n    var currentOffset = window.scrollX;\n    var currentOffsetSnapped = snapOffset(currentOffset + 1);\n\n    document.scrollingElement.scrollLeft = currentOffsetSnapped;\n}\n\n/// User Settings.\n\n// For setting user setting.\nfunction setProperty(key, value) {\n    var root = document.documentElement;\n\n    root.style.setProperty(key, value);\n}\n\n// For removing user setting.\nfunction removeProperty(key) {\n    var root = document.documentElement;\n\n    root.style.removeProperty(key);\n}\n\n\n/// Toolkit\n\nfunction debounce(delay, func) {\n    var timeout;\n    return function() {\n        var self = this;\n        var args = arguments;\n        function callback() {\n            func.apply(self, args);\n            timeout = null;\n        }\n        clearTimeout(timeout);\n        timeout = setTimeout(callback, delay);\n    };\n}\n\nfunction utils_log() {\n    var message = Array.prototype.slice.call(arguments).join(" ");\n    webkit.messageHandlers.log.postMessage(message);\n}\n\nfunction logException(e) {\n    webkit.messageHandlers.logError.postMessage({\n        "message": e.message\n    });\n}\n\n;// CONCATENATED MODULE: ./src/index.js\n//\n//  Copyright 2021 Readium Foundation. All rights reserved.\n//  Use of this source code is governed by the BSD-style license\n//  available in the top-level LICENSE file of the project.\n//\n\n// Base script used by both reflowable and fixed layout resources.\n\n\n\n\n\n\n\n\n// Public API used by the navigator.\nwindow.readium = {\n    // utils\n    \'scrollToId\': scrollToId,\n    \'scrollToPosition\': scrollToPosition,\n    \'scrollToText\': scrollToText,\n    \'scrollLeft\': scrollLeft,\n    \'scrollRight\': scrollRight,\n    \'setProperty\': setProperty,\n    \'removeProperty\': removeProperty,\n\n    // selection\n    \'getSelectionRect\': getSelectionRect,\n    \'getCurrentSelectionInfo\': getCurrentSelectionInfo,\n\n    // highlights\n    \'createHighlight\': createHighlight,\n    \'createHighlightRange\': createHighlightRange,\n\n    // Hypothesis\' anchoring\n    \'TextQuoteAnchor\': TextQuoteAnchor,\n};\n;// CONCATENATED MODULE: ./src/index-reflowable.js\n//\n//  Copyright 2021 Readium Foundation. All rights reserved.\n//  Use of this source code is governed by the BSD-style license\n//  available in the top-level LICENSE file of the project.\n//\n\n// Script used for reflowable resources.\n\n\n\nwindow.addEventListener("load", function() {\n  // Notifies native code that the page is loaded after it is rendered.\n  // Waiting for the next animation frame seems to do the trick to make sure the page is fully rendered.\n  window.requestAnimationFrame(function() {\n    webkit.messageHandlers.spreadLoaded.postMessage({});\n  });\n\n  // Setups the `viewport` meta tag to disable zooming.\n  let meta = document.createElement("meta");\n  meta.setAttribute("name", "viewport");\n  meta.setAttribute("content", "width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no");\n  document.head.appendChild(meta);\n});\n\n// Injects Readium CSS stylesheets.\ndocument.addEventListener(\'DOMContentLoaded\', function() {\n  function createLink(name) {\n    var link = document.createElement(\'link\');\n    link.setAttribute(\'rel\', \'stylesheet\');\n    link.setAttribute(\'type\', \'text/css\');\n    link.setAttribute(\'href\', window.readiumCSSBaseURL + name + \'.css\');\n    return link;\n  }\n\n  var head = document.getElementsByTagName(\'head\')[0];\n  head.appendChild(createLink(\'ReadiumCSS-after\'));\n  head.insertBefore(createLink(\'ReadiumCSS-before\'), head.children[0]);\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFkaXVtLWpzLy4vc3JjL3ZlbmRvci9oeXBvdGhlc2lzL2FuY2hvcmluZy9tYXRjaC1xdW90ZS5qcz9kZDZhIiwid2VicGFjazovL3JlYWRpdW0tanMvLi9zcmMvdmVuZG9yL2h5cG90aGVzaXMvYW5jaG9yaW5nL3RleHQtcmFuZ2UuanM/ZmRlZSIsIndlYnBhY2s6Ly9yZWFkaXVtLWpzLy4vc3JjL3ZlbmRvci9oeXBvdGhlc2lzL2FuY2hvcmluZy90eXBlcy5qcz80MDA0Iiwid2VicGFjazovL3JlYWRpdW0tanMvLi9zcmMvc2VsZWN0aW9uLmpzPzU5YWMiLCJ3ZWJwYWNrOi8vcmVhZGl1bS1qcy8uL3NyYy9yZWN0LmpzPzRkNWEiLCJ3ZWJwYWNrOi8vcmVhZGl1bS1qcy8uL3NyYy9oaWdobGlnaHQuanM/OGRhOCIsIndlYnBhY2s6Ly9yZWFkaXVtLWpzLy4vc3JjL3V0aWxzLmpzPzAyNWUiLCJ3ZWJwYWNrOi8vcmVhZGl1bS1qcy8uL3NyYy9pbmRleC5qcz9iNjM1Iiwid2VicGFjazovL3JlYWRpdW0tanMvLi9zcmMvaW5kZXgtcmVmbG93YWJsZS5qcz8zOTI1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUErQzs7QUFFL0M7QUFDQSxhQUFhLG9DQUFvQztBQUNqRDs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCLFVBQVUsT0FBTztBQUNqQixVQUFVLE9BQU87QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVMsdUJBQVk7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FB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QUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsUUFBUSxZQUFZO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FB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QUF3QixnQkFBZ0I7QUFDeEMsb0JBQW9CLFlBQVk7QUFDaEMsa0JBQWtCLFVBQVU7QUFDNUIsbUJBQW1CLFdBQVc7QUFDOUIsbUJBQW1CLFdBQVc7QUFDOUIsc0JBQXNCLGNBQWM7O0FBRXBDO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QywrQkFBK0IsdUJBQXVCOztBQUV0RDtBQUNBLHVCQUF1QixlQUFlO0FBQ3RDLDRCQUE0QixvQkFBb0I7O0FBRWhEO0FBQ0EsdUJBQXVCLGVBQWU7QUFDdEMsRTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3RELEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJmaWxlIjoiMzMyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGFwcHJveFNlYXJjaCBmcm9tICdhcHByb3gtc3RyaW5nLW1hdGNoJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdhcHByb3gtc3RyaW5nLW1hdGNoJykuTWF0Y2h9IFN0cmluZ01hdGNoXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiBNYXRjaFxuICogQHByb3Age251bWJlcn0gc3RhcnQgLSBTdGFydCBvZmZzZXQgb2YgbWF0Y2ggaW4gdGV4dFxuICogQHByb3Age251bWJlcn0gZW5kIC0gRW5kIG9mZnNldCBvZiBtYXRjaCBpbiB0ZXh0XG4gKiBAcHJvcCB7bnVtYmVyfSBzY29yZSAtXG4gKiAgIFNjb3JlIGZvciB0aGUgbWF0Y2ggYmV0d2VlbiAwIGFuZCAxLjAsIHdoZXJlIDEuMCBpbmRpY2F0ZXMgYSBwZXJmZWN0IG1hdGNoXG4gKiAgIGZvciB0aGUgcXVvdGUgYW5kIGNvbnRleHQuXG4gKi9cblxuLyoqXG4gKiBGaW5kIHRoZSBiZXN0IGFwcHJveGltYXRlIG1hdGNoZXMgZm9yIGBzdHJgIGluIGB0ZXh0YCBhbGxvd2luZyB1cCB0byBgbWF4RXJyb3JzYCBlcnJvcnMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhFcnJvcnNcbiAqIEByZXR1cm4ge1N0cmluZ01hdGNoW119XG4gKi9cbmZ1bmN0aW9uIHNlYXJjaCh0ZXh0LCBzdHIsIG1heEVycm9ycykge1xuICAvLyBEbyBhIGZhc3Qgc2VhcmNoIGZvciBleGFjdCBtYXRjaGVzLiBUaGUgYGFwcHJveC1zdHJpbmctbWF0Y2hgIGxpYnJhcnlcbiAgLy8gZG9lc24ndCBjdXJyZW50bHkgaW5jb3Jwb3JhdGUgdGhpcyBvcHRpbWl6YXRpb24gaXRzZWxmLlxuICBsZXQgbWF0Y2hQb3MgPSAwO1xuICBsZXQgZXhhY3RNYXRjaGVzID0gW107XG4gIHdoaWxlIChtYXRjaFBvcyAhPT0gLTEpIHtcbiAgICBtYXRjaFBvcyA9IHRleHQuaW5kZXhPZihzdHIsIG1hdGNoUG9zKTtcbiAgICBpZiAobWF0Y2hQb3MgIT09IC0xKSB7XG4gICAgICBleGFjdE1hdGNoZXMucHVzaCh7XG4gICAgICAgIHN0YXJ0OiBtYXRjaFBvcyxcbiAgICAgICAgZW5kOiBtYXRjaFBvcyArIHN0ci5sZW5ndGgsXG4gICAgICAgIGVycm9yczogMCxcbiAgICAgIH0pO1xuICAgICAgbWF0Y2hQb3MgKz0gMTtcbiAgICB9XG4gIH1cbiAgaWYgKGV4YWN0TWF0Y2hlcy5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIGV4YWN0TWF0Y2hlcztcbiAgfVxuXG4gIC8vIElmIHRoZXJlIGFyZSBubyBleGFjdCBtYXRjaGVzLCBkbyBhIG1vcmUgZXhwZW5zaXZlIHNlYXJjaCBmb3IgbWF0Y2hlc1xuICAvLyB3aXRoIGVycm9ycy5cbiAgcmV0dXJuIGFwcHJveFNlYXJjaCh0ZXh0LCBzdHIsIG1heEVycm9ycyk7XG59XG5cbi8qKlxuICogQ29tcHV0ZSBhIHNjb3JlIGJldHdlZW4gMCBhbmQgMS4wIGZvciB0aGUgc2ltaWxhcml0eSBiZXR3ZWVuIGB0ZXh0YCBhbmQgYHN0cmAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqL1xuZnVuY3Rpb24gdGV4dE1hdGNoU2NvcmUodGV4dCwgc3RyKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0IC0gYHNjb3JlTWF0Y2hgIHdpbGwgbmV2ZXIgcGFzcyBhbiBlbXB0eSBzdHJpbmcgKi9cbiAgaWYgKHN0ci5sZW5ndGggPT09IDAgfHwgdGV4dC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gMC4wO1xuICB9XG4gIGNvbnN0IG1hdGNoZXMgPSBzZWFyY2godGV4dCwgc3RyLCBzdHIubGVuZ3RoKTtcblxuICAvLyBwcmV0dGllci1pZ25vcmVcbiAgcmV0dXJuIDEgLSAobWF0Y2hlc1swXS5lcnJvcnMgLyBzdHIubGVuZ3RoKTtcbn1cblxuLyoqXG4gKiBGaW5kIHRoZSBiZXN0IGFwcHJveGltYXRlIG1hdGNoIGZvciBgcXVvdGVgIGluIGB0ZXh0YC5cbiAqXG4gKiBSZXR1cm5zIGBudWxsYCBpZiBubyBtYXRjaCBleGNlZWRpbmcgdGhlIG1pbmltdW0gcXVhbGl0eSB0aHJlc2hvbGQgd2FzIGZvdW5kLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gRG9jdW1lbnQgdGV4dCB0byBzZWFyY2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBxdW90ZSAtIFN0cmluZyB0byBmaW5kIHdpdGhpbiBgdGV4dGBcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0IC1cbiAqICAgQ29udGV4dCBpbiB3aGljaCB0aGUgcXVvdGUgb3JpZ2luYWxseSBhcHBlYXJlZC4gVGhpcyBpcyB1c2VkIHRvIGNob29zZSB0aGVcbiAqICAgYmVzdCBtYXRjaC5cbiAqICAgQHBhcmFtIHtzdHJpbmd9IFtjb250ZXh0LnByZWZpeF0gLSBFeHBlY3RlZCB0ZXh0IGJlZm9yZSB0aGUgcXVvdGVcbiAqICAgQHBhcmFtIHtzdHJpbmd9IFtjb250ZXh0LnN1ZmZpeF0gLSBFeHBlY3RlZCB0ZXh0IGFmdGVyIHRoZSBxdW90ZVxuICogICBAcGFyYW0ge251bWJlcn0gW2NvbnRleHQuaGludF0gLSBFeHBlY3RlZCBvZmZzZXQgb2YgbWF0Y2ggd2l0aGluIHRleHRcbiAqIEByZXR1cm4ge01hdGNofG51bGx9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXRjaFF1b3RlKHRleHQsIHF1b3RlLCBjb250ZXh0ID0ge30pIHtcbiAgaWYgKHF1b3RlLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gQ2hvb3NlIHRoZSBtYXhpbXVtIG51bWJlciBvZiBlcnJvcnMgdG8gYWxsb3cgZm9yIHRoZSBpbml0aWFsIHNlYXJjaC5cbiAgLy8gVGhpcyBjaG9pY2UgaW52b2x2ZXMgYSB0cmFkZW9mZiBiZXR3ZWVuOlxuICAvL1xuICAvLyAgLSBSZWNhbGwgKHByb3BvcnRpb24gb2YgXCJnb29kXCIgbWF0Y2hlcyBmb3VuZClcbiAgLy8gIC0gUHJlY2lzaW9uIChwcm9wb3J0aW9uIG9mIG1hdGNoZXMgZm91bmQgd2hpY2ggYXJlIFwiZ29vZFwiKVxuICAvLyAgLSBDb3N0IG9mIHRoZSBpbml0aWFsIHNlYXJjaCBhbmQgb2YgcHJvY2Vzc2luZyB0aGUgY2FuZGlkYXRlIG1hdGNoZXMgWzFdXG4gIC8vXG4gIC8vIFsxXSBTcGVjaWZpY2FsbHksIHRoZSBleHBlY3RlZC10aW1lIGNvbXBsZXhpdHkgb2YgdGhlIGluaXRpYWwgc2VhcmNoIGlzXG4gIC8vICAgICBgTygobWF4RXJyb3JzIC8gMzIpICogdGV4dC5sZW5ndGgpYC4gU2VlIGBhcHByb3gtc3RyaW5nLW1hdGNoYCBkb2NzLlxuICBjb25zdCBtYXhFcnJvcnMgPSBNYXRoLm1pbigyNTYsIHF1b3RlLmxlbmd0aCAvIDIpO1xuXG4gIC8vIEZpbmQgY2xvc2VzdCBtYXRjaGVzIGZvciBgcXVvdGVgIGluIGB0ZXh0YCBiYXNlZCBvbiBlZGl0IGRpc3RhbmNlLlxuICBjb25zdCBtYXRjaGVzID0gc2VhcmNoKHRleHQsIHF1b3RlLCBtYXhFcnJvcnMpO1xuXG4gIGlmIChtYXRjaGVzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXB1dGUgYSBzY29yZSBiZXR3ZWVuIDAgYW5kIDEuMCBmb3IgYSBtYXRjaCBjYW5kaWRhdGUuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nTWF0Y2h9IG1hdGNoXG4gICAqL1xuICBjb25zdCBzY29yZU1hdGNoID0gbWF0Y2ggPT4ge1xuICAgIGNvbnN0IHF1b3RlV2VpZ2h0ID0gNTA7IC8vIFNpbWlsYXJpdHkgb2YgbWF0Y2hlZCB0ZXh0IHRvIHF1b3RlLlxuICAgIGNvbnN0IHByZWZpeFdlaWdodCA9IDIwOyAvLyBTaW1pbGFyaXR5IG9mIHRleHQgYmVmb3JlIG1hdGNoZWQgdGV4dCB0byBgY29udGV4dC5wcmVmaXhgLlxuICAgIGNvbnN0IHN1ZmZpeFdlaWdodCA9IDIwOyAvLyBTaW1pbGFyaXR5IG9mIHRleHQgYWZ0ZXIgbWF0Y2hlZCB0ZXh0IHRvIGBjb250ZXh0LnN1ZmZpeGAuXG4gICAgY29uc3QgcG9zV2VpZ2h0ID0gMjsgLy8gUHJveGltaXR5IHRvIGV4cGVjdGVkIGxvY2F0aW9uLiBVc2VkIGFzIGEgdGllLWJyZWFrZXIuXG5cbiAgICBjb25zdCBxdW90ZVNjb3JlID0gMSAtIG1hdGNoLmVycm9ycyAvIHF1b3RlLmxlbmd0aDtcblxuICAgIGNvbnN0IHByZWZpeFNjb3JlID0gY29udGV4dC5wcmVmaXhcbiAgICAgID8gdGV4dE1hdGNoU2NvcmUoXG4gICAgICAgICAgdGV4dC5zbGljZShNYXRoLm1heCgwLCBtYXRjaC5zdGFydCAtIGNvbnRleHQucHJlZml4Lmxlbmd0aCksIG1hdGNoLnN0YXJ0KSxcbiAgICAgICAgICBjb250ZXh0LnByZWZpeFxuICAgICAgICApXG4gICAgICA6IDEuMDtcbiAgICBjb25zdCBzdWZmaXhTY29yZSA9IGNvbnRleHQuc3VmZml4XG4gICAgICA/IHRleHRNYXRjaFNjb3JlKFxuICAgICAgICAgIHRleHQuc2xpY2UobWF0Y2guZW5kLCBtYXRjaC5lbmQgKyBjb250ZXh0LnN1ZmZpeC5sZW5ndGgpLFxuICAgICAgICAgIGNvbnRleHQuc3VmZml4XG4gICAgICAgIClcbiAgICAgIDogMS4wO1xuXG4gICAgbGV0IHBvc1Njb3JlID0gMS4wO1xuICAgIGlmICh0eXBlb2YgY29udGV4dC5oaW50ID09PSAnbnVtYmVyJykge1xuICAgICAgY29uc3Qgb2Zmc2V0ID0gTWF0aC5hYnMobWF0Y2guc3RhcnQgLSBjb250ZXh0LmhpbnQpO1xuICAgICAgcG9zU2NvcmUgPSAxLjAgLSBvZmZzZXQgLyB0ZXh0Lmxlbmd0aDtcbiAgICB9XG5cbiAgICBjb25zdCByYXdTY29yZSA9XG4gICAgICBxdW90ZVdlaWdodCAqIHF1b3RlU2NvcmUgK1xuICAgICAgcHJlZml4V2VpZ2h0ICogcHJlZml4U2NvcmUgK1xuICAgICAgc3VmZml4V2VpZ2h0ICogc3VmZml4U2NvcmUgK1xuICAgICAgcG9zV2VpZ2h0ICogcG9zU2NvcmU7XG4gICAgY29uc3QgbWF4U2NvcmUgPSBxdW90ZVdlaWdodCArIHByZWZpeFdlaWdodCArIHN1ZmZpeFdlaWdodCArIHBvc1dlaWdodDtcbiAgICBjb25zdCBub3JtYWxpemVkU2NvcmUgPSByYXdTY29yZSAvIG1heFNjb3JlO1xuXG4gICAgcmV0dXJuIG5vcm1hbGl6ZWRTY29yZTtcbiAgfTtcblxuICAvLyBSYW5rIG1hdGNoZXMgYmFzZWQgb24gc2ltaWxhcml0eSBvZiBhY3R1YWwgYW5kIGV4cGVjdGVkIHN1cnJvdW5kaW5nIHRleHRcbiAgLy8gYW5kIGFjdHVhbC9leHBlY3RlZCBvZmZzZXQgaW4gdGhlIGRvY3VtZW50IHRleHQuXG4gIGNvbnN0IHNjb3JlZE1hdGNoZXMgPSBtYXRjaGVzLm1hcChtID0+ICh7XG4gICAgc3RhcnQ6IG0uc3RhcnQsXG4gICAgZW5kOiBtLmVuZCxcbiAgICBzY29yZTogc2NvcmVNYXRjaChtKSxcbiAgfSkpO1xuXG4gIC8vIENob29zZSBtYXRjaCB3aXRoIGhpZ2hlc3Qgc2NvcmUuXG4gIHNjb3JlZE1hdGNoZXMuc29ydCgoYSwgYikgPT4gYi5zY29yZSAtIGEuc2NvcmUpO1xuICByZXR1cm4gc2NvcmVkTWF0Y2hlc1swXTtcbn1cbiIsIi8qKlxuICogUmV0dXJuIHRoZSBjb21iaW5lZCBsZW5ndGggb2YgdGV4dCBub2RlcyBjb250YWluZWQgaW4gYG5vZGVgLlxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICovXG5mdW5jdGlvbiBub2RlVGV4dExlbmd0aChub2RlKSB7XG4gIHN3aXRjaCAobm9kZS5ub2RlVHlwZSkge1xuICAgIGNhc2UgTm9kZS5FTEVNRU5UX05PREU6XG4gICAgY2FzZSBOb2RlLlRFWFRfTk9ERTpcbiAgICAgIC8vIG5iLiBgdGV4dENvbnRlbnRgIGV4Y2x1ZGVzIHRleHQgaW4gY29tbWVudHMgYW5kIHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb25zXG4gICAgICAvLyB3aGVuIGNhbGxlZCBvbiBhIHBhcmVudCBlbGVtZW50LCBzbyB3ZSBkb24ndCBuZWVkIHRvIHN1YnRyYWN0IHRoYXQgaGVyZS5cblxuICAgICAgcmV0dXJuIC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAobm9kZS50ZXh0Q29udGVudCkubGVuZ3RoO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gMDtcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybiB0aGUgdG90YWwgbGVuZ3RoIG9mIHRoZSB0ZXh0IG9mIGFsbCBwcmV2aW91cyBzaWJsaW5ncyBvZiBgbm9kZWAuXG4gKlxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKi9cbmZ1bmN0aW9uIHByZXZpb3VzU2libGluZ3NUZXh0TGVuZ3RoKG5vZGUpIHtcbiAgbGV0IHNpYmxpbmcgPSBub2RlLnByZXZpb3VzU2libGluZztcbiAgbGV0IGxlbmd0aCA9IDA7XG4gIHdoaWxlIChzaWJsaW5nKSB7XG4gICAgbGVuZ3RoICs9IG5vZGVUZXh0TGVuZ3RoKHNpYmxpbmcpO1xuICAgIHNpYmxpbmcgPSBzaWJsaW5nLnByZXZpb3VzU2libGluZztcbiAgfVxuICByZXR1cm4gbGVuZ3RoO1xufVxuXG4vKipcbiAqIFJlc29sdmUgb25lIG9yIG1vcmUgY2hhcmFjdGVyIG9mZnNldHMgd2l0aGluIGFuIGVsZW1lbnQgdG8gKHRleHQgbm9kZSwgcG9zaXRpb24pXG4gKiBwYWlycy5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7bnVtYmVyW119IG9mZnNldHMgLSBPZmZzZXRzLCB3aGljaCBtdXN0IGJlIHNvcnRlZCBpbiBhc2NlbmRpbmcgb3JkZXJcbiAqIEByZXR1cm4ge3sgbm9kZTogVGV4dCwgb2Zmc2V0OiBudW1iZXIgfVtdfVxuICovXG5mdW5jdGlvbiByZXNvbHZlT2Zmc2V0cyhlbGVtZW50LCAuLi5vZmZzZXRzKSB7XG4gIGxldCBuZXh0T2Zmc2V0ID0gb2Zmc2V0cy5zaGlmdCgpO1xuICBjb25zdCBub2RlSXRlciA9IC8qKiBAdHlwZSB7RG9jdW1lbnR9ICovIChcbiAgICBlbGVtZW50Lm93bmVyRG9jdW1lbnRcbiAgKS5jcmVhdGVOb2RlSXRlcmF0b3IoZWxlbWVudCwgTm9kZUZpbHRlci5TSE9XX1RFWFQpO1xuICBjb25zdCByZXN1bHRzID0gW107XG5cbiAgbGV0IGN1cnJlbnROb2RlID0gbm9kZUl0ZXIubmV4dE5vZGUoKTtcbiAgbGV0IHRleHROb2RlO1xuICBsZXQgbGVuZ3RoID0gMDtcblxuICAvLyBGaW5kIHRoZSB0ZXh0IG5vZGUgY29udGFpbmluZyB0aGUgYG5leHRPZmZzZXRgdGggY2hhcmFjdGVyIGZyb20gdGhlIHN0YXJ0XG4gIC8vIG9mIGBlbGVtZW50YC5cbiAgd2hpbGUgKG5leHRPZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBjdXJyZW50Tm9kZSkge1xuICAgIHRleHROb2RlID0gLyoqIEB0eXBlIHtUZXh0fSAqLyAoY3VycmVudE5vZGUpO1xuICAgIGlmIChsZW5ndGggKyB0ZXh0Tm9kZS5kYXRhLmxlbmd0aCA+IG5leHRPZmZzZXQpIHtcbiAgICAgIHJlc3VsdHMucHVzaCh7IG5vZGU6IHRleHROb2RlLCBvZmZzZXQ6IG5leHRPZmZzZXQgLSBsZW5ndGggfSk7XG4gICAgICBuZXh0T2Zmc2V0ID0gb2Zmc2V0cy5zaGlmdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50Tm9kZSA9IG5vZGVJdGVyLm5leHROb2RlKCk7XG4gICAgICBsZW5ndGggKz0gdGV4dE5vZGUuZGF0YS5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgLy8gQm91bmRhcnkgY2FzZS5cbiAgd2hpbGUgKG5leHRPZmZzZXQgIT09IHVuZGVmaW5lZCAmJiB0ZXh0Tm9kZSAmJiBsZW5ndGggPT09IG5leHRPZmZzZXQpIHtcbiAgICByZXN1bHRzLnB1c2goeyBub2RlOiB0ZXh0Tm9kZSwgb2Zmc2V0OiB0ZXh0Tm9kZS5kYXRhLmxlbmd0aCB9KTtcbiAgICBuZXh0T2Zmc2V0ID0gb2Zmc2V0cy5zaGlmdCgpO1xuICB9XG5cbiAgaWYgKG5leHRPZmZzZXQgIT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPZmZzZXQgZXhjZWVkcyB0ZXh0IGxlbmd0aCcpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdHM7XG59XG5cbmV4cG9ydCBsZXQgUkVTT0xWRV9GT1JXQVJEUyA9IDE7XG5leHBvcnQgbGV0IFJFU09MVkVfQkFDS1dBUkRTID0gMjtcblxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIG9mZnNldCB3aXRoaW4gdGhlIHRleHQgY29udGVudCBvZiBhbiBlbGVtZW50LlxuICpcbiAqIFRoaXMgcG9zaXRpb24gY2FuIGJlIHJlc29sdmVkIHRvIGEgc3BlY2lmaWMgZGVzY2VuZGFudCBub2RlIGluIHRoZSBjdXJyZW50XG4gKiBET00gc3VidHJlZSBvZiB0aGUgZWxlbWVudCB1c2luZyB0aGUgYHJlc29sdmVgIG1ldGhvZC5cbiAqL1xuZXhwb3J0IGNsYXNzIFRleHRQb3NpdGlvbiB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBgVGV4dFBvc2l0aW9uYCB0aGF0IHJlZmVycyB0byB0aGUgdGV4dCBwb3NpdGlvbiBgb2Zmc2V0YCB3aXRoaW5cbiAgICogdGhlIHRleHQgY29udGVudCBvZiBgZWxlbWVudGAuXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqL1xuICBjb25zdHJ1Y3RvcihlbGVtZW50LCBvZmZzZXQpIHtcbiAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdPZmZzZXQgaXMgaW52YWxpZCcpO1xuICAgIH1cblxuICAgIC8qKiBFbGVtZW50IHRoYXQgYG9mZnNldGAgaXMgcmVsYXRpdmUgdG8uICovXG4gICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcblxuICAgIC8qKiBDaGFyYWN0ZXIgb2Zmc2V0IGZyb20gdGhlIHN0YXJ0IG9mIHRoZSBlbGVtZW50J3MgYHRleHRDb250ZW50YC4gKi9cbiAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBjb3B5IG9mIHRoaXMgcG9zaXRpb24gd2l0aCBvZmZzZXQgcmVsYXRpdmUgdG8gYSBnaXZlbiBhbmNlc3RvclxuICAgKiBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IHBhcmVudCAtIEFuY2VzdG9yIG9mIGB0aGlzLmVsZW1lbnRgXG4gICAqIEByZXR1cm4ge1RleHRQb3NpdGlvbn1cbiAgICovXG4gIHJlbGF0aXZlVG8ocGFyZW50KSB7XG4gICAgaWYgKCFwYXJlbnQuY29udGFpbnModGhpcy5lbGVtZW50KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXJlbnQgaXMgbm90IGFuIGFuY2VzdG9yIG9mIGN1cnJlbnQgZWxlbWVudCcpO1xuICAgIH1cblxuICAgIGxldCBlbCA9IHRoaXMuZWxlbWVudDtcbiAgICBsZXQgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgd2hpbGUgKGVsICE9PSBwYXJlbnQpIHtcbiAgICAgIG9mZnNldCArPSBwcmV2aW91c1NpYmxpbmdzVGV4dExlbmd0aChlbCk7XG4gICAgICBlbCA9IC8qKiBAdHlwZSB7RWxlbWVudH0gKi8gKGVsLnBhcmVudEVsZW1lbnQpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgVGV4dFBvc2l0aW9uKGVsLCBvZmZzZXQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc29sdmUgdGhlIHBvc2l0aW9uIHRvIGEgc3BlY2lmaWMgdGV4dCBub2RlIGFuZCBvZmZzZXQgd2l0aGluIHRoYXQgbm9kZS5cbiAgICpcbiAgICogVGhyb3dzIGlmIGB0aGlzLm9mZnNldGAgZXhjZWVkcyB0aGUgbGVuZ3RoIG9mIHRoZSBlbGVtZW50J3MgdGV4dC4gSW4gdGhlXG4gICAqIGNhc2Ugd2hlcmUgdGhlIGVsZW1lbnQgaGFzIG5vIHRleHQgYW5kIGB0aGlzLm9mZnNldGAgaXMgMCwgdGhlIGBkaXJlY3Rpb25gXG4gICAqIG9wdGlvbiBkZXRlcm1pbmVzIHdoYXQgaGFwcGVucy5cbiAgICpcbiAgICogT2Zmc2V0cyBhdCB0aGUgYm91bmRhcnkgYmV0d2VlbiB0d28gbm9kZXMgYXJlIHJlc29sdmVkIHRvIHRoZSBzdGFydCBvZiB0aGVcbiAgICogbm9kZSB0aGF0IGJlZ2lucyBhdCB0aGUgYm91bmRhcnkuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICBAcGFyYW0ge1JFU09MVkVfRk9SV0FSRFN8UkVTT0xWRV9CQUNLV0FSRFN9IFtvcHRpb25zLmRpcmVjdGlvbl0gLVxuICAgKiAgICAgU3BlY2lmaWVzIGluIHdoaWNoIGRpcmVjdGlvbiB0byBzZWFyY2ggZm9yIHRoZSBuZWFyZXN0IHRleHQgbm9kZSBpZlxuICAgKiAgICAgYHRoaXMub2Zmc2V0YCBpcyBgMGAgYW5kIGB0aGlzLmVsZW1lbnRgIGhhcyBubyB0ZXh0LiBJZiBub3Qgc3BlY2lmaWVkXG4gICAqICAgICBhbiBlcnJvciBpcyB0aHJvd24uXG4gICAqIEByZXR1cm4ge3sgbm9kZTogVGV4dCwgb2Zmc2V0OiBudW1iZXIgfX1cbiAgICogQHRocm93cyB7UmFuZ2VFcnJvcn1cbiAgICovXG4gIHJlc29sdmUob3B0aW9ucyA9IHt9KSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiByZXNvbHZlT2Zmc2V0cyh0aGlzLmVsZW1lbnQsIHRoaXMub2Zmc2V0KVswXTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmICh0aGlzLm9mZnNldCA9PT0gMCAmJiBvcHRpb25zLmRpcmVjdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IHR3ID0gZG9jdW1lbnQuY3JlYXRlVHJlZVdhbGtlcihcbiAgICAgICAgICB0aGlzLmVsZW1lbnQuZ2V0Um9vdE5vZGUoKSxcbiAgICAgICAgICBOb2RlRmlsdGVyLlNIT1dfVEVYVFxuICAgICAgICApO1xuICAgICAgICB0dy5jdXJyZW50Tm9kZSA9IHRoaXMuZWxlbWVudDtcbiAgICAgICAgY29uc3QgZm9yd2FyZHMgPSBvcHRpb25zLmRpcmVjdGlvbiA9PT0gUkVTT0xWRV9GT1JXQVJEUztcbiAgICAgICAgY29uc3QgdGV4dCA9IC8qKiBAdHlwZSB7VGV4dHxudWxsfSAqLyAoXG4gICAgICAgICAgZm9yd2FyZHMgPyB0dy5uZXh0Tm9kZSgpIDogdHcucHJldmlvdXNOb2RlKClcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKCF0ZXh0KSB7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IG5vZGU6IHRleHQsIG9mZnNldDogZm9yd2FyZHMgPyAwIDogdGV4dC5kYXRhLmxlbmd0aCB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBgVGV4dFBvc2l0aW9uYCB0aGF0IHJlZmVycyB0byB0aGUgYG9mZnNldGB0aCBjaGFyYWN0ZXIgd2l0aGluXG4gICAqIGBub2RlYC5cbiAgICpcbiAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICogQHJldHVybiB7VGV4dFBvc2l0aW9ufVxuICAgKi9cbiAgc3RhdGljIGZyb21DaGFyT2Zmc2V0KG5vZGUsIG9mZnNldCkge1xuICAgIHN3aXRjaCAobm9kZS5ub2RlVHlwZSkge1xuICAgICAgY2FzZSBOb2RlLlRFWFRfTk9ERTpcbiAgICAgICAgcmV0dXJuIFRleHRQb3NpdGlvbi5mcm9tUG9pbnQobm9kZSwgb2Zmc2V0KTtcbiAgICAgIGNhc2UgTm9kZS5FTEVNRU5UX05PREU6XG4gICAgICAgIHJldHVybiBuZXcgVGV4dFBvc2l0aW9uKC8qKiBAdHlwZSB7RWxlbWVudH0gKi8gKG5vZGUpLCBvZmZzZXQpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb2RlIGlzIG5vdCBhbiBlbGVtZW50IG9yIHRleHQgbm9kZScpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBgVGV4dFBvc2l0aW9uYCByZXByZXNlbnRpbmcgdGhlIHJhbmdlIHN0YXJ0IG9yIGVuZCBwb2ludCAobm9kZSwgb2Zmc2V0KS5cbiAgICpcbiAgICogQHBhcmFtIHtOb2RlfSBub2RlIC0gVGV4dCBvciBFbGVtZW50IG5vZGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCAtIE9mZnNldCB3aXRoaW4gdGhlIG5vZGUuXG4gICAqIEByZXR1cm4ge1RleHRQb3NpdGlvbn1cbiAgICovXG4gIHN0YXRpYyBmcm9tUG9pbnQobm9kZSwgb2Zmc2V0KSB7XG4gICAgc3dpdGNoIChub2RlLm5vZGVUeXBlKSB7XG4gICAgICBjYXNlIE5vZGUuVEVYVF9OT0RFOiB7XG4gICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCA+IC8qKiBAdHlwZSB7VGV4dH0gKi8gKG5vZGUpLmRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUZXh0IG5vZGUgb2Zmc2V0IGlzIG91dCBvZiByYW5nZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFub2RlLnBhcmVudEVsZW1lbnQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RleHQgbm9kZSBoYXMgbm8gcGFyZW50Jyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHZXQgdGhlIG9mZnNldCBmcm9tIHRoZSBzdGFydCBvZiB0aGUgcGFyZW50IGVsZW1lbnQuXG4gICAgICAgIGNvbnN0IHRleHRPZmZzZXQgPSBwcmV2aW91c1NpYmxpbmdzVGV4dExlbmd0aChub2RlKSArIG9mZnNldDtcblxuICAgICAgICByZXR1cm4gbmV3IFRleHRQb3NpdGlvbihub2RlLnBhcmVudEVsZW1lbnQsIHRleHRPZmZzZXQpO1xuICAgICAgfVxuICAgICAgY2FzZSBOb2RlLkVMRU1FTlRfTk9ERToge1xuICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgPiBub2RlLmNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDaGlsZCBub2RlIG9mZnNldCBpcyBvdXQgb2YgcmFuZ2UnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdldCB0aGUgdGV4dCBsZW5ndGggYmVmb3JlIHRoZSBgb2Zmc2V0YHRoIGNoaWxkIG9mIGVsZW1lbnQuXG4gICAgICAgIGxldCB0ZXh0T2Zmc2V0ID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvZmZzZXQ7IGkrKykge1xuICAgICAgICAgIHRleHRPZmZzZXQgKz0gbm9kZVRleHRMZW5ndGgobm9kZS5jaGlsZE5vZGVzW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgVGV4dFBvc2l0aW9uKC8qKiBAdHlwZSB7RWxlbWVudH0gKi8gKG5vZGUpLCB0ZXh0T2Zmc2V0KTtcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUG9pbnQgaXMgbm90IGluIGFuIGVsZW1lbnQgb3IgdGV4dCBub2RlJyk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIHJlZ2lvbiBvZiBhIGRvY3VtZW50IGFzIGEgKHN0YXJ0LCBlbmQpIHBhaXIgb2YgYFRleHRQb3NpdGlvbmAgcG9pbnRzLlxuICpcbiAqIFJlcHJlc2VudGluZyBhIHJhbmdlIGluIHRoaXMgd2F5IGFsbG93cyBmb3IgY2hhbmdlcyBpbiB0aGUgRE9NIGNvbnRlbnQgb2YgdGhlXG4gKiByYW5nZSB3aGljaCBkb24ndCBhZmZlY3QgaXRzIHRleHQgY29udGVudCwgd2l0aG91dCBhZmZlY3RpbmcgdGhlIHRleHQgY29udGVudFxuICogb2YgdGhlIHJhbmdlIGl0c2VsZi5cbiAqL1xuZXhwb3J0IGNsYXNzIFRleHRSYW5nZSB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYW4gaW1tdXRhYmxlIGBUZXh0UmFuZ2VgIGZyb20gYSBgc3RhcnRgIGFuZCBgZW5kYCBwb2ludC5cbiAgICpcbiAgICogQHBhcmFtIHtUZXh0UG9zaXRpb259IHN0YXJ0XG4gICAqIEBwYXJhbSB7VGV4dFBvc2l0aW9ufSBlbmRcbiAgICovXG4gIGNvbnN0cnVjdG9yKHN0YXJ0LCBlbmQpIHtcbiAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgdGhpcy5lbmQgPSBlbmQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGEgY29weSBvZiB0aGlzIHJhbmdlIHdpdGggc3RhcnQgYW5kIGVuZCBwb3NpdGlvbnMgcmVsYXRpdmUgdG8gYVxuICAgKiBnaXZlbiBhbmNlc3Rvci4gU2VlIGBUZXh0UG9zaXRpb24ucmVsYXRpdmVUb2AuXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICAgKi9cbiAgcmVsYXRpdmVUbyhlbGVtZW50KSB7XG4gICAgcmV0dXJuIG5ldyBUZXh0UmFuZ2UoXG4gICAgICB0aGlzLnN0YXJ0LnJlbGF0aXZlVG8oZWxlbWVudCksXG4gICAgICB0aGlzLmVuZC5yZWxhdGl2ZVRvKGVsZW1lbnQpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNvbHZlIHRoZSBgVGV4dFJhbmdlYCB0byBhIERPTSByYW5nZS5cbiAgICpcbiAgICogVGhlIHJlc3VsdGluZyBET00gUmFuZ2Ugd2lsbCBhbHdheXMgc3RhcnQgYW5kIGVuZCBpbiBhIGBUZXh0YCBub2RlLlxuICAgKiBIZW5jZSBgVGV4dFJhbmdlLmZyb21SYW5nZShyYW5nZSkudG9SYW5nZSgpYCBjYW4gYmUgdXNlZCB0byBcInNocmlua1wiIGFcbiAgICogcmFuZ2UgdG8gdGhlIHRleHQgaXQgY29udGFpbnMuXG4gICAqXG4gICAqIE1heSB0aHJvdyBpZiB0aGUgYHN0YXJ0YCBvciBgZW5kYCBwb3NpdGlvbnMgY2Fubm90IGJlIHJlc29sdmVkIHRvIGEgcmFuZ2UuXG4gICAqXG4gICAqIEByZXR1cm4ge1JhbmdlfVxuICAgKi9cbiAgdG9SYW5nZSgpIHtcbiAgICBsZXQgc3RhcnQ7XG4gICAgbGV0IGVuZDtcblxuICAgIGlmIChcbiAgICAgIHRoaXMuc3RhcnQuZWxlbWVudCA9PT0gdGhpcy5lbmQuZWxlbWVudCAmJlxuICAgICAgdGhpcy5zdGFydC5vZmZzZXQgPD0gdGhpcy5lbmQub2Zmc2V0XG4gICAgKSB7XG4gICAgICAvLyBGYXN0IHBhdGggZm9yIHN0YXJ0IGFuZCBlbmQgcG9pbnRzIGluIHNhbWUgZWxlbWVudC5cbiAgICAgIFtzdGFydCwgZW5kXSA9IHJlc29sdmVPZmZzZXRzKFxuICAgICAgICB0aGlzLnN0YXJ0LmVsZW1lbnQsXG4gICAgICAgIHRoaXMuc3RhcnQub2Zmc2V0LFxuICAgICAgICB0aGlzLmVuZC5vZmZzZXRcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0ID0gdGhpcy5zdGFydC5yZXNvbHZlKHsgZGlyZWN0aW9uOiBSRVNPTFZFX0ZPUldBUkRTIH0pO1xuICAgICAgZW5kID0gdGhpcy5lbmQucmVzb2x2ZSh7IGRpcmVjdGlvbjogUkVTT0xWRV9CQUNLV0FSRFMgfSk7XG4gICAgfVxuXG4gICAgY29uc3QgcmFuZ2UgPSBuZXcgUmFuZ2UoKTtcbiAgICByYW5nZS5zZXRTdGFydChzdGFydC5ub2RlLCBzdGFydC5vZmZzZXQpO1xuICAgIHJhbmdlLnNldEVuZChlbmQubm9kZSwgZW5kLm9mZnNldCk7XG4gICAgcmV0dXJuIHJhbmdlO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYW4gZXhpc3RpbmcgRE9NIGBSYW5nZWAgdG8gYSBgVGV4dFJhbmdlYFxuICAgKlxuICAgKiBAcGFyYW0ge1JhbmdlfSByYW5nZVxuICAgKiBAcmV0dXJuIHtUZXh0UmFuZ2V9XG4gICAqL1xuICBzdGF0aWMgZnJvbVJhbmdlKHJhbmdlKSB7XG4gICAgY29uc3Qgc3RhcnQgPSBUZXh0UG9zaXRpb24uZnJvbVBvaW50KFxuICAgICAgcmFuZ2Uuc3RhcnRDb250YWluZXIsXG4gICAgICByYW5nZS5zdGFydE9mZnNldFxuICAgICk7XG4gICAgY29uc3QgZW5kID0gVGV4dFBvc2l0aW9uLmZyb21Qb2ludChyYW5nZS5lbmRDb250YWluZXIsIHJhbmdlLmVuZE9mZnNldCk7XG4gICAgcmV0dXJuIG5ldyBUZXh0UmFuZ2Uoc3RhcnQsIGVuZCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGEgYFRleHRSYW5nZWAgZnJvbSB0aGUgYHN0YXJ0YHRoIHRvIGBlbmRgdGggY2hhcmFjdGVycyBpbiBgcm9vdGAuXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gcm9vdFxuICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRcbiAgICogQHBhcmFtIHtudW1iZXJ9IGVuZFxuICAgKi9cbiAgc3RhdGljIGZyb21PZmZzZXRzKHJvb3QsIHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gbmV3IFRleHRSYW5nZShcbiAgICAgIG5ldyBUZXh0UG9zaXRpb24ocm9vdCwgc3RhcnQpLFxuICAgICAgbmV3IFRleHRQb3NpdGlvbihyb290LCBlbmQpXG4gICAgKTtcbiAgfVxufVxuIiwiLyoqXG4gKiBUaGlzIG1vZHVsZSBleHBvcnRzIGEgc2V0IG9mIGNsYXNzZXMgZm9yIGNvbnZlcnRpbmcgYmV0d2VlbiBET00gYFJhbmdlYFxuICogb2JqZWN0cyBhbmQgZGlmZmVyZW50IHR5cGVzIG9mIHNlbGVjdG9ycy4gSXQgaXMgbW9zdGx5IGEgdGhpbiB3cmFwcGVyIGFyb3VuZCBhXG4gKiBzZXQgb2YgYW5jaG9yaW5nIGxpYnJhcmllcy4gSXQgc2VydmVzIHR3byBtYWluIHB1cnBvc2VzOlxuICpcbiAqICAxLiBQcm92aWRpbmcgYSBjb25zaXN0ZW50IGludGVyZmFjZSBhY3Jvc3MgZGlmZmVyZW50IHR5cGVzIG9mIGFuY2hvcnMuXG4gKiAgMi4gSW5zdWxhdGluZyB0aGUgcmVzdCBvZiB0aGUgY29kZSBmcm9tIEFQSSBjaGFuZ2VzIGluIHRoZSB1bmRlcmx5aW5nIGFuY2hvcmluZ1xuICogICAgIGxpYnJhcmllcy5cbiAqL1xuXG5pbXBvcnQgeyBtYXRjaFF1b3RlIH0gZnJvbSAnLi9tYXRjaC1xdW90ZSc7XG5pbXBvcnQgeyBUZXh0UmFuZ2UsIFRleHRQb3NpdGlvbiB9IGZyb20gJy4vdGV4dC1yYW5nZSc7XG5pbXBvcnQgeyBub2RlRnJvbVhQYXRoLCB4cGF0aEZyb21Ob2RlIH0gZnJvbSAnLi94cGF0aCc7XG5cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnLi4vLi4vdHlwZXMvYXBpJykuUmFuZ2VTZWxlY3Rvcn0gUmFuZ2VTZWxlY3RvclxuICogQHR5cGVkZWYge2ltcG9ydCgnLi4vLi4vdHlwZXMvYXBpJykuVGV4dFBvc2l0aW9uU2VsZWN0b3J9IFRleHRQb3NpdGlvblNlbGVjdG9yXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi8uLi90eXBlcy9hcGknKS5UZXh0UXVvdGVTZWxlY3Rvcn0gVGV4dFF1b3RlU2VsZWN0b3JcbiAqL1xuXG4vKipcbiAqIENvbnZlcnRzIGJldHdlZW4gYFJhbmdlU2VsZWN0b3JgIHNlbGVjdG9ycyBhbmQgYFJhbmdlYCBvYmplY3RzLlxuICovXG5leHBvcnQgY2xhc3MgUmFuZ2VBbmNob3Ige1xuICAvKipcbiAgICogQHBhcmFtIHtOb2RlfSByb290IC0gQSByb290IGVsZW1lbnQgZnJvbSB3aGljaCB0byBhbmNob3IuXG4gICAqIEBwYXJhbSB7UmFuZ2V9IHJhbmdlIC0gIEEgcmFuZ2UgZGVzY3JpYmluZyB0aGUgYW5jaG9yLlxuICAgKi9cbiAgY29uc3RydWN0b3Iocm9vdCwgcmFuZ2UpIHtcbiAgICB0aGlzLnJvb3QgPSByb290O1xuICAgIHRoaXMucmFuZ2UgPSByYW5nZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge05vZGV9IHJvb3QgLSAgQSByb290IGVsZW1lbnQgZnJvbSB3aGljaCB0byBhbmNob3IuXG4gICAqIEBwYXJhbSB7UmFuZ2V9IHJhbmdlIC0gIEEgcmFuZ2UgZGVzY3JpYmluZyB0aGUgYW5jaG9yLlxuICAgKi9cbiAgc3RhdGljIGZyb21SYW5nZShyb290LCByYW5nZSkge1xuICAgIHJldHVybiBuZXcgUmFuZ2VBbmNob3Iocm9vdCwgcmFuZ2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBhbmNob3IgZnJvbSBhIHNlcmlhbGl6ZWQgYFJhbmdlU2VsZWN0b3JgIHNlbGVjdG9yLlxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IHJvb3QgLSAgQSByb290IGVsZW1lbnQgZnJvbSB3aGljaCB0byBhbmNob3IuXG4gICAqIEBwYXJhbSB7UmFuZ2VTZWxlY3Rvcn0gc2VsZWN0b3JcbiAgICovXG4gIHN0YXRpYyBmcm9tU2VsZWN0b3Iocm9vdCwgc2VsZWN0b3IpIHtcbiAgICBjb25zdCBzdGFydENvbnRhaW5lciA9IG5vZGVGcm9tWFBhdGgoc2VsZWN0b3Iuc3RhcnRDb250YWluZXIsIHJvb3QpO1xuICAgIGlmICghc3RhcnRDb250YWluZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHJlc29sdmUgc3RhcnRDb250YWluZXIgWFBhdGgnKTtcbiAgICB9XG5cbiAgICBjb25zdCBlbmRDb250YWluZXIgPSBub2RlRnJvbVhQYXRoKHNlbGVjdG9yLmVuZENvbnRhaW5lciwgcm9vdCk7XG4gICAgaWYgKCFlbmRDb250YWluZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHJlc29sdmUgZW5kQ29udGFpbmVyIFhQYXRoJyk7XG4gICAgfVxuXG4gICAgY29uc3Qgc3RhcnRQb3MgPSBUZXh0UG9zaXRpb24uZnJvbUNoYXJPZmZzZXQoXG4gICAgICBzdGFydENvbnRhaW5lcixcbiAgICAgIHNlbGVjdG9yLnN0YXJ0T2Zmc2V0XG4gICAgKTtcbiAgICBjb25zdCBlbmRQb3MgPSBUZXh0UG9zaXRpb24uZnJvbUNoYXJPZmZzZXQoXG4gICAgICBlbmRDb250YWluZXIsXG4gICAgICBzZWxlY3Rvci5lbmRPZmZzZXRcbiAgICApO1xuXG4gICAgY29uc3QgcmFuZ2UgPSBuZXcgVGV4dFJhbmdlKHN0YXJ0UG9zLCBlbmRQb3MpLnRvUmFuZ2UoKTtcbiAgICByZXR1cm4gbmV3IFJhbmdlQW5jaG9yKHJvb3QsIHJhbmdlKTtcbiAgfVxuXG4gIHRvUmFuZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMucmFuZ2U7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7UmFuZ2VTZWxlY3Rvcn1cbiAgICovXG4gIHRvU2VsZWN0b3IoKSB7XG4gICAgLy8gXCJTaHJpbmtcIiB0aGUgcmFuZ2Ugc28gdGhhdCBpdCB0aWdodGx5IHdyYXBzIGl0cyB0ZXh0LiBUaGlzIGVuc3VyZXMgbW9yZVxuICAgIC8vIHByZWRpY3RhYmxlIG91dHB1dCBmb3IgYSBnaXZlbiB0ZXh0IHNlbGVjdGlvbi5cbiAgICBjb25zdCBub3JtYWxpemVkUmFuZ2UgPSBUZXh0UmFuZ2UuZnJvbVJhbmdlKHRoaXMucmFuZ2UpLnRvUmFuZ2UoKTtcblxuICAgIGNvbnN0IHRleHRSYW5nZSA9IFRleHRSYW5nZS5mcm9tUmFuZ2Uobm9ybWFsaXplZFJhbmdlKTtcbiAgICBjb25zdCBzdGFydENvbnRhaW5lciA9IHhwYXRoRnJvbU5vZGUodGV4dFJhbmdlLnN0YXJ0LmVsZW1lbnQsIHRoaXMucm9vdCk7XG4gICAgY29uc3QgZW5kQ29udGFpbmVyID0geHBhdGhGcm9tTm9kZSh0ZXh0UmFuZ2UuZW5kLmVsZW1lbnQsIHRoaXMucm9vdCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ1JhbmdlU2VsZWN0b3InLFxuICAgICAgc3RhcnRDb250YWluZXIsXG4gICAgICBzdGFydE9mZnNldDogdGV4dFJhbmdlLnN0YXJ0Lm9mZnNldCxcbiAgICAgIGVuZENvbnRhaW5lcixcbiAgICAgIGVuZE9mZnNldDogdGV4dFJhbmdlLmVuZC5vZmZzZXQsXG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIENvbnZlcnRzIGJldHdlZW4gYFRleHRQb3NpdGlvblNlbGVjdG9yYCBzZWxlY3RvcnMgYW5kIGBSYW5nZWAgb2JqZWN0cy5cbiAqL1xuZXhwb3J0IGNsYXNzIFRleHRQb3NpdGlvbkFuY2hvciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IHJvb3RcbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBlbmRcbiAgICovXG4gIGNvbnN0cnVjdG9yKHJvb3QsIHN0YXJ0LCBlbmQpIHtcbiAgICB0aGlzLnJvb3QgPSByb290O1xuICAgIHRoaXMuc3RhcnQgPSBzdGFydDtcbiAgICB0aGlzLmVuZCA9IGVuZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IHJvb3RcbiAgICogQHBhcmFtIHtSYW5nZX0gcmFuZ2VcbiAgICovXG4gIHN0YXRpYyBmcm9tUmFuZ2Uocm9vdCwgcmFuZ2UpIHtcbiAgICBjb25zdCB0ZXh0UmFuZ2UgPSBUZXh0UmFuZ2UuZnJvbVJhbmdlKHJhbmdlKS5yZWxhdGl2ZVRvKHJvb3QpO1xuICAgIHJldHVybiBuZXcgVGV4dFBvc2l0aW9uQW5jaG9yKFxuICAgICAgcm9vdCxcbiAgICAgIHRleHRSYW5nZS5zdGFydC5vZmZzZXQsXG4gICAgICB0ZXh0UmFuZ2UuZW5kLm9mZnNldFxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gcm9vdFxuICAgKiBAcGFyYW0ge1RleHRQb3NpdGlvblNlbGVjdG9yfSBzZWxlY3RvclxuICAgKi9cbiAgc3RhdGljIGZyb21TZWxlY3Rvcihyb290LCBzZWxlY3Rvcikge1xuICAgIHJldHVybiBuZXcgVGV4dFBvc2l0aW9uQW5jaG9yKHJvb3QsIHNlbGVjdG9yLnN0YXJ0LCBzZWxlY3Rvci5lbmQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge1RleHRQb3NpdGlvblNlbGVjdG9yfVxuICAgKi9cbiAgdG9TZWxlY3RvcigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ1RleHRQb3NpdGlvblNlbGVjdG9yJyxcbiAgICAgIHN0YXJ0OiB0aGlzLnN0YXJ0LFxuICAgICAgZW5kOiB0aGlzLmVuZCxcbiAgICB9O1xuICB9XG5cbiAgdG9SYW5nZSgpIHtcbiAgICByZXR1cm4gVGV4dFJhbmdlLmZyb21PZmZzZXRzKHRoaXMucm9vdCwgdGhpcy5zdGFydCwgdGhpcy5lbmQpLnRvUmFuZ2UoKTtcbiAgfVxufVxuXG4vKipcbiAqIEB0eXBlZGVmIFF1b3RlTWF0Y2hPcHRpb25zXG4gKiBAcHJvcCB7bnVtYmVyfSBbaGludF0gLSBFeHBlY3RlZCBwb3NpdGlvbiBvZiBtYXRjaCBpbiB0ZXh0LiBTZWUgYG1hdGNoUXVvdGVgLlxuICovXG5cbi8qKlxuICogQ29udmVydHMgYmV0d2VlbiBgVGV4dFF1b3RlU2VsZWN0b3JgIHNlbGVjdG9ycyBhbmQgYFJhbmdlYCBvYmplY3RzLlxuICovXG5leHBvcnQgY2xhc3MgVGV4dFF1b3RlQW5jaG9yIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gcm9vdCAtIEEgcm9vdCBlbGVtZW50IGZyb20gd2hpY2ggdG8gYW5jaG9yLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXhhY3RcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiAgICogICBAcGFyYW0ge3N0cmluZ30gW2NvbnRleHQucHJlZml4XVxuICAgKiAgIEBwYXJhbSB7c3RyaW5nfSBbY29udGV4dC5zdWZmaXhdXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihyb290LCBleGFjdCwgY29udGV4dCA9IHt9KSB7XG4gICAgdGhpcy5yb290ID0gcm9vdDtcbiAgICB0aGlzLmV4YWN0ID0gZXhhY3Q7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBgVGV4dFF1b3RlQW5jaG9yYCBmcm9tIGEgcmFuZ2UuXG4gICAqXG4gICAqIFdpbGwgdGhyb3cgaWYgYHJhbmdlYCBkb2VzIG5vdCBjb250YWluIGFueSB0ZXh0IG5vZGVzLlxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IHJvb3RcbiAgICogQHBhcmFtIHtSYW5nZX0gcmFuZ2VcbiAgICovXG4gIHN0YXRpYyBmcm9tUmFuZ2Uocm9vdCwgcmFuZ2UpIHtcbiAgICBjb25zdCB0ZXh0ID0gLyoqIEB0eXBlIHtzdHJpbmd9ICovIChyb290LnRleHRDb250ZW50KTtcbiAgICBjb25zdCB0ZXh0UmFuZ2UgPSBUZXh0UmFuZ2UuZnJvbVJhbmdlKHJhbmdlKS5yZWxhdGl2ZVRvKHJvb3QpO1xuXG4gICAgY29uc3Qgc3RhcnQgPSB0ZXh0UmFuZ2Uuc3RhcnQub2Zmc2V0O1xuICAgIGNvbnN0IGVuZCA9IHRleHRSYW5nZS5lbmQub2Zmc2V0O1xuXG4gICAgLy8gTnVtYmVyIG9mIGNoYXJhY3RlcnMgYXJvdW5kIHRoZSBxdW90ZSB0byBjYXB0dXJlIGFzIGNvbnRleHQuIFdlIGN1cnJlbnRseVxuICAgIC8vIGFsd2F5cyB1c2UgYSBmaXhlZCBhbW91bnQsIGJ1dCBpdCB3b3VsZCBiZSBiZXR0ZXIgaWYgdGhpcyBjb2RlIHdhcyBhd2FyZVxuICAgIC8vIG9mIGxvZ2ljYWwgYm91bmRhcmllcyBpbiB0aGUgZG9jdW1lbnQgKHBhcmFncmFwaCwgYXJ0aWNsZSBldGMuKSB0byBhdm9pZFxuICAgIC8vIGNhcHR1cmluZyB0ZXh0IHVucmVsYXRlZCB0byB0aGUgcXVvdGUuXG4gICAgLy9cbiAgICAvLyBJbiByZWd1bGFyIHByb3NlIHRoZSBpZGVhbCBjb250ZW50IHdvdWxkIG9mdGVuIGJlIHRoZSBzdXJyb3VuZGluZyBzZW50ZW5jZS5cbiAgICAvLyBUaGlzIGlzIGEgbmF0dXJhbCB1bml0IG9mIG1lYW5pbmcgd2hpY2ggZW5hYmxlcyBkaXNwbGF5aW5nIHF1b3RlcyBpblxuICAgIC8vIGNvbnRleHQgZXZlbiB3aGVuIHRoZSBkb2N1bWVudCBpcyBub3QgYXZhaWxhYmxlLiBXZSBjb3VsZCB1c2UgYEludGwuU2VnbWVudGVyYFxuICAgIC8vIGZvciB0aGlzIHdoZW4gYXZhaWxhYmxlLlxuICAgIGNvbnN0IGNvbnRleHRMZW4gPSAzMjtcblxuICAgIHJldHVybiBuZXcgVGV4dFF1b3RlQW5jaG9yKHJvb3QsIHRleHQuc2xpY2Uoc3RhcnQsIGVuZCksIHtcbiAgICAgIHByZWZpeDogdGV4dC5zbGljZShNYXRoLm1heCgwLCBzdGFydCAtIGNvbnRleHRMZW4pLCBzdGFydCksXG4gICAgICBzdWZmaXg6IHRleHQuc2xpY2UoZW5kLCBNYXRoLm1pbih0ZXh0Lmxlbmd0aCwgZW5kICsgY29udGV4dExlbikpLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gcm9vdFxuICAgKiBAcGFyYW0ge1RleHRRdW90ZVNlbGVjdG9yfSBzZWxlY3RvclxuICAgKi9cbiAgc3RhdGljIGZyb21TZWxlY3Rvcihyb290LCBzZWxlY3Rvcikge1xuICAgIGNvbnN0IHsgcHJlZml4LCBzdWZmaXggfSA9IHNlbGVjdG9yO1xuICAgIHJldHVybiBuZXcgVGV4dFF1b3RlQW5jaG9yKHJvb3QsIHNlbGVjdG9yLmV4YWN0LCB7IHByZWZpeCwgc3VmZml4IH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge1RleHRRdW90ZVNlbGVjdG9yfVxuICAgKi9cbiAgdG9TZWxlY3RvcigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ1RleHRRdW90ZVNlbGVjdG9yJyxcbiAgICAgIGV4YWN0OiB0aGlzLmV4YWN0LFxuICAgICAgcHJlZml4OiB0aGlzLmNvbnRleHQucHJlZml4LFxuICAgICAgc3VmZml4OiB0aGlzLmNvbnRleHQuc3VmZml4LFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtRdW90ZU1hdGNoT3B0aW9uc30gW29wdGlvbnNdXG4gICAqL1xuICB0b1JhbmdlKG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLnRvUG9zaXRpb25BbmNob3Iob3B0aW9ucykudG9SYW5nZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7UXVvdGVNYXRjaE9wdGlvbnN9IFtvcHRpb25zXVxuICAgKi9cbiAgdG9Qb3NpdGlvbkFuY2hvcihvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB0ZXh0ID0gLyoqIEB0eXBlIHtzdHJpbmd9ICovICh0aGlzLnJvb3QudGV4dENvbnRlbnQpO1xuICAgIGNvbnN0IG1hdGNoID0gbWF0Y2hRdW90ZSh0ZXh0LCB0aGlzLmV4YWN0LCB7XG4gICAgICAuLi50aGlzLmNvbnRleHQsXG4gICAgICBoaW50OiBvcHRpb25zLmhpbnQsXG4gICAgfSk7XG4gICAgaWYgKCFtYXRjaCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdRdW90ZSBub3QgZm91bmQnKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBUZXh0UG9zaXRpb25BbmNob3IodGhpcy5yb290LCBtYXRjaC5zdGFydCwgbWF0Y2guZW5kKTtcbiAgfVxufVxuIiwiLy9cbi8vICBDb3B5cmlnaHQgMjAyMSBSZWFkaXVtIEZvdW5kYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgdGhlIEJTRC1zdHlsZSBsaWNlbnNlXG4vLyAgYXZhaWxhYmxlIGluIHRoZSB0b3AtbGV2ZWwgTElDRU5TRSBmaWxlIG9mIHRoZSBwcm9qZWN0LlxuLy9cblxuaW1wb3J0IHtsb2cgYXMgbG9nTmF0aXZlLCBsb2dFeGNlcHRpb259IGZyb20gXCIuL3V0aWxzXCI7XG5cbmNvbnN0IGRlYnVnID0gdHJ1ZTtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFNlbGVjdGlvblJlY3QoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgbGV0IHNlbCA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgaWYgKCFzZWwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmFuZ2UgPSBzZWwuZ2V0UmFuZ2VBdCgwKTtcblxuICAgICAgICBjb25zdCBjbGllbnRSZWN0ID0gcmFuZ2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNjcmVlbldpZHRoOiB3aW5kb3cub3V0ZXJXaWR0aCxcbiAgICAgICAgICAgIHNjcmVlbkhlaWdodDogd2luZG93Lm91dGVySGVpZ2h0LFxuICAgICAgICAgICAgbGVmdDogY2xpZW50UmVjdC5sZWZ0LFxuICAgICAgICAgICAgd2lkdGg6IGNsaWVudFJlY3Qud2lkdGgsXG4gICAgICAgICAgICB0b3A6IGNsaWVudFJlY3QudG9wLFxuICAgICAgICAgICAgaGVpZ2h0OiBjbGllbnRSZWN0LmhlaWdodFxuICAgICAgICB9O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgbG9nRXhjZXB0aW9uKGUpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEN1cnJlbnRTZWxlY3Rpb25JbmZvKCkge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoIXNlbGVjdGlvbikge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAoc2VsZWN0aW9uLmlzQ29sbGFwc2VkKSB7XG4gICAgICAgIGxvZyhcIl5eXiBTRUxFQ1RJT04gQ09MTEFQU0VELlwiKTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3QgcmF3VGV4dCA9IHNlbGVjdGlvbi50b1N0cmluZygpO1xuICAgIGNvbnN0IGNsZWFuVGV4dCA9IHJhd1RleHQudHJpbSgpLnJlcGxhY2UoL1xcbi9nLCBcIiBcIikucmVwbGFjZSgvXFxzXFxzKy9nLCBcIiBcIik7XG4gICAgaWYgKGNsZWFuVGV4dC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgbG9nKFwiXl5eIFNFTEVDVElPTiBURVhUIEVNUFRZLlwiKTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKCFzZWxlY3Rpb24uYW5jaG9yTm9kZSB8fCAhc2VsZWN0aW9uLmZvY3VzTm9kZSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCByYW5nZSA9IHNlbGVjdGlvbi5yYW5nZUNvdW50ID09PSAxID8gc2VsZWN0aW9uLmdldFJhbmdlQXQoMCkgOlxuICAgICAgICBjcmVhdGVPcmRlcmVkUmFuZ2Uoc2VsZWN0aW9uLmFuY2hvck5vZGUsIHNlbGVjdGlvbi5hbmNob3JPZmZzZXQsIHNlbGVjdGlvbi5mb2N1c05vZGUsIHNlbGVjdGlvbi5mb2N1c09mZnNldCk7XG4gICAgaWYgKCFyYW5nZSB8fCByYW5nZS5jb2xsYXBzZWQpIHtcbiAgICAgICAgbG9nKFwiJCQkJCQkJCQkJCQkJCQkJCQgQ0FOTk9UIEdFVCBOT04tQ09MTEFQU0VEIFNFTEVDVElPTiBSQU5HRT8hXCIpO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCByYW5nZUluZm8gPSBjb252ZXJ0UmFuZ2UocmFuZ2UsIGZ1bGxRdWFsaWZpZWRTZWxlY3Rvcik7XG4gICAgaWYgKCFyYW5nZUluZm8pIHtcbiAgICAgICAgbG9nKFwiXl5eIFNFTEVDVElPTiBSQU5HRSBJTkZPIEZBSUw/IVwiKTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBsb2NhdGlvbnM6IHJhbmdlSW5mbzJMb2NhdGlvbihyYW5nZUluZm8pLFxuICAgICAgICB0ZXh0OiB7XG4gICAgICAgICAgICBoaWdobGlnaHQ6IHJhd1RleHRcbiAgICAgICAgfVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU9yZGVyZWRSYW5nZShzdGFydE5vZGUsIHN0YXJ0T2Zmc2V0LCBlbmROb2RlLCBlbmRPZmZzZXQpIHtcbiAgICBjb25zdCByYW5nZSA9IG5ldyBSYW5nZSgpO1xuICAgIHJhbmdlLnNldFN0YXJ0KHN0YXJ0Tm9kZSwgc3RhcnRPZmZzZXQpO1xuICAgIHJhbmdlLnNldEVuZChlbmROb2RlLCBlbmRPZmZzZXQpO1xuICAgIGlmICghcmFuZ2UuY29sbGFwc2VkKSB7XG4gICAgICAgIHJldHVybiByYW5nZTtcbiAgICB9XG4gICAgbG9nKFwiPj4+IGNyZWF0ZU9yZGVyZWRSYW5nZSBDT0xMQVBTRUQgLi4uIFJBTkdFIFJFVkVSU0U/XCIpO1xuICAgIGNvbnN0IHJhbmdlUmV2ZXJzZSA9IG5ldyBSYW5nZSgpO1xuICAgIHJhbmdlUmV2ZXJzZS5zZXRTdGFydChlbmROb2RlLCBlbmRPZmZzZXQpO1xuICAgIHJhbmdlUmV2ZXJzZS5zZXRFbmQoc3RhcnROb2RlLCBzdGFydE9mZnNldCk7XG4gICAgaWYgKCFyYW5nZVJldmVyc2UuY29sbGFwc2VkKSB7XG4gICAgICAgIGxvZyhcIj4+PiBjcmVhdGVPcmRlcmVkUmFuZ2UgUkFOR0UgUkVWRVJTRSBPSy5cIik7XG4gICAgICAgIHJldHVybiByYW5nZTtcbiAgICB9XG4gICAgbG9nKFwiPj4+IGNyZWF0ZU9yZGVyZWRSYW5nZSBSQU5HRSBSRVZFUlNFIEFMU08gQ09MTEFQU0VEPyFcIik7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gY29udmVydFJhbmdlKHJhbmdlLCBnZXRDc3NTZWxlY3Rvcikge1xuICAgIGNvbnN0IHN0YXJ0SXNFbGVtZW50ID0gcmFuZ2Uuc3RhcnRDb250YWluZXIubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFO1xuICAgIGNvbnN0IHN0YXJ0Q29udGFpbmVyRWxlbWVudCA9IHN0YXJ0SXNFbGVtZW50ID9cbiAgICAgICAgcmFuZ2Uuc3RhcnRDb250YWluZXIgOlxuICAgICAgICAoKHJhbmdlLnN0YXJ0Q29udGFpbmVyLnBhcmVudE5vZGUgJiYgcmFuZ2Uuc3RhcnRDb250YWluZXIucGFyZW50Tm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpID9cbiAgICAgICAgICAgIHJhbmdlLnN0YXJ0Q29udGFpbmVyLnBhcmVudE5vZGUgOiB1bmRlZmluZWQpO1xuICAgIGlmICghc3RhcnRDb250YWluZXJFbGVtZW50KSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNvbnN0IHN0YXJ0Q29udGFpbmVyQ2hpbGRUZXh0Tm9kZUluZGV4ID0gc3RhcnRJc0VsZW1lbnQgPyAtMSA6XG4gICAgICAgIEFycmF5LmZyb20oc3RhcnRDb250YWluZXJFbGVtZW50LmNoaWxkTm9kZXMpLmluZGV4T2YocmFuZ2Uuc3RhcnRDb250YWluZXIpO1xuICAgIGlmIChzdGFydENvbnRhaW5lckNoaWxkVGV4dE5vZGVJbmRleCA8IC0xKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNvbnN0IHN0YXJ0Q29udGFpbmVyRWxlbWVudENzc1NlbGVjdG9yID0gZ2V0Q3NzU2VsZWN0b3Ioc3RhcnRDb250YWluZXJFbGVtZW50KTtcblxuICAgIGNvbnN0IGVuZElzRWxlbWVudCA9IHJhbmdlLmVuZENvbnRhaW5lci5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREU7XG4gICAgY29uc3QgZW5kQ29udGFpbmVyRWxlbWVudCA9IGVuZElzRWxlbWVudCA/XG4gICAgICAgIHJhbmdlLmVuZENvbnRhaW5lciA6XG4gICAgICAgICgocmFuZ2UuZW5kQ29udGFpbmVyLnBhcmVudE5vZGUgJiYgcmFuZ2UuZW5kQ29udGFpbmVyLnBhcmVudE5vZGUubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKSA/XG4gICAgICAgICAgICByYW5nZS5lbmRDb250YWluZXIucGFyZW50Tm9kZSA6IHVuZGVmaW5lZCk7XG4gICAgaWYgKCFlbmRDb250YWluZXJFbGVtZW50KSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNvbnN0IGVuZENvbnRhaW5lckNoaWxkVGV4dE5vZGVJbmRleCA9IGVuZElzRWxlbWVudCA/IC0xIDpcbiAgICAgICAgQXJyYXkuZnJvbShlbmRDb250YWluZXJFbGVtZW50LmNoaWxkTm9kZXMpLmluZGV4T2YocmFuZ2UuZW5kQ29udGFpbmVyKTtcbiAgICBpZiAoZW5kQ29udGFpbmVyQ2hpbGRUZXh0Tm9kZUluZGV4IDwgLTEpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3QgZW5kQ29udGFpbmVyRWxlbWVudENzc1NlbGVjdG9yID0gZ2V0Q3NzU2VsZWN0b3IoZW5kQ29udGFpbmVyRWxlbWVudCk7XG5cbiAgICBjb25zdCBjb21tb25FbGVtZW50QW5jZXN0b3IgPSBnZXRDb21tb25BbmNlc3RvckVsZW1lbnQocmFuZ2Uuc3RhcnRDb250YWluZXIsIHJhbmdlLmVuZENvbnRhaW5lcik7XG4gICAgaWYgKCFjb21tb25FbGVtZW50QW5jZXN0b3IpIHtcbiAgICAgICAgbG9nKFwiXl5eIE5PIFJBTkdFIENPTU1PTiBBTkNFU1RPUj8hXCIpO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAocmFuZ2UuY29tbW9uQW5jZXN0b3JDb250YWluZXIpIHtcbiAgICAgICAgY29uc3QgcmFuZ2VDb21tb25BbmNlc3RvckVsZW1lbnQgPSByYW5nZS5jb21tb25BbmNlc3RvckNvbnRhaW5lci5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUgP1xuICAgICAgICAgICAgcmFuZ2UuY29tbW9uQW5jZXN0b3JDb250YWluZXIgOiByYW5nZS5jb21tb25BbmNlc3RvckNvbnRhaW5lci5wYXJlbnROb2RlO1xuICAgICAgICBpZiAocmFuZ2VDb21tb25BbmNlc3RvckVsZW1lbnQgJiYgcmFuZ2VDb21tb25BbmNlc3RvckVsZW1lbnQubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICBpZiAoY29tbW9uRWxlbWVudEFuY2VzdG9yICE9PSByYW5nZUNvbW1vbkFuY2VzdG9yRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGxvZyhcIj4+Pj4+PiBDT01NT04gQU5DRVNUT1IgQ09OVEFJTkVSIERJRkY/PyFcIik7XG4gICAgICAgICAgICAgICAgbG9nKGdldENzc1NlbGVjdG9yKGNvbW1vbkVsZW1lbnRBbmNlc3RvcikpO1xuICAgICAgICAgICAgICAgIGxvZyhnZXRDc3NTZWxlY3RvcihyYW5nZUNvbW1vbkFuY2VzdG9yRWxlbWVudCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGVuZENvbnRhaW5lckNoaWxkVGV4dE5vZGVJbmRleCxcbiAgICAgICAgZW5kQ29udGFpbmVyRWxlbWVudENzc1NlbGVjdG9yLFxuICAgICAgICBlbmRPZmZzZXQ6IHJhbmdlLmVuZE9mZnNldCxcbiAgICAgICAgc3RhcnRDb250YWluZXJDaGlsZFRleHROb2RlSW5kZXgsXG4gICAgICAgIHN0YXJ0Q29udGFpbmVyRWxlbWVudENzc1NlbGVjdG9yLFxuICAgICAgICBzdGFydE9mZnNldDogcmFuZ2Uuc3RhcnRPZmZzZXQsXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0Q29tbW9uQW5jZXN0b3JFbGVtZW50KG5vZGUxLCBub2RlMikge1xuICAgIGlmIChub2RlMS5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUgJiYgbm9kZTEgPT09IG5vZGUyKSB7XG4gICAgICAgIHJldHVybiBub2RlMTtcbiAgICB9XG4gICAgaWYgKG5vZGUxLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSAmJiBub2RlMS5jb250YWlucyhub2RlMikpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUxO1xuICAgIH1cbiAgICBpZiAobm9kZTIubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFICYmIG5vZGUyLmNvbnRhaW5zKG5vZGUxKSkge1xuICAgICAgICByZXR1cm4gbm9kZTI7XG4gICAgfVxuICAgIGNvbnN0IG5vZGUxRWxlbWVudEFuY2VzdG9yQ2hhaW4gPSBbXTtcbiAgICBsZXQgcGFyZW50ID0gbm9kZTEucGFyZW50Tm9kZTtcbiAgICB3aGlsZSAocGFyZW50ICYmIHBhcmVudC5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgbm9kZTFFbGVtZW50QW5jZXN0b3JDaGFpbi5wdXNoKHBhcmVudCk7XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xuICAgIH1cbiAgICBjb25zdCBub2RlMkVsZW1lbnRBbmNlc3RvckNoYWluID0gW107XG4gICAgcGFyZW50ID0gbm9kZTIucGFyZW50Tm9kZTtcbiAgICB3aGlsZSAocGFyZW50ICYmIHBhcmVudC5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgbm9kZTJFbGVtZW50QW5jZXN0b3JDaGFpbi5wdXNoKHBhcmVudCk7XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xuICAgIH1cbiAgICBsZXQgY29tbW9uQW5jZXN0b3IgPSBub2RlMUVsZW1lbnRBbmNlc3RvckNoYWluLmZpbmQoKG5vZGUxRWxlbWVudEFuY2VzdG9yKSA9PiB7XG4gICAgICAgIHJldHVybiBub2RlMkVsZW1lbnRBbmNlc3RvckNoYWluLmluZGV4T2Yobm9kZTFFbGVtZW50QW5jZXN0b3IpID49IDA7XG4gICAgfSk7XG4gICAgaWYgKCFjb21tb25BbmNlc3Rvcikge1xuICAgICAgICBjb21tb25BbmNlc3RvciA9IG5vZGUyRWxlbWVudEFuY2VzdG9yQ2hhaW4uZmluZCgobm9kZTJFbGVtZW50QW5jZXN0b3IpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBub2RlMUVsZW1lbnRBbmNlc3RvckNoYWluLmluZGV4T2Yobm9kZTJFbGVtZW50QW5jZXN0b3IpID49IDA7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gY29tbW9uQW5jZXN0b3I7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0UmFuZ2VJbmZvKGRvY3VtZW50LCByYW5nZUluZm8pIHtcbiAgICBjb25zdCBzdGFydEVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHJhbmdlSW5mby5zdGFydENvbnRhaW5lckVsZW1lbnRDc3NTZWxlY3Rvcik7XG4gICAgaWYgKCFzdGFydEVsZW1lbnQpIHtcbiAgICAgICAgbG9nKFwiXl5eIGNvbnZlcnRSYW5nZUluZm8gTk8gU1RBUlQgRUxFTUVOVCBDU1MgU0VMRUNUT1I/IVwiKTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgbGV0IHN0YXJ0Q29udGFpbmVyID0gc3RhcnRFbGVtZW50O1xuICAgIGlmIChyYW5nZUluZm8uc3RhcnRDb250YWluZXJDaGlsZFRleHROb2RlSW5kZXggPj0gMCkge1xuICAgICAgICBpZiAocmFuZ2VJbmZvLnN0YXJ0Q29udGFpbmVyQ2hpbGRUZXh0Tm9kZUluZGV4ID49IHN0YXJ0RWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgbG9nKFwiXl5eIGNvbnZlcnRSYW5nZUluZm8gcmFuZ2VJbmZvLnN0YXJ0Q29udGFpbmVyQ2hpbGRUZXh0Tm9kZUluZGV4ID49IHN0YXJ0RWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aD8hXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBzdGFydENvbnRhaW5lciA9IHN0YXJ0RWxlbWVudC5jaGlsZE5vZGVzW3JhbmdlSW5mby5zdGFydENvbnRhaW5lckNoaWxkVGV4dE5vZGVJbmRleF07XG4gICAgICAgIGlmIChzdGFydENvbnRhaW5lci5ub2RlVHlwZSAhPT0gTm9kZS5URVhUX05PREUpIHtcbiAgICAgICAgICAgIGxvZyhcIl5eXiBjb252ZXJ0UmFuZ2VJbmZvIHN0YXJ0Q29udGFpbmVyLm5vZGVUeXBlICE9PSBOb2RlLlRFWFRfTk9ERT8hXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBlbmRFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihyYW5nZUluZm8uZW5kQ29udGFpbmVyRWxlbWVudENzc1NlbGVjdG9yKTtcbiAgICBpZiAoIWVuZEVsZW1lbnQpIHtcbiAgICAgICAgbG9nKFwiXl5eIGNvbnZlcnRSYW5nZUluZm8gTk8gRU5EIEVMRU1FTlQgQ1NTIFNFTEVDVE9SPyFcIik7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGxldCBlbmRDb250YWluZXIgPSBlbmRFbGVtZW50O1xuICAgIGlmIChyYW5nZUluZm8uZW5kQ29udGFpbmVyQ2hpbGRUZXh0Tm9kZUluZGV4ID49IDApIHtcbiAgICAgICAgaWYgKHJhbmdlSW5mby5lbmRDb250YWluZXJDaGlsZFRleHROb2RlSW5kZXggPj0gZW5kRWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgbG9nKFwiXl5eIGNvbnZlcnRSYW5nZUluZm8gcmFuZ2VJbmZvLmVuZENvbnRhaW5lckNoaWxkVGV4dE5vZGVJbmRleCA+PSBlbmRFbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoPyFcIik7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVuZENvbnRhaW5lciA9IGVuZEVsZW1lbnQuY2hpbGROb2Rlc1tyYW5nZUluZm8uZW5kQ29udGFpbmVyQ2hpbGRUZXh0Tm9kZUluZGV4XTtcbiAgICAgICAgaWYgKGVuZENvbnRhaW5lci5ub2RlVHlwZSAhPT0gTm9kZS5URVhUX05PREUpIHtcbiAgICAgICAgICAgIGxvZyhcIl5eXiBjb252ZXJ0UmFuZ2VJbmZvIGVuZENvbnRhaW5lci5ub2RlVHlwZSAhPT0gTm9kZS5URVhUX05PREU/IVwiKTtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZU9yZGVyZWRSYW5nZShzdGFydENvbnRhaW5lciwgcmFuZ2VJbmZvLnN0YXJ0T2Zmc2V0LCBlbmRDb250YWluZXIsIHJhbmdlSW5mby5lbmRPZmZzZXQpO1xufVxuXG5mdW5jdGlvbiByYW5nZUluZm8yTG9jYXRpb24ocmFuZ2VJbmZvKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY3NzU2VsZWN0b3I6IHJhbmdlSW5mby5zdGFydENvbnRhaW5lckVsZW1lbnRDc3NTZWxlY3RvcixcbiAgICAgICAgZG9tUmFuZ2U6IHtcbiAgICAgICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgICAgICAgY3NzU2VsZWN0b3I6IHJhbmdlSW5mby5zdGFydENvbnRhaW5lckVsZW1lbnRDc3NTZWxlY3RvcixcbiAgICAgICAgICAgICAgICB0ZXh0Tm9kZUluZGV4OiByYW5nZUluZm8uc3RhcnRDb250YWluZXJDaGlsZFRleHROb2RlSW5kZXgsXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiByYW5nZUluZm8uc3RhcnRPZmZzZXRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbmQ6IHtcbiAgICAgICAgICAgICAgICBjc3NTZWxlY3RvcjogcmFuZ2VJbmZvLmVuZENvbnRhaW5lckVsZW1lbnRDc3NTZWxlY3RvcixcbiAgICAgICAgICAgICAgICB0ZXh0Tm9kZUluZGV4OiByYW5nZUluZm8uZW5kQ29udGFpbmVyQ2hpbGRUZXh0Tm9kZUluZGV4LFxuICAgICAgICAgICAgICAgIG9mZnNldDogcmFuZ2VJbmZvLmVuZE9mZnNldFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbG9jYXRpb24yUmFuZ2VJbmZvKGxvY2F0aW9uKSB7XG4gICAgY29uc3QgbG9jYXRpb25zID0gbG9jYXRpb24ubG9jYXRpb25zXG4gICAgY29uc3QgZG9tUmFuZ2UgPSBsb2NhdGlvbnMuZG9tUmFuZ2VcbiAgICBjb25zdCBzdGFydCA9IGRvbVJhbmdlLnN0YXJ0XG4gICAgY29uc3QgZW5kID0gZG9tUmFuZ2UuZW5kXG5cbiAgICByZXR1cm4ge1xuICAgICAgICBlbmRDb250YWluZXJDaGlsZFRleHROb2RlSW5kZXg6IGVuZC50ZXh0Tm9kZUluZGV4LFxuICAgICAgICBlbmRDb250YWluZXJFbGVtZW50Q3NzU2VsZWN0b3I6IGVuZC5jc3NTZWxlY3RvcixcbiAgICAgICAgZW5kT2Zmc2V0OiBlbmQub2Zmc2V0LFxuICAgICAgICBzdGFydENvbnRhaW5lckNoaWxkVGV4dE5vZGVJbmRleDogc3RhcnQudGV4dE5vZGVJbmRleCxcbiAgICAgICAgc3RhcnRDb250YWluZXJFbGVtZW50Q3NzU2VsZWN0b3I6IHN0YXJ0LmNzc1NlbGVjdG9yLFxuICAgICAgICBzdGFydE9mZnNldDogc3RhcnQub2Zmc2V0XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gZnVsbFF1YWxpZmllZFNlbGVjdG9yKG5vZGUpIHtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgcmV0dXJuIChub2RlLmxvY2FsTmFtZSAmJiBub2RlLmxvY2FsTmFtZS50b0xvd2VyQ2FzZSgpKVxuICAgICAgICAgICAgfHwgbm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgICAvL3JldHVybiBjc3NQYXRoKG5vZGUsIGp1c3RTZWxlY3Rvcik7XG4gICAgcmV0dXJuIGNzc1BhdGgobm9kZSwgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGNzc1BhdGgobm9kZSwgb3B0aW1pemVkKSB7XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cblxuICAgIGNvbnN0IHN0ZXBzID0gW107XG4gICAgbGV0IGNvbnRleHROb2RlID0gbm9kZTtcbiAgICB3aGlsZSAoY29udGV4dE5vZGUpIHtcbiAgICAgICAgY29uc3Qgc3RlcCA9IF9jc3NQYXRoU3RlcChjb250ZXh0Tm9kZSwgISFvcHRpbWl6ZWQsIGNvbnRleHROb2RlID09PSBub2RlKTtcbiAgICAgICAgaWYgKCFzdGVwKSB7XG4gICAgICAgICAgICBicmVhazsgLy8gRXJyb3IgLSBiYWlsIG91dCBlYXJseS5cbiAgICAgICAgfVxuICAgICAgICBzdGVwcy5wdXNoKHN0ZXAudmFsdWUpO1xuICAgICAgICBpZiAoc3RlcC5vcHRpbWl6ZWQpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHROb2RlID0gY29udGV4dE5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgc3RlcHMucmV2ZXJzZSgpO1xuICAgIHJldHVybiBzdGVwcy5qb2luKFwiID4gXCIpO1xufVxuXG4vLyBodHRwczovL2Nocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vYmxpbmsvKy9tYXN0ZXIvU291cmNlL2RldnRvb2xzL2Zyb250X2VuZC9jb21wb25lbnRzL0RPTVByZXNlbnRhdGlvblV0aWxzLmpzIzMxNlxuZnVuY3Rpb24gX2Nzc1BhdGhTdGVwKG5vZGUsIG9wdGltaXplZCwgaXNUYXJnZXROb2RlKSB7XG5cbiAgICBmdW5jdGlvbiBpZFNlbGVjdG9yKGlkZCkge1xuICAgICAgICByZXR1cm4gXCIjXCIgKyBlc2NhcGVJZGVudGlmaWVySWZOZWVkZWQoaWRkKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlc2NhcGVJZGVudGlmaWVySWZOZWVkZWQoaWRlbnQpIHtcbiAgICAgICAgaWYgKGlzQ1NTSWRlbnRpZmllcihpZGVudCkpIHtcbiAgICAgICAgICAgIHJldHVybiBpZGVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHNob3VsZEVzY2FwZUZpcnN0ID0gL14oPzpbMC05XXwtWzAtOS1dPykvLnRlc3QoaWRlbnQpO1xuICAgICAgICBjb25zdCBsYXN0SW5kZXggPSBpZGVudC5sZW5ndGggLSAxO1xuICAgICAgICByZXR1cm4gaWRlbnQucmVwbGFjZSgvLi9nLCBmdW5jdGlvbiAoYywgaWkpIHtcbiAgICAgICAgICAgIHJldHVybiAoKHNob3VsZEVzY2FwZUZpcnN0ICYmIGlpID09PSAwKSB8fCAhaXNDU1NJZGVudENoYXIoYykpID8gZXNjYXBlQXNjaWlDaGFyKGMsIGlpID09PSBsYXN0SW5kZXgpIDogYztcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNDU1NJZGVudGlmaWVyKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAvXi0/W2EtekEtWl9dW2EtekEtWjAtOV8tXSokLy50ZXN0KHZhbHVlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0NTU0lkZW50Q2hhcihjKSB7XG4gICAgICAgIGlmICgvW2EtekEtWjAtOV8tXS8udGVzdChjKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGMuY2hhckNvZGVBdCgwKSA+PSAweEEwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVzY2FwZUFzY2lpQ2hhcihjLCBpc0xhc3QpIHtcbiAgICAgICAgcmV0dXJuIFwiXFxcXFwiICsgdG9IZXhCeXRlKGMpICsgKGlzTGFzdCA/IFwiXCIgOiBcIiBcIik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9IZXhCeXRlKGMpIHtcbiAgICAgICAgbGV0IGhleEJ5dGUgPSBjLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpO1xuICAgICAgICBpZiAoaGV4Qnl0ZS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGhleEJ5dGUgPSBcIjBcIiArIGhleEJ5dGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhleEJ5dGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJlZml4ZWRFbGVtZW50Q2xhc3NOYW1lcyhuZCkge1xuICAgICAgICBjb25zdCBjbGFzc0F0dHJpYnV0ZSA9IG5kLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpO1xuICAgICAgICBpZiAoIWNsYXNzQXR0cmlidXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2xhc3NBdHRyaWJ1dGUuc3BsaXQoL1xccysvZykuZmlsdGVyKEJvb2xlYW4pLm1hcCgobm0pID0+IHtcbiAgICAgICAgICAgIC8vIFRoZSBwcmVmaXggaXMgcmVxdWlyZWQgdG8gc3RvcmUgXCJfX3Byb3RvX19cIiBpbiBhIG9iamVjdC1iYXNlZCBtYXAuXG4gICAgICAgICAgICByZXR1cm4gXCIkXCIgKyBubTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKG5vZGUubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNvbnN0IGxvd2VyQ2FzZU5hbWUgPSAobm9kZS5sb2NhbE5hbWUgJiYgbm9kZS5sb2NhbE5hbWUudG9Mb3dlckNhc2UoKSlcbiAgICAgICAgfHwgbm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgY29uc3QgZWxlbWVudCA9IG5vZGU7XG5cbiAgICBjb25zdCBpZCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiaWRcIik7XG5cbiAgICBpZiAob3B0aW1pemVkKSB7XG4gICAgICAgIGlmIChpZCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBvcHRpbWl6ZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGlkU2VsZWN0b3IoaWQpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobG93ZXJDYXNlTmFtZSA9PT0gXCJib2R5XCIgfHwgbG93ZXJDYXNlTmFtZSA9PT0gXCJoZWFkXCIgfHwgbG93ZXJDYXNlTmFtZSA9PT0gXCJodG1sXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgb3B0aW1pemVkOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBsb3dlckNhc2VOYW1lLCAvLyBub2RlLm5vZGVOYW1lSW5Db3JyZWN0Q2FzZSgpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IG5vZGVOYW1lID0gbG93ZXJDYXNlTmFtZTsgLy8gbm9kZS5ub2RlTmFtZUluQ29ycmVjdENhc2UoKTtcbiAgICBpZiAoaWQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9wdGltaXplZDogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBub2RlTmFtZSArIGlkU2VsZWN0b3IoaWQpLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGNvbnN0IHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZTtcblxuICAgIGlmICghcGFyZW50IHx8IHBhcmVudC5ub2RlVHlwZSA9PT0gTm9kZS5ET0NVTUVOVF9OT0RFKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvcHRpbWl6ZWQ6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogbm9kZU5hbWUsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgY29uc3QgcHJlZml4ZWRPd25DbGFzc05hbWVzQXJyYXlfID0gcHJlZml4ZWRFbGVtZW50Q2xhc3NOYW1lcyhlbGVtZW50KTtcblxuICAgIGNvbnN0IHByZWZpeGVkT3duQ2xhc3NOYW1lc0FycmF5ID0gW107IC8vIC5rZXlTZXQoKVxuICAgIHByZWZpeGVkT3duQ2xhc3NOYW1lc0FycmF5Xy5mb3JFYWNoKChhcnJJdGVtKSA9PiB7XG4gICAgICAgIGlmIChwcmVmaXhlZE93bkNsYXNzTmFtZXNBcnJheS5pbmRleE9mKGFyckl0ZW0pIDwgMCkge1xuICAgICAgICAgICAgcHJlZml4ZWRPd25DbGFzc05hbWVzQXJyYXkucHVzaChhcnJJdGVtKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgbGV0IG5lZWRzQ2xhc3NOYW1lcyA9IGZhbHNlO1xuICAgIGxldCBuZWVkc050aENoaWxkID0gZmFsc2U7XG4gICAgbGV0IG93bkluZGV4ID0gLTE7XG4gICAgbGV0IGVsZW1lbnRJbmRleCA9IC0xO1xuICAgIGNvbnN0IHNpYmxpbmdzID0gcGFyZW50LmNoaWxkcmVuO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IChvd25JbmRleCA9PT0gLTEgfHwgIW5lZWRzTnRoQ2hpbGQpICYmIGkgPCBzaWJsaW5ncy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBzaWJsaW5nID0gc2libGluZ3NbaV07XG4gICAgICAgIGlmIChzaWJsaW5nLm5vZGVUeXBlICE9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxlbWVudEluZGV4ICs9IDE7XG4gICAgICAgIGlmIChzaWJsaW5nID09PSBub2RlKSB7XG4gICAgICAgICAgICBvd25JbmRleCA9IGVsZW1lbnRJbmRleDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZWVkc050aENoaWxkKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNpYmxpbmcubm9kZU5hbWVJbkNvcnJlY3RDYXNlKClcbiAgICAgICAgY29uc3Qgc2libGluZ05hbWUgPSAoc2libGluZy5sb2NhbE5hbWUgJiYgc2libGluZy5sb2NhbE5hbWUudG9Mb3dlckNhc2UoKSkgfHwgc2libGluZy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoc2libGluZ05hbWUgIT09IG5vZGVOYW1lKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBuZWVkc0NsYXNzTmFtZXMgPSB0cnVlO1xuXG4gICAgICAgIGNvbnN0IG93bkNsYXNzTmFtZXMgPSBbXTtcbiAgICAgICAgcHJlZml4ZWRPd25DbGFzc05hbWVzQXJyYXkuZm9yRWFjaCgoYXJySXRlbSkgPT4ge1xuICAgICAgICAgICAgb3duQ2xhc3NOYW1lcy5wdXNoKGFyckl0ZW0pO1xuICAgICAgICB9KTtcbiAgICAgICAgbGV0IG93bkNsYXNzTmFtZUNvdW50ID0gb3duQ2xhc3NOYW1lcy5sZW5ndGg7XG5cbiAgICAgICAgaWYgKG93bkNsYXNzTmFtZUNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICBuZWVkc050aENoaWxkID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNpYmxpbmdDbGFzc05hbWVzQXJyYXlfID0gcHJlZml4ZWRFbGVtZW50Q2xhc3NOYW1lcyhzaWJsaW5nKTtcbiAgICAgICAgY29uc3Qgc2libGluZ0NsYXNzTmFtZXNBcnJheSA9IFtdOyAvLyAua2V5U2V0KClcbiAgICAgICAgc2libGluZ0NsYXNzTmFtZXNBcnJheV8uZm9yRWFjaCgoYXJySXRlbSkgPT4ge1xuICAgICAgICAgICAgaWYgKHNpYmxpbmdDbGFzc05hbWVzQXJyYXkuaW5kZXhPZihhcnJJdGVtKSA8IDApIHtcbiAgICAgICAgICAgICAgICBzaWJsaW5nQ2xhc3NOYW1lc0FycmF5LnB1c2goYXJySXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZvciAoY29uc3Qgc2libGluZ0NsYXNzIG9mIHNpYmxpbmdDbGFzc05hbWVzQXJyYXkpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZCA9IG93bkNsYXNzTmFtZXMuaW5kZXhPZihzaWJsaW5nQ2xhc3MpO1xuICAgICAgICAgICAgaWYgKGluZCA8IDApIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb3duQ2xhc3NOYW1lcy5zcGxpY2UoaW5kLCAxKTsgLy8gZGVsZXRlIG93bkNsYXNzTmFtZXNbc2libGluZ0NsYXNzXTtcblxuICAgICAgICAgICAgaWYgKCEtLW93bkNsYXNzTmFtZUNvdW50KSB7XG4gICAgICAgICAgICAgICAgbmVlZHNOdGhDaGlsZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgcmVzdWx0ID0gbm9kZU5hbWU7XG4gICAgaWYgKGlzVGFyZ2V0Tm9kZSAmJlxuICAgICAgICBub2RlTmFtZSA9PT0gXCJpbnB1dFwiICYmXG4gICAgICAgIGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwidHlwZVwiKSAmJlxuICAgICAgICAhZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJpZFwiKSAmJlxuICAgICAgICAhZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSkge1xuICAgICAgICByZXN1bHQgKz0gXCJbdHlwZT1cXFwiXCIgKyBlbGVtZW50LmdldEF0dHJpYnV0ZShcInR5cGVcIikgKyBcIlxcXCJdXCI7XG4gICAgfVxuICAgIGlmIChuZWVkc050aENoaWxkKSB7XG4gICAgICAgIHJlc3VsdCArPSBcIjpudGgtY2hpbGQoXCIgKyAob3duSW5kZXggKyAxKSArIFwiKVwiO1xuICAgIH0gZWxzZSBpZiAobmVlZHNDbGFzc05hbWVzKSB7XG4gICAgICAgIGZvciAoY29uc3QgcHJlZml4ZWROYW1lIG9mIHByZWZpeGVkT3duQ2xhc3NOYW1lc0FycmF5KSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gXCIuXCIgKyBlc2NhcGVJZGVudGlmaWVySWZOZWVkZWQocHJlZml4ZWROYW1lLnN1YnN0cigxKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBvcHRpbWl6ZWQ6IGZhbHNlLFxuICAgICAgICB2YWx1ZTogcmVzdWx0LFxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGxvZygpIHtcbiAgICBpZiAoZGVidWcpIHtcbiAgICAgICAgbG9nTmF0aXZlLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfVxufSIsIi8vXG4vLyAgQ29weXJpZ2h0IDIwMjEgUmVhZGl1bSBGb3VuZGF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IHRoZSBCU0Qtc3R5bGUgbGljZW5zZVxuLy8gIGF2YWlsYWJsZSBpbiB0aGUgdG9wLWxldmVsIExJQ0VOU0UgZmlsZSBvZiB0aGUgcHJvamVjdC5cbi8vXG5cbmltcG9ydCB7bG9nIGFzIGxvZ05hdGl2ZX0gZnJvbSBcIi4vdXRpbHNcIjtcblxuY29uc3QgZGVidWcgPSBmYWxzZTtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldENsaWVudFJlY3RzTm9PdmVybGFwKHJhbmdlLCBkb05vdE1lcmdlSG9yaXpvbnRhbGx5QWxpZ25lZFJlY3RzKSB7XG4gICAgbGV0IGNsaWVudFJlY3RzID0gcmFuZ2UuZ2V0Q2xpZW50UmVjdHMoKTtcblxuICAgIGNvbnN0IHRvbGVyYW5jZSA9IDE7XG4gICAgY29uc3Qgb3JpZ2luYWxSZWN0cyA9IFtdO1xuICAgIGZvciAoY29uc3QgcmFuZ2VDbGllbnRSZWN0IG9mIGNsaWVudFJlY3RzKSB7XG4gICAgICAgIG9yaWdpbmFsUmVjdHMucHVzaCh7XG4gICAgICAgICAgICBib3R0b206IHJhbmdlQ2xpZW50UmVjdC5ib3R0b20sXG4gICAgICAgICAgICBoZWlnaHQ6IHJhbmdlQ2xpZW50UmVjdC5oZWlnaHQsXG4gICAgICAgICAgICBsZWZ0OiByYW5nZUNsaWVudFJlY3QubGVmdCxcbiAgICAgICAgICAgIHJpZ2h0OiByYW5nZUNsaWVudFJlY3QucmlnaHQsXG4gICAgICAgICAgICB0b3A6IHJhbmdlQ2xpZW50UmVjdC50b3AsXG4gICAgICAgICAgICB3aWR0aDogcmFuZ2VDbGllbnRSZWN0LndpZHRoLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgbWVyZ2VkUmVjdHMgPSBtZXJnZVRvdWNoaW5nUmVjdHMob3JpZ2luYWxSZWN0cywgdG9sZXJhbmNlLCBkb05vdE1lcmdlSG9yaXpvbnRhbGx5QWxpZ25lZFJlY3RzKTtcbiAgICBjb25zdCBub0NvbnRhaW5lZFJlY3RzID0gcmVtb3ZlQ29udGFpbmVkUmVjdHMobWVyZ2VkUmVjdHMsIHRvbGVyYW5jZSk7XG4gICAgY29uc3QgbmV3UmVjdHMgPSByZXBsYWNlT3ZlcmxhcGluZ1JlY3RzKG5vQ29udGFpbmVkUmVjdHMpO1xuICAgIGNvbnN0IG1pbkFyZWEgPSAyICogMjtcbiAgICBmb3IgKGxldCBqID0gbmV3UmVjdHMubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgY29uc3QgcmVjdCA9IG5ld1JlY3RzW2pdO1xuICAgICAgICBjb25zdCBiaWdFbm91Z2ggPSAocmVjdC53aWR0aCAqIHJlY3QuaGVpZ2h0KSA+IG1pbkFyZWE7XG4gICAgICAgIGlmICghYmlnRW5vdWdoKSB7XG4gICAgICAgICAgICBpZiAobmV3UmVjdHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIGxvZyhcIkNMSUVOVCBSRUNUOiByZW1vdmUgc21hbGxcIik7XG4gICAgICAgICAgICAgICAgbmV3UmVjdHMuc3BsaWNlKGosIDEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2coXCJDTElFTlQgUkVDVDogcmVtb3ZlIHNtYWxsLCBidXQga2VlcCBvdGhlcndpc2UgZW1wdHkhXCIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGxvZyhgQ0xJRU5UIFJFQ1Q6IHJlZHVjZWQgJHtvcmlnaW5hbFJlY3RzLmxlbmd0aH0gLS0+ICR7bmV3UmVjdHMubGVuZ3RofWApO1xuICAgIHJldHVybiBuZXdSZWN0cztcbn1cblxuZnVuY3Rpb24gbWVyZ2VUb3VjaGluZ1JlY3RzKHJlY3RzLCB0b2xlcmFuY2UsIGRvTm90TWVyZ2VIb3Jpem9udGFsbHlBbGlnbmVkUmVjdHMpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlY3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IHJlY3RzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBjb25zdCByZWN0MSA9IHJlY3RzW2ldO1xuICAgICAgICAgICAgY29uc3QgcmVjdDIgPSByZWN0c1tqXTtcbiAgICAgICAgICAgIGlmIChyZWN0MSA9PT0gcmVjdDIpIHtcbiAgICAgICAgICAgICAgICBsb2coXCJtZXJnZVRvdWNoaW5nUmVjdHMgcmVjdDEgPT09IHJlY3QyID8/IVwiKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlY3RzTGluZVVwVmVydGljYWxseSA9IGFsbW9zdEVxdWFsKHJlY3QxLnRvcCwgcmVjdDIudG9wLCB0b2xlcmFuY2UpICYmXG4gICAgICAgICAgICAgICAgYWxtb3N0RXF1YWwocmVjdDEuYm90dG9tLCByZWN0Mi5ib3R0b20sIHRvbGVyYW5jZSk7XG4gICAgICAgICAgICBjb25zdCByZWN0c0xpbmVVcEhvcml6b250YWxseSA9IGFsbW9zdEVxdWFsKHJlY3QxLmxlZnQsIHJlY3QyLmxlZnQsIHRvbGVyYW5jZSkgJiZcbiAgICAgICAgICAgICAgICBhbG1vc3RFcXVhbChyZWN0MS5yaWdodCwgcmVjdDIucmlnaHQsIHRvbGVyYW5jZSk7XG4gICAgICAgICAgICBjb25zdCBob3Jpem9udGFsQWxsb3dlZCA9ICFkb05vdE1lcmdlSG9yaXpvbnRhbGx5QWxpZ25lZFJlY3RzO1xuICAgICAgICAgICAgY29uc3QgYWxpZ25lZCA9IChyZWN0c0xpbmVVcEhvcml6b250YWxseSAmJiBob3Jpem9udGFsQWxsb3dlZCkgfHwgKHJlY3RzTGluZVVwVmVydGljYWxseSAmJiAhcmVjdHNMaW5lVXBIb3Jpem9udGFsbHkpO1xuICAgICAgICAgICAgY29uc3QgY2FuTWVyZ2UgPSBhbGlnbmVkICYmIHJlY3RzVG91Y2hPck92ZXJsYXAocmVjdDEsIHJlY3QyLCB0b2xlcmFuY2UpO1xuICAgICAgICAgICAgaWYgKGNhbk1lcmdlKSB7XG4gICAgICAgICAgICAgICAgbG9nKGBDTElFTlQgUkVDVDogbWVyZ2luZyB0d28gaW50byBvbmUsIFZFUlRJQ0FMOiAke3JlY3RzTGluZVVwVmVydGljYWxseX0gSE9SSVpPTlRBTDogJHtyZWN0c0xpbmVVcEhvcml6b250YWxseX0gKCR7ZG9Ob3RNZXJnZUhvcml6b250YWxseUFsaWduZWRSZWN0c30pYCk7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3UmVjdHMgPSByZWN0cy5maWx0ZXIoKHJlY3QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlY3QgIT09IHJlY3QxICYmIHJlY3QgIT09IHJlY3QyO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlcGxhY2VtZW50Q2xpZW50UmVjdCA9IGdldEJvdW5kaW5nUmVjdChyZWN0MSwgcmVjdDIpO1xuICAgICAgICAgICAgICAgIG5ld1JlY3RzLnB1c2gocmVwbGFjZW1lbnRDbGllbnRSZWN0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWVyZ2VUb3VjaGluZ1JlY3RzKG5ld1JlY3RzLCB0b2xlcmFuY2UsIGRvTm90TWVyZ2VIb3Jpem9udGFsbHlBbGlnbmVkUmVjdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZWN0cztcbn1cblxuZnVuY3Rpb24gZ2V0Qm91bmRpbmdSZWN0KHJlY3QxLCByZWN0Mikge1xuICAgIGNvbnN0IGxlZnQgPSBNYXRoLm1pbihyZWN0MS5sZWZ0LCByZWN0Mi5sZWZ0KTtcbiAgICBjb25zdCByaWdodCA9IE1hdGgubWF4KHJlY3QxLnJpZ2h0LCByZWN0Mi5yaWdodCk7XG4gICAgY29uc3QgdG9wID0gTWF0aC5taW4ocmVjdDEudG9wLCByZWN0Mi50b3ApO1xuICAgIGNvbnN0IGJvdHRvbSA9IE1hdGgubWF4KHJlY3QxLmJvdHRvbSwgcmVjdDIuYm90dG9tKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBib3R0b20sXG4gICAgICAgIGhlaWdodDogYm90dG9tIC0gdG9wLFxuICAgICAgICBsZWZ0LFxuICAgICAgICByaWdodCxcbiAgICAgICAgdG9wLFxuICAgICAgICB3aWR0aDogcmlnaHQgLSBsZWZ0LFxuICAgIH07XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUNvbnRhaW5lZFJlY3RzKHJlY3RzLCB0b2xlcmFuY2UpIHtcbiAgICBjb25zdCByZWN0c1RvS2VlcCA9IG5ldyBTZXQocmVjdHMpO1xuICAgIGZvciAoY29uc3QgcmVjdCBvZiByZWN0cykge1xuICAgICAgICBjb25zdCBiaWdFbm91Z2ggPSByZWN0LndpZHRoID4gMSAmJiByZWN0LmhlaWdodCA+IDE7XG4gICAgICAgIGlmICghYmlnRW5vdWdoKSB7XG4gICAgICAgICAgICBsb2coXCJDTElFTlQgUkVDVDogcmVtb3ZlIHRpbnlcIik7XG4gICAgICAgICAgICByZWN0c1RvS2VlcC5kZWxldGUocmVjdCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHBvc3NpYmx5Q29udGFpbmluZ1JlY3Qgb2YgcmVjdHMpIHtcbiAgICAgICAgICAgIGlmIChyZWN0ID09PSBwb3NzaWJseUNvbnRhaW5pbmdSZWN0KSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXJlY3RzVG9LZWVwLmhhcyhwb3NzaWJseUNvbnRhaW5pbmdSZWN0KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlY3RDb250YWlucyhwb3NzaWJseUNvbnRhaW5pbmdSZWN0LCByZWN0LCB0b2xlcmFuY2UpKSB7XG4gICAgICAgICAgICAgICAgbG9nKFwiQ0xJRU5UIFJFQ1Q6IHJlbW92ZSBjb250YWluZWRcIik7XG4gICAgICAgICAgICAgICAgcmVjdHNUb0tlZXAuZGVsZXRlKHJlY3QpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBBcnJheS5mcm9tKHJlY3RzVG9LZWVwKTtcbn1cblxuZnVuY3Rpb24gcmVjdENvbnRhaW5zKHJlY3QxLCByZWN0MiwgdG9sZXJhbmNlKSB7XG4gICAgcmV0dXJuIChyZWN0Q29udGFpbnNQb2ludChyZWN0MSwgcmVjdDIubGVmdCwgcmVjdDIudG9wLCB0b2xlcmFuY2UpICYmXG4gICAgICAgIHJlY3RDb250YWluc1BvaW50KHJlY3QxLCByZWN0Mi5yaWdodCwgcmVjdDIudG9wLCB0b2xlcmFuY2UpICYmXG4gICAgICAgIHJlY3RDb250YWluc1BvaW50KHJlY3QxLCByZWN0Mi5sZWZ0LCByZWN0Mi5ib3R0b20sIHRvbGVyYW5jZSkgJiZcbiAgICAgICAgcmVjdENvbnRhaW5zUG9pbnQocmVjdDEsIHJlY3QyLnJpZ2h0LCByZWN0Mi5ib3R0b20sIHRvbGVyYW5jZSkpO1xufVxuXG5mdW5jdGlvbiByZWN0Q29udGFpbnNQb2ludChyZWN0LCB4LCB5LCB0b2xlcmFuY2UpIHtcbiAgICByZXR1cm4gKHJlY3QubGVmdCA8IHggfHwgYWxtb3N0RXF1YWwocmVjdC5sZWZ0LCB4LCB0b2xlcmFuY2UpKSAmJlxuICAgICAgICAocmVjdC5yaWdodCA+IHggfHwgYWxtb3N0RXF1YWwocmVjdC5yaWdodCwgeCwgdG9sZXJhbmNlKSkgJiZcbiAgICAgICAgKHJlY3QudG9wIDwgeSB8fCBhbG1vc3RFcXVhbChyZWN0LnRvcCwgeSwgdG9sZXJhbmNlKSkgJiZcbiAgICAgICAgKHJlY3QuYm90dG9tID4geSB8fCBhbG1vc3RFcXVhbChyZWN0LmJvdHRvbSwgeSwgdG9sZXJhbmNlKSk7XG59XG5cbmZ1bmN0aW9uIHJlcGxhY2VPdmVybGFwaW5nUmVjdHMocmVjdHMpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlY3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IHJlY3RzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBjb25zdCByZWN0MSA9IHJlY3RzW2ldO1xuICAgICAgICAgICAgY29uc3QgcmVjdDIgPSByZWN0c1tqXTtcbiAgICAgICAgICAgIGlmIChyZWN0MSA9PT0gcmVjdDIpIHtcbiAgICAgICAgICAgICAgICBsb2coXCJyZXBsYWNlT3ZlcmxhcGluZ1JlY3RzIHJlY3QxID09PSByZWN0MiA/PyFcIik7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVjdHNUb3VjaE9yT3ZlcmxhcChyZWN0MSwgcmVjdDIsIC0xKSkge1xuICAgICAgICAgICAgICAgIGxldCB0b0FkZCA9IFtdO1xuICAgICAgICAgICAgICAgIGxldCB0b1JlbW92ZTtcbiAgICAgICAgICAgICAgICBsZXQgdG9QcmVzZXJ2ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdWJ0cmFjdFJlY3RzMSA9IHJlY3RTdWJ0cmFjdChyZWN0MSwgcmVjdDIpO1xuICAgICAgICAgICAgICAgIGlmIChzdWJ0cmFjdFJlY3RzMS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9BZGQgPSBzdWJ0cmFjdFJlY3RzMTtcbiAgICAgICAgICAgICAgICAgICAgdG9SZW1vdmUgPSByZWN0MTtcbiAgICAgICAgICAgICAgICAgICAgdG9QcmVzZXJ2ZSA9IHJlY3QyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN1YnRyYWN0UmVjdHMyID0gcmVjdFN1YnRyYWN0KHJlY3QyLCByZWN0MSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdWJ0cmFjdFJlY3RzMS5sZW5ndGggPCBzdWJ0cmFjdFJlY3RzMi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvQWRkID0gc3VidHJhY3RSZWN0czE7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b1JlbW92ZSA9IHJlY3QxO1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9QcmVzZXJ2ZSA9IHJlY3QyO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9BZGQgPSBzdWJ0cmFjdFJlY3RzMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvUmVtb3ZlID0gcmVjdDI7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b1ByZXNlcnZlID0gcmVjdDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbG9nKGBDTElFTlQgUkVDVDogb3ZlcmxhcCwgY3V0IG9uZSByZWN0IGludG8gJHt0b0FkZC5sZW5ndGh9YCk7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3UmVjdHMgPSByZWN0cy5maWx0ZXIoKHJlY3QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlY3QgIT09IHRvUmVtb3ZlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KG5ld1JlY3RzLCB0b0FkZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcGxhY2VPdmVybGFwaW5nUmVjdHMobmV3UmVjdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZWN0cztcbn1cblxuZnVuY3Rpb24gcmVjdFN1YnRyYWN0KHJlY3QxLCByZWN0Mikge1xuICAgIGNvbnN0IHJlY3RJbnRlcnNlY3RlZCA9IHJlY3RJbnRlcnNlY3QocmVjdDIsIHJlY3QxKTtcbiAgICBpZiAocmVjdEludGVyc2VjdGVkLmhlaWdodCA9PT0gMCB8fCByZWN0SW50ZXJzZWN0ZWQud2lkdGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFtyZWN0MV07XG4gICAgfVxuICAgIGNvbnN0IHJlY3RzID0gW107XG4gICAge1xuICAgICAgICBjb25zdCByZWN0QSA9IHtcbiAgICAgICAgICAgIGJvdHRvbTogcmVjdDEuYm90dG9tLFxuICAgICAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICAgICAgbGVmdDogcmVjdDEubGVmdCxcbiAgICAgICAgICAgIHJpZ2h0OiByZWN0SW50ZXJzZWN0ZWQubGVmdCxcbiAgICAgICAgICAgIHRvcDogcmVjdDEudG9wLFxuICAgICAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgIH07XG4gICAgICAgIHJlY3RBLndpZHRoID0gcmVjdEEucmlnaHQgLSByZWN0QS5sZWZ0O1xuICAgICAgICByZWN0QS5oZWlnaHQgPSByZWN0QS5ib3R0b20gLSByZWN0QS50b3A7XG4gICAgICAgIGlmIChyZWN0QS5oZWlnaHQgIT09IDAgJiYgcmVjdEEud2lkdGggIT09IDApIHtcbiAgICAgICAgICAgIHJlY3RzLnB1c2gocmVjdEEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHtcbiAgICAgICAgY29uc3QgcmVjdEIgPSB7XG4gICAgICAgICAgICBib3R0b206IHJlY3RJbnRlcnNlY3RlZC50b3AsXG4gICAgICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgICAgICBsZWZ0OiByZWN0SW50ZXJzZWN0ZWQubGVmdCxcbiAgICAgICAgICAgIHJpZ2h0OiByZWN0SW50ZXJzZWN0ZWQucmlnaHQsXG4gICAgICAgICAgICB0b3A6IHJlY3QxLnRvcCxcbiAgICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICB9O1xuICAgICAgICByZWN0Qi53aWR0aCA9IHJlY3RCLnJpZ2h0IC0gcmVjdEIubGVmdDtcbiAgICAgICAgcmVjdEIuaGVpZ2h0ID0gcmVjdEIuYm90dG9tIC0gcmVjdEIudG9wO1xuICAgICAgICBpZiAocmVjdEIuaGVpZ2h0ICE9PSAwICYmIHJlY3RCLndpZHRoICE9PSAwKSB7XG4gICAgICAgICAgICByZWN0cy5wdXNoKHJlY3RCKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB7XG4gICAgICAgIGNvbnN0IHJlY3RDID0ge1xuICAgICAgICAgICAgYm90dG9tOiByZWN0MS5ib3R0b20sXG4gICAgICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgICAgICBsZWZ0OiByZWN0SW50ZXJzZWN0ZWQubGVmdCxcbiAgICAgICAgICAgIHJpZ2h0OiByZWN0SW50ZXJzZWN0ZWQucmlnaHQsXG4gICAgICAgICAgICB0b3A6IHJlY3RJbnRlcnNlY3RlZC5ib3R0b20sXG4gICAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgfTtcbiAgICAgICAgcmVjdEMud2lkdGggPSByZWN0Qy5yaWdodCAtIHJlY3RDLmxlZnQ7XG4gICAgICAgIHJlY3RDLmhlaWdodCA9IHJlY3RDLmJvdHRvbSAtIHJlY3RDLnRvcDtcbiAgICAgICAgaWYgKHJlY3RDLmhlaWdodCAhPT0gMCAmJiByZWN0Qy53aWR0aCAhPT0gMCkge1xuICAgICAgICAgICAgcmVjdHMucHVzaChyZWN0Qyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAge1xuICAgICAgICBjb25zdCByZWN0RCA9IHtcbiAgICAgICAgICAgIGJvdHRvbTogcmVjdDEuYm90dG9tLFxuICAgICAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICAgICAgbGVmdDogcmVjdEludGVyc2VjdGVkLnJpZ2h0LFxuICAgICAgICAgICAgcmlnaHQ6IHJlY3QxLnJpZ2h0LFxuICAgICAgICAgICAgdG9wOiByZWN0MS50b3AsXG4gICAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgfTtcbiAgICAgICAgcmVjdEQud2lkdGggPSByZWN0RC5yaWdodCAtIHJlY3RELmxlZnQ7XG4gICAgICAgIHJlY3RELmhlaWdodCA9IHJlY3RELmJvdHRvbSAtIHJlY3RELnRvcDtcbiAgICAgICAgaWYgKHJlY3RELmhlaWdodCAhPT0gMCAmJiByZWN0RC53aWR0aCAhPT0gMCkge1xuICAgICAgICAgICAgcmVjdHMucHVzaChyZWN0RCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlY3RzO1xufVxuXG5mdW5jdGlvbiByZWN0SW50ZXJzZWN0KHJlY3QxLCByZWN0Mikge1xuICAgIGNvbnN0IG1heExlZnQgPSBNYXRoLm1heChyZWN0MS5sZWZ0LCByZWN0Mi5sZWZ0KTtcbiAgICBjb25zdCBtaW5SaWdodCA9IE1hdGgubWluKHJlY3QxLnJpZ2h0LCByZWN0Mi5yaWdodCk7XG4gICAgY29uc3QgbWF4VG9wID0gTWF0aC5tYXgocmVjdDEudG9wLCByZWN0Mi50b3ApO1xuICAgIGNvbnN0IG1pbkJvdHRvbSA9IE1hdGgubWluKHJlY3QxLmJvdHRvbSwgcmVjdDIuYm90dG9tKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBib3R0b206IG1pbkJvdHRvbSxcbiAgICAgICAgaGVpZ2h0OiBNYXRoLm1heCgwLCBtaW5Cb3R0b20gLSBtYXhUb3ApLFxuICAgICAgICBsZWZ0OiBtYXhMZWZ0LFxuICAgICAgICByaWdodDogbWluUmlnaHQsXG4gICAgICAgIHRvcDogbWF4VG9wLFxuICAgICAgICB3aWR0aDogTWF0aC5tYXgoMCwgbWluUmlnaHQgLSBtYXhMZWZ0KSxcbiAgICB9O1xufVxuXG5mdW5jdGlvbiByZWN0c1RvdWNoT3JPdmVybGFwKHJlY3QxLCByZWN0MiwgdG9sZXJhbmNlKSB7XG4gICAgcmV0dXJuICgocmVjdDEubGVmdCA8IHJlY3QyLnJpZ2h0IHx8ICh0b2xlcmFuY2UgPj0gMCAmJiBhbG1vc3RFcXVhbChyZWN0MS5sZWZ0LCByZWN0Mi5yaWdodCwgdG9sZXJhbmNlKSkpICYmXG4gICAgICAgIChyZWN0Mi5sZWZ0IDwgcmVjdDEucmlnaHQgfHwgKHRvbGVyYW5jZSA+PSAwICYmIGFsbW9zdEVxdWFsKHJlY3QyLmxlZnQsIHJlY3QxLnJpZ2h0LCB0b2xlcmFuY2UpKSkgJiZcbiAgICAgICAgKHJlY3QxLnRvcCA8IHJlY3QyLmJvdHRvbSB8fCAodG9sZXJhbmNlID49IDAgJiYgYWxtb3N0RXF1YWwocmVjdDEudG9wLCByZWN0Mi5ib3R0b20sIHRvbGVyYW5jZSkpKSAmJlxuICAgICAgICAocmVjdDIudG9wIDwgcmVjdDEuYm90dG9tIHx8ICh0b2xlcmFuY2UgPj0gMCAmJiBhbG1vc3RFcXVhbChyZWN0Mi50b3AsIHJlY3QxLmJvdHRvbSwgdG9sZXJhbmNlKSkpKTtcbn1cblxuZnVuY3Rpb24gYWxtb3N0RXF1YWwoYSwgYiwgdG9sZXJhbmNlKSB7XG4gICAgcmV0dXJuIE1hdGguYWJzKGEgLSBiKSA8PSB0b2xlcmFuY2U7XG59XG5cbmZ1bmN0aW9uIGxvZygpIHtcbiAgICBpZiAoZGVidWcpIHtcbiAgICAgICAgbG9nTmF0aXZlLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfVxufSIsIi8vXG4vLyAgQ29weXJpZ2h0IDIwMjEgUmVhZGl1bSBGb3VuZGF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IHRoZSBCU0Qtc3R5bGUgbGljZW5zZVxuLy8gIGF2YWlsYWJsZSBpbiB0aGUgdG9wLWxldmVsIExJQ0VOU0UgZmlsZSBvZiB0aGUgcHJvamVjdC5cbi8vXG5cbmltcG9ydCB7Y29udmVydFJhbmdlSW5mbywgbG9jYXRpb24yUmFuZ2VJbmZvfSBmcm9tIFwiLi9zZWxlY3Rpb25cIjtcbmltcG9ydCB7Z2V0Q2xpZW50UmVjdHNOb092ZXJsYXB9IGZyb20gXCIuL3JlY3RcIjtcbmltcG9ydCB7bG9nfSBmcm9tIFwiLi91dGlsc1wiO1xuXG5jb25zdCBkZWJ1ZyA9IGZhbHNlO1xuXG5jb25zdCBJRF9ISUdITElHSFRTX0NPTlRBSU5FUiA9IFwiUjJfSURfSElHSExJR0hUU19DT05UQUlORVJcIjtcbmNvbnN0IENMQVNTX0hJR0hMSUdIVF9DT05UQUlORVIgPSBcIlIyX0NMQVNTX0hJR0hMSUdIVF9DT05UQUlORVJcIjtcbmNvbnN0IENMQVNTX0hJR0hMSUdIVF9BUkVBID0gXCJSMl9DTEFTU19ISUdITElHSFRfQVJFQVwiO1xuY29uc3QgQ0xBU1NfSElHSExJR0hUX0JPVU5ESU5HX0FSRUEgPSBcIlIyX0NMQVNTX0hJR0hMSUdIVF9CT1VORElOR19BUkVBXCI7XG5cbmNvbnN0IF9oaWdobGlnaHRzID0gW107XG5sZXQgX2hpZ2hsaWdodHNDb250YWluZXI7XG5cbmNvbnN0IGRlZmF1bHRCYWNrZ3JvdW5kT3BhY2l0eSA9IDAuMztcblxuY29uc3QgZGVmYXVsdEJhY2tncm91bmRDb2xvciA9IHtcbiAgICBibHVlOiAxMDAsXG4gICAgZ3JlZW46IDUwLFxuICAgIHJlZDogMjMwLFxufTtcblxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIGZ1bmN0aW9uKCl7IC8vIG9uIHBhZ2UgbG9hZFxuICAgIGNvbnN0IGJvZHkgPSBkb2N1bWVudC5ib2R5O1xuICAgIHZhciBsYXN0U2l6ZSA9IHsgd2lkdGg6IDAsIGhlaWdodDogMCB9XG4gICAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoKCkgPT4ge1xuICAgICAgICBsb2coYm9keS5jbGllbnRXaWR0aCwgYm9keS5jbGllbnRIZWlnaHQpXG4gICAgICAgIGlmIChsYXN0U2l6ZS53aWR0aCA9PT0gYm9keS5jbGllbnRXaWR0aCAmJiBsYXN0U2l6ZS5oZWlnaHQgPT09IGJvZHkuY2xpZW50SGVpZ2h0KSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBsYXN0U2l6ZSA9IHtcbiAgICAgICAgICAgIHdpZHRoOiBib2R5LmNsaWVudFdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBib2R5LmNsaWVudEhlaWdodCxcbiAgICAgICAgfVxuICAgICAgICByZXNldEhpZ2hsaWdodHMoKVxuICAgIH0pXG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZShib2R5KVxuXG59LCBmYWxzZSk7XG5cbmV4cG9ydCBmdW5jdGlvbiByZWN0Rm9ySGlnaGxpZ2h0V2l0aElEKGlkKSB7XG4gICAgY29uc3QgY2xpZW50UmVjdHMgPSBmcmFtZUZvckhpZ2hsaWdodFdpdGhJRChpZCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBzY3JlZW5XaWR0aDogd2luZG93Lm91dGVyV2lkdGgsXG4gICAgICAgIHNjcmVlbkhlaWdodDogd2luZG93Lm91dGVySGVpZ2h0LFxuICAgICAgICBsZWZ0OiBjbGllbnRSZWN0c1swXS5sZWZ0LFxuICAgICAgICB3aWR0aDogY2xpZW50UmVjdHNbMF0ud2lkdGgsXG4gICAgICAgIHRvcDogY2xpZW50UmVjdHNbMF0udG9wLFxuICAgICAgICBoZWlnaHQ6IGNsaWVudFJlY3RzWzBdLmhlaWdodFxuICAgIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZXN0cm95QWxsSGlnaGxpZ2h0cygpIHtcbiAgICBoaWRlQWxsSGlnaGxpZ2h0cygpO1xuICAgIF9oaWdobGlnaHRzLnNwbGljZSgwLCBfaGlnaGxpZ2h0cy5sZW5ndGgpO1xufVxuXG5mdW5jdGlvbiBoaWRlQWxsSGlnaGxpZ2h0cygpIHtcbiAgICBpZiAoX2hpZ2hsaWdodHNDb250YWluZXIpIHtcbiAgICAgICAgX2hpZ2hsaWdodHNDb250YWluZXIucmVtb3ZlKCk7XG4gICAgICAgIF9oaWdobGlnaHRzQ29udGFpbmVyID0gbnVsbDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHJlc2V0SGlnaGxpZ2h0cygpIHtcbiAgICBoaWRlQWxsSGlnaGxpZ2h0cygpXG5cbiAgICBmb3IgKGNvbnN0IGhpZ2hsaWdodCBvZiBfaGlnaGxpZ2h0cykge1xuICAgICAgICBjcmVhdGVIaWdobGlnaHRET00oaGlnaGxpZ2h0KVxuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUhpZ2hsaWdodFJhbmdlKHJhbmdlKSB7XG5cbiAgICAvLyBGSVhNRTogVXNlIHVzZXItcHJvdmlkZWQgSUQuXG4gICAgbGV0IGlkID0gXCJSMl9ISUdITElHSFRfXCIgKyBEYXRlLm5vdygpO1xuXG4gICAgZGVzdHJveUhpZ2hsaWdodChpZCk7XG5cbiAgICBjb25zdCBoaWdobGlnaHQgPSB7XG4gICAgICAgIGNvbG9yOiBkZWZhdWx0QmFja2dyb3VuZENvbG9yLFxuICAgICAgICBpZCxcbiAgICAgICAgcG9pbnRlckludGVyYWN0aW9uOiB0cnVlLFxuICAgICAgICByYW5nZTogcmFuZ2UsXG4gICAgfTtcbiAgICBfaGlnaGxpZ2h0cy5wdXNoKGhpZ2hsaWdodCk7XG4gICAgY3JlYXRlSGlnaGxpZ2h0RE9NKGhpZ2hsaWdodCk7XG5cbiAgICByZXR1cm4gaGlnaGxpZ2h0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlSGlnaGxpZ2h0KGxvY2F0aW9ucywgY29sb3IsIHBvaW50ZXJJbnRlcmFjdGlvbikge1xuICAgIGNvbnN0IHJhbmdlSW5mbyA9IGxvY2F0aW9uMlJhbmdlSW5mbyhsb2NhdGlvbnMpXG5cbiAgICAvLyBGSVhNRTogVXNlIHVzZXItcHJvdmlkZWQgSUQuXG4gICAgbGV0IGlkID0gXCJSMl9ISUdITElHSFRfXCIgKyBEYXRlLm5vdygpO1xuXG4gICAgZGVzdHJveUhpZ2hsaWdodChpZCk7XG5cbiAgICBjb25zdCBoaWdobGlnaHQgPSB7XG4gICAgICAgIGNvbG9yOiBjb2xvciA/IGNvbG9yIDogZGVmYXVsdEJhY2tncm91bmRDb2xvcixcbiAgICAgICAgaWQsXG4gICAgICAgIHBvaW50ZXJJbnRlcmFjdGlvbixcbiAgICAgICAgcmFuZ2U6IGNvbnZlcnRSYW5nZUluZm8oZG9jdW1lbnQsIHJhbmdlSW5mbyksXG4gICAgfTtcbiAgICBfaGlnaGxpZ2h0cy5wdXNoKGhpZ2hsaWdodCk7XG4gICAgY3JlYXRlSGlnaGxpZ2h0RE9NKGhpZ2hsaWdodCk7XG5cbiAgICByZXR1cm4gaGlnaGxpZ2h0O1xufVxuXG5mdW5jdGlvbiBkZXN0cm95SGlnaGxpZ2h0KGlkKSB7XG4gICAgbGV0IGkgPSAtMTtcbiAgICBsZXQgX2RvY3VtZW50ID0gd2luZG93LmRvY3VtZW50XG4gICAgY29uc3QgaGlnaGxpZ2h0ID0gX2hpZ2hsaWdodHMuZmluZCgoaCwgaikgPT4ge1xuICAgICAgICBpID0gajtcbiAgICAgICAgcmV0dXJuIGguaWQgPT09IGlkO1xuICAgIH0pO1xuICAgIGlmIChoaWdobGlnaHQgJiYgaSA+PSAwICYmIGkgPCBfaGlnaGxpZ2h0cy5sZW5ndGgpIHtcbiAgICAgICAgX2hpZ2hsaWdodHMuc3BsaWNlKGksIDEpO1xuICAgIH1cbiAgICBjb25zdCBoaWdobGlnaHRDb250YWluZXIgPSBfZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpO1xuICAgIGlmIChoaWdobGlnaHRDb250YWluZXIpIHtcbiAgICAgICAgaGlnaGxpZ2h0Q29udGFpbmVyLnJlbW92ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlSGlnaGxpZ2h0RE9NKGhpZ2hsaWdodCkge1xuICAgIGlmICghaGlnaGxpZ2h0LnJhbmdlKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgY29uc3Qgc2NhbGUgPSAxIC8gKCh3aW5kb3cuUkVBRElVTTIgJiYgd2luZG93LlJFQURJVU0yLmlzRml4ZWRMYXlvdXQpID8gd2luZG93LlJFQURJVU0yLmZ4bFZpZXdwb3J0U2NhbGUgOiAxKTtcblxuICAgIGNvbnN0IHNjcm9sbEVsZW1lbnQgPSBkb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50O1xuXG4gICAgY29uc3QgcGFnaW5hdGVkID0gIWlzU2Nyb2xsTW9kZUVuYWJsZWQoKVxuICAgIGNvbnN0IGhpZ2hsaWdodHNDb250YWluZXIgPSBlbnN1cmVDb250YWluZXIod2luZG93KTtcbiAgICBjb25zdCBoaWdobGlnaHRQYXJlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXG4gICAgaGlnaGxpZ2h0UGFyZW50LnNldEF0dHJpYnV0ZShcImlkXCIsIGhpZ2hsaWdodC5pZCk7XG4gICAgaGlnaGxpZ2h0UGFyZW50LnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIENMQVNTX0hJR0hMSUdIVF9DT05UQUlORVIpO1xuXG4gICAgaGlnaGxpZ2h0UGFyZW50LnN0eWxlLnNldFByb3BlcnR5KFwicG9pbnRlci1ldmVudHNcIiwgXCJub25lXCIpO1xuICAgIGlmIChoaWdobGlnaHQucG9pbnRlckludGVyYWN0aW9uKSB7XG4gICAgICAgIGhpZ2hsaWdodFBhcmVudC5zZXRBdHRyaWJ1dGUoXCJkYXRhLWNsaWNrXCIsIFwiMVwiKTtcbiAgICB9XG5cbiAgICBjb25zdCBib2R5UmVjdCA9IGRvY3VtZW50LmJvZHkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3QgZHJhd1VuZGVybGluZSA9IGZhbHNlO1xuICAgIGNvbnN0IGRyYXdTdHJpa2VUaHJvdWdoID0gZmFsc2U7XG4gICAgY29uc3QgZG9Ob3RNZXJnZUhvcml6b250YWxseUFsaWduZWRSZWN0cyA9IGRyYXdVbmRlcmxpbmUgfHwgZHJhd1N0cmlrZVRocm91Z2g7XG4gICAgY29uc3QgY2xpZW50UmVjdHMgPSBnZXRDbGllbnRSZWN0c05vT3ZlcmxhcChoaWdobGlnaHQucmFuZ2UsIGRvTm90TWVyZ2VIb3Jpem9udGFsbHlBbGlnbmVkUmVjdHMpO1xuICAgIGNvbnN0IHJvdW5kZWRDb3JuZXIgPSAzO1xuICAgIGNvbnN0IHVuZGVybGluZVRoaWNrbmVzcyA9IDI7XG4gICAgY29uc3Qgc3RyaWtlVGhyb3VnaExpbmVUaGlja25lc3MgPSAzO1xuICAgIGNvbnN0IG9wYWNpdHkgPSBkZWZhdWx0QmFja2dyb3VuZE9wYWNpdHk7XG4gICAgbGV0IGV4dHJhID0gXCJcIjtcblxuICAgIGxldCB4T2Zmc2V0ID0gcGFnaW5hdGVkID8gKC1zY3JvbGxFbGVtZW50LnNjcm9sbExlZnQpIDogYm9keVJlY3QubGVmdDtcbiAgICBsZXQgeU9mZnNldCA9IHBhZ2luYXRlZCA/ICgtc2Nyb2xsRWxlbWVudC5zY3JvbGxUb3ApIDogYm9keVJlY3QudG9wO1xuXG4gICAgZm9yIChjb25zdCBjbGllbnRSZWN0IG9mIGNsaWVudFJlY3RzKSB7XG4gICAgICAgIGNvbnN0IGhpZ2hsaWdodEFyZWEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXG4gICAgICAgIGhpZ2hsaWdodEFyZWEuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgQ0xBU1NfSElHSExJR0hUX0FSRUEpO1xuXG4gICAgICAgIGlmIChkZWJ1Zykge1xuICAgICAgICAgICAgY29uc3QgcmdiID0gTWF0aC5yb3VuZCgweGZmZmZmZiAqIE1hdGgucmFuZG9tKCkpO1xuICAgICAgICAgICAgY29uc3QgciA9IHJnYiA+PiAxNjtcbiAgICAgICAgICAgIGNvbnN0IGcgPSByZ2IgPj4gOCAmIDI1NTtcbiAgICAgICAgICAgIGNvbnN0IGIgPSByZ2IgJiAyNTU7XG4gICAgICAgICAgICBleHRyYSA9IGBvdXRsaW5lLWNvbG9yOiByZ2IoJHtyfSwgJHtnfSwgJHtifSk7IG91dGxpbmUtc3R5bGU6IHNvbGlkOyBvdXRsaW5lLXdpZHRoOiAxcHg7IG91dGxpbmUtb2Zmc2V0OiAtMXB4O2A7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoZHJhd1VuZGVybGluZSkge1xuICAgICAgICAgICAgICAgIGV4dHJhICs9IGBib3JkZXItYm90dG9tOiAke3VuZGVybGluZVRoaWNrbmVzcyAqIHNjYWxlfXB4IHNvbGlkIHJnYmEoJHtoaWdobGlnaHQuY29sb3IucmVkfSwgJHtoaWdobGlnaHQuY29sb3IuZ3JlZW59LCAke2hpZ2hsaWdodC5jb2xvci5ibHVlfSwgJHtvcGFjaXR5fSkgIWltcG9ydGFudGA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaGlnaGxpZ2h0QXJlYS5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBgYm9yZGVyLXJhZGl1czogJHtyb3VuZGVkQ29ybmVyfXB4ICFpbXBvcnRhbnQ7IGJhY2tncm91bmQtY29sb3I6IHJnYmEoJHtoaWdobGlnaHQuY29sb3IucmVkfSwgJHtoaWdobGlnaHQuY29sb3IuZ3JlZW59LCAke2hpZ2hsaWdodC5jb2xvci5ibHVlfSwgJHtvcGFjaXR5fSkgIWltcG9ydGFudDsgJHtleHRyYX1gKTtcbiAgICAgICAgaGlnaGxpZ2h0QXJlYS5zdHlsZS5zZXRQcm9wZXJ0eShcInBvaW50ZXItZXZlbnRzXCIsIFwibm9uZVwiKTtcbiAgICAgICAgaGlnaGxpZ2h0QXJlYS5zdHlsZS5wb3NpdGlvbiA9ICFwYWdpbmF0ZWQgPyBcImZpeGVkXCIgOiBcImFic29sdXRlXCI7XG4gICAgICAgIGhpZ2hsaWdodEFyZWEuc2NhbGUgPSBzY2FsZTtcbiAgICAgICAgLypcbiAgICAgICAgIGhpZ2hsaWdodEFyZWEucmVjdCA9IHtcbiAgICAgICAgIGhlaWdodDogY2xpZW50UmVjdC5oZWlnaHQsXG4gICAgICAgICBsZWZ0OiBjbGllbnRSZWN0LmxlZnQgLSB4T2Zmc2V0LFxuICAgICAgICAgdG9wOiBjbGllbnRSZWN0LnRvcCAtIHlPZmZzZXQsXG4gICAgICAgICB3aWR0aDogY2xpZW50UmVjdC53aWR0aCxcbiAgICAgICAgIH07XG4gICAgICAgICAqL1xuICAgICAgICBoaWdobGlnaHRBcmVhLnJlY3QgPSB7XG4gICAgICAgICAgICBoZWlnaHQ6IGNsaWVudFJlY3QuaGVpZ2h0LFxuICAgICAgICAgICAgbGVmdDogY2xpZW50UmVjdC5sZWZ0IC0geE9mZnNldCxcbiAgICAgICAgICAgIHRvcDogY2xpZW50UmVjdC50b3AgLSB5T2Zmc2V0LFxuICAgICAgICAgICAgd2lkdGg6IGNsaWVudFJlY3Qud2lkdGhcbiAgICAgICAgfTtcblxuICAgICAgICBoaWdobGlnaHRBcmVhLnN0eWxlLndpZHRoID0gYCR7aGlnaGxpZ2h0QXJlYS5yZWN0LndpZHRoICogc2NhbGV9cHhgO1xuICAgICAgICBoaWdobGlnaHRBcmVhLnN0eWxlLmhlaWdodCA9IGAke2hpZ2hsaWdodEFyZWEucmVjdC5oZWlnaHQgKiBzY2FsZX1weGA7XG4gICAgICAgIGhpZ2hsaWdodEFyZWEuc3R5bGUubGVmdCA9IGAke2hpZ2hsaWdodEFyZWEucmVjdC5sZWZ0ICogc2NhbGV9cHhgO1xuICAgICAgICBoaWdobGlnaHRBcmVhLnN0eWxlLnRvcCA9IGAke2hpZ2hsaWdodEFyZWEucmVjdC50b3AgKiBzY2FsZX1weGA7XG4gICAgICAgIGhpZ2hsaWdodFBhcmVudC5hcHBlbmQoaGlnaGxpZ2h0QXJlYSk7XG4gICAgICAgIGlmICghZGVidWcgJiYgZHJhd1N0cmlrZVRocm91Z2gpIHtcbiAgICAgICAgICAgIC8vaWYgKGRyYXdTdHJpa2VUaHJvdWdoKSB7XG4gICAgICAgICAgICBjb25zdCBoaWdobGlnaHRBcmVhTGluZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICBoaWdobGlnaHRBcmVhTGluZS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBDTEFTU19ISUdITElHSFRfQVJFQSk7XG5cbiAgICAgICAgICAgIGhpZ2hsaWdodEFyZWFMaW5lLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIGBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKCR7aGlnaGxpZ2h0LmNvbG9yLnJlZH0sICR7aGlnaGxpZ2h0LmNvbG9yLmdyZWVufSwgJHtoaWdobGlnaHQuY29sb3IuYmx1ZX0sICR7b3BhY2l0eX0pICFpbXBvcnRhbnQ7YCk7XG4gICAgICAgICAgICBoaWdobGlnaHRBcmVhTGluZS5zdHlsZS5zZXRQcm9wZXJ0eShcInBvaW50ZXItZXZlbnRzXCIsIFwibm9uZVwiKTtcbiAgICAgICAgICAgIGhpZ2hsaWdodEFyZWFMaW5lLnN0eWxlLnBvc2l0aW9uID0gcGFnaW5hdGVkID8gXCJmaXhlZFwiIDogXCJhYnNvbHV0ZVwiO1xuICAgICAgICAgICAgaGlnaGxpZ2h0QXJlYUxpbmUuc2NhbGUgPSBzY2FsZTtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgaGlnaGxpZ2h0QXJlYUxpbmUucmVjdCA9IHtcbiAgICAgICAgICAgICBoZWlnaHQ6IGNsaWVudFJlY3QuaGVpZ2h0LFxuICAgICAgICAgICAgIGxlZnQ6IGNsaWVudFJlY3QubGVmdCAtIHhPZmZzZXQsXG4gICAgICAgICAgICAgdG9wOiBjbGllbnRSZWN0LnRvcCAtIHlPZmZzZXQsXG4gICAgICAgICAgICAgd2lkdGg6IGNsaWVudFJlY3Qud2lkdGgsXG4gICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICBoaWdobGlnaHRBcmVhTGluZS5yZWN0ID0ge1xuICAgICAgICAgICAgICAgIGhlaWdodDogY2xpZW50UmVjdC5oZWlnaHQsXG4gICAgICAgICAgICAgICAgbGVmdDogY2xpZW50UmVjdC5sZWZ0IC0geE9mZnNldCxcbiAgICAgICAgICAgICAgICB0b3A6IGNsaWVudFJlY3QudG9wIC0geU9mZnNldCxcbiAgICAgICAgICAgICAgICB3aWR0aDogY2xpZW50UmVjdC53aWR0aFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaGlnaGxpZ2h0QXJlYUxpbmUuc3R5bGUud2lkdGggPSBgJHtoaWdobGlnaHRBcmVhTGluZS5yZWN0LndpZHRoICogc2NhbGV9cHhgO1xuICAgICAgICAgICAgaGlnaGxpZ2h0QXJlYUxpbmUuc3R5bGUuaGVpZ2h0ID0gYCR7c3RyaWtlVGhyb3VnaExpbmVUaGlja25lc3MgKiBzY2FsZX1weGA7XG4gICAgICAgICAgICBoaWdobGlnaHRBcmVhTGluZS5zdHlsZS5sZWZ0ID0gYCR7aGlnaGxpZ2h0QXJlYUxpbmUucmVjdC5sZWZ0ICogc2NhbGV9cHhgO1xuICAgICAgICAgICAgaGlnaGxpZ2h0QXJlYUxpbmUuc3R5bGUudG9wID0gYCR7KGhpZ2hsaWdodEFyZWFMaW5lLnJlY3QudG9wICsgKGhpZ2hsaWdodEFyZWFMaW5lLnJlY3QuaGVpZ2h0IC8gMikgLSAoc3RyaWtlVGhyb3VnaExpbmVUaGlja25lc3MgLyAyKSkgKiBzY2FsZX1weGA7XG4gICAgICAgICAgICBoaWdobGlnaHRQYXJlbnQuYXBwZW5kKGhpZ2hsaWdodEFyZWFMaW5lKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGhpZ2hsaWdodEJvdW5kaW5nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBoaWdobGlnaHRCb3VuZGluZy5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBDTEFTU19ISUdITElHSFRfQk9VTkRJTkdfQVJFQSk7XG5cbiAgICBoaWdobGlnaHRCb3VuZGluZy5zdHlsZS5zZXRQcm9wZXJ0eShcInBvaW50ZXItZXZlbnRzXCIsIFwibm9uZVwiKTtcbiAgICBoaWdobGlnaHRCb3VuZGluZy5zdHlsZS5wb3NpdGlvbiA9IHBhZ2luYXRlZCA/IFwiZml4ZWRcIiA6IFwiYWJzb2x1dGVcIjtcbiAgICBoaWdobGlnaHRCb3VuZGluZy5zY2FsZSA9IHNjYWxlO1xuXG4gICAgaWYgKGRlYnVnKSB7XG4gICAgICAgIGhpZ2hsaWdodEJvdW5kaW5nLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIGBvdXRsaW5lLWNvbG9yOiBtYWdlbnRhOyBvdXRsaW5lLXN0eWxlOiBzb2xpZDsgb3V0bGluZS13aWR0aDogMXB4OyBvdXRsaW5lLW9mZnNldDogLTFweDtgKTtcbiAgICB9XG5cbiAgICBjb25zdCByYW5nZUJvdW5kaW5nQ2xpZW50UmVjdCA9IGhpZ2hsaWdodC5yYW5nZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBoaWdobGlnaHRCb3VuZGluZy5yZWN0ID0ge1xuICAgICAgICBoZWlnaHQ6IHJhbmdlQm91bmRpbmdDbGllbnRSZWN0LmhlaWdodCxcbiAgICAgICAgbGVmdDogcmFuZ2VCb3VuZGluZ0NsaWVudFJlY3QubGVmdCAtIHhPZmZzZXQsXG4gICAgICAgIHRvcDogcmFuZ2VCb3VuZGluZ0NsaWVudFJlY3QudG9wIC0geU9mZnNldCxcbiAgICAgICAgd2lkdGg6IHJhbmdlQm91bmRpbmdDbGllbnRSZWN0LndpZHRoXG4gICAgfTtcblxuICAgIGhpZ2hsaWdodEJvdW5kaW5nLnN0eWxlLndpZHRoID0gYCR7aGlnaGxpZ2h0Qm91bmRpbmcucmVjdC53aWR0aCAqIHNjYWxlfXB4YDtcbiAgICBoaWdobGlnaHRCb3VuZGluZy5zdHlsZS5oZWlnaHQgPSBgJHtoaWdobGlnaHRCb3VuZGluZy5yZWN0LmhlaWdodCAqIHNjYWxlfXB4YDtcbiAgICBoaWdobGlnaHRCb3VuZGluZy5zdHlsZS5sZWZ0ID0gYCR7aGlnaGxpZ2h0Qm91bmRpbmcucmVjdC5sZWZ0ICogc2NhbGV9cHhgO1xuICAgIGhpZ2hsaWdodEJvdW5kaW5nLnN0eWxlLnRvcCA9IGAke2hpZ2hsaWdodEJvdW5kaW5nLnJlY3QudG9wICogc2NhbGV9cHhgO1xuXG4gICAgaGlnaGxpZ2h0UGFyZW50LmFwcGVuZChoaWdobGlnaHRCb3VuZGluZyk7XG4gICAgaGlnaGxpZ2h0c0NvbnRhaW5lci5hcHBlbmQoaGlnaGxpZ2h0UGFyZW50KTtcblxuICAgIHJldHVybiBoaWdobGlnaHRQYXJlbnQ7XG59XG5cbmZ1bmN0aW9uIGlzU2Nyb2xsTW9kZUVuYWJsZWQoKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKFwiLS1VU0VSX19zY3JvbGxcIikudG9TdHJpbmcoKS50cmltKCkgPT09ICdyZWFkaXVtLXNjcm9sbC1vbic7XG59XG5cbmZ1bmN0aW9uIGVuc3VyZUNvbnRhaW5lcih3aW4pIHtcbiAgICBjb25zdCBkb2N1bWVudCA9IHdpbi5kb2N1bWVudDtcblxuICAgIGlmICghX2hpZ2hsaWdodHNDb250YWluZXIpIHtcbiAgICAgICAgX2hpZ2hsaWdodHNDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBfaGlnaGxpZ2h0c0NvbnRhaW5lci5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBJRF9ISUdITElHSFRTX0NPTlRBSU5FUik7XG5cbiAgICAgICAgX2hpZ2hsaWdodHNDb250YWluZXIuc3R5bGUuc2V0UHJvcGVydHkoXCJwb2ludGVyLWV2ZW50c1wiLCBcIm5vbmVcIik7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kKF9oaWdobGlnaHRzQ29udGFpbmVyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX2hpZ2hsaWdodHNDb250YWluZXI7XG59XG5cbmZ1bmN0aW9uIGZyYW1lRm9ySGlnaGxpZ2h0V2l0aElEKGlkKSB7XG4gICAgY29uc3QgaGlnaGxpZ2h0ID0gaGlnaGxpZ2h0V2l0aElEKGlkKTtcbiAgICBpZiAoIWhpZ2hsaWdodClcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgaWYgKCFoaWdobGlnaHQucmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cblxuICAgIGNvbnN0IGRyYXdVbmRlcmxpbmUgPSBmYWxzZTtcbiAgICBjb25zdCBkcmF3U3RyaWtlVGhyb3VnaCA9IGZhbHNlO1xuICAgIGNvbnN0IGRvTm90TWVyZ2VIb3Jpem9udGFsbHlBbGlnbmVkUmVjdHMgPSBkcmF3VW5kZXJsaW5lIHx8IGRyYXdTdHJpa2VUaHJvdWdoO1xuICAgIHJldHVybiBnZXRDbGllbnRSZWN0c05vT3ZlcmxhcChoaWdobGlnaHQucmFuZ2UsIGRvTm90TWVyZ2VIb3Jpem9udGFsbHlBbGlnbmVkUmVjdHMpO1xufVxuXG5mdW5jdGlvbiBoaWdobGlnaHRXaXRoSUQoaWQpIHtcbiAgICBsZXQgaSA9IC0xO1xuICAgIHJldHVybiBfaGlnaGxpZ2h0cy5maW5kKChoLCBqKSA9PiB7XG4gICAgICAgIGkgPSBqO1xuICAgICAgICByZXR1cm4gaC5pZCA9PT0gaWQ7XG4gICAgfSlcbn0iLCIvL1xuLy8gIENvcHlyaWdodCAyMDIxIFJlYWRpdW0gRm91bmRhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSB0aGUgQlNELXN0eWxlIGxpY2Vuc2Vcbi8vICBhdmFpbGFibGUgaW4gdGhlIHRvcC1sZXZlbCBMSUNFTlNFIGZpbGUgb2YgdGhlIHByb2plY3QuXG4vL1xuXG4vLyBDYXRjaCBKUyBlcnJvcnMgdG8gbG9nIHRoZW0gaW4gdGhlIGFwcC5cblxuaW1wb3J0IHtUZXh0UXVvdGVBbmNob3J9IGZyb20gXCIuL3ZlbmRvci9oeXBvdGhlc2lzL2FuY2hvcmluZy90eXBlc1wiO1xuaW1wb3J0IHtjcmVhdGVIaWdobGlnaHRSYW5nZX0gZnJvbSBcIi4vaGlnaGxpZ2h0XCI7XG5cbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB3ZWJraXQubWVzc2FnZUhhbmRsZXJzLmxvZ0Vycm9yLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgXCJtZXNzYWdlXCI6IGV2ZW50Lm1lc3NhZ2UsXG4gICAgICAgIFwiZmlsZW5hbWVcIjogZXZlbnQuZmlsZW5hbWUsXG4gICAgICAgIFwibGluZVwiOiBldmVudC5saW5lbm9cbiAgICB9KTtcbn0sIGZhbHNlKTtcblxuLy8gTm90aWZ5IG5hdGl2ZSBjb2RlIHRoYXQgdGhlIHBhZ2UgaGFzIGxvYWRlZC5cbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCBmdW5jdGlvbigpeyAvLyBvbiBwYWdlIGxvYWRcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm9yaWVudGF0aW9uY2hhbmdlXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICBvcmllbnRhdGlvbkNoYW5nZWQoKTtcbiAgICAgICAgc25hcEN1cnJlbnRQb3NpdGlvbigpO1xuICAgIH0pO1xuICAgIG9yaWVudGF0aW9uQ2hhbmdlZCgpO1xufSwgZmFsc2UpO1xuXG52YXIgbGFzdF9rbm93bl9zY3JvbGxYX3Bvc2l0aW9uID0gMDtcbnZhciBsYXN0X2tub3duX3Njcm9sbFlfcG9zaXRpb24gPSAwO1xudmFyIHRpY2tpbmcgPSBmYWxzZTtcbnZhciBtYXhTY3JlZW5YID0gMDtcblxuLy8gUG9zaXRpb24gaW4gcmFuZ2UgWzAgLSAxXS5cbmZ1bmN0aW9uIHVwZGF0ZShwb3NpdGlvbikge1xuICAgIHZhciBwb3NpdGlvblN0cmluZyA9IHBvc2l0aW9uLnRvU3RyaW5nKClcbiAgICB3ZWJraXQubWVzc2FnZUhhbmRsZXJzLnByb2dyZXNzaW9uQ2hhbmdlZC5wb3N0TWVzc2FnZShwb3NpdGlvblN0cmluZyk7XG59XG5cbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBmdW5jdGlvbihlKSB7XG4gICAgbGFzdF9rbm93bl9zY3JvbGxZX3Bvc2l0aW9uID0gd2luZG93LnNjcm9sbFkgLyBkb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50LnNjcm9sbEhlaWdodDtcbiAgICAvLyBVc2luZyBNYXRoLmFicyBiZWNhdXNlIGZvciBSVEwgYm9va3MsIHRoZSB2YWx1ZSB3aWxsIGJlIG5lZ2F0aXZlLlxuICAgIGxhc3Rfa25vd25fc2Nyb2xsWF9wb3NpdGlvbiA9IE1hdGguYWJzKHdpbmRvdy5zY3JvbGxYIC8gZG9jdW1lbnQuc2Nyb2xsaW5nRWxlbWVudC5zY3JvbGxXaWR0aCk7XG5cbiAgICAvLyBXaW5kb3cgaXMgaGlkZGVuXG4gICAgaWYgKGRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnQuc2Nyb2xsV2lkdGggPT09IDAgfHwgZG9jdW1lbnQuc2Nyb2xsaW5nRWxlbWVudC5zY3JvbGxIZWlnaHQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghdGlja2luZykge1xuICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdXBkYXRlKGlzU2Nyb2xsTW9kZUVuYWJsZWQoKSA/IGxhc3Rfa25vd25fc2Nyb2xsWV9wb3NpdGlvbiA6IGxhc3Rfa25vd25fc2Nyb2xsWF9wb3NpdGlvbik7XG4gICAgICAgICAgICB0aWNraW5nID0gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB0aWNraW5nID0gdHJ1ZTtcbn0pO1xuXG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdzZWxlY3Rpb25jaGFuZ2UnLCBkZWJvdW5jZSg1MCwgZnVuY3Rpb24oKSB7XG4gICAgdmFyIGluZm8gPSB7fVxuICAgIHZhciBzZWxlY3Rpb24gPSBkb2N1bWVudC5nZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoc2VsZWN0aW9uICYmIHNlbGVjdGlvbi5yYW5nZUNvdW50ID4gMCkge1xuICAgICAgICB2YXIgcmVjdCA9IHNlbGVjdGlvbi5nZXRSYW5nZUF0KDApLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBpbmZvWyd0ZXh0J10gPSBzZWxlY3Rpb24udG9TdHJpbmcoKS50cmltKCk7XG4gICAgICAgIGluZm9bJ2ZyYW1lJ10gPSB7XG4gICAgICAgICAgICAneCc6IHJlY3QubGVmdCxcbiAgICAgICAgICAgICd5JzogcmVjdC50b3AsXG4gICAgICAgICAgICAnd2lkdGgnOiByZWN0LndpZHRoLFxuICAgICAgICAgICAgJ2hlaWdodCc6IHJlY3QuaGVpZ2h0XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgd2Via2l0Lm1lc3NhZ2VIYW5kbGVycy5zZWxlY3Rpb25DaGFuZ2VkLnBvc3RNZXNzYWdlKGluZm8pO1xufSkpO1xuXG5mdW5jdGlvbiBvcmllbnRhdGlvbkNoYW5nZWQoKSB7XG4gICAgbWF4U2NyZWVuWCA9ICh3aW5kb3cub3JpZW50YXRpb24gPT09IDAgfHwgd2luZG93Lm9yaWVudGF0aW9uID09IDE4MCkgPyBzY3JlZW4ud2lkdGggOiBzY3JlZW4uaGVpZ2h0O1xufVxuXG5mdW5jdGlvbiBpc1Njcm9sbE1vZGVFbmFibGVkKCkge1xuICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShcIi0tVVNFUl9fc2Nyb2xsXCIpLnRvU3RyaW5nKCkudHJpbSgpID09PSAncmVhZGl1bS1zY3JvbGwtb24nO1xufVxuXG4vLyBTY3JvbGwgdG8gdGhlIGdpdmVuIFRhZ0lkIGluIGRvY3VtZW50IGFuZCBzbmFwLlxuZXhwb3J0IGZ1bmN0aW9uIHNjcm9sbFRvSWQoaWQpIHtcbiAgICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKTtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBlbGVtZW50LnNjcm9sbEludG9WaWV3KCk7XG5cbiAgICBpZiAoIWlzU2Nyb2xsTW9kZUVuYWJsZWQoKSkge1xuICAgICAgICB2YXIgY3VycmVudE9mZnNldCA9IHdpbmRvdy5zY3JvbGxYO1xuICAgICAgICB2YXIgcGFnZVdpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgICAgIC8vIEFkZHMgaGFsZiBhIHBhZ2UgdG8gbWFrZSBzdXJlIHdlIGRvbid0IHNuYXAgdG8gdGhlIHByZXZpb3VzIHBhZ2UuXG4gICAgICAgIGRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnQuc2Nyb2xsTGVmdCA9IHNuYXBPZmZzZXQoY3VycmVudE9mZnNldCArIChwYWdlV2lkdGggLyAyKSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG4vLyBQb3NpdGlvbiBtdXN0IGJlIGluIHRoZSByYW5nZSBbMCAtIDFdLCAwLTEwMCUuXG5leHBvcnQgZnVuY3Rpb24gc2Nyb2xsVG9Qb3NpdGlvbihwb3NpdGlvbiwgZGlyKSB7XG4gICAgY29uc29sZS5sb2coXCJTY3JvbGxUb1Bvc2l0aW9uXCIpO1xuICAgIGlmICgocG9zaXRpb24gPCAwKSB8fCAocG9zaXRpb24gPiAxKSkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIkludmFsaWRQb3NpdGlvblwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChpc1Njcm9sbE1vZGVFbmFibGVkKCkpIHtcbiAgICAgICAgdmFyIG9mZnNldCA9IGRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnQuc2Nyb2xsSGVpZ2h0ICogcG9zaXRpb247XG4gICAgICAgIGRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnQuc2Nyb2xsVG9wID0gb2Zmc2V0O1xuICAgICAgICAvLyB3aW5kb3cuc2Nyb2xsVG8oMCwgb2Zmc2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZG9jdW1lbnRXaWR0aCA9IGRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnQuc2Nyb2xsV2lkdGg7XG4gICAgICAgIHZhciBmYWN0b3IgPSAoZGlyID09ICdydGwnKSA/IC0xIDogMTtcbiAgICAgICAgdmFyIG9mZnNldCA9IGRvY3VtZW50V2lkdGggKiBwb3NpdGlvbiAqIGZhY3RvcjtcbiAgICAgICAgZG9jdW1lbnQuc2Nyb2xsaW5nRWxlbWVudC5zY3JvbGxMZWZ0ID0gc25hcE9mZnNldChvZmZzZXQpO1xuICAgIH1cbn1cblxuLy8gU2Nyb2xscyB0byB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiB0aGUgZ2l2ZW4gdGV4dCBzbmlwcGV0LlxuLy9cbi8vIFRoZSBleHBlY3RlZCB0ZXh0IGFyZ3VtZW50IGlzIGEgTG9jYXRvciBUZXh0IG9iamVjdCwgYXMgZGVmaW5lZCBoZXJlOlxuLy8gaHR0cHM6Ly9yZWFkaXVtLm9yZy9hcmNoaXRlY3R1cmUvbW9kZWxzL2xvY2F0b3JzL1xuZXhwb3J0IGZ1bmN0aW9uIHNjcm9sbFRvVGV4dCh0ZXh0KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgbGV0IGFuY2hvciA9IG5ldyBUZXh0UXVvdGVBbmNob3IoZG9jdW1lbnQuYm9keSwgdGV4dC5oaWdobGlnaHQsIHtcbiAgICAgICAgICAgIHByZWZpeDogdGV4dC5iZWZvcmUsXG4gICAgICAgICAgICBzdWZmaXg6IHRleHQuYWZ0ZXIsXG4gICAgICAgIH0pXG5cbiAgICAgICAgc2Nyb2xsVG9SYW5nZShhbmNob3IudG9SYW5nZSgpKVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgbG9nRXhjZXB0aW9uKGUpXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbn1cblxuZnVuY3Rpb24gc2Nyb2xsVG9SYW5nZShyYW5nZSkge1xuICAgIHZhciByZWN0ID0gcmFuZ2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgaWYgKGlzU2Nyb2xsTW9kZUVuYWJsZWQoKSkge1xuICAgICAgICBkb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50LnNjcm9sbFRvcCA9IHJlY3QudG9wICsgd2luZG93LnNjcm9sbFkgLSAod2luZG93LmlubmVySGVpZ2h0IC8gMik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZG9jdW1lbnQuc2Nyb2xsaW5nRWxlbWVudC5zY3JvbGxMZWZ0ID0gcmVjdC5sZWZ0ICsgd2luZG93LnNjcm9sbFg7XG4gICAgICAgIHNuYXBDdXJyZW50UG9zaXRpb24oKTtcbiAgICB9XG4gICAgY3JlYXRlSGlnaGxpZ2h0UmFuZ2UocmFuZ2UpXG59XG5cbi8vIFJldHVybnMgZmFsc2UgaWYgdGhlIHBhZ2UgaXMgYWxyZWFkeSBhdCB0aGUgbGVmdC1tb3N0IHNjcm9sbCBvZmZzZXQuXG5leHBvcnQgZnVuY3Rpb24gc2Nyb2xsTGVmdChkaXIpIHtcbiAgICB2YXIgaXNSVEwgPSAoZGlyID09IFwicnRsXCIpO1xuICAgIHZhciBkb2N1bWVudFdpZHRoID0gZG9jdW1lbnQuc2Nyb2xsaW5nRWxlbWVudC5zY3JvbGxXaWR0aDtcbiAgICB2YXIgcGFnZVdpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgdmFyIG9mZnNldCA9IHdpbmRvdy5zY3JvbGxYIC0gcGFnZVdpZHRoO1xuICAgIHZhciBtaW5PZmZzZXQgPSBpc1JUTCA/IC0oZG9jdW1lbnRXaWR0aCAtIHBhZ2VXaWR0aCkgOiAwO1xuICAgIHJldHVybiBzY3JvbGxUb09mZnNldChNYXRoLm1heChvZmZzZXQsIG1pbk9mZnNldCkpO1xufVxuXG4vLyBSZXR1cm5zIGZhbHNlIGlmIHRoZSBwYWdlIGlzIGFscmVhZHkgYXQgdGhlIHJpZ2h0LW1vc3Qgc2Nyb2xsIG9mZnNldC5cbmV4cG9ydCBmdW5jdGlvbiBzY3JvbGxSaWdodChkaXIpIHtcbiAgICB2YXIgaXNSVEwgPSAoZGlyID09IFwicnRsXCIpO1xuICAgIHZhciBkb2N1bWVudFdpZHRoID0gZG9jdW1lbnQuc2Nyb2xsaW5nRWxlbWVudC5zY3JvbGxXaWR0aDtcbiAgICB2YXIgcGFnZVdpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgdmFyIG9mZnNldCA9IHdpbmRvdy5zY3JvbGxYICsgcGFnZVdpZHRoO1xuICAgIHZhciBtYXhPZmZzZXQgPSBpc1JUTCA/IDAgOiAoZG9jdW1lbnRXaWR0aCAtIHBhZ2VXaWR0aCk7XG4gICAgcmV0dXJuIHNjcm9sbFRvT2Zmc2V0KE1hdGgubWluKG9mZnNldCwgbWF4T2Zmc2V0KSk7XG59XG5cbi8vIFNjcm9sbHMgdG8gdGhlIGdpdmVuIGxlZnQgb2Zmc2V0LlxuLy8gUmV0dXJucyBmYWxzZSBpZiB0aGUgcGFnZSBzY3JvbGwgcG9zaXRpb24gaXMgYWxyZWFkeSBjbG9zZSBlbm91Z2ggdG8gdGhlIGdpdmVuIG9mZnNldC5cbmZ1bmN0aW9uIHNjcm9sbFRvT2Zmc2V0KG9mZnNldCkge1xuICAgIHZhciBjdXJyZW50T2Zmc2V0ID0gd2luZG93LnNjcm9sbFg7XG4gICAgdmFyIHBhZ2VXaWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgIGRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnQuc2Nyb2xsTGVmdCA9IG9mZnNldDtcbiAgICAvLyBJbiBzb21lIGNhc2UgdGhlIHNjcm9sbFggY2Fubm90IHJlYWNoIHRoZSBwb3NpdGlvbiByZXNwZWN0aW5nIHRvIGlubmVyV2lkdGhcbiAgICB2YXIgZGlmZiA9IE1hdGguYWJzKGN1cnJlbnRPZmZzZXQgLSBvZmZzZXQpIC8gcGFnZVdpZHRoO1xuICAgIHJldHVybiAoZGlmZiA+IDAuMDEpO1xufVxuXG4vLyBTbmFwIHRoZSBvZmZzZXQgdG8gdGhlIHNjcmVlbiB3aWR0aCAocGFnZSB3aWR0aCkuXG5mdW5jdGlvbiBzbmFwT2Zmc2V0KG9mZnNldCkge1xuICAgIHZhciB2YWx1ZSA9IG9mZnNldCArIDE7XG5cbiAgICByZXR1cm4gdmFsdWUgLSAodmFsdWUgJSBtYXhTY3JlZW5YKTtcbn1cblxuZnVuY3Rpb24gc25hcEN1cnJlbnRQb3NpdGlvbigpIHtcbiAgICBpZiAoaXNTY3JvbGxNb2RlRW5hYmxlZCgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGN1cnJlbnRPZmZzZXQgPSB3aW5kb3cuc2Nyb2xsWDtcbiAgICB2YXIgY3VycmVudE9mZnNldFNuYXBwZWQgPSBzbmFwT2Zmc2V0KGN1cnJlbnRPZmZzZXQgKyAxKTtcblxuICAgIGRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnQuc2Nyb2xsTGVmdCA9IGN1cnJlbnRPZmZzZXRTbmFwcGVkO1xufVxuXG4vLy8gVXNlciBTZXR0aW5ncy5cblxuLy8gRm9yIHNldHRpbmcgdXNlciBzZXR0aW5nLlxuZXhwb3J0IGZ1bmN0aW9uIHNldFByb3BlcnR5KGtleSwgdmFsdWUpIHtcbiAgICB2YXIgcm9vdCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuICAgIHJvb3Quc3R5bGUuc2V0UHJvcGVydHkoa2V5LCB2YWx1ZSk7XG59XG5cbi8vIEZvciByZW1vdmluZyB1c2VyIHNldHRpbmcuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlUHJvcGVydHkoa2V5KSB7XG4gICAgdmFyIHJvb3QgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cbiAgICByb290LnN0eWxlLnJlbW92ZVByb3BlcnR5KGtleSk7XG59XG5cblxuLy8vIFRvb2xraXRcblxuZnVuY3Rpb24gZGVib3VuY2UoZGVsYXksIGZ1bmMpIHtcbiAgICB2YXIgdGltZW91dDtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIGZ1bmN0aW9uIGNhbGxiYWNrKCkge1xuICAgICAgICAgICAgZnVuYy5hcHBseShzZWxmLCBhcmdzKTtcbiAgICAgICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoY2FsbGJhY2ssIGRlbGF5KTtcbiAgICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbG9nKCkge1xuICAgIHZhciBtZXNzYWdlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKS5qb2luKFwiIFwiKTtcbiAgICB3ZWJraXQubWVzc2FnZUhhbmRsZXJzLmxvZy5wb3N0TWVzc2FnZShtZXNzYWdlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxvZ0V4Y2VwdGlvbihlKSB7XG4gICAgd2Via2l0Lm1lc3NhZ2VIYW5kbGVycy5sb2dFcnJvci5wb3N0TWVzc2FnZSh7XG4gICAgICAgIFwibWVzc2FnZVwiOiBlLm1lc3NhZ2VcbiAgICB9KTtcbn1cbiIsIi8vXG4vLyAgQ29weXJpZ2h0IDIwMjEgUmVhZGl1bSBGb3VuZGF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IHRoZSBCU0Qtc3R5bGUgbGljZW5zZVxuLy8gIGF2YWlsYWJsZSBpbiB0aGUgdG9wLWxldmVsIExJQ0VOU0UgZmlsZSBvZiB0aGUgcHJvamVjdC5cbi8vXG5cbi8vIEJhc2Ugc2NyaXB0IHVzZWQgYnkgYm90aCByZWZsb3dhYmxlIGFuZCBmaXhlZCBsYXlvdXQgcmVzb3VyY2VzLlxuXG5pbXBvcnQgJy4vZ2VzdHVyZXMnXG5pbXBvcnQge3JlbW92ZVByb3BlcnR5LCBzY3JvbGxMZWZ0LCBzY3JvbGxSaWdodCwgc2Nyb2xsVG9JZCwgc2Nyb2xsVG9Qb3NpdGlvbiwgc2Nyb2xsVG9UZXh0LCBzZXRQcm9wZXJ0eX0gZnJvbSBcIi4vdXRpbHNcIjtcbmltcG9ydCB7Z2V0Q3VycmVudFNlbGVjdGlvbkluZm8sIGdldFNlbGVjdGlvblJlY3R9IGZyb20gXCIuL3NlbGVjdGlvblwiO1xuaW1wb3J0IHtjcmVhdGVIaWdobGlnaHQsIGNyZWF0ZUhpZ2hsaWdodFJhbmdlfSBmcm9tIFwiLi9oaWdobGlnaHRcIjtcbmltcG9ydCB7VGV4dFF1b3RlQW5jaG9yfSBmcm9tIFwiLi92ZW5kb3IvaHlwb3RoZXNpcy9hbmNob3JpbmcvdHlwZXNcIjtcblxuXG4vLyBQdWJsaWMgQVBJIHVzZWQgYnkgdGhlIG5hdmlnYXRvci5cbndpbmRvdy5yZWFkaXVtID0ge1xuICAgIC8vIHV0aWxzXG4gICAgJ3Njcm9sbFRvSWQnOiBzY3JvbGxUb0lkLFxuICAgICdzY3JvbGxUb1Bvc2l0aW9uJzogc2Nyb2xsVG9Qb3NpdGlvbixcbiAgICAnc2Nyb2xsVG9UZXh0Jzogc2Nyb2xsVG9UZXh0LFxuICAgICdzY3JvbGxMZWZ0Jzogc2Nyb2xsTGVmdCxcbiAgICAnc2Nyb2xsUmlnaHQnOiBzY3JvbGxSaWdodCxcbiAgICAnc2V0UHJvcGVydHknOiBzZXRQcm9wZXJ0eSxcbiAgICAncmVtb3ZlUHJvcGVydHknOiByZW1vdmVQcm9wZXJ0eSxcblxuICAgIC8vIHNlbGVjdGlvblxuICAgICdnZXRTZWxlY3Rpb25SZWN0JzogZ2V0U2VsZWN0aW9uUmVjdCxcbiAgICAnZ2V0Q3VycmVudFNlbGVjdGlvbkluZm8nOiBnZXRDdXJyZW50U2VsZWN0aW9uSW5mbyxcblxuICAgIC8vIGhpZ2hsaWdodHNcbiAgICAnY3JlYXRlSGlnaGxpZ2h0JzogY3JlYXRlSGlnaGxpZ2h0LFxuICAgICdjcmVhdGVIaWdobGlnaHRSYW5nZSc6IGNyZWF0ZUhpZ2hsaWdodFJhbmdlLFxuXG4gICAgLy8gSHlwb3RoZXNpcycgYW5jaG9yaW5nXG4gICAgJ1RleHRRdW90ZUFuY2hvcic6IFRleHRRdW90ZUFuY2hvcixcbn07IiwiLy9cbi8vICBDb3B5cmlnaHQgMjAyMSBSZWFkaXVtIEZvdW5kYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgdGhlIEJTRC1zdHlsZSBsaWNlbnNlXG4vLyAgYXZhaWxhYmxlIGluIHRoZSB0b3AtbGV2ZWwgTElDRU5TRSBmaWxlIG9mIHRoZSBwcm9qZWN0LlxuLy9cblxuLy8gU2NyaXB0IHVzZWQgZm9yIHJlZmxvd2FibGUgcmVzb3VyY2VzLlxuXG5pbXBvcnQgJy4vaW5kZXgnXG5cbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCBmdW5jdGlvbigpIHtcbiAgLy8gTm90aWZpZXMgbmF0aXZlIGNvZGUgdGhhdCB0aGUgcGFnZSBpcyBsb2FkZWQgYWZ0ZXIgaXQgaXMgcmVuZGVyZWQuXG4gIC8vIFdhaXRpbmcgZm9yIHRoZSBuZXh0IGFuaW1hdGlvbiBmcmFtZSBzZWVtcyB0byBkbyB0aGUgdHJpY2sgdG8gbWFrZSBzdXJlIHRoZSBwYWdlIGlzIGZ1bGx5IHJlbmRlcmVkLlxuICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCkge1xuICAgIHdlYmtpdC5tZXNzYWdlSGFuZGxlcnMuc3ByZWFkTG9hZGVkLnBvc3RNZXNzYWdlKHt9KTtcbiAgfSk7XG5cbiAgLy8gU2V0dXBzIHRoZSBgdmlld3BvcnRgIG1ldGEgdGFnIHRvIGRpc2FibGUgem9vbWluZy5cbiAgbGV0IG1ldGEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibWV0YVwiKTtcbiAgbWV0YS5zZXRBdHRyaWJ1dGUoXCJuYW1lXCIsIFwidmlld3BvcnRcIik7XG4gIG1ldGEuc2V0QXR0cmlidXRlKFwiY29udGVudFwiLCBcIndpZHRoPWRldmljZS13aWR0aCwgaW5pdGlhbC1zY2FsZT0xLjAsIG1heGltdW0tc2NhbGU9MS4wLCB1c2VyLXNjYWxhYmxlPW5vLCBzaHJpbmstdG8tZml0PW5vXCIpO1xuICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKG1ldGEpO1xufSk7XG5cbi8vIEluamVjdHMgUmVhZGl1bSBDU1Mgc3R5bGVzaGVldHMuXG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIGNyZWF0ZUxpbmsobmFtZSkge1xuICAgIHZhciBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGluaycpO1xuICAgIGxpbmsuc2V0QXR0cmlidXRlKCdyZWwnLCAnc3R5bGVzaGVldCcpO1xuICAgIGxpbmsuc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RleHQvY3NzJyk7XG4gICAgbGluay5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCB3aW5kb3cucmVhZGl1bUNTU0Jhc2VVUkwgKyBuYW1lICsgJy5jc3MnKTtcbiAgICByZXR1cm4gbGluaztcbiAgfVxuXG4gIHZhciBoZWFkID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXTtcbiAgaGVhZC5hcHBlbmRDaGlsZChjcmVhdGVMaW5rKCdSZWFkaXVtQ1NTLWFmdGVyJykpO1xuICBoZWFkLmluc2VydEJlZm9yZShjcmVhdGVMaW5rKCdSZWFkaXVtQ1NTLWJlZm9yZScpLCBoZWFkLmNoaWxkcmVuWzBdKTtcbn0pO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///332\n')}},__webpack_module_cache__={};function __webpack_require__(n){var g=__webpack_module_cache__[n];if(void 0!==g)return g.exports;var t=__webpack_module_cache__[n]={exports:{}};return __webpack_modules__[n](t,t.exports,__webpack_require__),t.exports}var __webpack_exports__=__webpack_require__(332)})();