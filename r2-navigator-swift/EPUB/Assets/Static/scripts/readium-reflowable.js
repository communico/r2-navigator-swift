(()=>{var __webpack_modules__={89:(__unused_webpack_module,exports)=>{"use strict";eval('var __webpack_unused_export__;\n\n/**\n * Implementation of Myers\' online approximate string matching algorithm [1],\n * with additional optimizations suggested by [2].\n *\n * This has O((k/w) * n) complexity where `n` is the length of the text, `k` is\n * the maximum number of errors allowed (always <= the pattern length) and `w`\n * is the word size. Because JS only supports bitwise operations on 32 bit\n * integers, `w` is 32.\n *\n * As far as I am aware, there aren\'t any online algorithms which are\n * significantly better for a wide range of input parameters. The problem can be\n * solved faster using "filter then verify" approaches which first filter out\n * regions of the text that cannot match using a "cheap" check and then verify\n * the remaining potential matches. The verify step requires an algorithm such\n * as this one however.\n *\n * The algorithm\'s approach is essentially to optimize the classic dynamic\n * programming solution to the problem by computing columns of the matrix in\n * word-sized chunks (ie. dealing with 32 chars of the pattern at a time) and\n * avoiding calculating regions of the matrix where the minimum error count is\n * guaranteed to exceed the input threshold.\n *\n * The paper consists of two parts, the first describes the core algorithm for\n * matching patterns <= the size of a word (implemented by `advanceBlock` here).\n * The second uses the core algorithm as part of a larger block-based algorithm\n * to handle longer patterns.\n *\n * [1] G. Myers, “A Fast Bit-Vector Algorithm for Approximate String Matching\n * Based on Dynamic Programming,” vol. 46, no. 3, pp. 395–415, 1999.\n *\n * [2] Šošić, M. (2014). An simd dynamic programming c/c++ library (Doctoral\n * dissertation, Fakultet Elektrotehnike i računarstva, Sveučilište u Zagrebu).\n */\n__webpack_unused_export__ = ({ value: true });\nfunction reverse(s) {\n    return s\n        .split("")\n        .reverse()\n        .join("");\n}\n/**\n * Given the ends of approximate matches for `pattern` in `text`, find\n * the start of the matches.\n *\n * @param findEndFn - Function for finding the end of matches in\n * text.\n * @return Matches with the `start` property set.\n */\nfunction findMatchStarts(text, pattern, matches) {\n    var patRev = reverse(pattern);\n    return matches.map(function (m) {\n        // Find start of each match by reversing the pattern and matching segment\n        // of text and searching for an approx match with the same number of\n        // errors.\n        var minStart = Math.max(0, m.end - pattern.length - m.errors);\n        var textRev = reverse(text.slice(minStart, m.end));\n        // If there are multiple possible start points, choose the one that\n        // maximizes the length of the match.\n        var start = findMatchEnds(textRev, patRev, m.errors).reduce(function (min, rm) {\n            if (m.end - rm.end < min) {\n                return m.end - rm.end;\n            }\n            return min;\n        }, m.end);\n        return {\n            start: start,\n            end: m.end,\n            errors: m.errors\n        };\n    });\n}\n/**\n * Return 1 if a number is non-zero or zero otherwise, without using\n * conditional operators.\n *\n * This should get inlined into `advanceBlock` below by the JIT.\n *\n * Adapted from https://stackoverflow.com/a/3912218/434243\n */\nfunction oneIfNotZero(n) {\n    return ((n | -n) >> 31) & 1;\n}\n/**\n * Block calculation step of the algorithm.\n *\n * From Fig 8. on p. 408 of [1], additionally optimized to replace conditional\n * checks with bitwise operations as per Section 4.2.3 of [2].\n *\n * @param ctx - The pattern context object\n * @param peq - The `peq` array for the current character (`ctx.peq.get(ch)`)\n * @param b - The block level\n * @param hIn - Horizontal input delta ∈ {1,0,-1}\n * @return Horizontal output delta ∈ {1,0,-1}\n */\nfunction advanceBlock(ctx, peq, b, hIn) {\n    var pV = ctx.P[b];\n    var mV = ctx.M[b];\n    var hInIsNegative = hIn >>> 31; // 1 if hIn < 0 or 0 otherwise.\n    var eq = peq[b] | hInIsNegative;\n    // Step 1: Compute horizontal deltas.\n    var xV = eq | mV;\n    var xH = (((eq & pV) + pV) ^ pV) | eq;\n    var pH = mV | ~(xH | pV);\n    var mH = pV & xH;\n    // Step 2: Update score (value of last row of this block).\n    var hOut = oneIfNotZero(pH & ctx.lastRowMask[b]) -\n        oneIfNotZero(mH & ctx.lastRowMask[b]);\n    // Step 3: Update vertical deltas for use when processing next char.\n    pH <<= 1;\n    mH <<= 1;\n    mH |= hInIsNegative;\n    pH |= oneIfNotZero(hIn) - hInIsNegative; // set pH[0] if hIn > 0\n    pV = mH | ~(xV | pH);\n    mV = pH & xV;\n    ctx.P[b] = pV;\n    ctx.M[b] = mV;\n    return hOut;\n}\n/**\n * Find the ends and error counts for matches of `pattern` in `text`.\n *\n * Only the matches with the lowest error count are reported. Other matches\n * with error counts <= maxErrors are discarded.\n *\n * This is the block-based search algorithm from Fig. 9 on p.410 of [1].\n */\nfunction findMatchEnds(text, pattern, maxErrors) {\n    if (pattern.length === 0) {\n        return [];\n    }\n    // Clamp error count so we can rely on the `maxErrors` and `pattern.length`\n    // rows being in the same block below.\n    maxErrors = Math.min(maxErrors, pattern.length);\n    var matches = [];\n    // Word size.\n    var w = 32;\n    // Index of maximum block level.\n    var bMax = Math.ceil(pattern.length / w) - 1;\n    // Context used across block calculations.\n    var ctx = {\n        P: new Uint32Array(bMax + 1),\n        M: new Uint32Array(bMax + 1),\n        lastRowMask: new Uint32Array(bMax + 1)\n    };\n    ctx.lastRowMask.fill(1 << 31);\n    ctx.lastRowMask[bMax] = 1 << (pattern.length - 1) % w;\n    // Dummy "peq" array for chars in the text which do not occur in the pattern.\n    var emptyPeq = new Uint32Array(bMax + 1);\n    // Map of UTF-16 character code to bit vector indicating positions in the\n    // pattern that equal that character.\n    var peq = new Map();\n    // Version of `peq` that only stores mappings for small characters. This\n    // allows faster lookups when iterating through the text because a simple\n    // array lookup can be done instead of a hash table lookup.\n    var asciiPeq = [];\n    for (var i = 0; i < 256; i++) {\n        asciiPeq.push(emptyPeq);\n    }\n    // Calculate `ctx.peq` - a map of character values to bitmasks indicating\n    // positions of that character within the pattern, where each bit represents\n    // a position in the pattern.\n    for (var c = 0; c < pattern.length; c += 1) {\n        var val = pattern.charCodeAt(c);\n        if (peq.has(val)) {\n            // Duplicate char in pattern.\n            continue;\n        }\n        var charPeq = new Uint32Array(bMax + 1);\n        peq.set(val, charPeq);\n        if (val < asciiPeq.length) {\n            asciiPeq[val] = charPeq;\n        }\n        for (var b = 0; b <= bMax; b += 1) {\n            charPeq[b] = 0;\n            // Set all the bits where the pattern matches the current char (ch).\n            // For indexes beyond the end of the pattern, always set the bit as if the\n            // pattern contained a wildcard char in that position.\n            for (var r = 0; r < w; r += 1) {\n                var idx = b * w + r;\n                if (idx >= pattern.length) {\n                    continue;\n                }\n                var match = pattern.charCodeAt(idx) === val;\n                if (match) {\n                    charPeq[b] |= 1 << r;\n                }\n            }\n        }\n    }\n    // Index of last-active block level in the column.\n    var y = Math.max(0, Math.ceil(maxErrors / w) - 1);\n    // Initialize maximum error count at bottom of each block.\n    var score = new Uint32Array(bMax + 1);\n    for (var b = 0; b <= y; b += 1) {\n        score[b] = (b + 1) * w;\n    }\n    score[bMax] = pattern.length;\n    // Initialize vertical deltas for each block.\n    for (var b = 0; b <= y; b += 1) {\n        ctx.P[b] = ~0;\n        ctx.M[b] = 0;\n    }\n    // Process each char of the text, computing the error count for `w` chars of\n    // the pattern at a time.\n    for (var j = 0; j < text.length; j += 1) {\n        // Lookup the bitmask representing the positions of the current char from\n        // the text within the pattern.\n        var charCode = text.charCodeAt(j);\n        var charPeq = void 0;\n        if (charCode < asciiPeq.length) {\n            // Fast array lookup.\n            charPeq = asciiPeq[charCode];\n        }\n        else {\n            // Slower hash table lookup.\n            charPeq = peq.get(charCode);\n            if (typeof charPeq === "undefined") {\n                charPeq = emptyPeq;\n            }\n        }\n        // Calculate error count for blocks that we definitely have to process for\n        // this column.\n        var carry = 0;\n        for (var b = 0; b <= y; b += 1) {\n            carry = advanceBlock(ctx, charPeq, b, carry);\n            score[b] += carry;\n        }\n        // Check if we also need to compute an additional block, or if we can reduce\n        // the number of blocks processed for the next column.\n        if (score[y] - carry <= maxErrors &&\n            y < bMax &&\n            (charPeq[y + 1] & 1 || carry < 0)) {\n            // Error count for bottom block is under threshold, increase the number of\n            // blocks processed for this column & next by 1.\n            y += 1;\n            ctx.P[y] = ~0;\n            ctx.M[y] = 0;\n            var maxBlockScore = y === bMax ? pattern.length % w : w;\n            score[y] =\n                score[y - 1] +\n                    maxBlockScore -\n                    carry +\n                    advanceBlock(ctx, charPeq, y, carry);\n        }\n        else {\n            // Error count for bottom block exceeds threshold, reduce the number of\n            // blocks processed for the next column.\n            while (y > 0 && score[y] >= maxErrors + w) {\n                y -= 1;\n            }\n        }\n        // If error count is under threshold, report a match.\n        if (y === bMax && score[y] <= maxErrors) {\n            if (score[y] < maxErrors) {\n                // Discard any earlier, worse matches.\n                matches.splice(0, matches.length);\n            }\n            matches.push({\n                start: -1,\n                end: j + 1,\n                errors: score[y]\n            });\n            // Because `search` only reports the matches with the lowest error count,\n            // we can "ratchet down" the max error threshold whenever a match is\n            // encountered and thereby save a small amount of work for the remainder\n            // of the text.\n            maxErrors = score[y];\n        }\n    }\n    return matches;\n}\n/**\n * Search for matches for `pattern` in `text` allowing up to `maxErrors` errors.\n *\n * Returns the start, and end positions and error counts for each lowest-cost\n * match. Only the "best" matches are returned.\n */\nfunction search(text, pattern, maxErrors) {\n    var matches = findMatchEnds(text, pattern, maxErrors);\n    return findMatchStarts(text, pattern, matches);\n}\nexports.Z = search;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFkaXVtLWpzLy4vbm9kZV9tb2R1bGVzL2FwcHJveC1zdHJpbmctbWF0Y2gvZGlzdC9pbmRleC5qcz83MjMwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QyxDQUFDLGNBQWMsQ0FBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsb0JBQW9CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFdBQVc7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsT0FBTztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixRQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBZSIsImZpbGUiOiI4OS5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBJbXBsZW1lbnRhdGlvbiBvZiBNeWVycycgb25saW5lIGFwcHJveGltYXRlIHN0cmluZyBtYXRjaGluZyBhbGdvcml0aG0gWzFdLFxuICogd2l0aCBhZGRpdGlvbmFsIG9wdGltaXphdGlvbnMgc3VnZ2VzdGVkIGJ5IFsyXS5cbiAqXG4gKiBUaGlzIGhhcyBPKChrL3cpICogbikgY29tcGxleGl0eSB3aGVyZSBgbmAgaXMgdGhlIGxlbmd0aCBvZiB0aGUgdGV4dCwgYGtgIGlzXG4gKiB0aGUgbWF4aW11bSBudW1iZXIgb2YgZXJyb3JzIGFsbG93ZWQgKGFsd2F5cyA8PSB0aGUgcGF0dGVybiBsZW5ndGgpIGFuZCBgd2BcbiAqIGlzIHRoZSB3b3JkIHNpemUuIEJlY2F1c2UgSlMgb25seSBzdXBwb3J0cyBiaXR3aXNlIG9wZXJhdGlvbnMgb24gMzIgYml0XG4gKiBpbnRlZ2VycywgYHdgIGlzIDMyLlxuICpcbiAqIEFzIGZhciBhcyBJIGFtIGF3YXJlLCB0aGVyZSBhcmVuJ3QgYW55IG9ubGluZSBhbGdvcml0aG1zIHdoaWNoIGFyZVxuICogc2lnbmlmaWNhbnRseSBiZXR0ZXIgZm9yIGEgd2lkZSByYW5nZSBvZiBpbnB1dCBwYXJhbWV0ZXJzLiBUaGUgcHJvYmxlbSBjYW4gYmVcbiAqIHNvbHZlZCBmYXN0ZXIgdXNpbmcgXCJmaWx0ZXIgdGhlbiB2ZXJpZnlcIiBhcHByb2FjaGVzIHdoaWNoIGZpcnN0IGZpbHRlciBvdXRcbiAqIHJlZ2lvbnMgb2YgdGhlIHRleHQgdGhhdCBjYW5ub3QgbWF0Y2ggdXNpbmcgYSBcImNoZWFwXCIgY2hlY2sgYW5kIHRoZW4gdmVyaWZ5XG4gKiB0aGUgcmVtYWluaW5nIHBvdGVudGlhbCBtYXRjaGVzLiBUaGUgdmVyaWZ5IHN0ZXAgcmVxdWlyZXMgYW4gYWxnb3JpdGhtIHN1Y2hcbiAqIGFzIHRoaXMgb25lIGhvd2V2ZXIuXG4gKlxuICogVGhlIGFsZ29yaXRobSdzIGFwcHJvYWNoIGlzIGVzc2VudGlhbGx5IHRvIG9wdGltaXplIHRoZSBjbGFzc2ljIGR5bmFtaWNcbiAqIHByb2dyYW1taW5nIHNvbHV0aW9uIHRvIHRoZSBwcm9ibGVtIGJ5IGNvbXB1dGluZyBjb2x1bW5zIG9mIHRoZSBtYXRyaXggaW5cbiAqIHdvcmQtc2l6ZWQgY2h1bmtzIChpZS4gZGVhbGluZyB3aXRoIDMyIGNoYXJzIG9mIHRoZSBwYXR0ZXJuIGF0IGEgdGltZSkgYW5kXG4gKiBhdm9pZGluZyBjYWxjdWxhdGluZyByZWdpb25zIG9mIHRoZSBtYXRyaXggd2hlcmUgdGhlIG1pbmltdW0gZXJyb3IgY291bnQgaXNcbiAqIGd1YXJhbnRlZWQgdG8gZXhjZWVkIHRoZSBpbnB1dCB0aHJlc2hvbGQuXG4gKlxuICogVGhlIHBhcGVyIGNvbnNpc3RzIG9mIHR3byBwYXJ0cywgdGhlIGZpcnN0IGRlc2NyaWJlcyB0aGUgY29yZSBhbGdvcml0aG0gZm9yXG4gKiBtYXRjaGluZyBwYXR0ZXJucyA8PSB0aGUgc2l6ZSBvZiBhIHdvcmQgKGltcGxlbWVudGVkIGJ5IGBhZHZhbmNlQmxvY2tgIGhlcmUpLlxuICogVGhlIHNlY29uZCB1c2VzIHRoZSBjb3JlIGFsZ29yaXRobSBhcyBwYXJ0IG9mIGEgbGFyZ2VyIGJsb2NrLWJhc2VkIGFsZ29yaXRobVxuICogdG8gaGFuZGxlIGxvbmdlciBwYXR0ZXJucy5cbiAqXG4gKiBbMV0gRy4gTXllcnMsIOKAnEEgRmFzdCBCaXQtVmVjdG9yIEFsZ29yaXRobSBmb3IgQXBwcm94aW1hdGUgU3RyaW5nIE1hdGNoaW5nXG4gKiBCYXNlZCBvbiBEeW5hbWljIFByb2dyYW1taW5nLOKAnSB2b2wuIDQ2LCBuby4gMywgcHAuIDM5NeKAkzQxNSwgMTk5OS5cbiAqXG4gKiBbMl0gxaBvxaFpxIcsIE0uICgyMDE0KS4gQW4gc2ltZCBkeW5hbWljIHByb2dyYW1taW5nIGMvYysrIGxpYnJhcnkgKERvY3RvcmFsXG4gKiBkaXNzZXJ0YXRpb24sIEZha3VsdGV0IEVsZWt0cm90ZWhuaWtlIGkgcmHEjXVuYXJzdHZhLCBTdmV1xI1pbGnFoXRlIHUgWmFncmVidSkuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmZ1bmN0aW9uIHJldmVyc2Uocykge1xuICAgIHJldHVybiBzXG4gICAgICAgIC5zcGxpdChcIlwiKVxuICAgICAgICAucmV2ZXJzZSgpXG4gICAgICAgIC5qb2luKFwiXCIpO1xufVxuLyoqXG4gKiBHaXZlbiB0aGUgZW5kcyBvZiBhcHByb3hpbWF0ZSBtYXRjaGVzIGZvciBgcGF0dGVybmAgaW4gYHRleHRgLCBmaW5kXG4gKiB0aGUgc3RhcnQgb2YgdGhlIG1hdGNoZXMuXG4gKlxuICogQHBhcmFtIGZpbmRFbmRGbiAtIEZ1bmN0aW9uIGZvciBmaW5kaW5nIHRoZSBlbmQgb2YgbWF0Y2hlcyBpblxuICogdGV4dC5cbiAqIEByZXR1cm4gTWF0Y2hlcyB3aXRoIHRoZSBgc3RhcnRgIHByb3BlcnR5IHNldC5cbiAqL1xuZnVuY3Rpb24gZmluZE1hdGNoU3RhcnRzKHRleHQsIHBhdHRlcm4sIG1hdGNoZXMpIHtcbiAgICB2YXIgcGF0UmV2ID0gcmV2ZXJzZShwYXR0ZXJuKTtcbiAgICByZXR1cm4gbWF0Y2hlcy5tYXAoZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgLy8gRmluZCBzdGFydCBvZiBlYWNoIG1hdGNoIGJ5IHJldmVyc2luZyB0aGUgcGF0dGVybiBhbmQgbWF0Y2hpbmcgc2VnbWVudFxuICAgICAgICAvLyBvZiB0ZXh0IGFuZCBzZWFyY2hpbmcgZm9yIGFuIGFwcHJveCBtYXRjaCB3aXRoIHRoZSBzYW1lIG51bWJlciBvZlxuICAgICAgICAvLyBlcnJvcnMuXG4gICAgICAgIHZhciBtaW5TdGFydCA9IE1hdGgubWF4KDAsIG0uZW5kIC0gcGF0dGVybi5sZW5ndGggLSBtLmVycm9ycyk7XG4gICAgICAgIHZhciB0ZXh0UmV2ID0gcmV2ZXJzZSh0ZXh0LnNsaWNlKG1pblN0YXJ0LCBtLmVuZCkpO1xuICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbXVsdGlwbGUgcG9zc2libGUgc3RhcnQgcG9pbnRzLCBjaG9vc2UgdGhlIG9uZSB0aGF0XG4gICAgICAgIC8vIG1heGltaXplcyB0aGUgbGVuZ3RoIG9mIHRoZSBtYXRjaC5cbiAgICAgICAgdmFyIHN0YXJ0ID0gZmluZE1hdGNoRW5kcyh0ZXh0UmV2LCBwYXRSZXYsIG0uZXJyb3JzKS5yZWR1Y2UoZnVuY3Rpb24gKG1pbiwgcm0pIHtcbiAgICAgICAgICAgIGlmIChtLmVuZCAtIHJtLmVuZCA8IG1pbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBtLmVuZCAtIHJtLmVuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtaW47XG4gICAgICAgIH0sIG0uZW5kKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgIGVuZDogbS5lbmQsXG4gICAgICAgICAgICBlcnJvcnM6IG0uZXJyb3JzXG4gICAgICAgIH07XG4gICAgfSk7XG59XG4vKipcbiAqIFJldHVybiAxIGlmIGEgbnVtYmVyIGlzIG5vbi16ZXJvIG9yIHplcm8gb3RoZXJ3aXNlLCB3aXRob3V0IHVzaW5nXG4gKiBjb25kaXRpb25hbCBvcGVyYXRvcnMuXG4gKlxuICogVGhpcyBzaG91bGQgZ2V0IGlubGluZWQgaW50byBgYWR2YW5jZUJsb2NrYCBiZWxvdyBieSB0aGUgSklULlxuICpcbiAqIEFkYXB0ZWQgZnJvbSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzkxMjIxOC80MzQyNDNcbiAqL1xuZnVuY3Rpb24gb25lSWZOb3RaZXJvKG4pIHtcbiAgICByZXR1cm4gKChuIHwgLW4pID4+IDMxKSAmIDE7XG59XG4vKipcbiAqIEJsb2NrIGNhbGN1bGF0aW9uIHN0ZXAgb2YgdGhlIGFsZ29yaXRobS5cbiAqXG4gKiBGcm9tIEZpZyA4LiBvbiBwLiA0MDggb2YgWzFdLCBhZGRpdGlvbmFsbHkgb3B0aW1pemVkIHRvIHJlcGxhY2UgY29uZGl0aW9uYWxcbiAqIGNoZWNrcyB3aXRoIGJpdHdpc2Ugb3BlcmF0aW9ucyBhcyBwZXIgU2VjdGlvbiA0LjIuMyBvZiBbMl0uXG4gKlxuICogQHBhcmFtIGN0eCAtIFRoZSBwYXR0ZXJuIGNvbnRleHQgb2JqZWN0XG4gKiBAcGFyYW0gcGVxIC0gVGhlIGBwZXFgIGFycmF5IGZvciB0aGUgY3VycmVudCBjaGFyYWN0ZXIgKGBjdHgucGVxLmdldChjaClgKVxuICogQHBhcmFtIGIgLSBUaGUgYmxvY2sgbGV2ZWxcbiAqIEBwYXJhbSBoSW4gLSBIb3Jpem9udGFsIGlucHV0IGRlbHRhIOKIiCB7MSwwLC0xfVxuICogQHJldHVybiBIb3Jpem9udGFsIG91dHB1dCBkZWx0YSDiiIggezEsMCwtMX1cbiAqL1xuZnVuY3Rpb24gYWR2YW5jZUJsb2NrKGN0eCwgcGVxLCBiLCBoSW4pIHtcbiAgICB2YXIgcFYgPSBjdHguUFtiXTtcbiAgICB2YXIgbVYgPSBjdHguTVtiXTtcbiAgICB2YXIgaEluSXNOZWdhdGl2ZSA9IGhJbiA+Pj4gMzE7IC8vIDEgaWYgaEluIDwgMCBvciAwIG90aGVyd2lzZS5cbiAgICB2YXIgZXEgPSBwZXFbYl0gfCBoSW5Jc05lZ2F0aXZlO1xuICAgIC8vIFN0ZXAgMTogQ29tcHV0ZSBob3Jpem9udGFsIGRlbHRhcy5cbiAgICB2YXIgeFYgPSBlcSB8IG1WO1xuICAgIHZhciB4SCA9ICgoKGVxICYgcFYpICsgcFYpIF4gcFYpIHwgZXE7XG4gICAgdmFyIHBIID0gbVYgfCB+KHhIIHwgcFYpO1xuICAgIHZhciBtSCA9IHBWICYgeEg7XG4gICAgLy8gU3RlcCAyOiBVcGRhdGUgc2NvcmUgKHZhbHVlIG9mIGxhc3Qgcm93IG9mIHRoaXMgYmxvY2spLlxuICAgIHZhciBoT3V0ID0gb25lSWZOb3RaZXJvKHBIICYgY3R4Lmxhc3RSb3dNYXNrW2JdKSAtXG4gICAgICAgIG9uZUlmTm90WmVybyhtSCAmIGN0eC5sYXN0Um93TWFza1tiXSk7XG4gICAgLy8gU3RlcCAzOiBVcGRhdGUgdmVydGljYWwgZGVsdGFzIGZvciB1c2Ugd2hlbiBwcm9jZXNzaW5nIG5leHQgY2hhci5cbiAgICBwSCA8PD0gMTtcbiAgICBtSCA8PD0gMTtcbiAgICBtSCB8PSBoSW5Jc05lZ2F0aXZlO1xuICAgIHBIIHw9IG9uZUlmTm90WmVybyhoSW4pIC0gaEluSXNOZWdhdGl2ZTsgLy8gc2V0IHBIWzBdIGlmIGhJbiA+IDBcbiAgICBwViA9IG1IIHwgfih4ViB8IHBIKTtcbiAgICBtViA9IHBIICYgeFY7XG4gICAgY3R4LlBbYl0gPSBwVjtcbiAgICBjdHguTVtiXSA9IG1WO1xuICAgIHJldHVybiBoT3V0O1xufVxuLyoqXG4gKiBGaW5kIHRoZSBlbmRzIGFuZCBlcnJvciBjb3VudHMgZm9yIG1hdGNoZXMgb2YgYHBhdHRlcm5gIGluIGB0ZXh0YC5cbiAqXG4gKiBPbmx5IHRoZSBtYXRjaGVzIHdpdGggdGhlIGxvd2VzdCBlcnJvciBjb3VudCBhcmUgcmVwb3J0ZWQuIE90aGVyIG1hdGNoZXNcbiAqIHdpdGggZXJyb3IgY291bnRzIDw9IG1heEVycm9ycyBhcmUgZGlzY2FyZGVkLlxuICpcbiAqIFRoaXMgaXMgdGhlIGJsb2NrLWJhc2VkIHNlYXJjaCBhbGdvcml0aG0gZnJvbSBGaWcuIDkgb24gcC40MTAgb2YgWzFdLlxuICovXG5mdW5jdGlvbiBmaW5kTWF0Y2hFbmRzKHRleHQsIHBhdHRlcm4sIG1heEVycm9ycykge1xuICAgIGlmIChwYXR0ZXJuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIC8vIENsYW1wIGVycm9yIGNvdW50IHNvIHdlIGNhbiByZWx5IG9uIHRoZSBgbWF4RXJyb3JzYCBhbmQgYHBhdHRlcm4ubGVuZ3RoYFxuICAgIC8vIHJvd3MgYmVpbmcgaW4gdGhlIHNhbWUgYmxvY2sgYmVsb3cuXG4gICAgbWF4RXJyb3JzID0gTWF0aC5taW4obWF4RXJyb3JzLCBwYXR0ZXJuLmxlbmd0aCk7XG4gICAgdmFyIG1hdGNoZXMgPSBbXTtcbiAgICAvLyBXb3JkIHNpemUuXG4gICAgdmFyIHcgPSAzMjtcbiAgICAvLyBJbmRleCBvZiBtYXhpbXVtIGJsb2NrIGxldmVsLlxuICAgIHZhciBiTWF4ID0gTWF0aC5jZWlsKHBhdHRlcm4ubGVuZ3RoIC8gdykgLSAxO1xuICAgIC8vIENvbnRleHQgdXNlZCBhY3Jvc3MgYmxvY2sgY2FsY3VsYXRpb25zLlxuICAgIHZhciBjdHggPSB7XG4gICAgICAgIFA6IG5ldyBVaW50MzJBcnJheShiTWF4ICsgMSksXG4gICAgICAgIE06IG5ldyBVaW50MzJBcnJheShiTWF4ICsgMSksXG4gICAgICAgIGxhc3RSb3dNYXNrOiBuZXcgVWludDMyQXJyYXkoYk1heCArIDEpXG4gICAgfTtcbiAgICBjdHgubGFzdFJvd01hc2suZmlsbCgxIDw8IDMxKTtcbiAgICBjdHgubGFzdFJvd01hc2tbYk1heF0gPSAxIDw8IChwYXR0ZXJuLmxlbmd0aCAtIDEpICUgdztcbiAgICAvLyBEdW1teSBcInBlcVwiIGFycmF5IGZvciBjaGFycyBpbiB0aGUgdGV4dCB3aGljaCBkbyBub3Qgb2NjdXIgaW4gdGhlIHBhdHRlcm4uXG4gICAgdmFyIGVtcHR5UGVxID0gbmV3IFVpbnQzMkFycmF5KGJNYXggKyAxKTtcbiAgICAvLyBNYXAgb2YgVVRGLTE2IGNoYXJhY3RlciBjb2RlIHRvIGJpdCB2ZWN0b3IgaW5kaWNhdGluZyBwb3NpdGlvbnMgaW4gdGhlXG4gICAgLy8gcGF0dGVybiB0aGF0IGVxdWFsIHRoYXQgY2hhcmFjdGVyLlxuICAgIHZhciBwZXEgPSBuZXcgTWFwKCk7XG4gICAgLy8gVmVyc2lvbiBvZiBgcGVxYCB0aGF0IG9ubHkgc3RvcmVzIG1hcHBpbmdzIGZvciBzbWFsbCBjaGFyYWN0ZXJzLiBUaGlzXG4gICAgLy8gYWxsb3dzIGZhc3RlciBsb29rdXBzIHdoZW4gaXRlcmF0aW5nIHRocm91Z2ggdGhlIHRleHQgYmVjYXVzZSBhIHNpbXBsZVxuICAgIC8vIGFycmF5IGxvb2t1cCBjYW4gYmUgZG9uZSBpbnN0ZWFkIG9mIGEgaGFzaCB0YWJsZSBsb29rdXAuXG4gICAgdmFyIGFzY2lpUGVxID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICAgICAgICBhc2NpaVBlcS5wdXNoKGVtcHR5UGVxKTtcbiAgICB9XG4gICAgLy8gQ2FsY3VsYXRlIGBjdHgucGVxYCAtIGEgbWFwIG9mIGNoYXJhY3RlciB2YWx1ZXMgdG8gYml0bWFza3MgaW5kaWNhdGluZ1xuICAgIC8vIHBvc2l0aW9ucyBvZiB0aGF0IGNoYXJhY3RlciB3aXRoaW4gdGhlIHBhdHRlcm4sIHdoZXJlIGVhY2ggYml0IHJlcHJlc2VudHNcbiAgICAvLyBhIHBvc2l0aW9uIGluIHRoZSBwYXR0ZXJuLlxuICAgIGZvciAodmFyIGMgPSAwOyBjIDwgcGF0dGVybi5sZW5ndGg7IGMgKz0gMSkge1xuICAgICAgICB2YXIgdmFsID0gcGF0dGVybi5jaGFyQ29kZUF0KGMpO1xuICAgICAgICBpZiAocGVxLmhhcyh2YWwpKSB7XG4gICAgICAgICAgICAvLyBEdXBsaWNhdGUgY2hhciBpbiBwYXR0ZXJuLlxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNoYXJQZXEgPSBuZXcgVWludDMyQXJyYXkoYk1heCArIDEpO1xuICAgICAgICBwZXEuc2V0KHZhbCwgY2hhclBlcSk7XG4gICAgICAgIGlmICh2YWwgPCBhc2NpaVBlcS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGFzY2lpUGVxW3ZhbF0gPSBjaGFyUGVxO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGIgPSAwOyBiIDw9IGJNYXg7IGIgKz0gMSkge1xuICAgICAgICAgICAgY2hhclBlcVtiXSA9IDA7XG4gICAgICAgICAgICAvLyBTZXQgYWxsIHRoZSBiaXRzIHdoZXJlIHRoZSBwYXR0ZXJuIG1hdGNoZXMgdGhlIGN1cnJlbnQgY2hhciAoY2gpLlxuICAgICAgICAgICAgLy8gRm9yIGluZGV4ZXMgYmV5b25kIHRoZSBlbmQgb2YgdGhlIHBhdHRlcm4sIGFsd2F5cyBzZXQgdGhlIGJpdCBhcyBpZiB0aGVcbiAgICAgICAgICAgIC8vIHBhdHRlcm4gY29udGFpbmVkIGEgd2lsZGNhcmQgY2hhciBpbiB0aGF0IHBvc2l0aW9uLlxuICAgICAgICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCB3OyByICs9IDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgaWR4ID0gYiAqIHcgKyByO1xuICAgICAgICAgICAgICAgIGlmIChpZHggPj0gcGF0dGVybi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IHBhdHRlcm4uY2hhckNvZGVBdChpZHgpID09PSB2YWw7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYXJQZXFbYl0gfD0gMSA8PCByO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBJbmRleCBvZiBsYXN0LWFjdGl2ZSBibG9jayBsZXZlbCBpbiB0aGUgY29sdW1uLlxuICAgIHZhciB5ID0gTWF0aC5tYXgoMCwgTWF0aC5jZWlsKG1heEVycm9ycyAvIHcpIC0gMSk7XG4gICAgLy8gSW5pdGlhbGl6ZSBtYXhpbXVtIGVycm9yIGNvdW50IGF0IGJvdHRvbSBvZiBlYWNoIGJsb2NrLlxuICAgIHZhciBzY29yZSA9IG5ldyBVaW50MzJBcnJheShiTWF4ICsgMSk7XG4gICAgZm9yICh2YXIgYiA9IDA7IGIgPD0geTsgYiArPSAxKSB7XG4gICAgICAgIHNjb3JlW2JdID0gKGIgKyAxKSAqIHc7XG4gICAgfVxuICAgIHNjb3JlW2JNYXhdID0gcGF0dGVybi5sZW5ndGg7XG4gICAgLy8gSW5pdGlhbGl6ZSB2ZXJ0aWNhbCBkZWx0YXMgZm9yIGVhY2ggYmxvY2suXG4gICAgZm9yICh2YXIgYiA9IDA7IGIgPD0geTsgYiArPSAxKSB7XG4gICAgICAgIGN0eC5QW2JdID0gfjA7XG4gICAgICAgIGN0eC5NW2JdID0gMDtcbiAgICB9XG4gICAgLy8gUHJvY2VzcyBlYWNoIGNoYXIgb2YgdGhlIHRleHQsIGNvbXB1dGluZyB0aGUgZXJyb3IgY291bnQgZm9yIGB3YCBjaGFycyBvZlxuICAgIC8vIHRoZSBwYXR0ZXJuIGF0IGEgdGltZS5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRleHQubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgLy8gTG9va3VwIHRoZSBiaXRtYXNrIHJlcHJlc2VudGluZyB0aGUgcG9zaXRpb25zIG9mIHRoZSBjdXJyZW50IGNoYXIgZnJvbVxuICAgICAgICAvLyB0aGUgdGV4dCB3aXRoaW4gdGhlIHBhdHRlcm4uXG4gICAgICAgIHZhciBjaGFyQ29kZSA9IHRleHQuY2hhckNvZGVBdChqKTtcbiAgICAgICAgdmFyIGNoYXJQZXEgPSB2b2lkIDA7XG4gICAgICAgIGlmIChjaGFyQ29kZSA8IGFzY2lpUGVxLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gRmFzdCBhcnJheSBsb29rdXAuXG4gICAgICAgICAgICBjaGFyUGVxID0gYXNjaWlQZXFbY2hhckNvZGVdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gU2xvd2VyIGhhc2ggdGFibGUgbG9va3VwLlxuICAgICAgICAgICAgY2hhclBlcSA9IHBlcS5nZXQoY2hhckNvZGUpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjaGFyUGVxID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgY2hhclBlcSA9IGVtcHR5UGVxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIENhbGN1bGF0ZSBlcnJvciBjb3VudCBmb3IgYmxvY2tzIHRoYXQgd2UgZGVmaW5pdGVseSBoYXZlIHRvIHByb2Nlc3MgZm9yXG4gICAgICAgIC8vIHRoaXMgY29sdW1uLlxuICAgICAgICB2YXIgY2FycnkgPSAwO1xuICAgICAgICBmb3IgKHZhciBiID0gMDsgYiA8PSB5OyBiICs9IDEpIHtcbiAgICAgICAgICAgIGNhcnJ5ID0gYWR2YW5jZUJsb2NrKGN0eCwgY2hhclBlcSwgYiwgY2FycnkpO1xuICAgICAgICAgICAgc2NvcmVbYl0gKz0gY2Fycnk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgaWYgd2UgYWxzbyBuZWVkIHRvIGNvbXB1dGUgYW4gYWRkaXRpb25hbCBibG9jaywgb3IgaWYgd2UgY2FuIHJlZHVjZVxuICAgICAgICAvLyB0aGUgbnVtYmVyIG9mIGJsb2NrcyBwcm9jZXNzZWQgZm9yIHRoZSBuZXh0IGNvbHVtbi5cbiAgICAgICAgaWYgKHNjb3JlW3ldIC0gY2FycnkgPD0gbWF4RXJyb3JzICYmXG4gICAgICAgICAgICB5IDwgYk1heCAmJlxuICAgICAgICAgICAgKGNoYXJQZXFbeSArIDFdICYgMSB8fCBjYXJyeSA8IDApKSB7XG4gICAgICAgICAgICAvLyBFcnJvciBjb3VudCBmb3IgYm90dG9tIGJsb2NrIGlzIHVuZGVyIHRocmVzaG9sZCwgaW5jcmVhc2UgdGhlIG51bWJlciBvZlxuICAgICAgICAgICAgLy8gYmxvY2tzIHByb2Nlc3NlZCBmb3IgdGhpcyBjb2x1bW4gJiBuZXh0IGJ5IDEuXG4gICAgICAgICAgICB5ICs9IDE7XG4gICAgICAgICAgICBjdHguUFt5XSA9IH4wO1xuICAgICAgICAgICAgY3R4Lk1beV0gPSAwO1xuICAgICAgICAgICAgdmFyIG1heEJsb2NrU2NvcmUgPSB5ID09PSBiTWF4ID8gcGF0dGVybi5sZW5ndGggJSB3IDogdztcbiAgICAgICAgICAgIHNjb3JlW3ldID1cbiAgICAgICAgICAgICAgICBzY29yZVt5IC0gMV0gK1xuICAgICAgICAgICAgICAgICAgICBtYXhCbG9ja1Njb3JlIC1cbiAgICAgICAgICAgICAgICAgICAgY2FycnkgK1xuICAgICAgICAgICAgICAgICAgICBhZHZhbmNlQmxvY2soY3R4LCBjaGFyUGVxLCB5LCBjYXJyeSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBFcnJvciBjb3VudCBmb3IgYm90dG9tIGJsb2NrIGV4Y2VlZHMgdGhyZXNob2xkLCByZWR1Y2UgdGhlIG51bWJlciBvZlxuICAgICAgICAgICAgLy8gYmxvY2tzIHByb2Nlc3NlZCBmb3IgdGhlIG5leHQgY29sdW1uLlxuICAgICAgICAgICAgd2hpbGUgKHkgPiAwICYmIHNjb3JlW3ldID49IG1heEVycm9ycyArIHcpIHtcbiAgICAgICAgICAgICAgICB5IC09IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgZXJyb3IgY291bnQgaXMgdW5kZXIgdGhyZXNob2xkLCByZXBvcnQgYSBtYXRjaC5cbiAgICAgICAgaWYgKHkgPT09IGJNYXggJiYgc2NvcmVbeV0gPD0gbWF4RXJyb3JzKSB7XG4gICAgICAgICAgICBpZiAoc2NvcmVbeV0gPCBtYXhFcnJvcnMpIHtcbiAgICAgICAgICAgICAgICAvLyBEaXNjYXJkIGFueSBlYXJsaWVyLCB3b3JzZSBtYXRjaGVzLlxuICAgICAgICAgICAgICAgIG1hdGNoZXMuc3BsaWNlKDAsIG1hdGNoZXMubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1hdGNoZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IC0xLFxuICAgICAgICAgICAgICAgIGVuZDogaiArIDEsXG4gICAgICAgICAgICAgICAgZXJyb3JzOiBzY29yZVt5XVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBCZWNhdXNlIGBzZWFyY2hgIG9ubHkgcmVwb3J0cyB0aGUgbWF0Y2hlcyB3aXRoIHRoZSBsb3dlc3QgZXJyb3IgY291bnQsXG4gICAgICAgICAgICAvLyB3ZSBjYW4gXCJyYXRjaGV0IGRvd25cIiB0aGUgbWF4IGVycm9yIHRocmVzaG9sZCB3aGVuZXZlciBhIG1hdGNoIGlzXG4gICAgICAgICAgICAvLyBlbmNvdW50ZXJlZCBhbmQgdGhlcmVieSBzYXZlIGEgc21hbGwgYW1vdW50IG9mIHdvcmsgZm9yIHRoZSByZW1haW5kZXJcbiAgICAgICAgICAgIC8vIG9mIHRoZSB0ZXh0LlxuICAgICAgICAgICAgbWF4RXJyb3JzID0gc2NvcmVbeV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1hdGNoZXM7XG59XG4vKipcbiAqIFNlYXJjaCBmb3IgbWF0Y2hlcyBmb3IgYHBhdHRlcm5gIGluIGB0ZXh0YCBhbGxvd2luZyB1cCB0byBgbWF4RXJyb3JzYCBlcnJvcnMuXG4gKlxuICogUmV0dXJucyB0aGUgc3RhcnQsIGFuZCBlbmQgcG9zaXRpb25zIGFuZCBlcnJvciBjb3VudHMgZm9yIGVhY2ggbG93ZXN0LWNvc3RcbiAqIG1hdGNoLiBPbmx5IHRoZSBcImJlc3RcIiBtYXRjaGVzIGFyZSByZXR1cm5lZC5cbiAqL1xuZnVuY3Rpb24gc2VhcmNoKHRleHQsIHBhdHRlcm4sIG1heEVycm9ycykge1xuICAgIHZhciBtYXRjaGVzID0gZmluZE1hdGNoRW5kcyh0ZXh0LCBwYXR0ZXJuLCBtYXhFcnJvcnMpO1xuICAgIHJldHVybiBmaW5kTWF0Y2hTdGFydHModGV4dCwgcGF0dGVybiwgbWF0Y2hlcyk7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBzZWFyY2g7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///89\n')},581:()=>{eval('//\n//  Copyright 2021 Readium Foundation. All rights reserved.\n//  Use of this source code is governed by the BSD-style license\n//  available in the top-level LICENSE file of the project.\n//\n\nwindow.addEventListener("DOMContentLoaded", function () {\n  // If we don\'t set the CSS cursor property to pointer, then the click events are not triggered pre-iOS 13.\n  document.body.style.cursor = "pointer";\n\n  document.addEventListener("click", onClick, false);\n});\n\nfunction onClick(event) {\n  if (!window.getSelection().isCollapsed) {\n    // There\'s an on-going selection, the tap will dismiss it so we don\'t forward it.\n    return;\n  }\n\n  // Send the tap data over the JS bridge even if it\'s been handled\n  // within the webview, so that it can be preserved and used\n  // by the WKNavigationDelegate if needed.\n  webkit.messageHandlers.tap.postMessage({\n    defaultPrevented: event.defaultPrevented,\n    screenX: event.screenX,\n    screenY: event.screenY,\n    clientX: event.clientX,\n    clientY: event.clientY,\n    targetElement: event.target.outerHTML,\n    interactiveElement: nearestInteractiveElement(event.target),\n  });\n\n  // We don\'t want to disable the default WebView behavior as it breaks some features without bringing any value.\n  //    event.stopPropagation();\n  //    event.preventDefault();\n}\n\n// See. https://github.com/JayPanoz/architecture/tree/touch-handling/misc/touch-handling\nfunction nearestInteractiveElement(element) {\n  var interactiveTags = [\n    "a",\n    "audio",\n    "button",\n    "canvas",\n    "details",\n    "input",\n    "label",\n    "option",\n    "select",\n    "submit",\n    "textarea",\n    "video",\n  ];\n  if (interactiveTags.indexOf(element.nodeName.toLowerCase()) !== -1) {\n    return element.outerHTML;\n  }\n\n  // Checks whether the element is editable by the user.\n  if (\n    element.hasAttribute("contenteditable") &&\n    element.getAttribute("contenteditable").toLowerCase() != "false"\n  ) {\n    return element.outerHTML;\n  }\n\n  // Checks parents recursively because the touch might be for example on an <em> inside a <a>.\n  if (element.parentElement) {\n    return nearestInteractiveElement(element.parentElement);\n  }\n\n  return null;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFkaXVtLWpzLy4vc3JjL2dlc3R1cmVzLmpzPzE0YzIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsImZpbGUiOiI1ODEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvL1xuLy8gIENvcHlyaWdodCAyMDIxIFJlYWRpdW0gRm91bmRhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSB0aGUgQlNELXN0eWxlIGxpY2Vuc2Vcbi8vICBhdmFpbGFibGUgaW4gdGhlIHRvcC1sZXZlbCBMSUNFTlNFIGZpbGUgb2YgdGhlIHByb2plY3QuXG4vL1xuXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgZnVuY3Rpb24gKCkge1xuICAvLyBJZiB3ZSBkb24ndCBzZXQgdGhlIENTUyBjdXJzb3IgcHJvcGVydHkgdG8gcG9pbnRlciwgdGhlbiB0aGUgY2xpY2sgZXZlbnRzIGFyZSBub3QgdHJpZ2dlcmVkIHByZS1pT1MgMTMuXG4gIGRvY3VtZW50LmJvZHkuc3R5bGUuY3Vyc29yID0gXCJwb2ludGVyXCI7XG5cbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIG9uQ2xpY2ssIGZhbHNlKTtcbn0pO1xuXG5mdW5jdGlvbiBvbkNsaWNrKGV2ZW50KSB7XG4gIGlmICghd2luZG93LmdldFNlbGVjdGlvbigpLmlzQ29sbGFwc2VkKSB7XG4gICAgLy8gVGhlcmUncyBhbiBvbi1nb2luZyBzZWxlY3Rpb24sIHRoZSB0YXAgd2lsbCBkaXNtaXNzIGl0IHNvIHdlIGRvbid0IGZvcndhcmQgaXQuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gU2VuZCB0aGUgdGFwIGRhdGEgb3ZlciB0aGUgSlMgYnJpZGdlIGV2ZW4gaWYgaXQncyBiZWVuIGhhbmRsZWRcbiAgLy8gd2l0aGluIHRoZSB3ZWJ2aWV3LCBzbyB0aGF0IGl0IGNhbiBiZSBwcmVzZXJ2ZWQgYW5kIHVzZWRcbiAgLy8gYnkgdGhlIFdLTmF2aWdhdGlvbkRlbGVnYXRlIGlmIG5lZWRlZC5cbiAgd2Via2l0Lm1lc3NhZ2VIYW5kbGVycy50YXAucG9zdE1lc3NhZ2Uoe1xuICAgIGRlZmF1bHRQcmV2ZW50ZWQ6IGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQsXG4gICAgc2NyZWVuWDogZXZlbnQuc2NyZWVuWCxcbiAgICBzY3JlZW5ZOiBldmVudC5zY3JlZW5ZLFxuICAgIGNsaWVudFg6IGV2ZW50LmNsaWVudFgsXG4gICAgY2xpZW50WTogZXZlbnQuY2xpZW50WSxcbiAgICB0YXJnZXRFbGVtZW50OiBldmVudC50YXJnZXQub3V0ZXJIVE1MLFxuICAgIGludGVyYWN0aXZlRWxlbWVudDogbmVhcmVzdEludGVyYWN0aXZlRWxlbWVudChldmVudC50YXJnZXQpLFxuICB9KTtcblxuICAvLyBXZSBkb24ndCB3YW50IHRvIGRpc2FibGUgdGhlIGRlZmF1bHQgV2ViVmlldyBiZWhhdmlvciBhcyBpdCBicmVha3Mgc29tZSBmZWF0dXJlcyB3aXRob3V0IGJyaW5naW5nIGFueSB2YWx1ZS5cbiAgLy8gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIC8vICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG59XG5cbi8vIFNlZS4gaHR0cHM6Ly9naXRodWIuY29tL0pheVBhbm96L2FyY2hpdGVjdHVyZS90cmVlL3RvdWNoLWhhbmRsaW5nL21pc2MvdG91Y2gtaGFuZGxpbmdcbmZ1bmN0aW9uIG5lYXJlc3RJbnRlcmFjdGl2ZUVsZW1lbnQoZWxlbWVudCkge1xuICB2YXIgaW50ZXJhY3RpdmVUYWdzID0gW1xuICAgIFwiYVwiLFxuICAgIFwiYXVkaW9cIixcbiAgICBcImJ1dHRvblwiLFxuICAgIFwiY2FudmFzXCIsXG4gICAgXCJkZXRhaWxzXCIsXG4gICAgXCJpbnB1dFwiLFxuICAgIFwibGFiZWxcIixcbiAgICBcIm9wdGlvblwiLFxuICAgIFwic2VsZWN0XCIsXG4gICAgXCJzdWJtaXRcIixcbiAgICBcInRleHRhcmVhXCIsXG4gICAgXCJ2aWRlb1wiLFxuICBdO1xuICBpZiAoaW50ZXJhY3RpdmVUYWdzLmluZGV4T2YoZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKSAhPT0gLTEpIHtcbiAgICByZXR1cm4gZWxlbWVudC5vdXRlckhUTUw7XG4gIH1cblxuICAvLyBDaGVja3Mgd2hldGhlciB0aGUgZWxlbWVudCBpcyBlZGl0YWJsZSBieSB0aGUgdXNlci5cbiAgaWYgKFxuICAgIGVsZW1lbnQuaGFzQXR0cmlidXRlKFwiY29udGVudGVkaXRhYmxlXCIpICYmXG4gICAgZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJjb250ZW50ZWRpdGFibGVcIikudG9Mb3dlckNhc2UoKSAhPSBcImZhbHNlXCJcbiAgKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQub3V0ZXJIVE1MO1xuICB9XG5cbiAgLy8gQ2hlY2tzIHBhcmVudHMgcmVjdXJzaXZlbHkgYmVjYXVzZSB0aGUgdG91Y2ggbWlnaHQgYmUgZm9yIGV4YW1wbGUgb24gYW4gPGVtPiBpbnNpZGUgYSA8YT4uXG4gIGlmIChlbGVtZW50LnBhcmVudEVsZW1lbnQpIHtcbiAgICByZXR1cm4gbmVhcmVzdEludGVyYWN0aXZlRWxlbWVudChlbGVtZW50LnBhcmVudEVsZW1lbnQpO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///581\n')},611:(__unused_webpack_module,__unused_webpack___webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXTERNAL MODULE: ./src/gestures.js\nvar gestures = __webpack_require__(581);\n// EXTERNAL MODULE: ./node_modules/approx-string-match/dist/index.js\nvar dist = __webpack_require__(89);\n;// CONCATENATED MODULE: ./src/vendor/hypothesis/anchoring/match-quote.js\n\n\n/**\n * @typedef {import(\'approx-string-match\').Match} StringMatch\n */\n\n/**\n * @typedef Match\n * @prop {number} start - Start offset of match in text\n * @prop {number} end - End offset of match in text\n * @prop {number} score -\n *   Score for the match between 0 and 1.0, where 1.0 indicates a perfect match\n *   for the quote and context.\n */\n\n/**\n * Find the best approximate matches for `str` in `text` allowing up to `maxErrors` errors.\n *\n * @param {string} text\n * @param {string} str\n * @param {number} maxErrors\n * @return {StringMatch[]}\n */\nfunction search(text, str, maxErrors) {\n  // Do a fast search for exact matches. The `approx-string-match` library\n  // doesn\'t currently incorporate this optimization itself.\n  let matchPos = 0;\n  let exactMatches = [];\n  while (matchPos !== -1) {\n    matchPos = text.indexOf(str, matchPos);\n    if (matchPos !== -1) {\n      exactMatches.push({\n        start: matchPos,\n        end: matchPos + str.length,\n        errors: 0,\n      });\n      matchPos += 1;\n    }\n  }\n  if (exactMatches.length > 0) {\n    return exactMatches;\n  }\n\n  // If there are no exact matches, do a more expensive search for matches\n  // with errors.\n  return (0,dist/* default */.Z)(text, str, maxErrors);\n}\n\n/**\n * Compute a score between 0 and 1.0 for the similarity between `text` and `str`.\n *\n * @param {string} text\n * @param {string} str\n */\nfunction textMatchScore(text, str) {\n  /* istanbul ignore next - `scoreMatch` will never pass an empty string */\n  if (str.length === 0 || text.length === 0) {\n    return 0.0;\n  }\n  const matches = search(text, str, str.length);\n\n  // prettier-ignore\n  return 1 - (matches[0].errors / str.length);\n}\n\n/**\n * Find the best approximate match for `quote` in `text`.\n *\n * Returns `null` if no match exceeding the minimum quality threshold was found.\n *\n * @param {string} text - Document text to search\n * @param {string} quote - String to find within `text`\n * @param {Object} context -\n *   Context in which the quote originally appeared. This is used to choose the\n *   best match.\n *   @param {string} [context.prefix] - Expected text before the quote\n *   @param {string} [context.suffix] - Expected text after the quote\n *   @param {number} [context.hint] - Expected offset of match within text\n * @return {Match|null}\n */\nfunction matchQuote(text, quote, context = {}) {\n  if (quote.length === 0) {\n    return null;\n  }\n\n  // Choose the maximum number of errors to allow for the initial search.\n  // This choice involves a tradeoff between:\n  //\n  //  - Recall (proportion of "good" matches found)\n  //  - Precision (proportion of matches found which are "good")\n  //  - Cost of the initial search and of processing the candidate matches [1]\n  //\n  // [1] Specifically, the expected-time complexity of the initial search is\n  //     `O((maxErrors / 32) * text.length)`. See `approx-string-match` docs.\n  const maxErrors = Math.min(256, quote.length / 2);\n\n  // Find closest matches for `quote` in `text` based on edit distance.\n  const matches = search(text, quote, maxErrors);\n\n  if (matches.length === 0) {\n    return null;\n  }\n\n  /**\n   * Compute a score between 0 and 1.0 for a match candidate.\n   *\n   * @param {StringMatch} match\n   */\n  const scoreMatch = match => {\n    const quoteWeight = 50; // Similarity of matched text to quote.\n    const prefixWeight = 20; // Similarity of text before matched text to `context.prefix`.\n    const suffixWeight = 20; // Similarity of text after matched text to `context.suffix`.\n    const posWeight = 2; // Proximity to expected location. Used as a tie-breaker.\n\n    const quoteScore = 1 - match.errors / quote.length;\n\n    const prefixScore = context.prefix\n      ? textMatchScore(\n          text.slice(Math.max(0, match.start - context.prefix.length), match.start),\n          context.prefix\n        )\n      : 1.0;\n    const suffixScore = context.suffix\n      ? textMatchScore(\n          text.slice(match.end, match.end + context.suffix.length),\n          context.suffix\n        )\n      : 1.0;\n\n    let posScore = 1.0;\n    if (typeof context.hint === \'number\') {\n      const offset = Math.abs(match.start - context.hint);\n      posScore = 1.0 - offset / text.length;\n    }\n\n    const rawScore =\n      quoteWeight * quoteScore +\n      prefixWeight * prefixScore +\n      suffixWeight * suffixScore +\n      posWeight * posScore;\n    const maxScore = quoteWeight + prefixWeight + suffixWeight + posWeight;\n    const normalizedScore = rawScore / maxScore;\n\n    return normalizedScore;\n  };\n\n  // Rank matches based on similarity of actual and expected surrounding text\n  // and actual/expected offset in the document text.\n  const scoredMatches = matches.map(m => ({\n    start: m.start,\n    end: m.end,\n    score: scoreMatch(m),\n  }));\n\n  // Choose match with highest score.\n  scoredMatches.sort((a, b) => b.score - a.score);\n  return scoredMatches[0];\n}\n\n;// CONCATENATED MODULE: ./src/vendor/hypothesis/anchoring/text-range.js\n/**\n * Return the combined length of text nodes contained in `node`.\n *\n * @param {Node} node\n */\nfunction nodeTextLength(node) {\n  switch (node.nodeType) {\n    case Node.ELEMENT_NODE:\n    case Node.TEXT_NODE:\n      // nb. `textContent` excludes text in comments and processing instructions\n      // when called on a parent element, so we don\'t need to subtract that here.\n\n      return /** @type {string} */ (node.textContent).length;\n    default:\n      return 0;\n  }\n}\n\n/**\n * Return the total length of the text of all previous siblings of `node`.\n *\n * @param {Node} node\n */\nfunction previousSiblingsTextLength(node) {\n  let sibling = node.previousSibling;\n  let length = 0;\n  while (sibling) {\n    length += nodeTextLength(sibling);\n    sibling = sibling.previousSibling;\n  }\n  return length;\n}\n\n/**\n * Resolve one or more character offsets within an element to (text node, position)\n * pairs.\n *\n * @param {Element} element\n * @param {number[]} offsets - Offsets, which must be sorted in ascending order\n * @return {{ node: Text, offset: number }[]}\n */\nfunction resolveOffsets(element, ...offsets) {\n  let nextOffset = offsets.shift();\n  const nodeIter = /** @type {Document} */ (\n    element.ownerDocument\n  ).createNodeIterator(element, NodeFilter.SHOW_TEXT);\n  const results = [];\n\n  let currentNode = nodeIter.nextNode();\n  let textNode;\n  let length = 0;\n\n  // Find the text node containing the `nextOffset`th character from the start\n  // of `element`.\n  while (nextOffset !== undefined && currentNode) {\n    textNode = /** @type {Text} */ (currentNode);\n    if (length + textNode.data.length > nextOffset) {\n      results.push({ node: textNode, offset: nextOffset - length });\n      nextOffset = offsets.shift();\n    } else {\n      currentNode = nodeIter.nextNode();\n      length += textNode.data.length;\n    }\n  }\n\n  // Boundary case.\n  while (nextOffset !== undefined && textNode && length === nextOffset) {\n    results.push({ node: textNode, offset: textNode.data.length });\n    nextOffset = offsets.shift();\n  }\n\n  if (nextOffset !== undefined) {\n    throw new RangeError(\'Offset exceeds text length\');\n  }\n\n  return results;\n}\n\nlet RESOLVE_FORWARDS = 1;\nlet RESOLVE_BACKWARDS = 2;\n\n/**\n * Represents an offset within the text content of an element.\n *\n * This position can be resolved to a specific descendant node in the current\n * DOM subtree of the element using the `resolve` method.\n */\nclass text_range_TextPosition {\n  /**\n   * Construct a `TextPosition` that refers to the text position `offset` within\n   * the text content of `element`.\n   *\n   * @param {Element} element\n   * @param {number} offset\n   */\n  constructor(element, offset) {\n    if (offset < 0) {\n      throw new Error(\'Offset is invalid\');\n    }\n\n    /** Element that `offset` is relative to. */\n    this.element = element;\n\n    /** Character offset from the start of the element\'s `textContent`. */\n    this.offset = offset;\n  }\n\n  /**\n   * Return a copy of this position with offset relative to a given ancestor\n   * element.\n   *\n   * @param {Element} parent - Ancestor of `this.element`\n   * @return {TextPosition}\n   */\n  relativeTo(parent) {\n    if (!parent.contains(this.element)) {\n      throw new Error(\'Parent is not an ancestor of current element\');\n    }\n\n    let el = this.element;\n    let offset = this.offset;\n    while (el !== parent) {\n      offset += previousSiblingsTextLength(el);\n      el = /** @type {Element} */ (el.parentElement);\n    }\n\n    return new text_range_TextPosition(el, offset);\n  }\n\n  /**\n   * Resolve the position to a specific text node and offset within that node.\n   *\n   * Throws if `this.offset` exceeds the length of the element\'s text. In the\n   * case where the element has no text and `this.offset` is 0, the `direction`\n   * option determines what happens.\n   *\n   * Offsets at the boundary between two nodes are resolved to the start of the\n   * node that begins at the boundary.\n   *\n   * @param {Object} [options]\n   *   @param {RESOLVE_FORWARDS|RESOLVE_BACKWARDS} [options.direction] -\n   *     Specifies in which direction to search for the nearest text node if\n   *     `this.offset` is `0` and `this.element` has no text. If not specified\n   *     an error is thrown.\n   * @return {{ node: Text, offset: number }}\n   * @throws {RangeError}\n   */\n  resolve(options = {}) {\n    try {\n      return resolveOffsets(this.element, this.offset)[0];\n    } catch (err) {\n      if (this.offset === 0 && options.direction !== undefined) {\n        const tw = document.createTreeWalker(\n          this.element.getRootNode(),\n          NodeFilter.SHOW_TEXT\n        );\n        tw.currentNode = this.element;\n        const forwards = options.direction === RESOLVE_FORWARDS;\n        const text = /** @type {Text|null} */ (\n          forwards ? tw.nextNode() : tw.previousNode()\n        );\n        if (!text) {\n          throw err;\n        }\n        return { node: text, offset: forwards ? 0 : text.data.length };\n      } else {\n        throw err;\n      }\n    }\n  }\n\n  /**\n   * Construct a `TextPosition` that refers to the `offset`th character within\n   * `node`.\n   *\n   * @param {Node} node\n   * @param {number} offset\n   * @return {TextPosition}\n   */\n  static fromCharOffset(node, offset) {\n    switch (node.nodeType) {\n      case Node.TEXT_NODE:\n        return text_range_TextPosition.fromPoint(node, offset);\n      case Node.ELEMENT_NODE:\n        return new text_range_TextPosition(/** @type {Element} */ (node), offset);\n      default:\n        throw new Error(\'Node is not an element or text node\');\n    }\n  }\n\n  /**\n   * Construct a `TextPosition` representing the range start or end point (node, offset).\n   *\n   * @param {Node} node - Text or Element node\n   * @param {number} offset - Offset within the node.\n   * @return {TextPosition}\n   */\n  static fromPoint(node, offset) {\n    switch (node.nodeType) {\n      case Node.TEXT_NODE: {\n        if (offset < 0 || offset > /** @type {Text} */ (node).data.length) {\n          throw new Error(\'Text node offset is out of range\');\n        }\n\n        if (!node.parentElement) {\n          throw new Error(\'Text node has no parent\');\n        }\n\n        // Get the offset from the start of the parent element.\n        const textOffset = previousSiblingsTextLength(node) + offset;\n\n        return new text_range_TextPosition(node.parentElement, textOffset);\n      }\n      case Node.ELEMENT_NODE: {\n        if (offset < 0 || offset > node.childNodes.length) {\n          throw new Error(\'Child node offset is out of range\');\n        }\n\n        // Get the text length before the `offset`th child of element.\n        let textOffset = 0;\n        for (let i = 0; i < offset; i++) {\n          textOffset += nodeTextLength(node.childNodes[i]);\n        }\n\n        return new text_range_TextPosition(/** @type {Element} */ (node), textOffset);\n      }\n      default:\n        throw new Error(\'Point is not in an element or text node\');\n    }\n  }\n}\n\n/**\n * Represents a region of a document as a (start, end) pair of `TextPosition` points.\n *\n * Representing a range in this way allows for changes in the DOM content of the\n * range which don\'t affect its text content, without affecting the text content\n * of the range itself.\n */\nclass text_range_TextRange {\n  /**\n   * Construct an immutable `TextRange` from a `start` and `end` point.\n   *\n   * @param {TextPosition} start\n   * @param {TextPosition} end\n   */\n  constructor(start, end) {\n    this.start = start;\n    this.end = end;\n  }\n\n  /**\n   * Return a copy of this range with start and end positions relative to a\n   * given ancestor. See `TextPosition.relativeTo`.\n   *\n   * @param {Element} element\n   */\n  relativeTo(element) {\n    return new text_range_TextRange(\n      this.start.relativeTo(element),\n      this.end.relativeTo(element)\n    );\n  }\n\n  /**\n   * Resolve the `TextRange` to a DOM range.\n   *\n   * The resulting DOM Range will always start and end in a `Text` node.\n   * Hence `TextRange.fromRange(range).toRange()` can be used to "shrink" a\n   * range to the text it contains.\n   *\n   * May throw if the `start` or `end` positions cannot be resolved to a range.\n   *\n   * @return {Range}\n   */\n  toRange() {\n    let start;\n    let end;\n\n    if (\n      this.start.element === this.end.element &&\n      this.start.offset <= this.end.offset\n    ) {\n      // Fast path for start and end points in same element.\n      [start, end] = resolveOffsets(\n        this.start.element,\n        this.start.offset,\n        this.end.offset\n      );\n    } else {\n      start = this.start.resolve({ direction: RESOLVE_FORWARDS });\n      end = this.end.resolve({ direction: RESOLVE_BACKWARDS });\n    }\n\n    const range = new Range();\n    range.setStart(start.node, start.offset);\n    range.setEnd(end.node, end.offset);\n    return range;\n  }\n\n  /**\n   * Convert an existing DOM `Range` to a `TextRange`\n   *\n   * @param {Range} range\n   * @return {TextRange}\n   */\n  static fromRange(range) {\n    const start = text_range_TextPosition.fromPoint(\n      range.startContainer,\n      range.startOffset\n    );\n    const end = text_range_TextPosition.fromPoint(range.endContainer, range.endOffset);\n    return new text_range_TextRange(start, end);\n  }\n\n  /**\n   * Return a `TextRange` from the `start`th to `end`th characters in `root`.\n   *\n   * @param {Element} root\n   * @param {number} start\n   * @param {number} end\n   */\n  static fromOffsets(root, start, end) {\n    return new text_range_TextRange(\n      new text_range_TextPosition(root, start),\n      new text_range_TextPosition(root, end)\n    );\n  }\n}\n\n;// CONCATENATED MODULE: ./src/vendor/hypothesis/anchoring/types.js\n/**\n * This module exports a set of classes for converting between DOM `Range`\n * objects and different types of selectors. It is mostly a thin wrapper around a\n * set of anchoring libraries. It serves two main purposes:\n *\n *  1. Providing a consistent interface across different types of anchors.\n *  2. Insulating the rest of the code from API changes in the underlying anchoring\n *     libraries.\n */\n\n\n\n\n\n/**\n * @typedef {import(\'../../types/api\').RangeSelector} RangeSelector\n * @typedef {import(\'../../types/api\').TextPositionSelector} TextPositionSelector\n * @typedef {import(\'../../types/api\').TextQuoteSelector} TextQuoteSelector\n */\n\n/**\n * Converts between `RangeSelector` selectors and `Range` objects.\n */\nclass RangeAnchor {\n  /**\n   * @param {Node} root - A root element from which to anchor.\n   * @param {Range} range -  A range describing the anchor.\n   */\n  constructor(root, range) {\n    this.root = root;\n    this.range = range;\n  }\n\n  /**\n   * @param {Node} root -  A root element from which to anchor.\n   * @param {Range} range -  A range describing the anchor.\n   */\n  static fromRange(root, range) {\n    return new RangeAnchor(root, range);\n  }\n\n  /**\n   * Create an anchor from a serialized `RangeSelector` selector.\n   *\n   * @param {Element} root -  A root element from which to anchor.\n   * @param {RangeSelector} selector\n   */\n  static fromSelector(root, selector) {\n    const startContainer = nodeFromXPath(selector.startContainer, root);\n    if (!startContainer) {\n      throw new Error(\'Failed to resolve startContainer XPath\');\n    }\n\n    const endContainer = nodeFromXPath(selector.endContainer, root);\n    if (!endContainer) {\n      throw new Error(\'Failed to resolve endContainer XPath\');\n    }\n\n    const startPos = TextPosition.fromCharOffset(\n      startContainer,\n      selector.startOffset\n    );\n    const endPos = TextPosition.fromCharOffset(\n      endContainer,\n      selector.endOffset\n    );\n\n    const range = new TextRange(startPos, endPos).toRange();\n    return new RangeAnchor(root, range);\n  }\n\n  toRange() {\n    return this.range;\n  }\n\n  /**\n   * @return {RangeSelector}\n   */\n  toSelector() {\n    // "Shrink" the range so that it tightly wraps its text. This ensures more\n    // predictable output for a given text selection.\n    const normalizedRange = TextRange.fromRange(this.range).toRange();\n\n    const textRange = TextRange.fromRange(normalizedRange);\n    const startContainer = xpathFromNode(textRange.start.element, this.root);\n    const endContainer = xpathFromNode(textRange.end.element, this.root);\n\n    return {\n      type: \'RangeSelector\',\n      startContainer,\n      startOffset: textRange.start.offset,\n      endContainer,\n      endOffset: textRange.end.offset,\n    };\n  }\n}\n\n/**\n * Converts between `TextPositionSelector` selectors and `Range` objects.\n */\nclass TextPositionAnchor {\n  /**\n   * @param {Element} root\n   * @param {number} start\n   * @param {number} end\n   */\n  constructor(root, start, end) {\n    this.root = root;\n    this.start = start;\n    this.end = end;\n  }\n\n  /**\n   * @param {Element} root\n   * @param {Range} range\n   */\n  static fromRange(root, range) {\n    const textRange = text_range_TextRange.fromRange(range).relativeTo(root);\n    return new TextPositionAnchor(\n      root,\n      textRange.start.offset,\n      textRange.end.offset\n    );\n  }\n  /**\n   * @param {Element} root\n   * @param {TextPositionSelector} selector\n   */\n  static fromSelector(root, selector) {\n    return new TextPositionAnchor(root, selector.start, selector.end);\n  }\n\n  /**\n   * @return {TextPositionSelector}\n   */\n  toSelector() {\n    return {\n      type: \'TextPositionSelector\',\n      start: this.start,\n      end: this.end,\n    };\n  }\n\n  toRange() {\n    return text_range_TextRange.fromOffsets(this.root, this.start, this.end).toRange();\n  }\n}\n\n/**\n * @typedef QuoteMatchOptions\n * @prop {number} [hint] - Expected position of match in text. See `matchQuote`.\n */\n\n/**\n * Converts between `TextQuoteSelector` selectors and `Range` objects.\n */\nclass types_TextQuoteAnchor {\n  /**\n   * @param {Element} root - A root element from which to anchor.\n   * @param {string} exact\n   * @param {Object} context\n   *   @param {string} [context.prefix]\n   *   @param {string} [context.suffix]\n   */\n  constructor(root, exact, context = {}) {\n    this.root = root;\n    this.exact = exact;\n    this.context = context;\n  }\n\n  /**\n   * Create a `TextQuoteAnchor` from a range.\n   *\n   * Will throw if `range` does not contain any text nodes.\n   *\n   * @param {Element} root\n   * @param {Range} range\n   */\n  static fromRange(root, range) {\n    const text = /** @type {string} */ (root.textContent);\n    const textRange = text_range_TextRange.fromRange(range).relativeTo(root);\n\n    const start = textRange.start.offset;\n    const end = textRange.end.offset;\n\n    // Number of characters around the quote to capture as context. We currently\n    // always use a fixed amount, but it would be better if this code was aware\n    // of logical boundaries in the document (paragraph, article etc.) to avoid\n    // capturing text unrelated to the quote.\n    //\n    // In regular prose the ideal content would often be the surrounding sentence.\n    // This is a natural unit of meaning which enables displaying quotes in\n    // context even when the document is not available. We could use `Intl.Segmenter`\n    // for this when available.\n    const contextLen = 32;\n\n    return new types_TextQuoteAnchor(root, text.slice(start, end), {\n      prefix: text.slice(Math.max(0, start - contextLen), start),\n      suffix: text.slice(end, Math.min(text.length, end + contextLen)),\n    });\n  }\n\n  /**\n   * @param {Element} root\n   * @param {TextQuoteSelector} selector\n   */\n  static fromSelector(root, selector) {\n    const { prefix, suffix } = selector;\n    return new types_TextQuoteAnchor(root, selector.exact, { prefix, suffix });\n  }\n\n  /**\n   * @return {TextQuoteSelector}\n   */\n  toSelector() {\n    return {\n      type: \'TextQuoteSelector\',\n      exact: this.exact,\n      prefix: this.context.prefix,\n      suffix: this.context.suffix,\n    };\n  }\n\n  /**\n   * @param {QuoteMatchOptions} [options]\n   */\n  toRange(options = {}) {\n    return this.toPositionAnchor(options).toRange();\n  }\n\n  /**\n   * @param {QuoteMatchOptions} [options]\n   */\n  toPositionAnchor(options = {}) {\n    const text = /** @type {string} */ (this.root.textContent);\n    const match = matchQuote(text, this.exact, {\n      ...this.context,\n      hint: options.hint,\n    });\n    if (!match) {\n      throw new Error(\'Quote not found\');\n    }\n    return new TextPositionAnchor(this.root, match.start, match.end);\n  }\n}\n\n;// CONCATENATED MODULE: ./src/utils.js\n//\n//  Copyright 2021 Readium Foundation. All rights reserved.\n//  Use of this source code is governed by the BSD-style license\n//  available in the top-level LICENSE file of the project.\n//\n\n// Catch JS errors to log them in the app.\n\n\n\nwindow.addEventListener(\n  "error",\n  function (event) {\n    webkit.messageHandlers.logError.postMessage({\n      message: event.message,\n      filename: event.filename,\n      line: event.lineno,\n    });\n  },\n  false\n);\n\n// Notify native code that the page has loaded.\nwindow.addEventListener(\n  "load",\n  function () {\n    // on page load\n    window.addEventListener("orientationchange", function () {\n      orientationChanged();\n      snapCurrentPosition();\n    });\n    orientationChanged();\n  },\n  false\n);\n\nvar last_known_scrollX_position = 0;\nvar last_known_scrollY_position = 0;\nvar ticking = false;\nvar maxScreenX = 0;\n\n// Position in range [0 - 1].\nfunction update(position) {\n  var positionString = position.toString();\n  webkit.messageHandlers.progressionChanged.postMessage(positionString);\n}\n\nwindow.addEventListener("scroll", function () {\n  last_known_scrollY_position =\n    window.scrollY / document.scrollingElement.scrollHeight;\n  // Using Math.abs because for RTL books, the value will be negative.\n  last_known_scrollX_position = Math.abs(\n    window.scrollX / document.scrollingElement.scrollWidth\n  );\n\n  // Window is hidden\n  if (\n    document.scrollingElement.scrollWidth === 0 ||\n    document.scrollingElement.scrollHeight === 0\n  ) {\n    return;\n  }\n\n  if (!ticking) {\n    window.requestAnimationFrame(function () {\n      update(\n        isScrollModeEnabled()\n          ? last_known_scrollY_position\n          : last_known_scrollX_position\n      );\n      ticking = false;\n    });\n  }\n  ticking = true;\n});\n\ndocument.addEventListener(\n  "selectionchange",\n  debounce(50, function () {\n    var info = {};\n    var selection = document.getSelection();\n    if (selection && selection.rangeCount > 0) {\n      var rect = selection.getRangeAt(0).getBoundingClientRect();\n      info["text"] = selection.toString().trim();\n      info["frame"] = {\n        x: rect.left,\n        y: rect.top,\n        width: rect.width,\n        height: rect.height,\n      };\n    }\n\n    webkit.messageHandlers.selectionChanged.postMessage(info);\n  })\n);\n\nfunction orientationChanged() {\n  maxScreenX =\n    window.orientation === 0 || window.orientation == 180\n      ? screen.width\n      : screen.height;\n}\n\nfunction isScrollModeEnabled() {\n  return (\n    document.documentElement.style\n      .getPropertyValue("--USER__scroll")\n      .toString()\n      .trim() === "readium-scroll-on"\n  );\n}\n\n// Scroll to the given TagId in document and snap.\nfunction scrollToId(id) {\n  var element = document.getElementById(id);\n  if (!element) {\n    return false;\n  }\n  element.scrollIntoView();\n\n  if (!isScrollModeEnabled()) {\n    var currentOffset = window.scrollX;\n    var pageWidth = window.innerWidth;\n    // Adds half a page to make sure we don\'t snap to the previous page.\n    document.scrollingElement.scrollLeft = snapOffset(\n      currentOffset + pageWidth / 2\n    );\n  }\n  return true;\n}\n\n// Position must be in the range [0 - 1], 0-100%.\nfunction scrollToPosition(position, dir) {\n  console.log("ScrollToPosition");\n  if (position < 0 || position > 1) {\n    console.log("InvalidPosition");\n    return;\n  }\n\n  if (isScrollModeEnabled()) {\n    let offset = document.scrollingElement.scrollHeight * position;\n    document.scrollingElement.scrollTop = offset;\n    // window.scrollTo(0, offset);\n  } else {\n    var documentWidth = document.scrollingElement.scrollWidth;\n    var factor = dir == "rtl" ? -1 : 1;\n    let offset = documentWidth * position * factor;\n    document.scrollingElement.scrollLeft = snapOffset(offset);\n  }\n}\n\n// Scrolls to the first occurrence of the given text snippet.\n//\n// The expected text argument is a Locator Text object, as defined here:\n// https://readium.org/architecture/models/locators/\nfunction scrollToText(text) {\n  let range = rangeFromLocator({ text });\n  if (!range) {\n    return false;\n  }\n  scrollToRange(range);\n  return true;\n}\n\nfunction scrollToRange(range) {\n  var rect = range.getBoundingClientRect();\n  if (isScrollModeEnabled()) {\n    document.scrollingElement.scrollTop =\n      rect.top + window.scrollY - window.innerHeight / 2;\n  } else {\n    document.scrollingElement.scrollLeft = rect.left + window.scrollX;\n    snapCurrentPosition();\n  }\n}\n\n// Returns false if the page is already at the left-most scroll offset.\nfunction scrollLeft(dir) {\n  var isRTL = dir == "rtl";\n  var documentWidth = document.scrollingElement.scrollWidth;\n  var pageWidth = window.innerWidth;\n  var offset = window.scrollX - pageWidth;\n  var minOffset = isRTL ? -(documentWidth - pageWidth) : 0;\n  return scrollToOffset(Math.max(offset, minOffset));\n}\n\n// Returns false if the page is already at the right-most scroll offset.\nfunction scrollRight(dir) {\n  var isRTL = dir == "rtl";\n  var documentWidth = document.scrollingElement.scrollWidth;\n  var pageWidth = window.innerWidth;\n  var offset = window.scrollX + pageWidth;\n  var maxOffset = isRTL ? 0 : documentWidth - pageWidth;\n  return scrollToOffset(Math.min(offset, maxOffset));\n}\n\n// Scrolls to the given left offset.\n// Returns false if the page scroll position is already close enough to the given offset.\nfunction scrollToOffset(offset) {\n  var currentOffset = window.scrollX;\n  var pageWidth = window.innerWidth;\n  document.scrollingElement.scrollLeft = offset;\n  // In some case the scrollX cannot reach the position respecting to innerWidth\n  var diff = Math.abs(currentOffset - offset) / pageWidth;\n  return diff > 0.01;\n}\n\n// Snap the offset to the screen width (page width).\nfunction snapOffset(offset) {\n  var value = offset + 1;\n\n  return value - (value % maxScreenX);\n}\n\nfunction snapCurrentPosition() {\n  if (isScrollModeEnabled()) {\n    return;\n  }\n  var currentOffset = window.scrollX;\n  var currentOffsetSnapped = snapOffset(currentOffset + 1);\n\n  document.scrollingElement.scrollLeft = currentOffsetSnapped;\n}\n\nfunction rangeFromLocator(locator) {\n  let text = locator.text;\n  if (!text || !text.highlight) {\n    return null;\n  }\n  try {\n    let anchor = new types_TextQuoteAnchor(document.body, text.highlight, {\n      prefix: text.before,\n      suffix: text.after,\n    });\n    return anchor.toRange();\n  } catch (e) {\n    utils_logError(e);\n    return null;\n  }\n}\n\n/// User Settings.\n\n// For setting user setting.\nfunction setProperty(key, value) {\n  var root = document.documentElement;\n\n  root.style.setProperty(key, value);\n}\n\n// For removing user setting.\nfunction removeProperty(key) {\n  var root = document.documentElement;\n\n  root.style.removeProperty(key);\n}\n\n/// Toolkit\n\nfunction debounce(delay, func) {\n  var timeout;\n  return function () {\n    var self = this;\n    var args = arguments;\n    function callback() {\n      func.apply(self, args);\n      timeout = null;\n    }\n    clearTimeout(timeout);\n    timeout = setTimeout(callback, delay);\n  };\n}\n\nfunction log() {\n  var message = Array.prototype.slice.call(arguments).join(" ");\n  webkit.messageHandlers.log.postMessage(message);\n}\n\nfunction logErrorMessage(msg) {\n  utils_logError(new Error(msg));\n}\n\nfunction utils_logError(e) {\n  webkit.messageHandlers.logError.postMessage({\n    message: e.message,\n  });\n}\n\n;// CONCATENATED MODULE: ./src/selection.js\n//\n//  Copyright 2021 Readium Foundation. All rights reserved.\n//  Use of this source code is governed by the BSD-style license\n//  available in the top-level LICENSE file of the project.\n//\n\n\n\n\nconst debug = true;\n\nfunction getSelectionRect() {\n  try {\n    let sel = window.getSelection();\n    if (!sel) {\n      return;\n    }\n    let range = sel.getRangeAt(0);\n\n    const clientRect = range.getBoundingClientRect();\n\n    return {\n      screenWidth: window.outerWidth,\n      screenHeight: window.outerHeight,\n      left: clientRect.left,\n      width: clientRect.width,\n      top: clientRect.top,\n      height: clientRect.height,\n    };\n  } catch (e) {\n    utils_logError(e);\n    return null;\n  }\n}\n\nfunction getCurrentSelectionInfo() {\n  const selection = window.getSelection();\n  if (!selection) {\n    return undefined;\n  }\n  if (selection.isCollapsed) {\n    selection_log("^^^ SELECTION COLLAPSED.");\n    return undefined;\n  }\n  const rawText = selection.toString();\n  const cleanText = rawText.trim().replace(/\\n/g, " ").replace(/\\s\\s+/g, " ");\n  if (cleanText.length === 0) {\n    selection_log("^^^ SELECTION TEXT EMPTY.");\n    return undefined;\n  }\n  if (!selection.anchorNode || !selection.focusNode) {\n    return undefined;\n  }\n  const range =\n    selection.rangeCount === 1\n      ? selection.getRangeAt(0)\n      : createOrderedRange(\n          selection.anchorNode,\n          selection.anchorOffset,\n          selection.focusNode,\n          selection.focusOffset\n        );\n  if (!range || range.collapsed) {\n    selection_log("$$$$$$$$$$$$$$$$$ CANNOT GET NON-COLLAPSED SELECTION RANGE?!");\n    return undefined;\n  }\n  const rangeInfo = convertRange(range, fullQualifiedSelector);\n  if (!rangeInfo) {\n    selection_log("^^^ SELECTION RANGE INFO FAIL?!");\n    return undefined;\n  }\n\n  const text = document.body.textContent;\n  const textRange = text_range_TextRange.fromRange(range).relativeTo(document.body);\n  const start = textRange.start.offset;\n  const end = textRange.end.offset;\n\n  const snippetLength = 200;\n\n  // Compute the text before the highlight, ignoring the first "word", which might be cut.\n  let before = text.slice(Math.max(0, start - snippetLength), start);\n  let firstWordStart = before.search(/\\P{L}\\p{L}/gu);\n  if (firstWordStart !== -1) {\n    before = before.slice(firstWordStart + 1);\n  }\n\n  // Compute the text after the highlight, ignoring the last "word", which might be cut.\n  let after = text.slice(end, Math.min(text.length, end + snippetLength));\n  let lastWordEnd = Array.from(after.matchAll(/\\p{L}\\P{L}/gu)).pop();\n  if (lastWordEnd !== undefined && lastWordEnd.index > 1) {\n    after = after.slice(0, lastWordEnd.index + 1);\n  }\n\n  return {\n    locations: rangeInfo2Location(rangeInfo),\n    text: {\n      highlight: rawText,\n      before: before,\n      after: after,\n    },\n  };\n}\n\nfunction createOrderedRange(startNode, startOffset, endNode, endOffset) {\n  const range = new Range();\n  range.setStart(startNode, startOffset);\n  range.setEnd(endNode, endOffset);\n  if (!range.collapsed) {\n    return range;\n  }\n  selection_log(">>> createOrderedRange COLLAPSED ... RANGE REVERSE?");\n  const rangeReverse = new Range();\n  rangeReverse.setStart(endNode, endOffset);\n  rangeReverse.setEnd(startNode, startOffset);\n  if (!rangeReverse.collapsed) {\n    selection_log(">>> createOrderedRange RANGE REVERSE OK.");\n    return range;\n  }\n  selection_log(">>> createOrderedRange RANGE REVERSE ALSO COLLAPSED?!");\n  return undefined;\n}\n\nfunction convertRange(range, getCssSelector) {\n  const startIsElement = range.startContainer.nodeType === Node.ELEMENT_NODE;\n  const startContainerElement = startIsElement\n    ? range.startContainer\n    : range.startContainer.parentNode &&\n      range.startContainer.parentNode.nodeType === Node.ELEMENT_NODE\n    ? range.startContainer.parentNode\n    : undefined;\n  if (!startContainerElement) {\n    return undefined;\n  }\n  const startContainerChildTextNodeIndex = startIsElement\n    ? -1\n    : Array.from(startContainerElement.childNodes).indexOf(\n        range.startContainer\n      );\n  if (startContainerChildTextNodeIndex < -1) {\n    return undefined;\n  }\n  const startContainerElementCssSelector = getCssSelector(\n    startContainerElement\n  );\n\n  const endIsElement = range.endContainer.nodeType === Node.ELEMENT_NODE;\n  const endContainerElement = endIsElement\n    ? range.endContainer\n    : range.endContainer.parentNode &&\n      range.endContainer.parentNode.nodeType === Node.ELEMENT_NODE\n    ? range.endContainer.parentNode\n    : undefined;\n  if (!endContainerElement) {\n    return undefined;\n  }\n  const endContainerChildTextNodeIndex = endIsElement\n    ? -1\n    : Array.from(endContainerElement.childNodes).indexOf(range.endContainer);\n  if (endContainerChildTextNodeIndex < -1) {\n    return undefined;\n  }\n  const endContainerElementCssSelector = getCssSelector(endContainerElement);\n\n  const commonElementAncestor = getCommonAncestorElement(\n    range.startContainer,\n    range.endContainer\n  );\n  if (!commonElementAncestor) {\n    selection_log("^^^ NO RANGE COMMON ANCESTOR?!");\n    return undefined;\n  }\n  if (range.commonAncestorContainer) {\n    const rangeCommonAncestorElement =\n      range.commonAncestorContainer.nodeType === Node.ELEMENT_NODE\n        ? range.commonAncestorContainer\n        : range.commonAncestorContainer.parentNode;\n    if (\n      rangeCommonAncestorElement &&\n      rangeCommonAncestorElement.nodeType === Node.ELEMENT_NODE\n    ) {\n      if (commonElementAncestor !== rangeCommonAncestorElement) {\n        selection_log(">>>>>> COMMON ANCESTOR CONTAINER DIFF??!");\n        selection_log(getCssSelector(commonElementAncestor));\n        selection_log(getCssSelector(rangeCommonAncestorElement));\n      }\n    }\n  }\n  return {\n    endContainerChildTextNodeIndex,\n    endContainerElementCssSelector,\n    endOffset: range.endOffset,\n    startContainerChildTextNodeIndex,\n    startContainerElementCssSelector,\n    startOffset: range.startOffset,\n  };\n}\n\nfunction getCommonAncestorElement(node1, node2) {\n  if (node1.nodeType === Node.ELEMENT_NODE && node1 === node2) {\n    return node1;\n  }\n  if (node1.nodeType === Node.ELEMENT_NODE && node1.contains(node2)) {\n    return node1;\n  }\n  if (node2.nodeType === Node.ELEMENT_NODE && node2.contains(node1)) {\n    return node2;\n  }\n  const node1ElementAncestorChain = [];\n  let parent = node1.parentNode;\n  while (parent && parent.nodeType === Node.ELEMENT_NODE) {\n    node1ElementAncestorChain.push(parent);\n    parent = parent.parentNode;\n  }\n  const node2ElementAncestorChain = [];\n  parent = node2.parentNode;\n  while (parent && parent.nodeType === Node.ELEMENT_NODE) {\n    node2ElementAncestorChain.push(parent);\n    parent = parent.parentNode;\n  }\n  let commonAncestor = node1ElementAncestorChain.find(\n    (node1ElementAncestor) => {\n      return node2ElementAncestorChain.indexOf(node1ElementAncestor) >= 0;\n    }\n  );\n  if (!commonAncestor) {\n    commonAncestor = node2ElementAncestorChain.find((node2ElementAncestor) => {\n      return node1ElementAncestorChain.indexOf(node2ElementAncestor) >= 0;\n    });\n  }\n  return commonAncestor;\n}\n\nfunction convertRangeInfo(document, rangeInfo) {\n  const startElement = document.querySelector(\n    rangeInfo.startContainerElementCssSelector\n  );\n  if (!startElement) {\n    selection_log("^^^ convertRangeInfo NO START ELEMENT CSS SELECTOR?!");\n    return undefined;\n  }\n  let startContainer = startElement;\n  if (rangeInfo.startContainerChildTextNodeIndex >= 0) {\n    if (\n      rangeInfo.startContainerChildTextNodeIndex >=\n      startElement.childNodes.length\n    ) {\n      selection_log(\n        "^^^ convertRangeInfo rangeInfo.startContainerChildTextNodeIndex >= startElement.childNodes.length?!"\n      );\n      return undefined;\n    }\n    startContainer =\n      startElement.childNodes[rangeInfo.startContainerChildTextNodeIndex];\n    if (startContainer.nodeType !== Node.TEXT_NODE) {\n      selection_log("^^^ convertRangeInfo startContainer.nodeType !== Node.TEXT_NODE?!");\n      return undefined;\n    }\n  }\n  const endElement = document.querySelector(\n    rangeInfo.endContainerElementCssSelector\n  );\n  if (!endElement) {\n    selection_log("^^^ convertRangeInfo NO END ELEMENT CSS SELECTOR?!");\n    return undefined;\n  }\n  let endContainer = endElement;\n  if (rangeInfo.endContainerChildTextNodeIndex >= 0) {\n    if (\n      rangeInfo.endContainerChildTextNodeIndex >= endElement.childNodes.length\n    ) {\n      selection_log(\n        "^^^ convertRangeInfo rangeInfo.endContainerChildTextNodeIndex >= endElement.childNodes.length?!"\n      );\n      return undefined;\n    }\n    endContainer =\n      endElement.childNodes[rangeInfo.endContainerChildTextNodeIndex];\n    if (endContainer.nodeType !== Node.TEXT_NODE) {\n      selection_log("^^^ convertRangeInfo endContainer.nodeType !== Node.TEXT_NODE?!");\n      return undefined;\n    }\n  }\n  return createOrderedRange(\n    startContainer,\n    rangeInfo.startOffset,\n    endContainer,\n    rangeInfo.endOffset\n  );\n}\n\nfunction rangeInfo2Location(rangeInfo) {\n  return {\n    cssSelector: rangeInfo.startContainerElementCssSelector,\n    domRange: {\n      start: {\n        cssSelector: rangeInfo.startContainerElementCssSelector,\n        textNodeIndex: rangeInfo.startContainerChildTextNodeIndex,\n        offset: rangeInfo.startOffset,\n      },\n      end: {\n        cssSelector: rangeInfo.endContainerElementCssSelector,\n        textNodeIndex: rangeInfo.endContainerChildTextNodeIndex,\n        offset: rangeInfo.endOffset,\n      },\n    },\n  };\n}\n\nfunction location2RangeInfo(location) {\n  const locations = location.locations;\n  const domRange = locations.domRange;\n  const start = domRange.start;\n  const end = domRange.end;\n\n  return {\n    endContainerChildTextNodeIndex: end.textNodeIndex,\n    endContainerElementCssSelector: end.cssSelector,\n    endOffset: end.offset,\n    startContainerChildTextNodeIndex: start.textNodeIndex,\n    startContainerElementCssSelector: start.cssSelector,\n    startOffset: start.offset,\n  };\n}\n\nfunction fullQualifiedSelector(node) {\n  if (node.nodeType !== Node.ELEMENT_NODE) {\n    return (\n      (node.localName && node.localName.toLowerCase()) ||\n      node.nodeName.toLowerCase()\n    );\n  }\n  //return cssPath(node, justSelector);\n  return cssPath(node, true);\n}\n\nfunction cssPath(node, optimized) {\n  if (node.nodeType !== Node.ELEMENT_NODE) {\n    return "";\n  }\n\n  const steps = [];\n  let contextNode = node;\n  while (contextNode) {\n    const step = _cssPathStep(contextNode, !!optimized, contextNode === node);\n    if (!step) {\n      break; // Error - bail out early.\n    }\n    steps.push(step.value);\n    if (step.optimized) {\n      break;\n    }\n    contextNode = contextNode.parentNode;\n  }\n  steps.reverse();\n  return steps.join(" > ");\n}\n\n// https://chromium.googlesource.com/chromium/blink/+/master/Source/devtools/front_end/components/DOMPresentationUtils.js#316\nfunction _cssPathStep(node, optimized, isTargetNode) {\n  function idSelector(idd) {\n    return "#" + escapeIdentifierIfNeeded(idd);\n  }\n\n  function escapeIdentifierIfNeeded(ident) {\n    if (isCSSIdentifier(ident)) {\n      return ident;\n    }\n\n    const shouldEscapeFirst = /^(?:[0-9]|-[0-9-]?)/.test(ident);\n    const lastIndex = ident.length - 1;\n    return ident.replace(/./g, function (c, ii) {\n      return (shouldEscapeFirst && ii === 0) || !isCSSIdentChar(c)\n        ? escapeAsciiChar(c, ii === lastIndex)\n        : c;\n    });\n  }\n\n  function isCSSIdentifier(value) {\n    return /^-?[a-zA-Z_][a-zA-Z0-9_-]*$/.test(value);\n  }\n\n  function isCSSIdentChar(c) {\n    if (/[a-zA-Z0-9_-]/.test(c)) {\n      return true;\n    }\n    return c.charCodeAt(0) >= 0xa0;\n  }\n\n  function escapeAsciiChar(c, isLast) {\n    return "\\\\" + toHexByte(c) + (isLast ? "" : " ");\n  }\n\n  function toHexByte(c) {\n    let hexByte = c.charCodeAt(0).toString(16);\n    if (hexByte.length === 1) {\n      hexByte = "0" + hexByte;\n    }\n    return hexByte;\n  }\n\n  function prefixedElementClassNames(nd) {\n    const classAttribute = nd.getAttribute("class");\n    if (!classAttribute) {\n      return [];\n    }\n\n    return classAttribute\n      .split(/\\s+/g)\n      .filter(Boolean)\n      .map((nm) => {\n        // The prefix is required to store "__proto__" in a object-based map.\n        return "$" + nm;\n      });\n  }\n\n  if (node.nodeType !== Node.ELEMENT_NODE) {\n    return undefined;\n  }\n  const lowerCaseName =\n    (node.localName && node.localName.toLowerCase()) ||\n    node.nodeName.toLowerCase();\n\n  const element = node;\n\n  const id = element.getAttribute("id");\n\n  if (optimized) {\n    if (id) {\n      return {\n        optimized: true,\n        value: idSelector(id),\n      };\n    }\n    if (\n      lowerCaseName === "body" ||\n      lowerCaseName === "head" ||\n      lowerCaseName === "html"\n    ) {\n      return {\n        optimized: true,\n        value: lowerCaseName, // node.nodeNameInCorrectCase(),\n      };\n    }\n  }\n\n  const nodeName = lowerCaseName; // node.nodeNameInCorrectCase();\n  if (id) {\n    return {\n      optimized: true,\n      value: nodeName + idSelector(id),\n    };\n  }\n\n  const parent = node.parentNode;\n\n  if (!parent || parent.nodeType === Node.DOCUMENT_NODE) {\n    return {\n      optimized: true,\n      value: nodeName,\n    };\n  }\n\n  const prefixedOwnClassNamesArray_ = prefixedElementClassNames(element);\n\n  const prefixedOwnClassNamesArray = []; // .keySet()\n  prefixedOwnClassNamesArray_.forEach((arrItem) => {\n    if (prefixedOwnClassNamesArray.indexOf(arrItem) < 0) {\n      prefixedOwnClassNamesArray.push(arrItem);\n    }\n  });\n\n  let needsClassNames = false;\n  let needsNthChild = false;\n  let ownIndex = -1;\n  let elementIndex = -1;\n  const siblings = parent.children;\n\n  for (\n    let i = 0;\n    (ownIndex === -1 || !needsNthChild) && i < siblings.length;\n    ++i\n  ) {\n    const sibling = siblings[i];\n    if (sibling.nodeType !== Node.ELEMENT_NODE) {\n      continue;\n    }\n    elementIndex += 1;\n    if (sibling === node) {\n      ownIndex = elementIndex;\n      continue;\n    }\n    if (needsNthChild) {\n      continue;\n    }\n\n    // sibling.nodeNameInCorrectCase()\n    const siblingName =\n      (sibling.localName && sibling.localName.toLowerCase()) ||\n      sibling.nodeName.toLowerCase();\n    if (siblingName !== nodeName) {\n      continue;\n    }\n    needsClassNames = true;\n\n    const ownClassNames = [];\n    prefixedOwnClassNamesArray.forEach((arrItem) => {\n      ownClassNames.push(arrItem);\n    });\n    let ownClassNameCount = ownClassNames.length;\n\n    if (ownClassNameCount === 0) {\n      needsNthChild = true;\n      continue;\n    }\n    const siblingClassNamesArray_ = prefixedElementClassNames(sibling);\n    const siblingClassNamesArray = []; // .keySet()\n    siblingClassNamesArray_.forEach((arrItem) => {\n      if (siblingClassNamesArray.indexOf(arrItem) < 0) {\n        siblingClassNamesArray.push(arrItem);\n      }\n    });\n\n    for (const siblingClass of siblingClassNamesArray) {\n      const ind = ownClassNames.indexOf(siblingClass);\n      if (ind < 0) {\n        continue;\n      }\n\n      ownClassNames.splice(ind, 1); // delete ownClassNames[siblingClass];\n\n      if (!--ownClassNameCount) {\n        needsNthChild = true;\n        break;\n      }\n    }\n  }\n\n  let result = nodeName;\n  if (\n    isTargetNode &&\n    nodeName === "input" &&\n    element.getAttribute("type") &&\n    !element.getAttribute("id") &&\n    !element.getAttribute("class")\n  ) {\n    result += \'[type="\' + element.getAttribute("type") + \'"]\';\n  }\n  if (needsNthChild) {\n    result += ":nth-child(" + (ownIndex + 1) + ")";\n  } else if (needsClassNames) {\n    for (const prefixedName of prefixedOwnClassNamesArray) {\n      result += "." + escapeIdentifierIfNeeded(prefixedName.substr(1));\n    }\n  }\n\n  return {\n    optimized: false,\n    value: result,\n  };\n}\n\nfunction selection_log() {\n  if (debug) {\n    log.apply(null, arguments);\n  }\n}\n\n;// CONCATENATED MODULE: ./src/rect.js\n//\n//  Copyright 2021 Readium Foundation. All rights reserved.\n//  Use of this source code is governed by the BSD-style license\n//  available in the top-level LICENSE file of the project.\n//\n\n\n\nconst rect_debug = false;\n\nfunction rect_getClientRectsNoOverlap(\n  range,\n  doNotMergeHorizontallyAlignedRects\n) {\n  let clientRects = range.getClientRects();\n\n  const tolerance = 1;\n  const originalRects = [];\n  for (const rangeClientRect of clientRects) {\n    originalRects.push({\n      bottom: rangeClientRect.bottom,\n      height: rangeClientRect.height,\n      left: rangeClientRect.left,\n      right: rangeClientRect.right,\n      top: rangeClientRect.top,\n      width: rangeClientRect.width,\n    });\n  }\n  const mergedRects = mergeTouchingRects(\n    originalRects,\n    tolerance,\n    doNotMergeHorizontallyAlignedRects\n  );\n  const noContainedRects = removeContainedRects(mergedRects, tolerance);\n  const newRects = replaceOverlapingRects(noContainedRects);\n  const minArea = 2 * 2;\n  for (let j = newRects.length - 1; j >= 0; j--) {\n    const rect = newRects[j];\n    const bigEnough = rect.width * rect.height > minArea;\n    if (!bigEnough) {\n      if (newRects.length > 1) {\n        rect_log("CLIENT RECT: remove small");\n        newRects.splice(j, 1);\n      } else {\n        rect_log("CLIENT RECT: remove small, but keep otherwise empty!");\n        break;\n      }\n    }\n  }\n  rect_log(`CLIENT RECT: reduced ${originalRects.length} --\x3e ${newRects.length}`);\n  return newRects;\n}\n\nfunction mergeTouchingRects(\n  rects,\n  tolerance,\n  doNotMergeHorizontallyAlignedRects\n) {\n  for (let i = 0; i < rects.length; i++) {\n    for (let j = i + 1; j < rects.length; j++) {\n      const rect1 = rects[i];\n      const rect2 = rects[j];\n      if (rect1 === rect2) {\n        rect_log("mergeTouchingRects rect1 === rect2 ??!");\n        continue;\n      }\n      const rectsLineUpVertically =\n        almostEqual(rect1.top, rect2.top, tolerance) &&\n        almostEqual(rect1.bottom, rect2.bottom, tolerance);\n      const rectsLineUpHorizontally =\n        almostEqual(rect1.left, rect2.left, tolerance) &&\n        almostEqual(rect1.right, rect2.right, tolerance);\n      const horizontalAllowed = !doNotMergeHorizontallyAlignedRects;\n      const aligned =\n        (rectsLineUpHorizontally && horizontalAllowed) ||\n        (rectsLineUpVertically && !rectsLineUpHorizontally);\n      const canMerge = aligned && rectsTouchOrOverlap(rect1, rect2, tolerance);\n      if (canMerge) {\n        rect_log(\n          `CLIENT RECT: merging two into one, VERTICAL: ${rectsLineUpVertically} HORIZONTAL: ${rectsLineUpHorizontally} (${doNotMergeHorizontallyAlignedRects})`\n        );\n        const newRects = rects.filter((rect) => {\n          return rect !== rect1 && rect !== rect2;\n        });\n        const replacementClientRect = getBoundingRect(rect1, rect2);\n        newRects.push(replacementClientRect);\n        return mergeTouchingRects(\n          newRects,\n          tolerance,\n          doNotMergeHorizontallyAlignedRects\n        );\n      }\n    }\n  }\n  return rects;\n}\n\nfunction getBoundingRect(rect1, rect2) {\n  const left = Math.min(rect1.left, rect2.left);\n  const right = Math.max(rect1.right, rect2.right);\n  const top = Math.min(rect1.top, rect2.top);\n  const bottom = Math.max(rect1.bottom, rect2.bottom);\n  return {\n    bottom,\n    height: bottom - top,\n    left,\n    right,\n    top,\n    width: right - left,\n  };\n}\n\nfunction removeContainedRects(rects, tolerance) {\n  const rectsToKeep = new Set(rects);\n  for (const rect of rects) {\n    const bigEnough = rect.width > 1 && rect.height > 1;\n    if (!bigEnough) {\n      rect_log("CLIENT RECT: remove tiny");\n      rectsToKeep.delete(rect);\n      continue;\n    }\n    for (const possiblyContainingRect of rects) {\n      if (rect === possiblyContainingRect) {\n        continue;\n      }\n      if (!rectsToKeep.has(possiblyContainingRect)) {\n        continue;\n      }\n      if (rectContains(possiblyContainingRect, rect, tolerance)) {\n        rect_log("CLIENT RECT: remove contained");\n        rectsToKeep.delete(rect);\n        break;\n      }\n    }\n  }\n  return Array.from(rectsToKeep);\n}\n\nfunction rectContains(rect1, rect2, tolerance) {\n  return (\n    rectContainsPoint(rect1, rect2.left, rect2.top, tolerance) &&\n    rectContainsPoint(rect1, rect2.right, rect2.top, tolerance) &&\n    rectContainsPoint(rect1, rect2.left, rect2.bottom, tolerance) &&\n    rectContainsPoint(rect1, rect2.right, rect2.bottom, tolerance)\n  );\n}\n\nfunction rectContainsPoint(rect, x, y, tolerance) {\n  return (\n    (rect.left < x || almostEqual(rect.left, x, tolerance)) &&\n    (rect.right > x || almostEqual(rect.right, x, tolerance)) &&\n    (rect.top < y || almostEqual(rect.top, y, tolerance)) &&\n    (rect.bottom > y || almostEqual(rect.bottom, y, tolerance))\n  );\n}\n\nfunction replaceOverlapingRects(rects) {\n  for (let i = 0; i < rects.length; i++) {\n    for (let j = i + 1; j < rects.length; j++) {\n      const rect1 = rects[i];\n      const rect2 = rects[j];\n      if (rect1 === rect2) {\n        rect_log("replaceOverlapingRects rect1 === rect2 ??!");\n        continue;\n      }\n      if (rectsTouchOrOverlap(rect1, rect2, -1)) {\n        let toAdd = [];\n        let toRemove;\n        const subtractRects1 = rectSubtract(rect1, rect2);\n        if (subtractRects1.length === 1) {\n          toAdd = subtractRects1;\n          toRemove = rect1;\n        } else {\n          const subtractRects2 = rectSubtract(rect2, rect1);\n          if (subtractRects1.length < subtractRects2.length) {\n            toAdd = subtractRects1;\n            toRemove = rect1;\n          } else {\n            toAdd = subtractRects2;\n            toRemove = rect2;\n          }\n        }\n        rect_log(`CLIENT RECT: overlap, cut one rect into ${toAdd.length}`);\n        const newRects = rects.filter((rect) => {\n          return rect !== toRemove;\n        });\n        Array.prototype.push.apply(newRects, toAdd);\n        return replaceOverlapingRects(newRects);\n      }\n    }\n  }\n  return rects;\n}\n\nfunction rectSubtract(rect1, rect2) {\n  const rectIntersected = rectIntersect(rect2, rect1);\n  if (rectIntersected.height === 0 || rectIntersected.width === 0) {\n    return [rect1];\n  }\n  const rects = [];\n  {\n    const rectA = {\n      bottom: rect1.bottom,\n      height: 0,\n      left: rect1.left,\n      right: rectIntersected.left,\n      top: rect1.top,\n      width: 0,\n    };\n    rectA.width = rectA.right - rectA.left;\n    rectA.height = rectA.bottom - rectA.top;\n    if (rectA.height !== 0 && rectA.width !== 0) {\n      rects.push(rectA);\n    }\n  }\n  {\n    const rectB = {\n      bottom: rectIntersected.top,\n      height: 0,\n      left: rectIntersected.left,\n      right: rectIntersected.right,\n      top: rect1.top,\n      width: 0,\n    };\n    rectB.width = rectB.right - rectB.left;\n    rectB.height = rectB.bottom - rectB.top;\n    if (rectB.height !== 0 && rectB.width !== 0) {\n      rects.push(rectB);\n    }\n  }\n  {\n    const rectC = {\n      bottom: rect1.bottom,\n      height: 0,\n      left: rectIntersected.left,\n      right: rectIntersected.right,\n      top: rectIntersected.bottom,\n      width: 0,\n    };\n    rectC.width = rectC.right - rectC.left;\n    rectC.height = rectC.bottom - rectC.top;\n    if (rectC.height !== 0 && rectC.width !== 0) {\n      rects.push(rectC);\n    }\n  }\n  {\n    const rectD = {\n      bottom: rect1.bottom,\n      height: 0,\n      left: rectIntersected.right,\n      right: rect1.right,\n      top: rect1.top,\n      width: 0,\n    };\n    rectD.width = rectD.right - rectD.left;\n    rectD.height = rectD.bottom - rectD.top;\n    if (rectD.height !== 0 && rectD.width !== 0) {\n      rects.push(rectD);\n    }\n  }\n  return rects;\n}\n\nfunction rectIntersect(rect1, rect2) {\n  const maxLeft = Math.max(rect1.left, rect2.left);\n  const minRight = Math.min(rect1.right, rect2.right);\n  const maxTop = Math.max(rect1.top, rect2.top);\n  const minBottom = Math.min(rect1.bottom, rect2.bottom);\n  return {\n    bottom: minBottom,\n    height: Math.max(0, minBottom - maxTop),\n    left: maxLeft,\n    right: minRight,\n    top: maxTop,\n    width: Math.max(0, minRight - maxLeft),\n  };\n}\n\nfunction rectsTouchOrOverlap(rect1, rect2, tolerance) {\n  return (\n    (rect1.left < rect2.right ||\n      (tolerance >= 0 && almostEqual(rect1.left, rect2.right, tolerance))) &&\n    (rect2.left < rect1.right ||\n      (tolerance >= 0 && almostEqual(rect2.left, rect1.right, tolerance))) &&\n    (rect1.top < rect2.bottom ||\n      (tolerance >= 0 && almostEqual(rect1.top, rect2.bottom, tolerance))) &&\n    (rect2.top < rect1.bottom ||\n      (tolerance >= 0 && almostEqual(rect2.top, rect1.bottom, tolerance)))\n  );\n}\n\nfunction almostEqual(a, b, tolerance) {\n  return Math.abs(a - b) <= tolerance;\n}\n\nfunction rect_log() {\n  if (rect_debug) {\n    log.apply(null, arguments);\n  }\n}\n\n;// CONCATENATED MODULE: ./src/highlight.js\n//\n//  Copyright 2021 Readium Foundation. All rights reserved.\n//  Use of this source code is governed by the BSD-style license\n//  available in the top-level LICENSE file of the project.\n//\n\n\n\n\n\n\nconst highlight_debug = false;\n\nconst ID_HIGHLIGHTS_CONTAINER = "R2_ID_HIGHLIGHTS_CONTAINER";\nconst CLASS_HIGHLIGHT_CONTAINER = "R2_CLASS_HIGHLIGHT_CONTAINER";\nconst CLASS_HIGHLIGHT_AREA = "R2_CLASS_HIGHLIGHT_AREA";\nconst CLASS_HIGHLIGHT_BOUNDING_AREA = "R2_CLASS_HIGHLIGHT_BOUNDING_AREA";\n\nconst _highlights = [];\nlet _highlightsContainer;\n\nconst defaultBackgroundOpacity = 0.3;\n\nconst defaultBackgroundColor = {\n  blue: 100,\n  green: 50,\n  red: 230,\n};\n\nwindow.addEventListener(\n  "load",\n  function () {\n    // on page load\n    const body = document.body;\n    var lastSize = { width: 0, height: 0 };\n    const observer = new ResizeObserver(() => {\n      log(body.clientWidth, body.clientHeight);\n      if (\n        lastSize.width === body.clientWidth &&\n        lastSize.height === body.clientHeight\n      ) {\n        return;\n      }\n      lastSize = {\n        width: body.clientWidth,\n        height: body.clientHeight,\n      };\n      resetHighlights();\n    });\n    observer.observe(body);\n  },\n  false\n);\n\nfunction rectForHighlightWithID(id) {\n  const clientRects = frameForHighlightWithID(id);\n\n  return {\n    screenWidth: window.outerWidth,\n    screenHeight: window.outerHeight,\n    left: clientRects[0].left,\n    width: clientRects[0].width,\n    top: clientRects[0].top,\n    height: clientRects[0].height,\n  };\n}\n\nfunction clearHighlights() {\n  hideAllHighlights();\n  _highlights.splice(0, _highlights.length);\n}\n\nfunction hideAllHighlights() {\n  if (_highlightsContainer) {\n    _highlightsContainer.remove();\n    _highlightsContainer = null;\n  }\n}\n\nfunction resetHighlights() {\n  hideAllHighlights();\n\n  let i = _highlights.length;\n  while (i--) {\n    let highlight = _highlights[i];\n    if (highlight.transient) {\n      _highlights.splice(i, 1);\n    } else {\n      createHighlightDOM(highlight);\n    }\n  }\n}\n\nfunction highlight(locator) {\n  let text = locator.text;\n  if (!text || !text.highlight) {\n    return;\n  }\n\n  try {\n    let anchor = new TextQuoteAnchor(document.body, text.highlight, {\n      prefix: text.before,\n      suffix: text.after,\n    });\n    anchor.toRange();\n    highlightRange(anchor.toRange());\n  } catch (e) {\n    logError(e);\n  }\n}\n\nfunction highlightRange(range) {\n  // FIXME: Use user-provided ID.\n  let id = "R2_HIGHLIGHT_" + Date.now();\n\n  destroyHighlight(id);\n\n  const highlight = {\n    color: defaultBackgroundColor,\n    id,\n    pointerInteraction: true,\n    range: range,\n    transient: true,\n  };\n  _highlights.push(highlight);\n  createHighlightDOM(highlight);\n\n  return highlight;\n}\n\nfunction destroyHighlight(id) {\n  let i = -1;\n  let _document = window.document;\n  const highlight = _highlights.find((h, j) => {\n    i = j;\n    return h.id === id;\n  });\n  if (highlight && i >= 0 && i < _highlights.length) {\n    _highlights.splice(i, 1);\n  }\n  const highlightContainer = _document.getElementById(id);\n  if (highlightContainer) {\n    highlightContainer.remove();\n  }\n}\n\nfunction createHighlightDOM(highlight) {\n  if (!highlight.range) {\n    return undefined;\n  }\n\n  const scrollElement = document.scrollingElement;\n\n  const paginated = !isScrollModeEnabled();\n  const highlightsContainer = ensureContainer(window);\n  const highlightParent = document.createElement("div");\n\n  highlightParent.setAttribute("id", highlight.id);\n  highlightParent.setAttribute("class", CLASS_HIGHLIGHT_CONTAINER);\n\n  highlightParent.style.setProperty("pointer-events", "none");\n  if (highlight.pointerInteraction) {\n    highlightParent.setAttribute("data-click", "1");\n  }\n\n  const bodyRect = document.body.getBoundingClientRect();\n  const drawUnderline = false;\n  const drawStrikeThrough = false;\n  const doNotMergeHorizontallyAlignedRects = drawUnderline || drawStrikeThrough;\n  const clientRects = rect_getClientRectsNoOverlap(\n    highlight.range,\n    doNotMergeHorizontallyAlignedRects\n  );\n  const roundedCorner = 3;\n  const underlineThickness = 2;\n  const strikeThroughLineThickness = 3;\n  const opacity = defaultBackgroundOpacity;\n  let extra = "";\n\n  let xOffset = paginated ? -scrollElement.scrollLeft : bodyRect.left;\n  let yOffset = paginated ? -scrollElement.scrollTop : bodyRect.top;\n\n  for (const clientRect of clientRects) {\n    const highlightArea = document.createElement("div");\n\n    highlightArea.setAttribute("class", CLASS_HIGHLIGHT_AREA);\n\n    if (highlight_debug) {\n      const rgb = Math.round(0xffffff * Math.random());\n      const r = rgb >> 16;\n      const g = (rgb >> 8) & 255;\n      const b = rgb & 255;\n      extra = `outline-color: rgb(${r}, ${g}, ${b}); outline-style: solid; outline-width: 1px; outline-offset: -1px;`;\n    } else {\n      if (drawUnderline) {\n        extra += `border-bottom: ${underlineThickness}px solid rgba(${highlight.color.red}, ${highlight.color.green}, ${highlight.color.blue}, ${opacity}) !important`;\n      }\n    }\n    highlightArea.setAttribute(\n      "style",\n      `border-radius: ${roundedCorner}px !important; background-color: rgba(${highlight.color.red}, ${highlight.color.green}, ${highlight.color.blue}, ${opacity}) !important; ${extra}`\n    );\n    highlightArea.style.setProperty("pointer-events", "none");\n    highlightArea.style.position = "absolute";\n    highlightArea.scale = 1;\n    /*\n         highlightArea.rect = {\n         height: clientRect.height,\n         left: clientRect.left - xOffset,\n         top: clientRect.top - yOffset,\n         width: clientRect.width,\n         };\n         */\n    highlightArea.rect = {\n      height: clientRect.height,\n      left: clientRect.left - xOffset,\n      top: clientRect.top - yOffset,\n      width: clientRect.width,\n    };\n\n    highlightArea.style.width = `${highlightArea.rect.width}px`;\n    highlightArea.style.height = `${highlightArea.rect.height}px`;\n    highlightArea.style.left = `${highlightArea.rect.left}px`;\n    highlightArea.style.top = `${highlightArea.rect.top}px`;\n    highlightParent.append(highlightArea);\n    if (!highlight_debug && drawStrikeThrough) {\n      //if (drawStrikeThrough) {\n      const highlightAreaLine = document.createElement("div");\n      highlightAreaLine.setAttribute("class", CLASS_HIGHLIGHT_AREA);\n\n      highlightAreaLine.setAttribute(\n        "style",\n        `background-color: rgba(${highlight.color.red}, ${highlight.color.green}, ${highlight.color.blue}, ${opacity}) !important;`\n      );\n      highlightAreaLine.style.setProperty("pointer-events", "none");\n      highlightAreaLine.style.position = paginated ? "fixed" : "absolute";\n      highlightAreaLine.scale = 1;\n      /*\n             highlightAreaLine.rect = {\n             height: clientRect.height,\n             left: clientRect.left - xOffset,\n             top: clientRect.top - yOffset,\n             width: clientRect.width,\n             };\n             */\n\n      highlightAreaLine.rect = {\n        height: clientRect.height,\n        left: clientRect.left - xOffset,\n        top: clientRect.top - yOffset,\n        width: clientRect.width,\n      };\n\n      highlightAreaLine.style.width = `${highlightAreaLine.rect.width}px`;\n      highlightAreaLine.style.height = `${strikeThroughLineThickness}px`;\n      highlightAreaLine.style.left = `${highlightAreaLine.rect.left}px`;\n      highlightAreaLine.style.top = `${\n        highlightAreaLine.rect.top +\n        highlightAreaLine.rect.height / 2 -\n        strikeThroughLineThickness / 2\n      }px`;\n      highlightParent.append(highlightAreaLine);\n    }\n  }\n\n  const highlightBounding = document.createElement("div");\n  highlightBounding.setAttribute("class", CLASS_HIGHLIGHT_BOUNDING_AREA);\n\n  highlightBounding.style.setProperty("pointer-events", "none");\n  highlightBounding.style.position = paginated ? "fixed" : "absolute";\n  highlightBounding.scale = 1;\n\n  if (highlight_debug) {\n    highlightBounding.setAttribute(\n      "style",\n      `outline-color: magenta; outline-style: solid; outline-width: 1px; outline-offset: -1px;`\n    );\n  }\n\n  const rangeBoundingClientRect = highlight.range.getBoundingClientRect();\n  highlightBounding.rect = {\n    height: rangeBoundingClientRect.height,\n    left: rangeBoundingClientRect.left - xOffset,\n    top: rangeBoundingClientRect.top - yOffset,\n    width: rangeBoundingClientRect.width,\n  };\n\n  highlightBounding.style.width = `${highlightBounding.rect.width}px`;\n  highlightBounding.style.height = `${highlightBounding.rect.height}px`;\n  highlightBounding.style.left = `${highlightBounding.rect.left}px`;\n  highlightBounding.style.top = `${highlightBounding.rect.top}px`;\n\n  highlightParent.append(highlightBounding);\n  highlightsContainer.append(highlightParent);\n\n  return highlightParent;\n}\n\nfunction ensureContainer(win) {\n  const document = win.document;\n\n  if (!_highlightsContainer) {\n    _highlightsContainer = document.createElement("div");\n    _highlightsContainer.setAttribute("id", ID_HIGHLIGHTS_CONTAINER);\n\n    _highlightsContainer.style.setProperty("pointer-events", "none");\n    document.body.append(_highlightsContainer);\n  }\n\n  return _highlightsContainer;\n}\n\nfunction frameForHighlightWithID(id) {\n  const highlight = highlightWithID(id);\n  if (!highlight) return;\n\n  if (!highlight.range) {\n    return undefined;\n  }\n\n  const drawUnderline = false;\n  const drawStrikeThrough = false;\n  const doNotMergeHorizontallyAlignedRects = drawUnderline || drawStrikeThrough;\n  return getClientRectsNoOverlap(\n    highlight.range,\n    doNotMergeHorizontallyAlignedRects\n  );\n}\n\nfunction highlightWithID(id) {\n  return _highlights.find((h) => {\n    return h.id === id;\n  });\n}\n\n;// CONCATENATED MODULE: ./src/decorator.js\n//\n//  Copyright 2021 Readium Foundation. All rights reserved.\n//  Use of this source code is governed by the BSD-style license\n//  available in the top-level LICENSE file of the project.\n//\n\n\n\n\nlet styles = new Map();\nlet groups = new Map();\nvar lastGroupId = 0;\n\nfunction registerStyles(newStyles) {\n  var stylesheet = "";\n\n  for (const [id, style] of Object.entries(newStyles)) {\n    try {\n      let template = document.createElement("template");\n      template.innerHTML = style.element.trim();\n      style.element = template;\n      styles.set(id, style);\n\n      if (style.stylesheet) {\n        stylesheet += style.stylesheet + "\\n";\n      }\n    } catch (error) {\n      logErrorMessage(`Invalid decoration style "${id}": ${error.message}`);\n    }\n  }\n\n  if (stylesheet) {\n    let styleElement = document.createElement("style");\n    styleElement.innerHTML = stylesheet;\n    document.getElementsByTagName("head")[0].appendChild(styleElement);\n  }\n}\n\nfunction getDecorations(groupIdentifier) {\n  var group = groups.get(groupIdentifier);\n  if (!group) {\n    let id = "r2-decoration-" + lastGroupId++;\n    group = DecorationGroup(id);\n    groups.set(groupIdentifier, group);\n  }\n  return group;\n}\n\nfunction DecorationGroup(groupId) {\n  var items = [];\n  var lastItemId = 0;\n  var container = null;\n\n  function add(decoration) {\n    let id = groupId + "-" + lastItemId++;\n\n    let range = rangeFromLocator(decoration.locator);\n    if (!range) {\n      log("Can\'t locate DOM range for decoration", decoration);\n      return;\n    }\n\n    let item = { id, decoration, range };\n    items.push(item);\n    layout(item);\n  }\n\n  function remove(decorationIdentifier) {\n    let index = items.findIndex(\n      (i) => i.decoration.identifier === decorationIdentifier\n    );\n    if (index === -1) {\n      return;\n    }\n\n    let item = items[index];\n    items.splice(index, 1);\n    let itemContainer = document.getElementById(item.id);\n    if (itemContainer) {\n      itemContainer.remove();\n      itemContainer = null;\n    }\n  }\n\n  function update(decoration) {\n    remove(decoration.identifier);\n    add(decoration);\n  }\n\n  function clear() {\n    clearContainer();\n    items = [];\n  }\n\n  function requestLayout() {\n    clearContainer();\n    items.forEach((item) => layout(item));\n  }\n\n  function layout(item) {\n    let groupContainer = requireContainer();\n\n    let style = styles.get(item.decoration.style);\n    if (!style) {\n      logErrorMessage(`Unknown decoration style: ${item.decoration.style}`);\n      return;\n    }\n\n    let itemContainer = document.createElement("div");\n    itemContainer.setAttribute("id", item.id);\n    itemContainer.style.setProperty("pointer-events", "none");\n    if (item.pointerInteraction) {\n      itemContainer.setAttribute("data-click", "1");\n    }\n    let tint = item.decoration.tint;\n    if (tint) {\n      itemContainer.style.setProperty(\n        "--r2-decoration-tint",\n        `rgb(${tint.red}, ${tint.green}, ${tint.blue})`\n      );\n    }\n\n    let viewportWidth = window.innerWidth;\n    let columnCount = parseInt(\n      getComputedStyle(document.documentElement).getPropertyValue(\n        "column-count"\n      )\n    );\n    let pageWidth = viewportWidth / (columnCount || 1);\n    let scrollingElement = document.scrollingElement;\n    let xOffset = scrollingElement.scrollLeft;\n    let yOffset = scrollingElement.scrollTop;\n\n    function positionElement(element, rect, boundingRect) {\n      element.style.position = "absolute";\n\n      if (style.width === "wrap") {\n        element.style.width = `${rect.width}px`;\n        element.style.height = `${rect.height}px`;\n        element.style.left = `${rect.left + xOffset}px`;\n        element.style.top = `${rect.top + yOffset}px`;\n      } else if (style.width === "viewport") {\n        element.style.width = `${viewportWidth}px`;\n        element.style.height = `${rect.height}px`;\n        let left = Math.floor(rect.left / viewportWidth) * viewportWidth;\n        element.style.left = `${left + xOffset}px`;\n        element.style.top = `${rect.top + yOffset}px`;\n      } else if (style.width === "bounds") {\n        element.style.width = `${boundingRect.width}px`;\n        element.style.height = `${rect.height}px`;\n        element.style.left = `${boundingRect.left + xOffset}px`;\n        element.style.top = `${rect.top + yOffset}px`;\n      } else if (style.width === "page") {\n        element.style.width = `${pageWidth}px`;\n        element.style.height = `${rect.height}px`;\n        let left = Math.floor(rect.left / pageWidth) * pageWidth;\n        element.style.left = `${left + xOffset}px`;\n        element.style.top = `${rect.top + yOffset}px`;\n      }\n    }\n\n    let boundingRect = item.range.getBoundingClientRect();\n\n    if (style.layout === "boxes") {\n      let doNotMergeHorizontallyAlignedRects = true;\n      let clientRects = rect_getClientRectsNoOverlap(\n        item.range,\n        doNotMergeHorizontallyAlignedRects\n      );\n\n      for (let clientRect of clientRects) {\n        const line = style.element.content.firstElementChild.cloneNode(true);\n        line.style.setProperty("pointer-events", "none");\n        positionElement(line, clientRect, boundingRect);\n        itemContainer.append(line);\n      }\n    } else if (style.layout === "bounds") {\n      const bounds = style.element.content.firstElementChild.cloneNode(true);\n      bounds.style.setProperty("pointer-events", "none");\n      positionElement(bounds, boundingRect, boundingRect);\n\n      itemContainer.append(bounds);\n    }\n\n    groupContainer.append(itemContainer);\n  }\n\n  function requireContainer() {\n    if (!container) {\n      container = document.createElement("div");\n      container.setAttribute("id", groupId);\n      container.style.setProperty("pointer-events", "none");\n      document.body.append(container);\n    }\n    return container;\n  }\n\n  function clearContainer() {\n    if (container) {\n      container.remove();\n      container = null;\n    }\n  }\n\n  return { add, remove, update, clear, requestLayout };\n}\n\nwindow.addEventListener(\n  "load",\n  function () {\n    // on page load\n    const body = document.body;\n    var lastSize = { width: 0, height: 0 };\n    const observer = new ResizeObserver(() => {\n      if (\n        lastSize.width === body.clientWidth &&\n        lastSize.height === body.clientHeight\n      ) {\n        return;\n      }\n      lastSize = {\n        width: body.clientWidth,\n        height: body.clientHeight,\n      };\n\n      groups.forEach(function (group) {\n        group.requestLayout();\n      });\n    });\n    observer.observe(body);\n  },\n  false\n);\n\n;// CONCATENATED MODULE: ./src/index.js\n//\n//  Copyright 2021 Readium Foundation. All rights reserved.\n//  Use of this source code is governed by the BSD-style license\n//  available in the top-level LICENSE file of the project.\n//\n\n// Base script used by both reflowable and fixed layout resources.\n\n\n\n\n\n\n\n// Public API used by the navigator.\nwindow.readium = {\n  // utils\n  scrollToId: scrollToId,\n  scrollToPosition: scrollToPosition,\n  scrollToText: scrollToText,\n  scrollLeft: scrollLeft,\n  scrollRight: scrollRight,\n  setProperty: setProperty,\n  removeProperty: removeProperty,\n\n  // decoration\n  registerDecorationStyles: registerStyles,\n  getDecorations: getDecorations,\n\n  // selection\n  getSelectionRect: getSelectionRect,\n  getCurrentSelectionInfo: getCurrentSelectionInfo,\n};\n\n;// CONCATENATED MODULE: ./src/index-reflowable.js\n//\n//  Copyright 2021 Readium Foundation. All rights reserved.\n//  Use of this source code is governed by the BSD-style license\n//  available in the top-level LICENSE file of the project.\n//\n\n// Script used for reflowable resources.\n\n\n\nwindow.addEventListener("load", function () {\n  // Notifies native code that the page is loaded after it is rendered.\n  // Waiting for the next animation frame seems to do the trick to make sure the page is fully rendered.\n  window.requestAnimationFrame(function () {\n    webkit.messageHandlers.spreadLoaded.postMessage({});\n  });\n\n  // Setups the `viewport` meta tag to disable zooming.\n  let meta = document.createElement("meta");\n  meta.setAttribute("name", "viewport");\n  meta.setAttribute(\n    "content",\n    "width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no"\n  );\n  document.head.appendChild(meta);\n});\n\n// Injects Readium CSS stylesheets.\ndocument.addEventListener("DOMContentLoaded", function () {\n  function createLink(name) {\n    var link = document.createElement("link");\n    link.setAttribute("rel", "stylesheet");\n    link.setAttribute("type", "text/css");\n    link.setAttribute("href", window.readiumCSSBaseURL + name + ".css");\n    return link;\n  }\n\n  var head = document.getElementsByTagName("head")[0];\n  head.appendChild(createLink("ReadiumCSS-after"));\n  head.insertBefore(createLink("ReadiumCSS-before"), head.children[0]);\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFkaXVtLWpzLy4vc3JjL3ZlbmRvci9oeXBvdGhlc2lzL2FuY2hvcmluZy9tYXRjaC1xdW90ZS5qcz9kZDZhIiwid2VicGFjazovL3JlYWRpdW0tanMvLi9zcmMvdmVuZG9yL2h5cG90aGVzaXMvYW5jaG9yaW5nL3RleHQtcmFuZ2UuanM/ZmRlZSIsIndlYnBhY2s6Ly9yZWFkaXVtLWpzLy4vc3JjL3ZlbmRvci9oeXBvdGhlc2lzL2FuY2hvcmluZy90eXBlcy5qcz80MDA0Iiwid2VicGFjazovL3JlYWRpdW0tanMvLi9zcmMvdXRpbHMuanM/MDI1ZSIsIndlYnBhY2s6Ly9yZWFkaXVtLWpzLy4vc3JjL3NlbGVjdGlvbi5qcz81OWFjIiwid2VicGFjazovL3JlYWRpdW0tanMvLi9zcmMvcmVjdC5qcz80ZDVhIiwid2VicGFjazovL3JlYWRpdW0tanMvLi9zcmMvaGlnaGxpZ2h0LmpzPzhkYTgiLCJ3ZWJwYWNrOi8vcmVhZGl1bS1qcy8uL3NyYy9kZWNvcmF0b3IuanM/MWIwNCIsIndlYnBhY2s6Ly9yZWFkaXVtLWpzLy4vc3JjL2luZGV4LmpzP2I2MzUiLCJ3ZWJwYWNrOi8vcmVhZGl1bS1qcy8uL3NyYy9pbmRleC1yZWZsb3dhYmxlLmpzPzM5MjUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQStDOztBQUUvQztBQUNBLGFBQWEsb0NBQW9DO0FBQ2pEOztBQUVBO0FBQ0E7QUFDQSxVQUFVLE9BQU87QUFDakIsVUFBVSxPQUFPO0FBQ2pCLFVBQVUsT0FBTztBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNB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cFBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRXNFOztBQUV0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLGdDQUFnQyxPQUFPO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7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QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksYUFBRztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLGFBQUc7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sYUFBRztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxhQUFHO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLGFBQUc7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sYUFBRztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBLFFBQVEsUUFBRztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsUUFBRyw0Q0FBNEMsYUFBYTtBQUNwRTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFNBQVMsUUFBRztBQUNaLE1BQU0sVUFBSztBQUNYLElBQUksU0FBZTtBQUNuQjtBQUNBOzs7QUMzU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFbUU7QUFDbEI7QUFDWTtBQUNTOztBQUV0RSxNQUFNLGVBQUs7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FB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O0FBQzFDLGtCQUFrQixjQUFjOztBQUVoQztBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEMsMkJBQTJCLHVCQUF1QjtBQUNsRDs7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwiZmlsZSI6IjYxMS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBhcHByb3hTZWFyY2ggZnJvbSAnYXBwcm94LXN0cmluZy1tYXRjaCc7XG5cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnYXBwcm94LXN0cmluZy1tYXRjaCcpLk1hdGNofSBTdHJpbmdNYXRjaFxuICovXG5cbi8qKlxuICogQHR5cGVkZWYgTWF0Y2hcbiAqIEBwcm9wIHtudW1iZXJ9IHN0YXJ0IC0gU3RhcnQgb2Zmc2V0IG9mIG1hdGNoIGluIHRleHRcbiAqIEBwcm9wIHtudW1iZXJ9IGVuZCAtIEVuZCBvZmZzZXQgb2YgbWF0Y2ggaW4gdGV4dFxuICogQHByb3Age251bWJlcn0gc2NvcmUgLVxuICogICBTY29yZSBmb3IgdGhlIG1hdGNoIGJldHdlZW4gMCBhbmQgMS4wLCB3aGVyZSAxLjAgaW5kaWNhdGVzIGEgcGVyZmVjdCBtYXRjaFxuICogICBmb3IgdGhlIHF1b3RlIGFuZCBjb250ZXh0LlxuICovXG5cbi8qKlxuICogRmluZCB0aGUgYmVzdCBhcHByb3hpbWF0ZSBtYXRjaGVzIGZvciBgc3RyYCBpbiBgdGV4dGAgYWxsb3dpbmcgdXAgdG8gYG1heEVycm9yc2AgZXJyb3JzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4RXJyb3JzXG4gKiBAcmV0dXJuIHtTdHJpbmdNYXRjaFtdfVxuICovXG5mdW5jdGlvbiBzZWFyY2godGV4dCwgc3RyLCBtYXhFcnJvcnMpIHtcbiAgLy8gRG8gYSBmYXN0IHNlYXJjaCBmb3IgZXhhY3QgbWF0Y2hlcy4gVGhlIGBhcHByb3gtc3RyaW5nLW1hdGNoYCBsaWJyYXJ5XG4gIC8vIGRvZXNuJ3QgY3VycmVudGx5IGluY29ycG9yYXRlIHRoaXMgb3B0aW1pemF0aW9uIGl0c2VsZi5cbiAgbGV0IG1hdGNoUG9zID0gMDtcbiAgbGV0IGV4YWN0TWF0Y2hlcyA9IFtdO1xuICB3aGlsZSAobWF0Y2hQb3MgIT09IC0xKSB7XG4gICAgbWF0Y2hQb3MgPSB0ZXh0LmluZGV4T2Yoc3RyLCBtYXRjaFBvcyk7XG4gICAgaWYgKG1hdGNoUG9zICE9PSAtMSkge1xuICAgICAgZXhhY3RNYXRjaGVzLnB1c2goe1xuICAgICAgICBzdGFydDogbWF0Y2hQb3MsXG4gICAgICAgIGVuZDogbWF0Y2hQb3MgKyBzdHIubGVuZ3RoLFxuICAgICAgICBlcnJvcnM6IDAsXG4gICAgICB9KTtcbiAgICAgIG1hdGNoUG9zICs9IDE7XG4gICAgfVxuICB9XG4gIGlmIChleGFjdE1hdGNoZXMubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBleGFjdE1hdGNoZXM7XG4gIH1cblxuICAvLyBJZiB0aGVyZSBhcmUgbm8gZXhhY3QgbWF0Y2hlcywgZG8gYSBtb3JlIGV4cGVuc2l2ZSBzZWFyY2ggZm9yIG1hdGNoZXNcbiAgLy8gd2l0aCBlcnJvcnMuXG4gIHJldHVybiBhcHByb3hTZWFyY2godGV4dCwgc3RyLCBtYXhFcnJvcnMpO1xufVxuXG4vKipcbiAqIENvbXB1dGUgYSBzY29yZSBiZXR3ZWVuIDAgYW5kIDEuMCBmb3IgdGhlIHNpbWlsYXJpdHkgYmV0d2VlbiBgdGV4dGAgYW5kIGBzdHJgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKi9cbmZ1bmN0aW9uIHRleHRNYXRjaFNjb3JlKHRleHQsIHN0cikge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAtIGBzY29yZU1hdGNoYCB3aWxsIG5ldmVyIHBhc3MgYW4gZW1wdHkgc3RyaW5nICovXG4gIGlmIChzdHIubGVuZ3RoID09PSAwIHx8IHRleHQubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIDAuMDtcbiAgfVxuICBjb25zdCBtYXRjaGVzID0gc2VhcmNoKHRleHQsIHN0ciwgc3RyLmxlbmd0aCk7XG5cbiAgLy8gcHJldHRpZXItaWdub3JlXG4gIHJldHVybiAxIC0gKG1hdGNoZXNbMF0uZXJyb3JzIC8gc3RyLmxlbmd0aCk7XG59XG5cbi8qKlxuICogRmluZCB0aGUgYmVzdCBhcHByb3hpbWF0ZSBtYXRjaCBmb3IgYHF1b3RlYCBpbiBgdGV4dGAuXG4gKlxuICogUmV0dXJucyBgbnVsbGAgaWYgbm8gbWF0Y2ggZXhjZWVkaW5nIHRoZSBtaW5pbXVtIHF1YWxpdHkgdGhyZXNob2xkIHdhcyBmb3VuZC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIERvY3VtZW50IHRleHQgdG8gc2VhcmNoXG4gKiBAcGFyYW0ge3N0cmluZ30gcXVvdGUgLSBTdHJpbmcgdG8gZmluZCB3aXRoaW4gYHRleHRgXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dCAtXG4gKiAgIENvbnRleHQgaW4gd2hpY2ggdGhlIHF1b3RlIG9yaWdpbmFsbHkgYXBwZWFyZWQuIFRoaXMgaXMgdXNlZCB0byBjaG9vc2UgdGhlXG4gKiAgIGJlc3QgbWF0Y2guXG4gKiAgIEBwYXJhbSB7c3RyaW5nfSBbY29udGV4dC5wcmVmaXhdIC0gRXhwZWN0ZWQgdGV4dCBiZWZvcmUgdGhlIHF1b3RlXG4gKiAgIEBwYXJhbSB7c3RyaW5nfSBbY29udGV4dC5zdWZmaXhdIC0gRXhwZWN0ZWQgdGV4dCBhZnRlciB0aGUgcXVvdGVcbiAqICAgQHBhcmFtIHtudW1iZXJ9IFtjb250ZXh0LmhpbnRdIC0gRXhwZWN0ZWQgb2Zmc2V0IG9mIG1hdGNoIHdpdGhpbiB0ZXh0XG4gKiBAcmV0dXJuIHtNYXRjaHxudWxsfVxuICovXG5leHBvcnQgZnVuY3Rpb24gbWF0Y2hRdW90ZSh0ZXh0LCBxdW90ZSwgY29udGV4dCA9IHt9KSB7XG4gIGlmIChxdW90ZS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIENob29zZSB0aGUgbWF4aW11bSBudW1iZXIgb2YgZXJyb3JzIHRvIGFsbG93IGZvciB0aGUgaW5pdGlhbCBzZWFyY2guXG4gIC8vIFRoaXMgY2hvaWNlIGludm9sdmVzIGEgdHJhZGVvZmYgYmV0d2VlbjpcbiAgLy9cbiAgLy8gIC0gUmVjYWxsIChwcm9wb3J0aW9uIG9mIFwiZ29vZFwiIG1hdGNoZXMgZm91bmQpXG4gIC8vICAtIFByZWNpc2lvbiAocHJvcG9ydGlvbiBvZiBtYXRjaGVzIGZvdW5kIHdoaWNoIGFyZSBcImdvb2RcIilcbiAgLy8gIC0gQ29zdCBvZiB0aGUgaW5pdGlhbCBzZWFyY2ggYW5kIG9mIHByb2Nlc3NpbmcgdGhlIGNhbmRpZGF0ZSBtYXRjaGVzIFsxXVxuICAvL1xuICAvLyBbMV0gU3BlY2lmaWNhbGx5LCB0aGUgZXhwZWN0ZWQtdGltZSBjb21wbGV4aXR5IG9mIHRoZSBpbml0aWFsIHNlYXJjaCBpc1xuICAvLyAgICAgYE8oKG1heEVycm9ycyAvIDMyKSAqIHRleHQubGVuZ3RoKWAuIFNlZSBgYXBwcm94LXN0cmluZy1tYXRjaGAgZG9jcy5cbiAgY29uc3QgbWF4RXJyb3JzID0gTWF0aC5taW4oMjU2LCBxdW90ZS5sZW5ndGggLyAyKTtcblxuICAvLyBGaW5kIGNsb3Nlc3QgbWF0Y2hlcyBmb3IgYHF1b3RlYCBpbiBgdGV4dGAgYmFzZWQgb24gZWRpdCBkaXN0YW5jZS5cbiAgY29uc3QgbWF0Y2hlcyA9IHNlYXJjaCh0ZXh0LCBxdW90ZSwgbWF4RXJyb3JzKTtcblxuICBpZiAobWF0Y2hlcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wdXRlIGEgc2NvcmUgYmV0d2VlbiAwIGFuZCAxLjAgZm9yIGEgbWF0Y2ggY2FuZGlkYXRlLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ01hdGNofSBtYXRjaFxuICAgKi9cbiAgY29uc3Qgc2NvcmVNYXRjaCA9IG1hdGNoID0+IHtcbiAgICBjb25zdCBxdW90ZVdlaWdodCA9IDUwOyAvLyBTaW1pbGFyaXR5IG9mIG1hdGNoZWQgdGV4dCB0byBxdW90ZS5cbiAgICBjb25zdCBwcmVmaXhXZWlnaHQgPSAyMDsgLy8gU2ltaWxhcml0eSBvZiB0ZXh0IGJlZm9yZSBtYXRjaGVkIHRleHQgdG8gYGNvbnRleHQucHJlZml4YC5cbiAgICBjb25zdCBzdWZmaXhXZWlnaHQgPSAyMDsgLy8gU2ltaWxhcml0eSBvZiB0ZXh0IGFmdGVyIG1hdGNoZWQgdGV4dCB0byBgY29udGV4dC5zdWZmaXhgLlxuICAgIGNvbnN0IHBvc1dlaWdodCA9IDI7IC8vIFByb3hpbWl0eSB0byBleHBlY3RlZCBsb2NhdGlvbi4gVXNlZCBhcyBhIHRpZS1icmVha2VyLlxuXG4gICAgY29uc3QgcXVvdGVTY29yZSA9IDEgLSBtYXRjaC5lcnJvcnMgLyBxdW90ZS5sZW5ndGg7XG5cbiAgICBjb25zdCBwcmVmaXhTY29yZSA9IGNvbnRleHQucHJlZml4XG4gICAgICA/IHRleHRNYXRjaFNjb3JlKFxuICAgICAgICAgIHRleHQuc2xpY2UoTWF0aC5tYXgoMCwgbWF0Y2guc3RhcnQgLSBjb250ZXh0LnByZWZpeC5sZW5ndGgpLCBtYXRjaC5zdGFydCksXG4gICAgICAgICAgY29udGV4dC5wcmVmaXhcbiAgICAgICAgKVxuICAgICAgOiAxLjA7XG4gICAgY29uc3Qgc3VmZml4U2NvcmUgPSBjb250ZXh0LnN1ZmZpeFxuICAgICAgPyB0ZXh0TWF0Y2hTY29yZShcbiAgICAgICAgICB0ZXh0LnNsaWNlKG1hdGNoLmVuZCwgbWF0Y2guZW5kICsgY29udGV4dC5zdWZmaXgubGVuZ3RoKSxcbiAgICAgICAgICBjb250ZXh0LnN1ZmZpeFxuICAgICAgICApXG4gICAgICA6IDEuMDtcblxuICAgIGxldCBwb3NTY29yZSA9IDEuMDtcbiAgICBpZiAodHlwZW9mIGNvbnRleHQuaGludCA9PT0gJ251bWJlcicpIHtcbiAgICAgIGNvbnN0IG9mZnNldCA9IE1hdGguYWJzKG1hdGNoLnN0YXJ0IC0gY29udGV4dC5oaW50KTtcbiAgICAgIHBvc1Njb3JlID0gMS4wIC0gb2Zmc2V0IC8gdGV4dC5sZW5ndGg7XG4gICAgfVxuXG4gICAgY29uc3QgcmF3U2NvcmUgPVxuICAgICAgcXVvdGVXZWlnaHQgKiBxdW90ZVNjb3JlICtcbiAgICAgIHByZWZpeFdlaWdodCAqIHByZWZpeFNjb3JlICtcbiAgICAgIHN1ZmZpeFdlaWdodCAqIHN1ZmZpeFNjb3JlICtcbiAgICAgIHBvc1dlaWdodCAqIHBvc1Njb3JlO1xuICAgIGNvbnN0IG1heFNjb3JlID0gcXVvdGVXZWlnaHQgKyBwcmVmaXhXZWlnaHQgKyBzdWZmaXhXZWlnaHQgKyBwb3NXZWlnaHQ7XG4gICAgY29uc3Qgbm9ybWFsaXplZFNjb3JlID0gcmF3U2NvcmUgLyBtYXhTY29yZTtcblxuICAgIHJldHVybiBub3JtYWxpemVkU2NvcmU7XG4gIH07XG5cbiAgLy8gUmFuayBtYXRjaGVzIGJhc2VkIG9uIHNpbWlsYXJpdHkgb2YgYWN0dWFsIGFuZCBleHBlY3RlZCBzdXJyb3VuZGluZyB0ZXh0XG4gIC8vIGFuZCBhY3R1YWwvZXhwZWN0ZWQgb2Zmc2V0IGluIHRoZSBkb2N1bWVudCB0ZXh0LlxuICBjb25zdCBzY29yZWRNYXRjaGVzID0gbWF0Y2hlcy5tYXAobSA9PiAoe1xuICAgIHN0YXJ0OiBtLnN0YXJ0LFxuICAgIGVuZDogbS5lbmQsXG4gICAgc2NvcmU6IHNjb3JlTWF0Y2gobSksXG4gIH0pKTtcblxuICAvLyBDaG9vc2UgbWF0Y2ggd2l0aCBoaWdoZXN0IHNjb3JlLlxuICBzY29yZWRNYXRjaGVzLnNvcnQoKGEsIGIpID0+IGIuc2NvcmUgLSBhLnNjb3JlKTtcbiAgcmV0dXJuIHNjb3JlZE1hdGNoZXNbMF07XG59XG4iLCIvKipcbiAqIFJldHVybiB0aGUgY29tYmluZWQgbGVuZ3RoIG9mIHRleHQgbm9kZXMgY29udGFpbmVkIGluIGBub2RlYC5cbiAqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAqL1xuZnVuY3Rpb24gbm9kZVRleHRMZW5ndGgobm9kZSkge1xuICBzd2l0Y2ggKG5vZGUubm9kZVR5cGUpIHtcbiAgICBjYXNlIE5vZGUuRUxFTUVOVF9OT0RFOlxuICAgIGNhc2UgTm9kZS5URVhUX05PREU6XG4gICAgICAvLyBuYi4gYHRleHRDb250ZW50YCBleGNsdWRlcyB0ZXh0IGluIGNvbW1lbnRzIGFuZCBwcm9jZXNzaW5nIGluc3RydWN0aW9uc1xuICAgICAgLy8gd2hlbiBjYWxsZWQgb24gYSBwYXJlbnQgZWxlbWVudCwgc28gd2UgZG9uJ3QgbmVlZCB0byBzdWJ0cmFjdCB0aGF0IGhlcmUuXG5cbiAgICAgIHJldHVybiAvKiogQHR5cGUge3N0cmluZ30gKi8gKG5vZGUudGV4dENvbnRlbnQpLmxlbmd0aDtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIDA7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIHRvdGFsIGxlbmd0aCBvZiB0aGUgdGV4dCBvZiBhbGwgcHJldmlvdXMgc2libGluZ3Mgb2YgYG5vZGVgLlxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICovXG5mdW5jdGlvbiBwcmV2aW91c1NpYmxpbmdzVGV4dExlbmd0aChub2RlKSB7XG4gIGxldCBzaWJsaW5nID0gbm9kZS5wcmV2aW91c1NpYmxpbmc7XG4gIGxldCBsZW5ndGggPSAwO1xuICB3aGlsZSAoc2libGluZykge1xuICAgIGxlbmd0aCArPSBub2RlVGV4dExlbmd0aChzaWJsaW5nKTtcbiAgICBzaWJsaW5nID0gc2libGluZy5wcmV2aW91c1NpYmxpbmc7XG4gIH1cbiAgcmV0dXJuIGxlbmd0aDtcbn1cblxuLyoqXG4gKiBSZXNvbHZlIG9uZSBvciBtb3JlIGNoYXJhY3RlciBvZmZzZXRzIHdpdGhpbiBhbiBlbGVtZW50IHRvICh0ZXh0IG5vZGUsIHBvc2l0aW9uKVxuICogcGFpcnMuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge251bWJlcltdfSBvZmZzZXRzIC0gT2Zmc2V0cywgd2hpY2ggbXVzdCBiZSBzb3J0ZWQgaW4gYXNjZW5kaW5nIG9yZGVyXG4gKiBAcmV0dXJuIHt7IG5vZGU6IFRleHQsIG9mZnNldDogbnVtYmVyIH1bXX1cbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZU9mZnNldHMoZWxlbWVudCwgLi4ub2Zmc2V0cykge1xuICBsZXQgbmV4dE9mZnNldCA9IG9mZnNldHMuc2hpZnQoKTtcbiAgY29uc3Qgbm9kZUl0ZXIgPSAvKiogQHR5cGUge0RvY3VtZW50fSAqLyAoXG4gICAgZWxlbWVudC5vd25lckRvY3VtZW50XG4gICkuY3JlYXRlTm9kZUl0ZXJhdG9yKGVsZW1lbnQsIE5vZGVGaWx0ZXIuU0hPV19URVhUKTtcbiAgY29uc3QgcmVzdWx0cyA9IFtdO1xuXG4gIGxldCBjdXJyZW50Tm9kZSA9IG5vZGVJdGVyLm5leHROb2RlKCk7XG4gIGxldCB0ZXh0Tm9kZTtcbiAgbGV0IGxlbmd0aCA9IDA7XG5cbiAgLy8gRmluZCB0aGUgdGV4dCBub2RlIGNvbnRhaW5pbmcgdGhlIGBuZXh0T2Zmc2V0YHRoIGNoYXJhY3RlciBmcm9tIHRoZSBzdGFydFxuICAvLyBvZiBgZWxlbWVudGAuXG4gIHdoaWxlIChuZXh0T2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgY3VycmVudE5vZGUpIHtcbiAgICB0ZXh0Tm9kZSA9IC8qKiBAdHlwZSB7VGV4dH0gKi8gKGN1cnJlbnROb2RlKTtcbiAgICBpZiAobGVuZ3RoICsgdGV4dE5vZGUuZGF0YS5sZW5ndGggPiBuZXh0T2Zmc2V0KSB7XG4gICAgICByZXN1bHRzLnB1c2goeyBub2RlOiB0ZXh0Tm9kZSwgb2Zmc2V0OiBuZXh0T2Zmc2V0IC0gbGVuZ3RoIH0pO1xuICAgICAgbmV4dE9mZnNldCA9IG9mZnNldHMuc2hpZnQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudE5vZGUgPSBub2RlSXRlci5uZXh0Tm9kZSgpO1xuICAgICAgbGVuZ3RoICs9IHRleHROb2RlLmRhdGEubGVuZ3RoO1xuICAgIH1cbiAgfVxuXG4gIC8vIEJvdW5kYXJ5IGNhc2UuXG4gIHdoaWxlIChuZXh0T2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgdGV4dE5vZGUgJiYgbGVuZ3RoID09PSBuZXh0T2Zmc2V0KSB7XG4gICAgcmVzdWx0cy5wdXNoKHsgbm9kZTogdGV4dE5vZGUsIG9mZnNldDogdGV4dE5vZGUuZGF0YS5sZW5ndGggfSk7XG4gICAgbmV4dE9mZnNldCA9IG9mZnNldHMuc2hpZnQoKTtcbiAgfVxuXG4gIGlmIChuZXh0T2Zmc2V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT2Zmc2V0IGV4Y2VlZHMgdGV4dCBsZW5ndGgnKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHRzO1xufVxuXG5leHBvcnQgbGV0IFJFU09MVkVfRk9SV0FSRFMgPSAxO1xuZXhwb3J0IGxldCBSRVNPTFZFX0JBQ0tXQVJEUyA9IDI7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhbiBvZmZzZXQgd2l0aGluIHRoZSB0ZXh0IGNvbnRlbnQgb2YgYW4gZWxlbWVudC5cbiAqXG4gKiBUaGlzIHBvc2l0aW9uIGNhbiBiZSByZXNvbHZlZCB0byBhIHNwZWNpZmljIGRlc2NlbmRhbnQgbm9kZSBpbiB0aGUgY3VycmVudFxuICogRE9NIHN1YnRyZWUgb2YgdGhlIGVsZW1lbnQgdXNpbmcgdGhlIGByZXNvbHZlYCBtZXRob2QuXG4gKi9cbmV4cG9ydCBjbGFzcyBUZXh0UG9zaXRpb24ge1xuICAvKipcbiAgICogQ29uc3RydWN0IGEgYFRleHRQb3NpdGlvbmAgdGhhdCByZWZlcnMgdG8gdGhlIHRleHQgcG9zaXRpb24gYG9mZnNldGAgd2l0aGluXG4gICAqIHRoZSB0ZXh0IGNvbnRlbnQgb2YgYGVsZW1lbnRgLlxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgKi9cbiAgY29uc3RydWN0b3IoZWxlbWVudCwgb2Zmc2V0KSB7XG4gICAgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignT2Zmc2V0IGlzIGludmFsaWQnKTtcbiAgICB9XG5cbiAgICAvKiogRWxlbWVudCB0aGF0IGBvZmZzZXRgIGlzIHJlbGF0aXZlIHRvLiAqL1xuICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG5cbiAgICAvKiogQ2hhcmFjdGVyIG9mZnNldCBmcm9tIHRoZSBzdGFydCBvZiB0aGUgZWxlbWVudCdzIGB0ZXh0Q29udGVudGAuICovXG4gICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGEgY29weSBvZiB0aGlzIHBvc2l0aW9uIHdpdGggb2Zmc2V0IHJlbGF0aXZlIHRvIGEgZ2l2ZW4gYW5jZXN0b3JcbiAgICogZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtFbGVtZW50fSBwYXJlbnQgLSBBbmNlc3RvciBvZiBgdGhpcy5lbGVtZW50YFxuICAgKiBAcmV0dXJuIHtUZXh0UG9zaXRpb259XG4gICAqL1xuICByZWxhdGl2ZVRvKHBhcmVudCkge1xuICAgIGlmICghcGFyZW50LmNvbnRhaW5zKHRoaXMuZWxlbWVudCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUGFyZW50IGlzIG5vdCBhbiBhbmNlc3RvciBvZiBjdXJyZW50IGVsZW1lbnQnKTtcbiAgICB9XG5cbiAgICBsZXQgZWwgPSB0aGlzLmVsZW1lbnQ7XG4gICAgbGV0IG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgIHdoaWxlIChlbCAhPT0gcGFyZW50KSB7XG4gICAgICBvZmZzZXQgKz0gcHJldmlvdXNTaWJsaW5nc1RleHRMZW5ndGgoZWwpO1xuICAgICAgZWwgPSAvKiogQHR5cGUge0VsZW1lbnR9ICovIChlbC5wYXJlbnRFbGVtZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFRleHRQb3NpdGlvbihlbCwgb2Zmc2V0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNvbHZlIHRoZSBwb3NpdGlvbiB0byBhIHNwZWNpZmljIHRleHQgbm9kZSBhbmQgb2Zmc2V0IHdpdGhpbiB0aGF0IG5vZGUuXG4gICAqXG4gICAqIFRocm93cyBpZiBgdGhpcy5vZmZzZXRgIGV4Y2VlZHMgdGhlIGxlbmd0aCBvZiB0aGUgZWxlbWVudCdzIHRleHQuIEluIHRoZVxuICAgKiBjYXNlIHdoZXJlIHRoZSBlbGVtZW50IGhhcyBubyB0ZXh0IGFuZCBgdGhpcy5vZmZzZXRgIGlzIDAsIHRoZSBgZGlyZWN0aW9uYFxuICAgKiBvcHRpb24gZGV0ZXJtaW5lcyB3aGF0IGhhcHBlbnMuXG4gICAqXG4gICAqIE9mZnNldHMgYXQgdGhlIGJvdW5kYXJ5IGJldHdlZW4gdHdvIG5vZGVzIGFyZSByZXNvbHZlZCB0byB0aGUgc3RhcnQgb2YgdGhlXG4gICAqIG5vZGUgdGhhdCBiZWdpbnMgYXQgdGhlIGJvdW5kYXJ5LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgQHBhcmFtIHtSRVNPTFZFX0ZPUldBUkRTfFJFU09MVkVfQkFDS1dBUkRTfSBbb3B0aW9ucy5kaXJlY3Rpb25dIC1cbiAgICogICAgIFNwZWNpZmllcyBpbiB3aGljaCBkaXJlY3Rpb24gdG8gc2VhcmNoIGZvciB0aGUgbmVhcmVzdCB0ZXh0IG5vZGUgaWZcbiAgICogICAgIGB0aGlzLm9mZnNldGAgaXMgYDBgIGFuZCBgdGhpcy5lbGVtZW50YCBoYXMgbm8gdGV4dC4gSWYgbm90IHNwZWNpZmllZFxuICAgKiAgICAgYW4gZXJyb3IgaXMgdGhyb3duLlxuICAgKiBAcmV0dXJuIHt7IG5vZGU6IFRleHQsIG9mZnNldDogbnVtYmVyIH19XG4gICAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9XG4gICAqL1xuICByZXNvbHZlKG9wdGlvbnMgPSB7fSkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZU9mZnNldHModGhpcy5lbGVtZW50LCB0aGlzLm9mZnNldClbMF07XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAodGhpcy5vZmZzZXQgPT09IDAgJiYgb3B0aW9ucy5kaXJlY3Rpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCB0dyA9IGRvY3VtZW50LmNyZWF0ZVRyZWVXYWxrZXIoXG4gICAgICAgICAgdGhpcy5lbGVtZW50LmdldFJvb3ROb2RlKCksXG4gICAgICAgICAgTm9kZUZpbHRlci5TSE9XX1RFWFRcbiAgICAgICAgKTtcbiAgICAgICAgdHcuY3VycmVudE5vZGUgPSB0aGlzLmVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IGZvcndhcmRzID0gb3B0aW9ucy5kaXJlY3Rpb24gPT09IFJFU09MVkVfRk9SV0FSRFM7XG4gICAgICAgIGNvbnN0IHRleHQgPSAvKiogQHR5cGUge1RleHR8bnVsbH0gKi8gKFxuICAgICAgICAgIGZvcndhcmRzID8gdHcubmV4dE5vZGUoKSA6IHR3LnByZXZpb3VzTm9kZSgpXG4gICAgICAgICk7XG4gICAgICAgIGlmICghdGV4dCkge1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBub2RlOiB0ZXh0LCBvZmZzZXQ6IGZvcndhcmRzID8gMCA6IHRleHQuZGF0YS5sZW5ndGggfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgYFRleHRQb3NpdGlvbmAgdGhhdCByZWZlcnMgdG8gdGhlIGBvZmZzZXRgdGggY2hhcmFjdGVyIHdpdGhpblxuICAgKiBgbm9kZWAuXG4gICAqXG4gICAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqIEByZXR1cm4ge1RleHRQb3NpdGlvbn1cbiAgICovXG4gIHN0YXRpYyBmcm9tQ2hhck9mZnNldChub2RlLCBvZmZzZXQpIHtcbiAgICBzd2l0Y2ggKG5vZGUubm9kZVR5cGUpIHtcbiAgICAgIGNhc2UgTm9kZS5URVhUX05PREU6XG4gICAgICAgIHJldHVybiBUZXh0UG9zaXRpb24uZnJvbVBvaW50KG5vZGUsIG9mZnNldCk7XG4gICAgICBjYXNlIE5vZGUuRUxFTUVOVF9OT0RFOlxuICAgICAgICByZXR1cm4gbmV3IFRleHRQb3NpdGlvbigvKiogQHR5cGUge0VsZW1lbnR9ICovIChub2RlKSwgb2Zmc2V0KTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm9kZSBpcyBub3QgYW4gZWxlbWVudCBvciB0ZXh0IG5vZGUnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgYFRleHRQb3NpdGlvbmAgcmVwcmVzZW50aW5nIHRoZSByYW5nZSBzdGFydCBvciBlbmQgcG9pbnQgKG5vZGUsIG9mZnNldCkuXG4gICAqXG4gICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSAtIFRleHQgb3IgRWxlbWVudCBub2RlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgLSBPZmZzZXQgd2l0aGluIHRoZSBub2RlLlxuICAgKiBAcmV0dXJuIHtUZXh0UG9zaXRpb259XG4gICAqL1xuICBzdGF0aWMgZnJvbVBvaW50KG5vZGUsIG9mZnNldCkge1xuICAgIHN3aXRjaCAobm9kZS5ub2RlVHlwZSkge1xuICAgICAgY2FzZSBOb2RlLlRFWFRfTk9ERToge1xuICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgPiAvKiogQHR5cGUge1RleHR9ICovIChub2RlKS5kYXRhLmxlbmd0aCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGV4dCBub2RlIG9mZnNldCBpcyBvdXQgb2YgcmFuZ2UnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbm9kZS5wYXJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUZXh0IG5vZGUgaGFzIG5vIHBhcmVudCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gR2V0IHRoZSBvZmZzZXQgZnJvbSB0aGUgc3RhcnQgb2YgdGhlIHBhcmVudCBlbGVtZW50LlxuICAgICAgICBjb25zdCB0ZXh0T2Zmc2V0ID0gcHJldmlvdXNTaWJsaW5nc1RleHRMZW5ndGgobm9kZSkgKyBvZmZzZXQ7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0UG9zaXRpb24obm9kZS5wYXJlbnRFbGVtZW50LCB0ZXh0T2Zmc2V0KTtcbiAgICAgIH1cbiAgICAgIGNhc2UgTm9kZS5FTEVNRU5UX05PREU6IHtcbiAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ID4gbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2hpbGQgbm9kZSBvZmZzZXQgaXMgb3V0IG9mIHJhbmdlJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHZXQgdGhlIHRleHQgbGVuZ3RoIGJlZm9yZSB0aGUgYG9mZnNldGB0aCBjaGlsZCBvZiBlbGVtZW50LlxuICAgICAgICBsZXQgdGV4dE9mZnNldCA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb2Zmc2V0OyBpKyspIHtcbiAgICAgICAgICB0ZXh0T2Zmc2V0ICs9IG5vZGVUZXh0TGVuZ3RoKG5vZGUuY2hpbGROb2Rlc1tpXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IFRleHRQb3NpdGlvbigvKiogQHR5cGUge0VsZW1lbnR9ICovIChub2RlKSwgdGV4dE9mZnNldCk7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BvaW50IGlzIG5vdCBpbiBhbiBlbGVtZW50IG9yIHRleHQgbm9kZScpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYSByZWdpb24gb2YgYSBkb2N1bWVudCBhcyBhIChzdGFydCwgZW5kKSBwYWlyIG9mIGBUZXh0UG9zaXRpb25gIHBvaW50cy5cbiAqXG4gKiBSZXByZXNlbnRpbmcgYSByYW5nZSBpbiB0aGlzIHdheSBhbGxvd3MgZm9yIGNoYW5nZXMgaW4gdGhlIERPTSBjb250ZW50IG9mIHRoZVxuICogcmFuZ2Ugd2hpY2ggZG9uJ3QgYWZmZWN0IGl0cyB0ZXh0IGNvbnRlbnQsIHdpdGhvdXQgYWZmZWN0aW5nIHRoZSB0ZXh0IGNvbnRlbnRcbiAqIG9mIHRoZSByYW5nZSBpdHNlbGYuXG4gKi9cbmV4cG9ydCBjbGFzcyBUZXh0UmFuZ2Uge1xuICAvKipcbiAgICogQ29uc3RydWN0IGFuIGltbXV0YWJsZSBgVGV4dFJhbmdlYCBmcm9tIGEgYHN0YXJ0YCBhbmQgYGVuZGAgcG9pbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7VGV4dFBvc2l0aW9ufSBzdGFydFxuICAgKiBAcGFyYW0ge1RleHRQb3NpdGlvbn0gZW5kXG4gICAqL1xuICBjb25zdHJ1Y3RvcihzdGFydCwgZW5kKSB7XG4gICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgIHRoaXMuZW5kID0gZW5kO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhIGNvcHkgb2YgdGhpcyByYW5nZSB3aXRoIHN0YXJ0IGFuZCBlbmQgcG9zaXRpb25zIHJlbGF0aXZlIHRvIGFcbiAgICogZ2l2ZW4gYW5jZXN0b3IuIFNlZSBgVGV4dFBvc2l0aW9uLnJlbGF0aXZlVG9gLlxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAgICovXG4gIHJlbGF0aXZlVG8oZWxlbWVudCkge1xuICAgIHJldHVybiBuZXcgVGV4dFJhbmdlKFxuICAgICAgdGhpcy5zdGFydC5yZWxhdGl2ZVRvKGVsZW1lbnQpLFxuICAgICAgdGhpcy5lbmQucmVsYXRpdmVUbyhlbGVtZW50KVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogUmVzb2x2ZSB0aGUgYFRleHRSYW5nZWAgdG8gYSBET00gcmFuZ2UuXG4gICAqXG4gICAqIFRoZSByZXN1bHRpbmcgRE9NIFJhbmdlIHdpbGwgYWx3YXlzIHN0YXJ0IGFuZCBlbmQgaW4gYSBgVGV4dGAgbm9kZS5cbiAgICogSGVuY2UgYFRleHRSYW5nZS5mcm9tUmFuZ2UocmFuZ2UpLnRvUmFuZ2UoKWAgY2FuIGJlIHVzZWQgdG8gXCJzaHJpbmtcIiBhXG4gICAqIHJhbmdlIHRvIHRoZSB0ZXh0IGl0IGNvbnRhaW5zLlxuICAgKlxuICAgKiBNYXkgdGhyb3cgaWYgdGhlIGBzdGFydGAgb3IgYGVuZGAgcG9zaXRpb25zIGNhbm5vdCBiZSByZXNvbHZlZCB0byBhIHJhbmdlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtSYW5nZX1cbiAgICovXG4gIHRvUmFuZ2UoKSB7XG4gICAgbGV0IHN0YXJ0O1xuICAgIGxldCBlbmQ7XG5cbiAgICBpZiAoXG4gICAgICB0aGlzLnN0YXJ0LmVsZW1lbnQgPT09IHRoaXMuZW5kLmVsZW1lbnQgJiZcbiAgICAgIHRoaXMuc3RhcnQub2Zmc2V0IDw9IHRoaXMuZW5kLm9mZnNldFxuICAgICkge1xuICAgICAgLy8gRmFzdCBwYXRoIGZvciBzdGFydCBhbmQgZW5kIHBvaW50cyBpbiBzYW1lIGVsZW1lbnQuXG4gICAgICBbc3RhcnQsIGVuZF0gPSByZXNvbHZlT2Zmc2V0cyhcbiAgICAgICAgdGhpcy5zdGFydC5lbGVtZW50LFxuICAgICAgICB0aGlzLnN0YXJ0Lm9mZnNldCxcbiAgICAgICAgdGhpcy5lbmQub2Zmc2V0XG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydCA9IHRoaXMuc3RhcnQucmVzb2x2ZSh7IGRpcmVjdGlvbjogUkVTT0xWRV9GT1JXQVJEUyB9KTtcbiAgICAgIGVuZCA9IHRoaXMuZW5kLnJlc29sdmUoeyBkaXJlY3Rpb246IFJFU09MVkVfQkFDS1dBUkRTIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IHJhbmdlID0gbmV3IFJhbmdlKCk7XG4gICAgcmFuZ2Uuc2V0U3RhcnQoc3RhcnQubm9kZSwgc3RhcnQub2Zmc2V0KTtcbiAgICByYW5nZS5zZXRFbmQoZW5kLm5vZGUsIGVuZC5vZmZzZXQpO1xuICAgIHJldHVybiByYW5nZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGFuIGV4aXN0aW5nIERPTSBgUmFuZ2VgIHRvIGEgYFRleHRSYW5nZWBcbiAgICpcbiAgICogQHBhcmFtIHtSYW5nZX0gcmFuZ2VcbiAgICogQHJldHVybiB7VGV4dFJhbmdlfVxuICAgKi9cbiAgc3RhdGljIGZyb21SYW5nZShyYW5nZSkge1xuICAgIGNvbnN0IHN0YXJ0ID0gVGV4dFBvc2l0aW9uLmZyb21Qb2ludChcbiAgICAgIHJhbmdlLnN0YXJ0Q29udGFpbmVyLFxuICAgICAgcmFuZ2Uuc3RhcnRPZmZzZXRcbiAgICApO1xuICAgIGNvbnN0IGVuZCA9IFRleHRQb3NpdGlvbi5mcm9tUG9pbnQocmFuZ2UuZW5kQ29udGFpbmVyLCByYW5nZS5lbmRPZmZzZXQpO1xuICAgIHJldHVybiBuZXcgVGV4dFJhbmdlKHN0YXJ0LCBlbmQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhIGBUZXh0UmFuZ2VgIGZyb20gdGhlIGBzdGFydGB0aCB0byBgZW5kYHRoIGNoYXJhY3RlcnMgaW4gYHJvb3RgLlxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IHJvb3RcbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBlbmRcbiAgICovXG4gIHN0YXRpYyBmcm9tT2Zmc2V0cyhyb290LCBzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIG5ldyBUZXh0UmFuZ2UoXG4gICAgICBuZXcgVGV4dFBvc2l0aW9uKHJvb3QsIHN0YXJ0KSxcbiAgICAgIG5ldyBUZXh0UG9zaXRpb24ocm9vdCwgZW5kKVxuICAgICk7XG4gIH1cbn1cbiIsIi8qKlxuICogVGhpcyBtb2R1bGUgZXhwb3J0cyBhIHNldCBvZiBjbGFzc2VzIGZvciBjb252ZXJ0aW5nIGJldHdlZW4gRE9NIGBSYW5nZWBcbiAqIG9iamVjdHMgYW5kIGRpZmZlcmVudCB0eXBlcyBvZiBzZWxlY3RvcnMuIEl0IGlzIG1vc3RseSBhIHRoaW4gd3JhcHBlciBhcm91bmQgYVxuICogc2V0IG9mIGFuY2hvcmluZyBsaWJyYXJpZXMuIEl0IHNlcnZlcyB0d28gbWFpbiBwdXJwb3NlczpcbiAqXG4gKiAgMS4gUHJvdmlkaW5nIGEgY29uc2lzdGVudCBpbnRlcmZhY2UgYWNyb3NzIGRpZmZlcmVudCB0eXBlcyBvZiBhbmNob3JzLlxuICogIDIuIEluc3VsYXRpbmcgdGhlIHJlc3Qgb2YgdGhlIGNvZGUgZnJvbSBBUEkgY2hhbmdlcyBpbiB0aGUgdW5kZXJseWluZyBhbmNob3JpbmdcbiAqICAgICBsaWJyYXJpZXMuXG4gKi9cblxuaW1wb3J0IHsgbWF0Y2hRdW90ZSB9IGZyb20gJy4vbWF0Y2gtcXVvdGUnO1xuaW1wb3J0IHsgVGV4dFJhbmdlLCBUZXh0UG9zaXRpb24gfSBmcm9tICcuL3RleHQtcmFuZ2UnO1xuaW1wb3J0IHsgbm9kZUZyb21YUGF0aCwgeHBhdGhGcm9tTm9kZSB9IGZyb20gJy4veHBhdGgnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4uLy4uL3R5cGVzL2FwaScpLlJhbmdlU2VsZWN0b3J9IFJhbmdlU2VsZWN0b3JcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4uLy4uL3R5cGVzL2FwaScpLlRleHRQb3NpdGlvblNlbGVjdG9yfSBUZXh0UG9zaXRpb25TZWxlY3RvclxuICogQHR5cGVkZWYge2ltcG9ydCgnLi4vLi4vdHlwZXMvYXBpJykuVGV4dFF1b3RlU2VsZWN0b3J9IFRleHRRdW90ZVNlbGVjdG9yXG4gKi9cblxuLyoqXG4gKiBDb252ZXJ0cyBiZXR3ZWVuIGBSYW5nZVNlbGVjdG9yYCBzZWxlY3RvcnMgYW5kIGBSYW5nZWAgb2JqZWN0cy5cbiAqL1xuZXhwb3J0IGNsYXNzIFJhbmdlQW5jaG9yIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7Tm9kZX0gcm9vdCAtIEEgcm9vdCBlbGVtZW50IGZyb20gd2hpY2ggdG8gYW5jaG9yLlxuICAgKiBAcGFyYW0ge1JhbmdlfSByYW5nZSAtICBBIHJhbmdlIGRlc2NyaWJpbmcgdGhlIGFuY2hvci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHJvb3QsIHJhbmdlKSB7XG4gICAgdGhpcy5yb290ID0gcm9vdDtcbiAgICB0aGlzLnJhbmdlID0gcmFuZ2U7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtOb2RlfSByb290IC0gIEEgcm9vdCBlbGVtZW50IGZyb20gd2hpY2ggdG8gYW5jaG9yLlxuICAgKiBAcGFyYW0ge1JhbmdlfSByYW5nZSAtICBBIHJhbmdlIGRlc2NyaWJpbmcgdGhlIGFuY2hvci5cbiAgICovXG4gIHN0YXRpYyBmcm9tUmFuZ2Uocm9vdCwgcmFuZ2UpIHtcbiAgICByZXR1cm4gbmV3IFJhbmdlQW5jaG9yKHJvb3QsIHJhbmdlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gYW5jaG9yIGZyb20gYSBzZXJpYWxpemVkIGBSYW5nZVNlbGVjdG9yYCBzZWxlY3Rvci5cbiAgICpcbiAgICogQHBhcmFtIHtFbGVtZW50fSByb290IC0gIEEgcm9vdCBlbGVtZW50IGZyb20gd2hpY2ggdG8gYW5jaG9yLlxuICAgKiBAcGFyYW0ge1JhbmdlU2VsZWN0b3J9IHNlbGVjdG9yXG4gICAqL1xuICBzdGF0aWMgZnJvbVNlbGVjdG9yKHJvb3QsIHNlbGVjdG9yKSB7XG4gICAgY29uc3Qgc3RhcnRDb250YWluZXIgPSBub2RlRnJvbVhQYXRoKHNlbGVjdG9yLnN0YXJ0Q29udGFpbmVyLCByb290KTtcbiAgICBpZiAoIXN0YXJ0Q29udGFpbmVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byByZXNvbHZlIHN0YXJ0Q29udGFpbmVyIFhQYXRoJyk7XG4gICAgfVxuXG4gICAgY29uc3QgZW5kQ29udGFpbmVyID0gbm9kZUZyb21YUGF0aChzZWxlY3Rvci5lbmRDb250YWluZXIsIHJvb3QpO1xuICAgIGlmICghZW5kQ29udGFpbmVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byByZXNvbHZlIGVuZENvbnRhaW5lciBYUGF0aCcpO1xuICAgIH1cblxuICAgIGNvbnN0IHN0YXJ0UG9zID0gVGV4dFBvc2l0aW9uLmZyb21DaGFyT2Zmc2V0KFxuICAgICAgc3RhcnRDb250YWluZXIsXG4gICAgICBzZWxlY3Rvci5zdGFydE9mZnNldFxuICAgICk7XG4gICAgY29uc3QgZW5kUG9zID0gVGV4dFBvc2l0aW9uLmZyb21DaGFyT2Zmc2V0KFxuICAgICAgZW5kQ29udGFpbmVyLFxuICAgICAgc2VsZWN0b3IuZW5kT2Zmc2V0XG4gICAgKTtcblxuICAgIGNvbnN0IHJhbmdlID0gbmV3IFRleHRSYW5nZShzdGFydFBvcywgZW5kUG9zKS50b1JhbmdlKCk7XG4gICAgcmV0dXJuIG5ldyBSYW5nZUFuY2hvcihyb290LCByYW5nZSk7XG4gIH1cblxuICB0b1JhbmdlKCkge1xuICAgIHJldHVybiB0aGlzLnJhbmdlO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge1JhbmdlU2VsZWN0b3J9XG4gICAqL1xuICB0b1NlbGVjdG9yKCkge1xuICAgIC8vIFwiU2hyaW5rXCIgdGhlIHJhbmdlIHNvIHRoYXQgaXQgdGlnaHRseSB3cmFwcyBpdHMgdGV4dC4gVGhpcyBlbnN1cmVzIG1vcmVcbiAgICAvLyBwcmVkaWN0YWJsZSBvdXRwdXQgZm9yIGEgZ2l2ZW4gdGV4dCBzZWxlY3Rpb24uXG4gICAgY29uc3Qgbm9ybWFsaXplZFJhbmdlID0gVGV4dFJhbmdlLmZyb21SYW5nZSh0aGlzLnJhbmdlKS50b1JhbmdlKCk7XG5cbiAgICBjb25zdCB0ZXh0UmFuZ2UgPSBUZXh0UmFuZ2UuZnJvbVJhbmdlKG5vcm1hbGl6ZWRSYW5nZSk7XG4gICAgY29uc3Qgc3RhcnRDb250YWluZXIgPSB4cGF0aEZyb21Ob2RlKHRleHRSYW5nZS5zdGFydC5lbGVtZW50LCB0aGlzLnJvb3QpO1xuICAgIGNvbnN0IGVuZENvbnRhaW5lciA9IHhwYXRoRnJvbU5vZGUodGV4dFJhbmdlLmVuZC5lbGVtZW50LCB0aGlzLnJvb3QpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdSYW5nZVNlbGVjdG9yJyxcbiAgICAgIHN0YXJ0Q29udGFpbmVyLFxuICAgICAgc3RhcnRPZmZzZXQ6IHRleHRSYW5nZS5zdGFydC5vZmZzZXQsXG4gICAgICBlbmRDb250YWluZXIsXG4gICAgICBlbmRPZmZzZXQ6IHRleHRSYW5nZS5lbmQub2Zmc2V0LFxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBiZXR3ZWVuIGBUZXh0UG9zaXRpb25TZWxlY3RvcmAgc2VsZWN0b3JzIGFuZCBgUmFuZ2VgIG9iamVjdHMuXG4gKi9cbmV4cG9ydCBjbGFzcyBUZXh0UG9zaXRpb25BbmNob3Ige1xuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSByb290XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydFxuICAgKiBAcGFyYW0ge251bWJlcn0gZW5kXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihyb290LCBzdGFydCwgZW5kKSB7XG4gICAgdGhpcy5yb290ID0gcm9vdDtcbiAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgdGhpcy5lbmQgPSBlbmQ7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSByb290XG4gICAqIEBwYXJhbSB7UmFuZ2V9IHJhbmdlXG4gICAqL1xuICBzdGF0aWMgZnJvbVJhbmdlKHJvb3QsIHJhbmdlKSB7XG4gICAgY29uc3QgdGV4dFJhbmdlID0gVGV4dFJhbmdlLmZyb21SYW5nZShyYW5nZSkucmVsYXRpdmVUbyhyb290KTtcbiAgICByZXR1cm4gbmV3IFRleHRQb3NpdGlvbkFuY2hvcihcbiAgICAgIHJvb3QsXG4gICAgICB0ZXh0UmFuZ2Uuc3RhcnQub2Zmc2V0LFxuICAgICAgdGV4dFJhbmdlLmVuZC5vZmZzZXRcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IHJvb3RcbiAgICogQHBhcmFtIHtUZXh0UG9zaXRpb25TZWxlY3Rvcn0gc2VsZWN0b3JcbiAgICovXG4gIHN0YXRpYyBmcm9tU2VsZWN0b3Iocm9vdCwgc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gbmV3IFRleHRQb3NpdGlvbkFuY2hvcihyb290LCBzZWxlY3Rvci5zdGFydCwgc2VsZWN0b3IuZW5kKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtUZXh0UG9zaXRpb25TZWxlY3Rvcn1cbiAgICovXG4gIHRvU2VsZWN0b3IoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdUZXh0UG9zaXRpb25TZWxlY3RvcicsXG4gICAgICBzdGFydDogdGhpcy5zdGFydCxcbiAgICAgIGVuZDogdGhpcy5lbmQsXG4gICAgfTtcbiAgfVxuXG4gIHRvUmFuZ2UoKSB7XG4gICAgcmV0dXJuIFRleHRSYW5nZS5mcm9tT2Zmc2V0cyh0aGlzLnJvb3QsIHRoaXMuc3RhcnQsIHRoaXMuZW5kKS50b1JhbmdlKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBAdHlwZWRlZiBRdW90ZU1hdGNoT3B0aW9uc1xuICogQHByb3Age251bWJlcn0gW2hpbnRdIC0gRXhwZWN0ZWQgcG9zaXRpb24gb2YgbWF0Y2ggaW4gdGV4dC4gU2VlIGBtYXRjaFF1b3RlYC5cbiAqL1xuXG4vKipcbiAqIENvbnZlcnRzIGJldHdlZW4gYFRleHRRdW90ZVNlbGVjdG9yYCBzZWxlY3RvcnMgYW5kIGBSYW5nZWAgb2JqZWN0cy5cbiAqL1xuZXhwb3J0IGNsYXNzIFRleHRRdW90ZUFuY2hvciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IHJvb3QgLSBBIHJvb3QgZWxlbWVudCBmcm9tIHdoaWNoIHRvIGFuY2hvci5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV4YWN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gICAqICAgQHBhcmFtIHtzdHJpbmd9IFtjb250ZXh0LnByZWZpeF1cbiAgICogICBAcGFyYW0ge3N0cmluZ30gW2NvbnRleHQuc3VmZml4XVxuICAgKi9cbiAgY29uc3RydWN0b3Iocm9vdCwgZXhhY3QsIGNvbnRleHQgPSB7fSkge1xuICAgIHRoaXMucm9vdCA9IHJvb3Q7XG4gICAgdGhpcy5leGFjdCA9IGV4YWN0O1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgYFRleHRRdW90ZUFuY2hvcmAgZnJvbSBhIHJhbmdlLlxuICAgKlxuICAgKiBXaWxsIHRocm93IGlmIGByYW5nZWAgZG9lcyBub3QgY29udGFpbiBhbnkgdGV4dCBub2Rlcy5cbiAgICpcbiAgICogQHBhcmFtIHtFbGVtZW50fSByb290XG4gICAqIEBwYXJhbSB7UmFuZ2V9IHJhbmdlXG4gICAqL1xuICBzdGF0aWMgZnJvbVJhbmdlKHJvb3QsIHJhbmdlKSB7XG4gICAgY29uc3QgdGV4dCA9IC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAocm9vdC50ZXh0Q29udGVudCk7XG4gICAgY29uc3QgdGV4dFJhbmdlID0gVGV4dFJhbmdlLmZyb21SYW5nZShyYW5nZSkucmVsYXRpdmVUbyhyb290KTtcblxuICAgIGNvbnN0IHN0YXJ0ID0gdGV4dFJhbmdlLnN0YXJ0Lm9mZnNldDtcbiAgICBjb25zdCBlbmQgPSB0ZXh0UmFuZ2UuZW5kLm9mZnNldDtcblxuICAgIC8vIE51bWJlciBvZiBjaGFyYWN0ZXJzIGFyb3VuZCB0aGUgcXVvdGUgdG8gY2FwdHVyZSBhcyBjb250ZXh0LiBXZSBjdXJyZW50bHlcbiAgICAvLyBhbHdheXMgdXNlIGEgZml4ZWQgYW1vdW50LCBidXQgaXQgd291bGQgYmUgYmV0dGVyIGlmIHRoaXMgY29kZSB3YXMgYXdhcmVcbiAgICAvLyBvZiBsb2dpY2FsIGJvdW5kYXJpZXMgaW4gdGhlIGRvY3VtZW50IChwYXJhZ3JhcGgsIGFydGljbGUgZXRjLikgdG8gYXZvaWRcbiAgICAvLyBjYXB0dXJpbmcgdGV4dCB1bnJlbGF0ZWQgdG8gdGhlIHF1b3RlLlxuICAgIC8vXG4gICAgLy8gSW4gcmVndWxhciBwcm9zZSB0aGUgaWRlYWwgY29udGVudCB3b3VsZCBvZnRlbiBiZSB0aGUgc3Vycm91bmRpbmcgc2VudGVuY2UuXG4gICAgLy8gVGhpcyBpcyBhIG5hdHVyYWwgdW5pdCBvZiBtZWFuaW5nIHdoaWNoIGVuYWJsZXMgZGlzcGxheWluZyBxdW90ZXMgaW5cbiAgICAvLyBjb250ZXh0IGV2ZW4gd2hlbiB0aGUgZG9jdW1lbnQgaXMgbm90IGF2YWlsYWJsZS4gV2UgY291bGQgdXNlIGBJbnRsLlNlZ21lbnRlcmBcbiAgICAvLyBmb3IgdGhpcyB3aGVuIGF2YWlsYWJsZS5cbiAgICBjb25zdCBjb250ZXh0TGVuID0gMzI7XG5cbiAgICByZXR1cm4gbmV3IFRleHRRdW90ZUFuY2hvcihyb290LCB0ZXh0LnNsaWNlKHN0YXJ0LCBlbmQpLCB7XG4gICAgICBwcmVmaXg6IHRleHQuc2xpY2UoTWF0aC5tYXgoMCwgc3RhcnQgLSBjb250ZXh0TGVuKSwgc3RhcnQpLFxuICAgICAgc3VmZml4OiB0ZXh0LnNsaWNlKGVuZCwgTWF0aC5taW4odGV4dC5sZW5ndGgsIGVuZCArIGNvbnRleHRMZW4pKSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IHJvb3RcbiAgICogQHBhcmFtIHtUZXh0UXVvdGVTZWxlY3Rvcn0gc2VsZWN0b3JcbiAgICovXG4gIHN0YXRpYyBmcm9tU2VsZWN0b3Iocm9vdCwgc2VsZWN0b3IpIHtcbiAgICBjb25zdCB7IHByZWZpeCwgc3VmZml4IH0gPSBzZWxlY3RvcjtcbiAgICByZXR1cm4gbmV3IFRleHRRdW90ZUFuY2hvcihyb290LCBzZWxlY3Rvci5leGFjdCwgeyBwcmVmaXgsIHN1ZmZpeCB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtUZXh0UXVvdGVTZWxlY3Rvcn1cbiAgICovXG4gIHRvU2VsZWN0b3IoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdUZXh0UXVvdGVTZWxlY3RvcicsXG4gICAgICBleGFjdDogdGhpcy5leGFjdCxcbiAgICAgIHByZWZpeDogdGhpcy5jb250ZXh0LnByZWZpeCxcbiAgICAgIHN1ZmZpeDogdGhpcy5jb250ZXh0LnN1ZmZpeCxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7UXVvdGVNYXRjaE9wdGlvbnN9IFtvcHRpb25zXVxuICAgKi9cbiAgdG9SYW5nZShvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy50b1Bvc2l0aW9uQW5jaG9yKG9wdGlvbnMpLnRvUmFuZ2UoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1F1b3RlTWF0Y2hPcHRpb25zfSBbb3B0aW9uc11cbiAgICovXG4gIHRvUG9zaXRpb25BbmNob3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgdGV4dCA9IC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAodGhpcy5yb290LnRleHRDb250ZW50KTtcbiAgICBjb25zdCBtYXRjaCA9IG1hdGNoUXVvdGUodGV4dCwgdGhpcy5leGFjdCwge1xuICAgICAgLi4udGhpcy5jb250ZXh0LFxuICAgICAgaGludDogb3B0aW9ucy5oaW50LFxuICAgIH0pO1xuICAgIGlmICghbWF0Y2gpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUXVvdGUgbm90IGZvdW5kJyk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVGV4dFBvc2l0aW9uQW5jaG9yKHRoaXMucm9vdCwgbWF0Y2guc3RhcnQsIG1hdGNoLmVuZCk7XG4gIH1cbn1cbiIsIi8vXG4vLyAgQ29weXJpZ2h0IDIwMjEgUmVhZGl1bSBGb3VuZGF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IHRoZSBCU0Qtc3R5bGUgbGljZW5zZVxuLy8gIGF2YWlsYWJsZSBpbiB0aGUgdG9wLWxldmVsIExJQ0VOU0UgZmlsZSBvZiB0aGUgcHJvamVjdC5cbi8vXG5cbi8vIENhdGNoIEpTIGVycm9ycyB0byBsb2cgdGhlbSBpbiB0aGUgYXBwLlxuXG5pbXBvcnQgeyBUZXh0UXVvdGVBbmNob3IgfSBmcm9tIFwiLi92ZW5kb3IvaHlwb3RoZXNpcy9hbmNob3JpbmcvdHlwZXNcIjtcblxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXG4gIFwiZXJyb3JcIixcbiAgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgd2Via2l0Lm1lc3NhZ2VIYW5kbGVycy5sb2dFcnJvci5wb3N0TWVzc2FnZSh7XG4gICAgICBtZXNzYWdlOiBldmVudC5tZXNzYWdlLFxuICAgICAgZmlsZW5hbWU6IGV2ZW50LmZpbGVuYW1lLFxuICAgICAgbGluZTogZXZlbnQubGluZW5vLFxuICAgIH0pO1xuICB9LFxuICBmYWxzZVxuKTtcblxuLy8gTm90aWZ5IG5hdGl2ZSBjb2RlIHRoYXQgdGhlIHBhZ2UgaGFzIGxvYWRlZC5cbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKFxuICBcImxvYWRcIixcbiAgZnVuY3Rpb24gKCkge1xuICAgIC8vIG9uIHBhZ2UgbG9hZFxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwib3JpZW50YXRpb25jaGFuZ2VcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgb3JpZW50YXRpb25DaGFuZ2VkKCk7XG4gICAgICBzbmFwQ3VycmVudFBvc2l0aW9uKCk7XG4gICAgfSk7XG4gICAgb3JpZW50YXRpb25DaGFuZ2VkKCk7XG4gIH0sXG4gIGZhbHNlXG4pO1xuXG52YXIgbGFzdF9rbm93bl9zY3JvbGxYX3Bvc2l0aW9uID0gMDtcbnZhciBsYXN0X2tub3duX3Njcm9sbFlfcG9zaXRpb24gPSAwO1xudmFyIHRpY2tpbmcgPSBmYWxzZTtcbnZhciBtYXhTY3JlZW5YID0gMDtcblxuLy8gUG9zaXRpb24gaW4gcmFuZ2UgWzAgLSAxXS5cbmZ1bmN0aW9uIHVwZGF0ZShwb3NpdGlvbikge1xuICB2YXIgcG9zaXRpb25TdHJpbmcgPSBwb3NpdGlvbi50b1N0cmluZygpO1xuICB3ZWJraXQubWVzc2FnZUhhbmRsZXJzLnByb2dyZXNzaW9uQ2hhbmdlZC5wb3N0TWVzc2FnZShwb3NpdGlvblN0cmluZyk7XG59XG5cbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIGZ1bmN0aW9uICgpIHtcbiAgbGFzdF9rbm93bl9zY3JvbGxZX3Bvc2l0aW9uID1cbiAgICB3aW5kb3cuc2Nyb2xsWSAvIGRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnQuc2Nyb2xsSGVpZ2h0O1xuICAvLyBVc2luZyBNYXRoLmFicyBiZWNhdXNlIGZvciBSVEwgYm9va3MsIHRoZSB2YWx1ZSB3aWxsIGJlIG5lZ2F0aXZlLlxuICBsYXN0X2tub3duX3Njcm9sbFhfcG9zaXRpb24gPSBNYXRoLmFicyhcbiAgICB3aW5kb3cuc2Nyb2xsWCAvIGRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnQuc2Nyb2xsV2lkdGhcbiAgKTtcblxuICAvLyBXaW5kb3cgaXMgaGlkZGVuXG4gIGlmIChcbiAgICBkb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50LnNjcm9sbFdpZHRoID09PSAwIHx8XG4gICAgZG9jdW1lbnQuc2Nyb2xsaW5nRWxlbWVudC5zY3JvbGxIZWlnaHQgPT09IDBcbiAgKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKCF0aWNraW5nKSB7XG4gICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICB1cGRhdGUoXG4gICAgICAgIGlzU2Nyb2xsTW9kZUVuYWJsZWQoKVxuICAgICAgICAgID8gbGFzdF9rbm93bl9zY3JvbGxZX3Bvc2l0aW9uXG4gICAgICAgICAgOiBsYXN0X2tub3duX3Njcm9sbFhfcG9zaXRpb25cbiAgICAgICk7XG4gICAgICB0aWNraW5nID0gZmFsc2U7XG4gICAgfSk7XG4gIH1cbiAgdGlja2luZyA9IHRydWU7XG59KTtcblxuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcbiAgXCJzZWxlY3Rpb25jaGFuZ2VcIixcbiAgZGVib3VuY2UoNTAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaW5mbyA9IHt9O1xuICAgIHZhciBzZWxlY3Rpb24gPSBkb2N1bWVudC5nZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoc2VsZWN0aW9uICYmIHNlbGVjdGlvbi5yYW5nZUNvdW50ID4gMCkge1xuICAgICAgdmFyIHJlY3QgPSBzZWxlY3Rpb24uZ2V0UmFuZ2VBdCgwKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGluZm9bXCJ0ZXh0XCJdID0gc2VsZWN0aW9uLnRvU3RyaW5nKCkudHJpbSgpO1xuICAgICAgaW5mb1tcImZyYW1lXCJdID0ge1xuICAgICAgICB4OiByZWN0LmxlZnQsXG4gICAgICAgIHk6IHJlY3QudG9wLFxuICAgICAgICB3aWR0aDogcmVjdC53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiByZWN0LmhlaWdodCxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgd2Via2l0Lm1lc3NhZ2VIYW5kbGVycy5zZWxlY3Rpb25DaGFuZ2VkLnBvc3RNZXNzYWdlKGluZm8pO1xuICB9KVxuKTtcblxuZnVuY3Rpb24gb3JpZW50YXRpb25DaGFuZ2VkKCkge1xuICBtYXhTY3JlZW5YID1cbiAgICB3aW5kb3cub3JpZW50YXRpb24gPT09IDAgfHwgd2luZG93Lm9yaWVudGF0aW9uID09IDE4MFxuICAgICAgPyBzY3JlZW4ud2lkdGhcbiAgICAgIDogc2NyZWVuLmhlaWdodDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzU2Nyb2xsTW9kZUVuYWJsZWQoKSB7XG4gIHJldHVybiAoXG4gICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlXG4gICAgICAuZ2V0UHJvcGVydHlWYWx1ZShcIi0tVVNFUl9fc2Nyb2xsXCIpXG4gICAgICAudG9TdHJpbmcoKVxuICAgICAgLnRyaW0oKSA9PT0gXCJyZWFkaXVtLXNjcm9sbC1vblwiXG4gICk7XG59XG5cbi8vIFNjcm9sbCB0byB0aGUgZ2l2ZW4gVGFnSWQgaW4gZG9jdW1lbnQgYW5kIHNuYXAuXG5leHBvcnQgZnVuY3Rpb24gc2Nyb2xsVG9JZChpZCkge1xuICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKTtcbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGVsZW1lbnQuc2Nyb2xsSW50b1ZpZXcoKTtcblxuICBpZiAoIWlzU2Nyb2xsTW9kZUVuYWJsZWQoKSkge1xuICAgIHZhciBjdXJyZW50T2Zmc2V0ID0gd2luZG93LnNjcm9sbFg7XG4gICAgdmFyIHBhZ2VXaWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgIC8vIEFkZHMgaGFsZiBhIHBhZ2UgdG8gbWFrZSBzdXJlIHdlIGRvbid0IHNuYXAgdG8gdGhlIHByZXZpb3VzIHBhZ2UuXG4gICAgZG9jdW1lbnQuc2Nyb2xsaW5nRWxlbWVudC5zY3JvbGxMZWZ0ID0gc25hcE9mZnNldChcbiAgICAgIGN1cnJlbnRPZmZzZXQgKyBwYWdlV2lkdGggLyAyXG4gICAgKTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gUG9zaXRpb24gbXVzdCBiZSBpbiB0aGUgcmFuZ2UgWzAgLSAxXSwgMC0xMDAlLlxuZXhwb3J0IGZ1bmN0aW9uIHNjcm9sbFRvUG9zaXRpb24ocG9zaXRpb24sIGRpcikge1xuICBjb25zb2xlLmxvZyhcIlNjcm9sbFRvUG9zaXRpb25cIik7XG4gIGlmIChwb3NpdGlvbiA8IDAgfHwgcG9zaXRpb24gPiAxKSB7XG4gICAgY29uc29sZS5sb2coXCJJbnZhbGlkUG9zaXRpb25cIik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGlzU2Nyb2xsTW9kZUVuYWJsZWQoKSkge1xuICAgIGxldCBvZmZzZXQgPSBkb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50LnNjcm9sbEhlaWdodCAqIHBvc2l0aW9uO1xuICAgIGRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnQuc2Nyb2xsVG9wID0gb2Zmc2V0O1xuICAgIC8vIHdpbmRvdy5zY3JvbGxUbygwLCBvZmZzZXQpO1xuICB9IGVsc2Uge1xuICAgIHZhciBkb2N1bWVudFdpZHRoID0gZG9jdW1lbnQuc2Nyb2xsaW5nRWxlbWVudC5zY3JvbGxXaWR0aDtcbiAgICB2YXIgZmFjdG9yID0gZGlyID09IFwicnRsXCIgPyAtMSA6IDE7XG4gICAgbGV0IG9mZnNldCA9IGRvY3VtZW50V2lkdGggKiBwb3NpdGlvbiAqIGZhY3RvcjtcbiAgICBkb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50LnNjcm9sbExlZnQgPSBzbmFwT2Zmc2V0KG9mZnNldCk7XG4gIH1cbn1cblxuLy8gU2Nyb2xscyB0byB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiB0aGUgZ2l2ZW4gdGV4dCBzbmlwcGV0LlxuLy9cbi8vIFRoZSBleHBlY3RlZCB0ZXh0IGFyZ3VtZW50IGlzIGEgTG9jYXRvciBUZXh0IG9iamVjdCwgYXMgZGVmaW5lZCBoZXJlOlxuLy8gaHR0cHM6Ly9yZWFkaXVtLm9yZy9hcmNoaXRlY3R1cmUvbW9kZWxzL2xvY2F0b3JzL1xuZXhwb3J0IGZ1bmN0aW9uIHNjcm9sbFRvVGV4dCh0ZXh0KSB7XG4gIGxldCByYW5nZSA9IHJhbmdlRnJvbUxvY2F0b3IoeyB0ZXh0IH0pO1xuICBpZiAoIXJhbmdlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHNjcm9sbFRvUmFuZ2UocmFuZ2UpO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gc2Nyb2xsVG9SYW5nZShyYW5nZSkge1xuICB2YXIgcmVjdCA9IHJhbmdlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICBpZiAoaXNTY3JvbGxNb2RlRW5hYmxlZCgpKSB7XG4gICAgZG9jdW1lbnQuc2Nyb2xsaW5nRWxlbWVudC5zY3JvbGxUb3AgPVxuICAgICAgcmVjdC50b3AgKyB3aW5kb3cuc2Nyb2xsWSAtIHdpbmRvdy5pbm5lckhlaWdodCAvIDI7XG4gIH0gZWxzZSB7XG4gICAgZG9jdW1lbnQuc2Nyb2xsaW5nRWxlbWVudC5zY3JvbGxMZWZ0ID0gcmVjdC5sZWZ0ICsgd2luZG93LnNjcm9sbFg7XG4gICAgc25hcEN1cnJlbnRQb3NpdGlvbigpO1xuICB9XG59XG5cbi8vIFJldHVybnMgZmFsc2UgaWYgdGhlIHBhZ2UgaXMgYWxyZWFkeSBhdCB0aGUgbGVmdC1tb3N0IHNjcm9sbCBvZmZzZXQuXG5leHBvcnQgZnVuY3Rpb24gc2Nyb2xsTGVmdChkaXIpIHtcbiAgdmFyIGlzUlRMID0gZGlyID09IFwicnRsXCI7XG4gIHZhciBkb2N1bWVudFdpZHRoID0gZG9jdW1lbnQuc2Nyb2xsaW5nRWxlbWVudC5zY3JvbGxXaWR0aDtcbiAgdmFyIHBhZ2VXaWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICB2YXIgb2Zmc2V0ID0gd2luZG93LnNjcm9sbFggLSBwYWdlV2lkdGg7XG4gIHZhciBtaW5PZmZzZXQgPSBpc1JUTCA/IC0oZG9jdW1lbnRXaWR0aCAtIHBhZ2VXaWR0aCkgOiAwO1xuICByZXR1cm4gc2Nyb2xsVG9PZmZzZXQoTWF0aC5tYXgob2Zmc2V0LCBtaW5PZmZzZXQpKTtcbn1cblxuLy8gUmV0dXJucyBmYWxzZSBpZiB0aGUgcGFnZSBpcyBhbHJlYWR5IGF0IHRoZSByaWdodC1tb3N0IHNjcm9sbCBvZmZzZXQuXG5leHBvcnQgZnVuY3Rpb24gc2Nyb2xsUmlnaHQoZGlyKSB7XG4gIHZhciBpc1JUTCA9IGRpciA9PSBcInJ0bFwiO1xuICB2YXIgZG9jdW1lbnRXaWR0aCA9IGRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnQuc2Nyb2xsV2lkdGg7XG4gIHZhciBwYWdlV2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgdmFyIG9mZnNldCA9IHdpbmRvdy5zY3JvbGxYICsgcGFnZVdpZHRoO1xuICB2YXIgbWF4T2Zmc2V0ID0gaXNSVEwgPyAwIDogZG9jdW1lbnRXaWR0aCAtIHBhZ2VXaWR0aDtcbiAgcmV0dXJuIHNjcm9sbFRvT2Zmc2V0KE1hdGgubWluKG9mZnNldCwgbWF4T2Zmc2V0KSk7XG59XG5cbi8vIFNjcm9sbHMgdG8gdGhlIGdpdmVuIGxlZnQgb2Zmc2V0LlxuLy8gUmV0dXJucyBmYWxzZSBpZiB0aGUgcGFnZSBzY3JvbGwgcG9zaXRpb24gaXMgYWxyZWFkeSBjbG9zZSBlbm91Z2ggdG8gdGhlIGdpdmVuIG9mZnNldC5cbmZ1bmN0aW9uIHNjcm9sbFRvT2Zmc2V0KG9mZnNldCkge1xuICB2YXIgY3VycmVudE9mZnNldCA9IHdpbmRvdy5zY3JvbGxYO1xuICB2YXIgcGFnZVdpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XG4gIGRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnQuc2Nyb2xsTGVmdCA9IG9mZnNldDtcbiAgLy8gSW4gc29tZSBjYXNlIHRoZSBzY3JvbGxYIGNhbm5vdCByZWFjaCB0aGUgcG9zaXRpb24gcmVzcGVjdGluZyB0byBpbm5lcldpZHRoXG4gIHZhciBkaWZmID0gTWF0aC5hYnMoY3VycmVudE9mZnNldCAtIG9mZnNldCkgLyBwYWdlV2lkdGg7XG4gIHJldHVybiBkaWZmID4gMC4wMTtcbn1cblxuLy8gU25hcCB0aGUgb2Zmc2V0IHRvIHRoZSBzY3JlZW4gd2lkdGggKHBhZ2Ugd2lkdGgpLlxuZnVuY3Rpb24gc25hcE9mZnNldChvZmZzZXQpIHtcbiAgdmFyIHZhbHVlID0gb2Zmc2V0ICsgMTtcblxuICByZXR1cm4gdmFsdWUgLSAodmFsdWUgJSBtYXhTY3JlZW5YKTtcbn1cblxuZnVuY3Rpb24gc25hcEN1cnJlbnRQb3NpdGlvbigpIHtcbiAgaWYgKGlzU2Nyb2xsTW9kZUVuYWJsZWQoKSkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgY3VycmVudE9mZnNldCA9IHdpbmRvdy5zY3JvbGxYO1xuICB2YXIgY3VycmVudE9mZnNldFNuYXBwZWQgPSBzbmFwT2Zmc2V0KGN1cnJlbnRPZmZzZXQgKyAxKTtcblxuICBkb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50LnNjcm9sbExlZnQgPSBjdXJyZW50T2Zmc2V0U25hcHBlZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJhbmdlRnJvbUxvY2F0b3IobG9jYXRvcikge1xuICBsZXQgdGV4dCA9IGxvY2F0b3IudGV4dDtcbiAgaWYgKCF0ZXh0IHx8ICF0ZXh0LmhpZ2hsaWdodCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHRyeSB7XG4gICAgbGV0IGFuY2hvciA9IG5ldyBUZXh0UXVvdGVBbmNob3IoZG9jdW1lbnQuYm9keSwgdGV4dC5oaWdobGlnaHQsIHtcbiAgICAgIHByZWZpeDogdGV4dC5iZWZvcmUsXG4gICAgICBzdWZmaXg6IHRleHQuYWZ0ZXIsXG4gICAgfSk7XG4gICAgcmV0dXJuIGFuY2hvci50b1JhbmdlKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBsb2dFcnJvcihlKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vLy8gVXNlciBTZXR0aW5ncy5cblxuLy8gRm9yIHNldHRpbmcgdXNlciBzZXR0aW5nLlxuZXhwb3J0IGZ1bmN0aW9uIHNldFByb3BlcnR5KGtleSwgdmFsdWUpIHtcbiAgdmFyIHJvb3QgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cbiAgcm9vdC5zdHlsZS5zZXRQcm9wZXJ0eShrZXksIHZhbHVlKTtcbn1cblxuLy8gRm9yIHJlbW92aW5nIHVzZXIgc2V0dGluZy5cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVQcm9wZXJ0eShrZXkpIHtcbiAgdmFyIHJvb3QgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cbiAgcm9vdC5zdHlsZS5yZW1vdmVQcm9wZXJ0eShrZXkpO1xufVxuXG4vLy8gVG9vbGtpdFxuXG5mdW5jdGlvbiBkZWJvdW5jZShkZWxheSwgZnVuYykge1xuICB2YXIgdGltZW91dDtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgZnVuY3Rpb24gY2FsbGJhY2soKSB7XG4gICAgICBmdW5jLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgfVxuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICB0aW1lb3V0ID0gc2V0VGltZW91dChjYWxsYmFjaywgZGVsYXkpO1xuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbG9nKCkge1xuICB2YXIgbWVzc2FnZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykuam9pbihcIiBcIik7XG4gIHdlYmtpdC5tZXNzYWdlSGFuZGxlcnMubG9nLnBvc3RNZXNzYWdlKG1lc3NhZ2UpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbG9nRXJyb3JNZXNzYWdlKG1zZykge1xuICBsb2dFcnJvcihuZXcgRXJyb3IobXNnKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsb2dFcnJvcihlKSB7XG4gIHdlYmtpdC5tZXNzYWdlSGFuZGxlcnMubG9nRXJyb3IucG9zdE1lc3NhZ2Uoe1xuICAgIG1lc3NhZ2U6IGUubWVzc2FnZSxcbiAgfSk7XG59XG4iLCIvL1xuLy8gIENvcHlyaWdodCAyMDIxIFJlYWRpdW0gRm91bmRhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSB0aGUgQlNELXN0eWxlIGxpY2Vuc2Vcbi8vICBhdmFpbGFibGUgaW4gdGhlIHRvcC1sZXZlbCBMSUNFTlNFIGZpbGUgb2YgdGhlIHByb2plY3QuXG4vL1xuXG5pbXBvcnQgeyBsb2cgYXMgbG9nTmF0aXZlLCBsb2dFcnJvciB9IGZyb20gXCIuL3V0aWxzXCI7XG5pbXBvcnQgeyBUZXh0UmFuZ2UgfSBmcm9tIFwiLi92ZW5kb3IvaHlwb3RoZXNpcy9hbmNob3JpbmcvdGV4dC1yYW5nZVwiO1xuXG5jb25zdCBkZWJ1ZyA9IHRydWU7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTZWxlY3Rpb25SZWN0KCkge1xuICB0cnkge1xuICAgIGxldCBzZWwgPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCFzZWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHJhbmdlID0gc2VsLmdldFJhbmdlQXQoMCk7XG5cbiAgICBjb25zdCBjbGllbnRSZWN0ID0gcmFuZ2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgc2NyZWVuV2lkdGg6IHdpbmRvdy5vdXRlcldpZHRoLFxuICAgICAgc2NyZWVuSGVpZ2h0OiB3aW5kb3cub3V0ZXJIZWlnaHQsXG4gICAgICBsZWZ0OiBjbGllbnRSZWN0LmxlZnQsXG4gICAgICB3aWR0aDogY2xpZW50UmVjdC53aWR0aCxcbiAgICAgIHRvcDogY2xpZW50UmVjdC50b3AsXG4gICAgICBoZWlnaHQ6IGNsaWVudFJlY3QuaGVpZ2h0LFxuICAgIH07XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBsb2dFcnJvcihlKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q3VycmVudFNlbGVjdGlvbkluZm8oKSB7XG4gIGNvbnN0IHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgaWYgKCFzZWxlY3Rpb24pIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGlmIChzZWxlY3Rpb24uaXNDb2xsYXBzZWQpIHtcbiAgICBsb2coXCJeXl4gU0VMRUNUSU9OIENPTExBUFNFRC5cIik7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBjb25zdCByYXdUZXh0ID0gc2VsZWN0aW9uLnRvU3RyaW5nKCk7XG4gIGNvbnN0IGNsZWFuVGV4dCA9IHJhd1RleHQudHJpbSgpLnJlcGxhY2UoL1xcbi9nLCBcIiBcIikucmVwbGFjZSgvXFxzXFxzKy9nLCBcIiBcIik7XG4gIGlmIChjbGVhblRleHQubGVuZ3RoID09PSAwKSB7XG4gICAgbG9nKFwiXl5eIFNFTEVDVElPTiBURVhUIEVNUFRZLlwiKTtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGlmICghc2VsZWN0aW9uLmFuY2hvck5vZGUgfHwgIXNlbGVjdGlvbi5mb2N1c05vZGUpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGNvbnN0IHJhbmdlID1cbiAgICBzZWxlY3Rpb24ucmFuZ2VDb3VudCA9PT0gMVxuICAgICAgPyBzZWxlY3Rpb24uZ2V0UmFuZ2VBdCgwKVxuICAgICAgOiBjcmVhdGVPcmRlcmVkUmFuZ2UoXG4gICAgICAgICAgc2VsZWN0aW9uLmFuY2hvck5vZGUsXG4gICAgICAgICAgc2VsZWN0aW9uLmFuY2hvck9mZnNldCxcbiAgICAgICAgICBzZWxlY3Rpb24uZm9jdXNOb2RlLFxuICAgICAgICAgIHNlbGVjdGlvbi5mb2N1c09mZnNldFxuICAgICAgICApO1xuICBpZiAoIXJhbmdlIHx8IHJhbmdlLmNvbGxhcHNlZCkge1xuICAgIGxvZyhcIiQkJCQkJCQkJCQkJCQkJCQkIENBTk5PVCBHRVQgTk9OLUNPTExBUFNFRCBTRUxFQ1RJT04gUkFOR0U/IVwiKTtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGNvbnN0IHJhbmdlSW5mbyA9IGNvbnZlcnRSYW5nZShyYW5nZSwgZnVsbFF1YWxpZmllZFNlbGVjdG9yKTtcbiAgaWYgKCFyYW5nZUluZm8pIHtcbiAgICBsb2coXCJeXl4gU0VMRUNUSU9OIFJBTkdFIElORk8gRkFJTD8hXCIpO1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBjb25zdCB0ZXh0ID0gZG9jdW1lbnQuYm9keS50ZXh0Q29udGVudDtcbiAgY29uc3QgdGV4dFJhbmdlID0gVGV4dFJhbmdlLmZyb21SYW5nZShyYW5nZSkucmVsYXRpdmVUbyhkb2N1bWVudC5ib2R5KTtcbiAgY29uc3Qgc3RhcnQgPSB0ZXh0UmFuZ2Uuc3RhcnQub2Zmc2V0O1xuICBjb25zdCBlbmQgPSB0ZXh0UmFuZ2UuZW5kLm9mZnNldDtcblxuICBjb25zdCBzbmlwcGV0TGVuZ3RoID0gMjAwO1xuXG4gIC8vIENvbXB1dGUgdGhlIHRleHQgYmVmb3JlIHRoZSBoaWdobGlnaHQsIGlnbm9yaW5nIHRoZSBmaXJzdCBcIndvcmRcIiwgd2hpY2ggbWlnaHQgYmUgY3V0LlxuICBsZXQgYmVmb3JlID0gdGV4dC5zbGljZShNYXRoLm1heCgwLCBzdGFydCAtIHNuaXBwZXRMZW5ndGgpLCBzdGFydCk7XG4gIGxldCBmaXJzdFdvcmRTdGFydCA9IGJlZm9yZS5zZWFyY2goL1xcUHtMfVxccHtMfS9ndSk7XG4gIGlmIChmaXJzdFdvcmRTdGFydCAhPT0gLTEpIHtcbiAgICBiZWZvcmUgPSBiZWZvcmUuc2xpY2UoZmlyc3RXb3JkU3RhcnQgKyAxKTtcbiAgfVxuXG4gIC8vIENvbXB1dGUgdGhlIHRleHQgYWZ0ZXIgdGhlIGhpZ2hsaWdodCwgaWdub3JpbmcgdGhlIGxhc3QgXCJ3b3JkXCIsIHdoaWNoIG1pZ2h0IGJlIGN1dC5cbiAgbGV0IGFmdGVyID0gdGV4dC5zbGljZShlbmQsIE1hdGgubWluKHRleHQubGVuZ3RoLCBlbmQgKyBzbmlwcGV0TGVuZ3RoKSk7XG4gIGxldCBsYXN0V29yZEVuZCA9IEFycmF5LmZyb20oYWZ0ZXIubWF0Y2hBbGwoL1xccHtMfVxcUHtMfS9ndSkpLnBvcCgpO1xuICBpZiAobGFzdFdvcmRFbmQgIT09IHVuZGVmaW5lZCAmJiBsYXN0V29yZEVuZC5pbmRleCA+IDEpIHtcbiAgICBhZnRlciA9IGFmdGVyLnNsaWNlKDAsIGxhc3RXb3JkRW5kLmluZGV4ICsgMSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGxvY2F0aW9uczogcmFuZ2VJbmZvMkxvY2F0aW9uKHJhbmdlSW5mbyksXG4gICAgdGV4dDoge1xuICAgICAgaGlnaGxpZ2h0OiByYXdUZXh0LFxuICAgICAgYmVmb3JlOiBiZWZvcmUsXG4gICAgICBhZnRlcjogYWZ0ZXIsXG4gICAgfSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlT3JkZXJlZFJhbmdlKHN0YXJ0Tm9kZSwgc3RhcnRPZmZzZXQsIGVuZE5vZGUsIGVuZE9mZnNldCkge1xuICBjb25zdCByYW5nZSA9IG5ldyBSYW5nZSgpO1xuICByYW5nZS5zZXRTdGFydChzdGFydE5vZGUsIHN0YXJ0T2Zmc2V0KTtcbiAgcmFuZ2Uuc2V0RW5kKGVuZE5vZGUsIGVuZE9mZnNldCk7XG4gIGlmICghcmFuZ2UuY29sbGFwc2VkKSB7XG4gICAgcmV0dXJuIHJhbmdlO1xuICB9XG4gIGxvZyhcIj4+PiBjcmVhdGVPcmRlcmVkUmFuZ2UgQ09MTEFQU0VEIC4uLiBSQU5HRSBSRVZFUlNFP1wiKTtcbiAgY29uc3QgcmFuZ2VSZXZlcnNlID0gbmV3IFJhbmdlKCk7XG4gIHJhbmdlUmV2ZXJzZS5zZXRTdGFydChlbmROb2RlLCBlbmRPZmZzZXQpO1xuICByYW5nZVJldmVyc2Uuc2V0RW5kKHN0YXJ0Tm9kZSwgc3RhcnRPZmZzZXQpO1xuICBpZiAoIXJhbmdlUmV2ZXJzZS5jb2xsYXBzZWQpIHtcbiAgICBsb2coXCI+Pj4gY3JlYXRlT3JkZXJlZFJhbmdlIFJBTkdFIFJFVkVSU0UgT0suXCIpO1xuICAgIHJldHVybiByYW5nZTtcbiAgfVxuICBsb2coXCI+Pj4gY3JlYXRlT3JkZXJlZFJhbmdlIFJBTkdFIFJFVkVSU0UgQUxTTyBDT0xMQVBTRUQ/IVwiKTtcbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gY29udmVydFJhbmdlKHJhbmdlLCBnZXRDc3NTZWxlY3Rvcikge1xuICBjb25zdCBzdGFydElzRWxlbWVudCA9IHJhbmdlLnN0YXJ0Q29udGFpbmVyLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERTtcbiAgY29uc3Qgc3RhcnRDb250YWluZXJFbGVtZW50ID0gc3RhcnRJc0VsZW1lbnRcbiAgICA/IHJhbmdlLnN0YXJ0Q29udGFpbmVyXG4gICAgOiByYW5nZS5zdGFydENvbnRhaW5lci5wYXJlbnROb2RlICYmXG4gICAgICByYW5nZS5zdGFydENvbnRhaW5lci5wYXJlbnROb2RlLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERVxuICAgID8gcmFuZ2Uuc3RhcnRDb250YWluZXIucGFyZW50Tm9kZVxuICAgIDogdW5kZWZpbmVkO1xuICBpZiAoIXN0YXJ0Q29udGFpbmVyRWxlbWVudCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgY29uc3Qgc3RhcnRDb250YWluZXJDaGlsZFRleHROb2RlSW5kZXggPSBzdGFydElzRWxlbWVudFxuICAgID8gLTFcbiAgICA6IEFycmF5LmZyb20oc3RhcnRDb250YWluZXJFbGVtZW50LmNoaWxkTm9kZXMpLmluZGV4T2YoXG4gICAgICAgIHJhbmdlLnN0YXJ0Q29udGFpbmVyXG4gICAgICApO1xuICBpZiAoc3RhcnRDb250YWluZXJDaGlsZFRleHROb2RlSW5kZXggPCAtMSkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgY29uc3Qgc3RhcnRDb250YWluZXJFbGVtZW50Q3NzU2VsZWN0b3IgPSBnZXRDc3NTZWxlY3RvcihcbiAgICBzdGFydENvbnRhaW5lckVsZW1lbnRcbiAgKTtcblxuICBjb25zdCBlbmRJc0VsZW1lbnQgPSByYW5nZS5lbmRDb250YWluZXIubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFO1xuICBjb25zdCBlbmRDb250YWluZXJFbGVtZW50ID0gZW5kSXNFbGVtZW50XG4gICAgPyByYW5nZS5lbmRDb250YWluZXJcbiAgICA6IHJhbmdlLmVuZENvbnRhaW5lci5wYXJlbnROb2RlICYmXG4gICAgICByYW5nZS5lbmRDb250YWluZXIucGFyZW50Tm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREVcbiAgICA/IHJhbmdlLmVuZENvbnRhaW5lci5wYXJlbnROb2RlXG4gICAgOiB1bmRlZmluZWQ7XG4gIGlmICghZW5kQ29udGFpbmVyRWxlbWVudCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgY29uc3QgZW5kQ29udGFpbmVyQ2hpbGRUZXh0Tm9kZUluZGV4ID0gZW5kSXNFbGVtZW50XG4gICAgPyAtMVxuICAgIDogQXJyYXkuZnJvbShlbmRDb250YWluZXJFbGVtZW50LmNoaWxkTm9kZXMpLmluZGV4T2YocmFuZ2UuZW5kQ29udGFpbmVyKTtcbiAgaWYgKGVuZENvbnRhaW5lckNoaWxkVGV4dE5vZGVJbmRleCA8IC0xKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBjb25zdCBlbmRDb250YWluZXJFbGVtZW50Q3NzU2VsZWN0b3IgPSBnZXRDc3NTZWxlY3RvcihlbmRDb250YWluZXJFbGVtZW50KTtcblxuICBjb25zdCBjb21tb25FbGVtZW50QW5jZXN0b3IgPSBnZXRDb21tb25BbmNlc3RvckVsZW1lbnQoXG4gICAgcmFuZ2Uuc3RhcnRDb250YWluZXIsXG4gICAgcmFuZ2UuZW5kQ29udGFpbmVyXG4gICk7XG4gIGlmICghY29tbW9uRWxlbWVudEFuY2VzdG9yKSB7XG4gICAgbG9nKFwiXl5eIE5PIFJBTkdFIENPTU1PTiBBTkNFU1RPUj8hXCIpO1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKHJhbmdlLmNvbW1vbkFuY2VzdG9yQ29udGFpbmVyKSB7XG4gICAgY29uc3QgcmFuZ2VDb21tb25BbmNlc3RvckVsZW1lbnQgPVxuICAgICAgcmFuZ2UuY29tbW9uQW5jZXN0b3JDb250YWluZXIubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFXG4gICAgICAgID8gcmFuZ2UuY29tbW9uQW5jZXN0b3JDb250YWluZXJcbiAgICAgICAgOiByYW5nZS5jb21tb25BbmNlc3RvckNvbnRhaW5lci5wYXJlbnROb2RlO1xuICAgIGlmIChcbiAgICAgIHJhbmdlQ29tbW9uQW5jZXN0b3JFbGVtZW50ICYmXG4gICAgICByYW5nZUNvbW1vbkFuY2VzdG9yRWxlbWVudC5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREVcbiAgICApIHtcbiAgICAgIGlmIChjb21tb25FbGVtZW50QW5jZXN0b3IgIT09IHJhbmdlQ29tbW9uQW5jZXN0b3JFbGVtZW50KSB7XG4gICAgICAgIGxvZyhcIj4+Pj4+PiBDT01NT04gQU5DRVNUT1IgQ09OVEFJTkVSIERJRkY/PyFcIik7XG4gICAgICAgIGxvZyhnZXRDc3NTZWxlY3Rvcihjb21tb25FbGVtZW50QW5jZXN0b3IpKTtcbiAgICAgICAgbG9nKGdldENzc1NlbGVjdG9yKHJhbmdlQ29tbW9uQW5jZXN0b3JFbGVtZW50KSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgZW5kQ29udGFpbmVyQ2hpbGRUZXh0Tm9kZUluZGV4LFxuICAgIGVuZENvbnRhaW5lckVsZW1lbnRDc3NTZWxlY3RvcixcbiAgICBlbmRPZmZzZXQ6IHJhbmdlLmVuZE9mZnNldCxcbiAgICBzdGFydENvbnRhaW5lckNoaWxkVGV4dE5vZGVJbmRleCxcbiAgICBzdGFydENvbnRhaW5lckVsZW1lbnRDc3NTZWxlY3RvcixcbiAgICBzdGFydE9mZnNldDogcmFuZ2Uuc3RhcnRPZmZzZXQsXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldENvbW1vbkFuY2VzdG9yRWxlbWVudChub2RlMSwgbm9kZTIpIHtcbiAgaWYgKG5vZGUxLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSAmJiBub2RlMSA9PT0gbm9kZTIpIHtcbiAgICByZXR1cm4gbm9kZTE7XG4gIH1cbiAgaWYgKG5vZGUxLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSAmJiBub2RlMS5jb250YWlucyhub2RlMikpIHtcbiAgICByZXR1cm4gbm9kZTE7XG4gIH1cbiAgaWYgKG5vZGUyLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSAmJiBub2RlMi5jb250YWlucyhub2RlMSkpIHtcbiAgICByZXR1cm4gbm9kZTI7XG4gIH1cbiAgY29uc3Qgbm9kZTFFbGVtZW50QW5jZXN0b3JDaGFpbiA9IFtdO1xuICBsZXQgcGFyZW50ID0gbm9kZTEucGFyZW50Tm9kZTtcbiAgd2hpbGUgKHBhcmVudCAmJiBwYXJlbnQubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgbm9kZTFFbGVtZW50QW5jZXN0b3JDaGFpbi5wdXNoKHBhcmVudCk7XG4gICAgcGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGU7XG4gIH1cbiAgY29uc3Qgbm9kZTJFbGVtZW50QW5jZXN0b3JDaGFpbiA9IFtdO1xuICBwYXJlbnQgPSBub2RlMi5wYXJlbnROb2RlO1xuICB3aGlsZSAocGFyZW50ICYmIHBhcmVudC5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICBub2RlMkVsZW1lbnRBbmNlc3RvckNoYWluLnB1c2gocGFyZW50KTtcbiAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZTtcbiAgfVxuICBsZXQgY29tbW9uQW5jZXN0b3IgPSBub2RlMUVsZW1lbnRBbmNlc3RvckNoYWluLmZpbmQoXG4gICAgKG5vZGUxRWxlbWVudEFuY2VzdG9yKSA9PiB7XG4gICAgICByZXR1cm4gbm9kZTJFbGVtZW50QW5jZXN0b3JDaGFpbi5pbmRleE9mKG5vZGUxRWxlbWVudEFuY2VzdG9yKSA+PSAwO1xuICAgIH1cbiAgKTtcbiAgaWYgKCFjb21tb25BbmNlc3Rvcikge1xuICAgIGNvbW1vbkFuY2VzdG9yID0gbm9kZTJFbGVtZW50QW5jZXN0b3JDaGFpbi5maW5kKChub2RlMkVsZW1lbnRBbmNlc3RvcikgPT4ge1xuICAgICAgcmV0dXJuIG5vZGUxRWxlbWVudEFuY2VzdG9yQ2hhaW4uaW5kZXhPZihub2RlMkVsZW1lbnRBbmNlc3RvcikgPj0gMDtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gY29tbW9uQW5jZXN0b3I7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0UmFuZ2VJbmZvKGRvY3VtZW50LCByYW5nZUluZm8pIHtcbiAgY29uc3Qgc3RhcnRFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcbiAgICByYW5nZUluZm8uc3RhcnRDb250YWluZXJFbGVtZW50Q3NzU2VsZWN0b3JcbiAgKTtcbiAgaWYgKCFzdGFydEVsZW1lbnQpIHtcbiAgICBsb2coXCJeXl4gY29udmVydFJhbmdlSW5mbyBOTyBTVEFSVCBFTEVNRU5UIENTUyBTRUxFQ1RPUj8hXCIpO1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgbGV0IHN0YXJ0Q29udGFpbmVyID0gc3RhcnRFbGVtZW50O1xuICBpZiAocmFuZ2VJbmZvLnN0YXJ0Q29udGFpbmVyQ2hpbGRUZXh0Tm9kZUluZGV4ID49IDApIHtcbiAgICBpZiAoXG4gICAgICByYW5nZUluZm8uc3RhcnRDb250YWluZXJDaGlsZFRleHROb2RlSW5kZXggPj1cbiAgICAgIHN0YXJ0RWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aFxuICAgICkge1xuICAgICAgbG9nKFxuICAgICAgICBcIl5eXiBjb252ZXJ0UmFuZ2VJbmZvIHJhbmdlSW5mby5zdGFydENvbnRhaW5lckNoaWxkVGV4dE5vZGVJbmRleCA+PSBzdGFydEVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGg/IVwiXG4gICAgICApO1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgc3RhcnRDb250YWluZXIgPVxuICAgICAgc3RhcnRFbGVtZW50LmNoaWxkTm9kZXNbcmFuZ2VJbmZvLnN0YXJ0Q29udGFpbmVyQ2hpbGRUZXh0Tm9kZUluZGV4XTtcbiAgICBpZiAoc3RhcnRDb250YWluZXIubm9kZVR5cGUgIT09IE5vZGUuVEVYVF9OT0RFKSB7XG4gICAgICBsb2coXCJeXl4gY29udmVydFJhbmdlSW5mbyBzdGFydENvbnRhaW5lci5ub2RlVHlwZSAhPT0gTm9kZS5URVhUX05PREU/IVwiKTtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG4gIGNvbnN0IGVuZEVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFxuICAgIHJhbmdlSW5mby5lbmRDb250YWluZXJFbGVtZW50Q3NzU2VsZWN0b3JcbiAgKTtcbiAgaWYgKCFlbmRFbGVtZW50KSB7XG4gICAgbG9nKFwiXl5eIGNvbnZlcnRSYW5nZUluZm8gTk8gRU5EIEVMRU1FTlQgQ1NTIFNFTEVDVE9SPyFcIik7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBsZXQgZW5kQ29udGFpbmVyID0gZW5kRWxlbWVudDtcbiAgaWYgKHJhbmdlSW5mby5lbmRDb250YWluZXJDaGlsZFRleHROb2RlSW5kZXggPj0gMCkge1xuICAgIGlmIChcbiAgICAgIHJhbmdlSW5mby5lbmRDb250YWluZXJDaGlsZFRleHROb2RlSW5kZXggPj0gZW5kRWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aFxuICAgICkge1xuICAgICAgbG9nKFxuICAgICAgICBcIl5eXiBjb252ZXJ0UmFuZ2VJbmZvIHJhbmdlSW5mby5lbmRDb250YWluZXJDaGlsZFRleHROb2RlSW5kZXggPj0gZW5kRWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aD8hXCJcbiAgICAgICk7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBlbmRDb250YWluZXIgPVxuICAgICAgZW5kRWxlbWVudC5jaGlsZE5vZGVzW3JhbmdlSW5mby5lbmRDb250YWluZXJDaGlsZFRleHROb2RlSW5kZXhdO1xuICAgIGlmIChlbmRDb250YWluZXIubm9kZVR5cGUgIT09IE5vZGUuVEVYVF9OT0RFKSB7XG4gICAgICBsb2coXCJeXl4gY29udmVydFJhbmdlSW5mbyBlbmRDb250YWluZXIubm9kZVR5cGUgIT09IE5vZGUuVEVYVF9OT0RFPyFcIik7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY3JlYXRlT3JkZXJlZFJhbmdlKFxuICAgIHN0YXJ0Q29udGFpbmVyLFxuICAgIHJhbmdlSW5mby5zdGFydE9mZnNldCxcbiAgICBlbmRDb250YWluZXIsXG4gICAgcmFuZ2VJbmZvLmVuZE9mZnNldFxuICApO1xufVxuXG5mdW5jdGlvbiByYW5nZUluZm8yTG9jYXRpb24ocmFuZ2VJbmZvKSB7XG4gIHJldHVybiB7XG4gICAgY3NzU2VsZWN0b3I6IHJhbmdlSW5mby5zdGFydENvbnRhaW5lckVsZW1lbnRDc3NTZWxlY3RvcixcbiAgICBkb21SYW5nZToge1xuICAgICAgc3RhcnQ6IHtcbiAgICAgICAgY3NzU2VsZWN0b3I6IHJhbmdlSW5mby5zdGFydENvbnRhaW5lckVsZW1lbnRDc3NTZWxlY3RvcixcbiAgICAgICAgdGV4dE5vZGVJbmRleDogcmFuZ2VJbmZvLnN0YXJ0Q29udGFpbmVyQ2hpbGRUZXh0Tm9kZUluZGV4LFxuICAgICAgICBvZmZzZXQ6IHJhbmdlSW5mby5zdGFydE9mZnNldCxcbiAgICAgIH0sXG4gICAgICBlbmQ6IHtcbiAgICAgICAgY3NzU2VsZWN0b3I6IHJhbmdlSW5mby5lbmRDb250YWluZXJFbGVtZW50Q3NzU2VsZWN0b3IsXG4gICAgICAgIHRleHROb2RlSW5kZXg6IHJhbmdlSW5mby5lbmRDb250YWluZXJDaGlsZFRleHROb2RlSW5kZXgsXG4gICAgICAgIG9mZnNldDogcmFuZ2VJbmZvLmVuZE9mZnNldCxcbiAgICAgIH0sXG4gICAgfSxcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxvY2F0aW9uMlJhbmdlSW5mbyhsb2NhdGlvbikge1xuICBjb25zdCBsb2NhdGlvbnMgPSBsb2NhdGlvbi5sb2NhdGlvbnM7XG4gIGNvbnN0IGRvbVJhbmdlID0gbG9jYXRpb25zLmRvbVJhbmdlO1xuICBjb25zdCBzdGFydCA9IGRvbVJhbmdlLnN0YXJ0O1xuICBjb25zdCBlbmQgPSBkb21SYW5nZS5lbmQ7XG5cbiAgcmV0dXJuIHtcbiAgICBlbmRDb250YWluZXJDaGlsZFRleHROb2RlSW5kZXg6IGVuZC50ZXh0Tm9kZUluZGV4LFxuICAgIGVuZENvbnRhaW5lckVsZW1lbnRDc3NTZWxlY3RvcjogZW5kLmNzc1NlbGVjdG9yLFxuICAgIGVuZE9mZnNldDogZW5kLm9mZnNldCxcbiAgICBzdGFydENvbnRhaW5lckNoaWxkVGV4dE5vZGVJbmRleDogc3RhcnQudGV4dE5vZGVJbmRleCxcbiAgICBzdGFydENvbnRhaW5lckVsZW1lbnRDc3NTZWxlY3Rvcjogc3RhcnQuY3NzU2VsZWN0b3IsXG4gICAgc3RhcnRPZmZzZXQ6IHN0YXJ0Lm9mZnNldCxcbiAgfTtcbn1cblxuZnVuY3Rpb24gZnVsbFF1YWxpZmllZFNlbGVjdG9yKG5vZGUpIHtcbiAgaWYgKG5vZGUubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIChub2RlLmxvY2FsTmFtZSAmJiBub2RlLmxvY2FsTmFtZS50b0xvd2VyQ2FzZSgpKSB8fFxuICAgICAgbm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpXG4gICAgKTtcbiAgfVxuICAvL3JldHVybiBjc3NQYXRoKG5vZGUsIGp1c3RTZWxlY3Rvcik7XG4gIHJldHVybiBjc3NQYXRoKG5vZGUsIHRydWUpO1xufVxuXG5mdW5jdGlvbiBjc3NQYXRoKG5vZGUsIG9wdGltaXplZCkge1xuICBpZiAobm9kZS5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICByZXR1cm4gXCJcIjtcbiAgfVxuXG4gIGNvbnN0IHN0ZXBzID0gW107XG4gIGxldCBjb250ZXh0Tm9kZSA9IG5vZGU7XG4gIHdoaWxlIChjb250ZXh0Tm9kZSkge1xuICAgIGNvbnN0IHN0ZXAgPSBfY3NzUGF0aFN0ZXAoY29udGV4dE5vZGUsICEhb3B0aW1pemVkLCBjb250ZXh0Tm9kZSA9PT0gbm9kZSk7XG4gICAgaWYgKCFzdGVwKSB7XG4gICAgICBicmVhazsgLy8gRXJyb3IgLSBiYWlsIG91dCBlYXJseS5cbiAgICB9XG4gICAgc3RlcHMucHVzaChzdGVwLnZhbHVlKTtcbiAgICBpZiAoc3RlcC5vcHRpbWl6ZWQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjb250ZXh0Tm9kZSA9IGNvbnRleHROb2RlLnBhcmVudE5vZGU7XG4gIH1cbiAgc3RlcHMucmV2ZXJzZSgpO1xuICByZXR1cm4gc3RlcHMuam9pbihcIiA+IFwiKTtcbn1cblxuLy8gaHR0cHM6Ly9jaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL2JsaW5rLysvbWFzdGVyL1NvdXJjZS9kZXZ0b29scy9mcm9udF9lbmQvY29tcG9uZW50cy9ET01QcmVzZW50YXRpb25VdGlscy5qcyMzMTZcbmZ1bmN0aW9uIF9jc3NQYXRoU3RlcChub2RlLCBvcHRpbWl6ZWQsIGlzVGFyZ2V0Tm9kZSkge1xuICBmdW5jdGlvbiBpZFNlbGVjdG9yKGlkZCkge1xuICAgIHJldHVybiBcIiNcIiArIGVzY2FwZUlkZW50aWZpZXJJZk5lZWRlZChpZGQpO1xuICB9XG5cbiAgZnVuY3Rpb24gZXNjYXBlSWRlbnRpZmllcklmTmVlZGVkKGlkZW50KSB7XG4gICAgaWYgKGlzQ1NTSWRlbnRpZmllcihpZGVudCkpIHtcbiAgICAgIHJldHVybiBpZGVudDtcbiAgICB9XG5cbiAgICBjb25zdCBzaG91bGRFc2NhcGVGaXJzdCA9IC9eKD86WzAtOV18LVswLTktXT8pLy50ZXN0KGlkZW50KTtcbiAgICBjb25zdCBsYXN0SW5kZXggPSBpZGVudC5sZW5ndGggLSAxO1xuICAgIHJldHVybiBpZGVudC5yZXBsYWNlKC8uL2csIGZ1bmN0aW9uIChjLCBpaSkge1xuICAgICAgcmV0dXJuIChzaG91bGRFc2NhcGVGaXJzdCAmJiBpaSA9PT0gMCkgfHwgIWlzQ1NTSWRlbnRDaGFyKGMpXG4gICAgICAgID8gZXNjYXBlQXNjaWlDaGFyKGMsIGlpID09PSBsYXN0SW5kZXgpXG4gICAgICAgIDogYztcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzQ1NTSWRlbnRpZmllcih2YWx1ZSkge1xuICAgIHJldHVybiAvXi0/W2EtekEtWl9dW2EtekEtWjAtOV8tXSokLy50ZXN0KHZhbHVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzQ1NTSWRlbnRDaGFyKGMpIHtcbiAgICBpZiAoL1thLXpBLVowLTlfLV0vLnRlc3QoYykpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gYy5jaGFyQ29kZUF0KDApID49IDB4YTA7XG4gIH1cblxuICBmdW5jdGlvbiBlc2NhcGVBc2NpaUNoYXIoYywgaXNMYXN0KSB7XG4gICAgcmV0dXJuIFwiXFxcXFwiICsgdG9IZXhCeXRlKGMpICsgKGlzTGFzdCA/IFwiXCIgOiBcIiBcIik7XG4gIH1cblxuICBmdW5jdGlvbiB0b0hleEJ5dGUoYykge1xuICAgIGxldCBoZXhCeXRlID0gYy5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KTtcbiAgICBpZiAoaGV4Qnl0ZS5sZW5ndGggPT09IDEpIHtcbiAgICAgIGhleEJ5dGUgPSBcIjBcIiArIGhleEJ5dGU7XG4gICAgfVxuICAgIHJldHVybiBoZXhCeXRlO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJlZml4ZWRFbGVtZW50Q2xhc3NOYW1lcyhuZCkge1xuICAgIGNvbnN0IGNsYXNzQXR0cmlidXRlID0gbmQuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIik7XG4gICAgaWYgKCFjbGFzc0F0dHJpYnV0ZSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIHJldHVybiBjbGFzc0F0dHJpYnV0ZVxuICAgICAgLnNwbGl0KC9cXHMrL2cpXG4gICAgICAuZmlsdGVyKEJvb2xlYW4pXG4gICAgICAubWFwKChubSkgPT4ge1xuICAgICAgICAvLyBUaGUgcHJlZml4IGlzIHJlcXVpcmVkIHRvIHN0b3JlIFwiX19wcm90b19fXCIgaW4gYSBvYmplY3QtYmFzZWQgbWFwLlxuICAgICAgICByZXR1cm4gXCIkXCIgKyBubTtcbiAgICAgIH0pO1xuICB9XG5cbiAgaWYgKG5vZGUubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBjb25zdCBsb3dlckNhc2VOYW1lID1cbiAgICAobm9kZS5sb2NhbE5hbWUgJiYgbm9kZS5sb2NhbE5hbWUudG9Mb3dlckNhc2UoKSkgfHxcbiAgICBub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgY29uc3QgZWxlbWVudCA9IG5vZGU7XG5cbiAgY29uc3QgaWQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShcImlkXCIpO1xuXG4gIGlmIChvcHRpbWl6ZWQpIHtcbiAgICBpZiAoaWQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG9wdGltaXplZDogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGlkU2VsZWN0b3IoaWQpLFxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKFxuICAgICAgbG93ZXJDYXNlTmFtZSA9PT0gXCJib2R5XCIgfHxcbiAgICAgIGxvd2VyQ2FzZU5hbWUgPT09IFwiaGVhZFwiIHx8XG4gICAgICBsb3dlckNhc2VOYW1lID09PSBcImh0bWxcIlxuICAgICkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb3B0aW1pemVkOiB0cnVlLFxuICAgICAgICB2YWx1ZTogbG93ZXJDYXNlTmFtZSwgLy8gbm9kZS5ub2RlTmFtZUluQ29ycmVjdENhc2UoKSxcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgY29uc3Qgbm9kZU5hbWUgPSBsb3dlckNhc2VOYW1lOyAvLyBub2RlLm5vZGVOYW1lSW5Db3JyZWN0Q2FzZSgpO1xuICBpZiAoaWQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgb3B0aW1pemVkOiB0cnVlLFxuICAgICAgdmFsdWU6IG5vZGVOYW1lICsgaWRTZWxlY3RvcihpZCksXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0IHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZTtcblxuICBpZiAoIXBhcmVudCB8fCBwYXJlbnQubm9kZVR5cGUgPT09IE5vZGUuRE9DVU1FTlRfTk9ERSkge1xuICAgIHJldHVybiB7XG4gICAgICBvcHRpbWl6ZWQ6IHRydWUsXG4gICAgICB2YWx1ZTogbm9kZU5hbWUsXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0IHByZWZpeGVkT3duQ2xhc3NOYW1lc0FycmF5XyA9IHByZWZpeGVkRWxlbWVudENsYXNzTmFtZXMoZWxlbWVudCk7XG5cbiAgY29uc3QgcHJlZml4ZWRPd25DbGFzc05hbWVzQXJyYXkgPSBbXTsgLy8gLmtleVNldCgpXG4gIHByZWZpeGVkT3duQ2xhc3NOYW1lc0FycmF5Xy5mb3JFYWNoKChhcnJJdGVtKSA9PiB7XG4gICAgaWYgKHByZWZpeGVkT3duQ2xhc3NOYW1lc0FycmF5LmluZGV4T2YoYXJySXRlbSkgPCAwKSB7XG4gICAgICBwcmVmaXhlZE93bkNsYXNzTmFtZXNBcnJheS5wdXNoKGFyckl0ZW0pO1xuICAgIH1cbiAgfSk7XG5cbiAgbGV0IG5lZWRzQ2xhc3NOYW1lcyA9IGZhbHNlO1xuICBsZXQgbmVlZHNOdGhDaGlsZCA9IGZhbHNlO1xuICBsZXQgb3duSW5kZXggPSAtMTtcbiAgbGV0IGVsZW1lbnRJbmRleCA9IC0xO1xuICBjb25zdCBzaWJsaW5ncyA9IHBhcmVudC5jaGlsZHJlbjtcblxuICBmb3IgKFxuICAgIGxldCBpID0gMDtcbiAgICAob3duSW5kZXggPT09IC0xIHx8ICFuZWVkc050aENoaWxkKSAmJiBpIDwgc2libGluZ3MubGVuZ3RoO1xuICAgICsraVxuICApIHtcbiAgICBjb25zdCBzaWJsaW5nID0gc2libGluZ3NbaV07XG4gICAgaWYgKHNpYmxpbmcubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgZWxlbWVudEluZGV4ICs9IDE7XG4gICAgaWYgKHNpYmxpbmcgPT09IG5vZGUpIHtcbiAgICAgIG93bkluZGV4ID0gZWxlbWVudEluZGV4O1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChuZWVkc050aENoaWxkKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBzaWJsaW5nLm5vZGVOYW1lSW5Db3JyZWN0Q2FzZSgpXG4gICAgY29uc3Qgc2libGluZ05hbWUgPVxuICAgICAgKHNpYmxpbmcubG9jYWxOYW1lICYmIHNpYmxpbmcubG9jYWxOYW1lLnRvTG93ZXJDYXNlKCkpIHx8XG4gICAgICBzaWJsaW5nLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKHNpYmxpbmdOYW1lICE9PSBub2RlTmFtZSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIG5lZWRzQ2xhc3NOYW1lcyA9IHRydWU7XG5cbiAgICBjb25zdCBvd25DbGFzc05hbWVzID0gW107XG4gICAgcHJlZml4ZWRPd25DbGFzc05hbWVzQXJyYXkuZm9yRWFjaCgoYXJySXRlbSkgPT4ge1xuICAgICAgb3duQ2xhc3NOYW1lcy5wdXNoKGFyckl0ZW0pO1xuICAgIH0pO1xuICAgIGxldCBvd25DbGFzc05hbWVDb3VudCA9IG93bkNsYXNzTmFtZXMubGVuZ3RoO1xuXG4gICAgaWYgKG93bkNsYXNzTmFtZUNvdW50ID09PSAwKSB7XG4gICAgICBuZWVkc050aENoaWxkID0gdHJ1ZTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBzaWJsaW5nQ2xhc3NOYW1lc0FycmF5XyA9IHByZWZpeGVkRWxlbWVudENsYXNzTmFtZXMoc2libGluZyk7XG4gICAgY29uc3Qgc2libGluZ0NsYXNzTmFtZXNBcnJheSA9IFtdOyAvLyAua2V5U2V0KClcbiAgICBzaWJsaW5nQ2xhc3NOYW1lc0FycmF5Xy5mb3JFYWNoKChhcnJJdGVtKSA9PiB7XG4gICAgICBpZiAoc2libGluZ0NsYXNzTmFtZXNBcnJheS5pbmRleE9mKGFyckl0ZW0pIDwgMCkge1xuICAgICAgICBzaWJsaW5nQ2xhc3NOYW1lc0FycmF5LnB1c2goYXJySXRlbSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBmb3IgKGNvbnN0IHNpYmxpbmdDbGFzcyBvZiBzaWJsaW5nQ2xhc3NOYW1lc0FycmF5KSB7XG4gICAgICBjb25zdCBpbmQgPSBvd25DbGFzc05hbWVzLmluZGV4T2Yoc2libGluZ0NsYXNzKTtcbiAgICAgIGlmIChpbmQgPCAwKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBvd25DbGFzc05hbWVzLnNwbGljZShpbmQsIDEpOyAvLyBkZWxldGUgb3duQ2xhc3NOYW1lc1tzaWJsaW5nQ2xhc3NdO1xuXG4gICAgICBpZiAoIS0tb3duQ2xhc3NOYW1lQ291bnQpIHtcbiAgICAgICAgbmVlZHNOdGhDaGlsZCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGxldCByZXN1bHQgPSBub2RlTmFtZTtcbiAgaWYgKFxuICAgIGlzVGFyZ2V0Tm9kZSAmJlxuICAgIG5vZGVOYW1lID09PSBcImlucHV0XCIgJiZcbiAgICBlbGVtZW50LmdldEF0dHJpYnV0ZShcInR5cGVcIikgJiZcbiAgICAhZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJpZFwiKSAmJlxuICAgICFlbGVtZW50LmdldEF0dHJpYnV0ZShcImNsYXNzXCIpXG4gICkge1xuICAgIHJlc3VsdCArPSAnW3R5cGU9XCInICsgZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpICsgJ1wiXSc7XG4gIH1cbiAgaWYgKG5lZWRzTnRoQ2hpbGQpIHtcbiAgICByZXN1bHQgKz0gXCI6bnRoLWNoaWxkKFwiICsgKG93bkluZGV4ICsgMSkgKyBcIilcIjtcbiAgfSBlbHNlIGlmIChuZWVkc0NsYXNzTmFtZXMpIHtcbiAgICBmb3IgKGNvbnN0IHByZWZpeGVkTmFtZSBvZiBwcmVmaXhlZE93bkNsYXNzTmFtZXNBcnJheSkge1xuICAgICAgcmVzdWx0ICs9IFwiLlwiICsgZXNjYXBlSWRlbnRpZmllcklmTmVlZGVkKHByZWZpeGVkTmFtZS5zdWJzdHIoMSkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgb3B0aW1pemVkOiBmYWxzZSxcbiAgICB2YWx1ZTogcmVzdWx0LFxuICB9O1xufVxuXG5mdW5jdGlvbiBsb2coKSB7XG4gIGlmIChkZWJ1Zykge1xuICAgIGxvZ05hdGl2ZS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICB9XG59XG4iLCIvL1xuLy8gIENvcHlyaWdodCAyMDIxIFJlYWRpdW0gRm91bmRhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSB0aGUgQlNELXN0eWxlIGxpY2Vuc2Vcbi8vICBhdmFpbGFibGUgaW4gdGhlIHRvcC1sZXZlbCBMSUNFTlNFIGZpbGUgb2YgdGhlIHByb2plY3QuXG4vL1xuXG5pbXBvcnQgeyBsb2cgYXMgbG9nTmF0aXZlIH0gZnJvbSBcIi4vdXRpbHNcIjtcblxuY29uc3QgZGVidWcgPSBmYWxzZTtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldENsaWVudFJlY3RzTm9PdmVybGFwKFxuICByYW5nZSxcbiAgZG9Ob3RNZXJnZUhvcml6b250YWxseUFsaWduZWRSZWN0c1xuKSB7XG4gIGxldCBjbGllbnRSZWN0cyA9IHJhbmdlLmdldENsaWVudFJlY3RzKCk7XG5cbiAgY29uc3QgdG9sZXJhbmNlID0gMTtcbiAgY29uc3Qgb3JpZ2luYWxSZWN0cyA9IFtdO1xuICBmb3IgKGNvbnN0IHJhbmdlQ2xpZW50UmVjdCBvZiBjbGllbnRSZWN0cykge1xuICAgIG9yaWdpbmFsUmVjdHMucHVzaCh7XG4gICAgICBib3R0b206IHJhbmdlQ2xpZW50UmVjdC5ib3R0b20sXG4gICAgICBoZWlnaHQ6IHJhbmdlQ2xpZW50UmVjdC5oZWlnaHQsXG4gICAgICBsZWZ0OiByYW5nZUNsaWVudFJlY3QubGVmdCxcbiAgICAgIHJpZ2h0OiByYW5nZUNsaWVudFJlY3QucmlnaHQsXG4gICAgICB0b3A6IHJhbmdlQ2xpZW50UmVjdC50b3AsXG4gICAgICB3aWR0aDogcmFuZ2VDbGllbnRSZWN0LndpZHRoLFxuICAgIH0pO1xuICB9XG4gIGNvbnN0IG1lcmdlZFJlY3RzID0gbWVyZ2VUb3VjaGluZ1JlY3RzKFxuICAgIG9yaWdpbmFsUmVjdHMsXG4gICAgdG9sZXJhbmNlLFxuICAgIGRvTm90TWVyZ2VIb3Jpem9udGFsbHlBbGlnbmVkUmVjdHNcbiAgKTtcbiAgY29uc3Qgbm9Db250YWluZWRSZWN0cyA9IHJlbW92ZUNvbnRhaW5lZFJlY3RzKG1lcmdlZFJlY3RzLCB0b2xlcmFuY2UpO1xuICBjb25zdCBuZXdSZWN0cyA9IHJlcGxhY2VPdmVybGFwaW5nUmVjdHMobm9Db250YWluZWRSZWN0cyk7XG4gIGNvbnN0IG1pbkFyZWEgPSAyICogMjtcbiAgZm9yIChsZXQgaiA9IG5ld1JlY3RzLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgY29uc3QgcmVjdCA9IG5ld1JlY3RzW2pdO1xuICAgIGNvbnN0IGJpZ0Vub3VnaCA9IHJlY3Qud2lkdGggKiByZWN0LmhlaWdodCA+IG1pbkFyZWE7XG4gICAgaWYgKCFiaWdFbm91Z2gpIHtcbiAgICAgIGlmIChuZXdSZWN0cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGxvZyhcIkNMSUVOVCBSRUNUOiByZW1vdmUgc21hbGxcIik7XG4gICAgICAgIG5ld1JlY3RzLnNwbGljZShqLCAxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvZyhcIkNMSUVOVCBSRUNUOiByZW1vdmUgc21hbGwsIGJ1dCBrZWVwIG90aGVyd2lzZSBlbXB0eSFcIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBsb2coYENMSUVOVCBSRUNUOiByZWR1Y2VkICR7b3JpZ2luYWxSZWN0cy5sZW5ndGh9IC0tPiAke25ld1JlY3RzLmxlbmd0aH1gKTtcbiAgcmV0dXJuIG5ld1JlY3RzO1xufVxuXG5mdW5jdGlvbiBtZXJnZVRvdWNoaW5nUmVjdHMoXG4gIHJlY3RzLFxuICB0b2xlcmFuY2UsXG4gIGRvTm90TWVyZ2VIb3Jpem9udGFsbHlBbGlnbmVkUmVjdHNcbikge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHJlY3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgZm9yIChsZXQgaiA9IGkgKyAxOyBqIDwgcmVjdHMubGVuZ3RoOyBqKyspIHtcbiAgICAgIGNvbnN0IHJlY3QxID0gcmVjdHNbaV07XG4gICAgICBjb25zdCByZWN0MiA9IHJlY3RzW2pdO1xuICAgICAgaWYgKHJlY3QxID09PSByZWN0Mikge1xuICAgICAgICBsb2coXCJtZXJnZVRvdWNoaW5nUmVjdHMgcmVjdDEgPT09IHJlY3QyID8/IVwiKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCByZWN0c0xpbmVVcFZlcnRpY2FsbHkgPVxuICAgICAgICBhbG1vc3RFcXVhbChyZWN0MS50b3AsIHJlY3QyLnRvcCwgdG9sZXJhbmNlKSAmJlxuICAgICAgICBhbG1vc3RFcXVhbChyZWN0MS5ib3R0b20sIHJlY3QyLmJvdHRvbSwgdG9sZXJhbmNlKTtcbiAgICAgIGNvbnN0IHJlY3RzTGluZVVwSG9yaXpvbnRhbGx5ID1cbiAgICAgICAgYWxtb3N0RXF1YWwocmVjdDEubGVmdCwgcmVjdDIubGVmdCwgdG9sZXJhbmNlKSAmJlxuICAgICAgICBhbG1vc3RFcXVhbChyZWN0MS5yaWdodCwgcmVjdDIucmlnaHQsIHRvbGVyYW5jZSk7XG4gICAgICBjb25zdCBob3Jpem9udGFsQWxsb3dlZCA9ICFkb05vdE1lcmdlSG9yaXpvbnRhbGx5QWxpZ25lZFJlY3RzO1xuICAgICAgY29uc3QgYWxpZ25lZCA9XG4gICAgICAgIChyZWN0c0xpbmVVcEhvcml6b250YWxseSAmJiBob3Jpem9udGFsQWxsb3dlZCkgfHxcbiAgICAgICAgKHJlY3RzTGluZVVwVmVydGljYWxseSAmJiAhcmVjdHNMaW5lVXBIb3Jpem9udGFsbHkpO1xuICAgICAgY29uc3QgY2FuTWVyZ2UgPSBhbGlnbmVkICYmIHJlY3RzVG91Y2hPck92ZXJsYXAocmVjdDEsIHJlY3QyLCB0b2xlcmFuY2UpO1xuICAgICAgaWYgKGNhbk1lcmdlKSB7XG4gICAgICAgIGxvZyhcbiAgICAgICAgICBgQ0xJRU5UIFJFQ1Q6IG1lcmdpbmcgdHdvIGludG8gb25lLCBWRVJUSUNBTDogJHtyZWN0c0xpbmVVcFZlcnRpY2FsbHl9IEhPUklaT05UQUw6ICR7cmVjdHNMaW5lVXBIb3Jpem9udGFsbHl9ICgke2RvTm90TWVyZ2VIb3Jpem9udGFsbHlBbGlnbmVkUmVjdHN9KWBcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgbmV3UmVjdHMgPSByZWN0cy5maWx0ZXIoKHJlY3QpID0+IHtcbiAgICAgICAgICByZXR1cm4gcmVjdCAhPT0gcmVjdDEgJiYgcmVjdCAhPT0gcmVjdDI7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZXBsYWNlbWVudENsaWVudFJlY3QgPSBnZXRCb3VuZGluZ1JlY3QocmVjdDEsIHJlY3QyKTtcbiAgICAgICAgbmV3UmVjdHMucHVzaChyZXBsYWNlbWVudENsaWVudFJlY3QpO1xuICAgICAgICByZXR1cm4gbWVyZ2VUb3VjaGluZ1JlY3RzKFxuICAgICAgICAgIG5ld1JlY3RzLFxuICAgICAgICAgIHRvbGVyYW5jZSxcbiAgICAgICAgICBkb05vdE1lcmdlSG9yaXpvbnRhbGx5QWxpZ25lZFJlY3RzXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZWN0cztcbn1cblxuZnVuY3Rpb24gZ2V0Qm91bmRpbmdSZWN0KHJlY3QxLCByZWN0Mikge1xuICBjb25zdCBsZWZ0ID0gTWF0aC5taW4ocmVjdDEubGVmdCwgcmVjdDIubGVmdCk7XG4gIGNvbnN0IHJpZ2h0ID0gTWF0aC5tYXgocmVjdDEucmlnaHQsIHJlY3QyLnJpZ2h0KTtcbiAgY29uc3QgdG9wID0gTWF0aC5taW4ocmVjdDEudG9wLCByZWN0Mi50b3ApO1xuICBjb25zdCBib3R0b20gPSBNYXRoLm1heChyZWN0MS5ib3R0b20sIHJlY3QyLmJvdHRvbSk7XG4gIHJldHVybiB7XG4gICAgYm90dG9tLFxuICAgIGhlaWdodDogYm90dG9tIC0gdG9wLFxuICAgIGxlZnQsXG4gICAgcmlnaHQsXG4gICAgdG9wLFxuICAgIHdpZHRoOiByaWdodCAtIGxlZnQsXG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUNvbnRhaW5lZFJlY3RzKHJlY3RzLCB0b2xlcmFuY2UpIHtcbiAgY29uc3QgcmVjdHNUb0tlZXAgPSBuZXcgU2V0KHJlY3RzKTtcbiAgZm9yIChjb25zdCByZWN0IG9mIHJlY3RzKSB7XG4gICAgY29uc3QgYmlnRW5vdWdoID0gcmVjdC53aWR0aCA+IDEgJiYgcmVjdC5oZWlnaHQgPiAxO1xuICAgIGlmICghYmlnRW5vdWdoKSB7XG4gICAgICBsb2coXCJDTElFTlQgUkVDVDogcmVtb3ZlIHRpbnlcIik7XG4gICAgICByZWN0c1RvS2VlcC5kZWxldGUocmVjdCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBwb3NzaWJseUNvbnRhaW5pbmdSZWN0IG9mIHJlY3RzKSB7XG4gICAgICBpZiAocmVjdCA9PT0gcG9zc2libHlDb250YWluaW5nUmVjdCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICghcmVjdHNUb0tlZXAuaGFzKHBvc3NpYmx5Q29udGFpbmluZ1JlY3QpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHJlY3RDb250YWlucyhwb3NzaWJseUNvbnRhaW5pbmdSZWN0LCByZWN0LCB0b2xlcmFuY2UpKSB7XG4gICAgICAgIGxvZyhcIkNMSUVOVCBSRUNUOiByZW1vdmUgY29udGFpbmVkXCIpO1xuICAgICAgICByZWN0c1RvS2VlcC5kZWxldGUocmVjdCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gQXJyYXkuZnJvbShyZWN0c1RvS2VlcCk7XG59XG5cbmZ1bmN0aW9uIHJlY3RDb250YWlucyhyZWN0MSwgcmVjdDIsIHRvbGVyYW5jZSkge1xuICByZXR1cm4gKFxuICAgIHJlY3RDb250YWluc1BvaW50KHJlY3QxLCByZWN0Mi5sZWZ0LCByZWN0Mi50b3AsIHRvbGVyYW5jZSkgJiZcbiAgICByZWN0Q29udGFpbnNQb2ludChyZWN0MSwgcmVjdDIucmlnaHQsIHJlY3QyLnRvcCwgdG9sZXJhbmNlKSAmJlxuICAgIHJlY3RDb250YWluc1BvaW50KHJlY3QxLCByZWN0Mi5sZWZ0LCByZWN0Mi5ib3R0b20sIHRvbGVyYW5jZSkgJiZcbiAgICByZWN0Q29udGFpbnNQb2ludChyZWN0MSwgcmVjdDIucmlnaHQsIHJlY3QyLmJvdHRvbSwgdG9sZXJhbmNlKVxuICApO1xufVxuXG5mdW5jdGlvbiByZWN0Q29udGFpbnNQb2ludChyZWN0LCB4LCB5LCB0b2xlcmFuY2UpIHtcbiAgcmV0dXJuIChcbiAgICAocmVjdC5sZWZ0IDwgeCB8fCBhbG1vc3RFcXVhbChyZWN0LmxlZnQsIHgsIHRvbGVyYW5jZSkpICYmXG4gICAgKHJlY3QucmlnaHQgPiB4IHx8IGFsbW9zdEVxdWFsKHJlY3QucmlnaHQsIHgsIHRvbGVyYW5jZSkpICYmXG4gICAgKHJlY3QudG9wIDwgeSB8fCBhbG1vc3RFcXVhbChyZWN0LnRvcCwgeSwgdG9sZXJhbmNlKSkgJiZcbiAgICAocmVjdC5ib3R0b20gPiB5IHx8IGFsbW9zdEVxdWFsKHJlY3QuYm90dG9tLCB5LCB0b2xlcmFuY2UpKVxuICApO1xufVxuXG5mdW5jdGlvbiByZXBsYWNlT3ZlcmxhcGluZ1JlY3RzKHJlY3RzKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcmVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCByZWN0cy5sZW5ndGg7IGorKykge1xuICAgICAgY29uc3QgcmVjdDEgPSByZWN0c1tpXTtcbiAgICAgIGNvbnN0IHJlY3QyID0gcmVjdHNbal07XG4gICAgICBpZiAocmVjdDEgPT09IHJlY3QyKSB7XG4gICAgICAgIGxvZyhcInJlcGxhY2VPdmVybGFwaW5nUmVjdHMgcmVjdDEgPT09IHJlY3QyID8/IVwiKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAocmVjdHNUb3VjaE9yT3ZlcmxhcChyZWN0MSwgcmVjdDIsIC0xKSkge1xuICAgICAgICBsZXQgdG9BZGQgPSBbXTtcbiAgICAgICAgbGV0IHRvUmVtb3ZlO1xuICAgICAgICBjb25zdCBzdWJ0cmFjdFJlY3RzMSA9IHJlY3RTdWJ0cmFjdChyZWN0MSwgcmVjdDIpO1xuICAgICAgICBpZiAoc3VidHJhY3RSZWN0czEubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgdG9BZGQgPSBzdWJ0cmFjdFJlY3RzMTtcbiAgICAgICAgICB0b1JlbW92ZSA9IHJlY3QxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHN1YnRyYWN0UmVjdHMyID0gcmVjdFN1YnRyYWN0KHJlY3QyLCByZWN0MSk7XG4gICAgICAgICAgaWYgKHN1YnRyYWN0UmVjdHMxLmxlbmd0aCA8IHN1YnRyYWN0UmVjdHMyLmxlbmd0aCkge1xuICAgICAgICAgICAgdG9BZGQgPSBzdWJ0cmFjdFJlY3RzMTtcbiAgICAgICAgICAgIHRvUmVtb3ZlID0gcmVjdDE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRvQWRkID0gc3VidHJhY3RSZWN0czI7XG4gICAgICAgICAgICB0b1JlbW92ZSA9IHJlY3QyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsb2coYENMSUVOVCBSRUNUOiBvdmVybGFwLCBjdXQgb25lIHJlY3QgaW50byAke3RvQWRkLmxlbmd0aH1gKTtcbiAgICAgICAgY29uc3QgbmV3UmVjdHMgPSByZWN0cy5maWx0ZXIoKHJlY3QpID0+IHtcbiAgICAgICAgICByZXR1cm4gcmVjdCAhPT0gdG9SZW1vdmU7XG4gICAgICAgIH0pO1xuICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShuZXdSZWN0cywgdG9BZGQpO1xuICAgICAgICByZXR1cm4gcmVwbGFjZU92ZXJsYXBpbmdSZWN0cyhuZXdSZWN0cyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZWN0cztcbn1cblxuZnVuY3Rpb24gcmVjdFN1YnRyYWN0KHJlY3QxLCByZWN0Mikge1xuICBjb25zdCByZWN0SW50ZXJzZWN0ZWQgPSByZWN0SW50ZXJzZWN0KHJlY3QyLCByZWN0MSk7XG4gIGlmIChyZWN0SW50ZXJzZWN0ZWQuaGVpZ2h0ID09PSAwIHx8IHJlY3RJbnRlcnNlY3RlZC53aWR0aCA9PT0gMCkge1xuICAgIHJldHVybiBbcmVjdDFdO1xuICB9XG4gIGNvbnN0IHJlY3RzID0gW107XG4gIHtcbiAgICBjb25zdCByZWN0QSA9IHtcbiAgICAgIGJvdHRvbTogcmVjdDEuYm90dG9tLFxuICAgICAgaGVpZ2h0OiAwLFxuICAgICAgbGVmdDogcmVjdDEubGVmdCxcbiAgICAgIHJpZ2h0OiByZWN0SW50ZXJzZWN0ZWQubGVmdCxcbiAgICAgIHRvcDogcmVjdDEudG9wLFxuICAgICAgd2lkdGg6IDAsXG4gICAgfTtcbiAgICByZWN0QS53aWR0aCA9IHJlY3RBLnJpZ2h0IC0gcmVjdEEubGVmdDtcbiAgICByZWN0QS5oZWlnaHQgPSByZWN0QS5ib3R0b20gLSByZWN0QS50b3A7XG4gICAgaWYgKHJlY3RBLmhlaWdodCAhPT0gMCAmJiByZWN0QS53aWR0aCAhPT0gMCkge1xuICAgICAgcmVjdHMucHVzaChyZWN0QSk7XG4gICAgfVxuICB9XG4gIHtcbiAgICBjb25zdCByZWN0QiA9IHtcbiAgICAgIGJvdHRvbTogcmVjdEludGVyc2VjdGVkLnRvcCxcbiAgICAgIGhlaWdodDogMCxcbiAgICAgIGxlZnQ6IHJlY3RJbnRlcnNlY3RlZC5sZWZ0LFxuICAgICAgcmlnaHQ6IHJlY3RJbnRlcnNlY3RlZC5yaWdodCxcbiAgICAgIHRvcDogcmVjdDEudG9wLFxuICAgICAgd2lkdGg6IDAsXG4gICAgfTtcbiAgICByZWN0Qi53aWR0aCA9IHJlY3RCLnJpZ2h0IC0gcmVjdEIubGVmdDtcbiAgICByZWN0Qi5oZWlnaHQgPSByZWN0Qi5ib3R0b20gLSByZWN0Qi50b3A7XG4gICAgaWYgKHJlY3RCLmhlaWdodCAhPT0gMCAmJiByZWN0Qi53aWR0aCAhPT0gMCkge1xuICAgICAgcmVjdHMucHVzaChyZWN0Qik7XG4gICAgfVxuICB9XG4gIHtcbiAgICBjb25zdCByZWN0QyA9IHtcbiAgICAgIGJvdHRvbTogcmVjdDEuYm90dG9tLFxuICAgICAgaGVpZ2h0OiAwLFxuICAgICAgbGVmdDogcmVjdEludGVyc2VjdGVkLmxlZnQsXG4gICAgICByaWdodDogcmVjdEludGVyc2VjdGVkLnJpZ2h0LFxuICAgICAgdG9wOiByZWN0SW50ZXJzZWN0ZWQuYm90dG9tLFxuICAgICAgd2lkdGg6IDAsXG4gICAgfTtcbiAgICByZWN0Qy53aWR0aCA9IHJlY3RDLnJpZ2h0IC0gcmVjdEMubGVmdDtcbiAgICByZWN0Qy5oZWlnaHQgPSByZWN0Qy5ib3R0b20gLSByZWN0Qy50b3A7XG4gICAgaWYgKHJlY3RDLmhlaWdodCAhPT0gMCAmJiByZWN0Qy53aWR0aCAhPT0gMCkge1xuICAgICAgcmVjdHMucHVzaChyZWN0Qyk7XG4gICAgfVxuICB9XG4gIHtcbiAgICBjb25zdCByZWN0RCA9IHtcbiAgICAgIGJvdHRvbTogcmVjdDEuYm90dG9tLFxuICAgICAgaGVpZ2h0OiAwLFxuICAgICAgbGVmdDogcmVjdEludGVyc2VjdGVkLnJpZ2h0LFxuICAgICAgcmlnaHQ6IHJlY3QxLnJpZ2h0LFxuICAgICAgdG9wOiByZWN0MS50b3AsXG4gICAgICB3aWR0aDogMCxcbiAgICB9O1xuICAgIHJlY3RELndpZHRoID0gcmVjdEQucmlnaHQgLSByZWN0RC5sZWZ0O1xuICAgIHJlY3RELmhlaWdodCA9IHJlY3RELmJvdHRvbSAtIHJlY3RELnRvcDtcbiAgICBpZiAocmVjdEQuaGVpZ2h0ICE9PSAwICYmIHJlY3RELndpZHRoICE9PSAwKSB7XG4gICAgICByZWN0cy5wdXNoKHJlY3REKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlY3RzO1xufVxuXG5mdW5jdGlvbiByZWN0SW50ZXJzZWN0KHJlY3QxLCByZWN0Mikge1xuICBjb25zdCBtYXhMZWZ0ID0gTWF0aC5tYXgocmVjdDEubGVmdCwgcmVjdDIubGVmdCk7XG4gIGNvbnN0IG1pblJpZ2h0ID0gTWF0aC5taW4ocmVjdDEucmlnaHQsIHJlY3QyLnJpZ2h0KTtcbiAgY29uc3QgbWF4VG9wID0gTWF0aC5tYXgocmVjdDEudG9wLCByZWN0Mi50b3ApO1xuICBjb25zdCBtaW5Cb3R0b20gPSBNYXRoLm1pbihyZWN0MS5ib3R0b20sIHJlY3QyLmJvdHRvbSk7XG4gIHJldHVybiB7XG4gICAgYm90dG9tOiBtaW5Cb3R0b20sXG4gICAgaGVpZ2h0OiBNYXRoLm1heCgwLCBtaW5Cb3R0b20gLSBtYXhUb3ApLFxuICAgIGxlZnQ6IG1heExlZnQsXG4gICAgcmlnaHQ6IG1pblJpZ2h0LFxuICAgIHRvcDogbWF4VG9wLFxuICAgIHdpZHRoOiBNYXRoLm1heCgwLCBtaW5SaWdodCAtIG1heExlZnQpLFxuICB9O1xufVxuXG5mdW5jdGlvbiByZWN0c1RvdWNoT3JPdmVybGFwKHJlY3QxLCByZWN0MiwgdG9sZXJhbmNlKSB7XG4gIHJldHVybiAoXG4gICAgKHJlY3QxLmxlZnQgPCByZWN0Mi5yaWdodCB8fFxuICAgICAgKHRvbGVyYW5jZSA+PSAwICYmIGFsbW9zdEVxdWFsKHJlY3QxLmxlZnQsIHJlY3QyLnJpZ2h0LCB0b2xlcmFuY2UpKSkgJiZcbiAgICAocmVjdDIubGVmdCA8IHJlY3QxLnJpZ2h0IHx8XG4gICAgICAodG9sZXJhbmNlID49IDAgJiYgYWxtb3N0RXF1YWwocmVjdDIubGVmdCwgcmVjdDEucmlnaHQsIHRvbGVyYW5jZSkpKSAmJlxuICAgIChyZWN0MS50b3AgPCByZWN0Mi5ib3R0b20gfHxcbiAgICAgICh0b2xlcmFuY2UgPj0gMCAmJiBhbG1vc3RFcXVhbChyZWN0MS50b3AsIHJlY3QyLmJvdHRvbSwgdG9sZXJhbmNlKSkpICYmXG4gICAgKHJlY3QyLnRvcCA8IHJlY3QxLmJvdHRvbSB8fFxuICAgICAgKHRvbGVyYW5jZSA+PSAwICYmIGFsbW9zdEVxdWFsKHJlY3QyLnRvcCwgcmVjdDEuYm90dG9tLCB0b2xlcmFuY2UpKSlcbiAgKTtcbn1cblxuZnVuY3Rpb24gYWxtb3N0RXF1YWwoYSwgYiwgdG9sZXJhbmNlKSB7XG4gIHJldHVybiBNYXRoLmFicyhhIC0gYikgPD0gdG9sZXJhbmNlO1xufVxuXG5mdW5jdGlvbiBsb2coKSB7XG4gIGlmIChkZWJ1Zykge1xuICAgIGxvZ05hdGl2ZS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICB9XG59XG4iLCIvL1xuLy8gIENvcHlyaWdodCAyMDIxIFJlYWRpdW0gRm91bmRhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSB0aGUgQlNELXN0eWxlIGxpY2Vuc2Vcbi8vICBhdmFpbGFibGUgaW4gdGhlIHRvcC1sZXZlbCBMSUNFTlNFIGZpbGUgb2YgdGhlIHByb2plY3QuXG4vL1xuXG5pbXBvcnQgeyBjb252ZXJ0UmFuZ2VJbmZvLCBsb2NhdGlvbjJSYW5nZUluZm8gfSBmcm9tIFwiLi9zZWxlY3Rpb25cIjtcbmltcG9ydCB7IGdldENsaWVudFJlY3RzTm9PdmVybGFwIH0gZnJvbSBcIi4vcmVjdFwiO1xuaW1wb3J0IHsgaXNTY3JvbGxNb2RlRW5hYmxlZCwgbG9nLCBsb2dFcnJvciB9IGZyb20gXCIuL3V0aWxzXCI7XG5pbXBvcnQgeyBUZXh0UXVvdGVBbmNob3IgfSBmcm9tIFwiLi92ZW5kb3IvaHlwb3RoZXNpcy9hbmNob3JpbmcvdHlwZXNcIjtcblxuY29uc3QgZGVidWcgPSBmYWxzZTtcblxuY29uc3QgSURfSElHSExJR0hUU19DT05UQUlORVIgPSBcIlIyX0lEX0hJR0hMSUdIVFNfQ09OVEFJTkVSXCI7XG5jb25zdCBDTEFTU19ISUdITElHSFRfQ09OVEFJTkVSID0gXCJSMl9DTEFTU19ISUdITElHSFRfQ09OVEFJTkVSXCI7XG5jb25zdCBDTEFTU19ISUdITElHSFRfQVJFQSA9IFwiUjJfQ0xBU1NfSElHSExJR0hUX0FSRUFcIjtcbmNvbnN0IENMQVNTX0hJR0hMSUdIVF9CT1VORElOR19BUkVBID0gXCJSMl9DTEFTU19ISUdITElHSFRfQk9VTkRJTkdfQVJFQVwiO1xuXG5jb25zdCBfaGlnaGxpZ2h0cyA9IFtdO1xubGV0IF9oaWdobGlnaHRzQ29udGFpbmVyO1xuXG5jb25zdCBkZWZhdWx0QmFja2dyb3VuZE9wYWNpdHkgPSAwLjM7XG5cbmNvbnN0IGRlZmF1bHRCYWNrZ3JvdW5kQ29sb3IgPSB7XG4gIGJsdWU6IDEwMCxcbiAgZ3JlZW46IDUwLFxuICByZWQ6IDIzMCxcbn07XG5cbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKFxuICBcImxvYWRcIixcbiAgZnVuY3Rpb24gKCkge1xuICAgIC8vIG9uIHBhZ2UgbG9hZFxuICAgIGNvbnN0IGJvZHkgPSBkb2N1bWVudC5ib2R5O1xuICAgIHZhciBsYXN0U2l6ZSA9IHsgd2lkdGg6IDAsIGhlaWdodDogMCB9O1xuICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKCgpID0+IHtcbiAgICAgIGxvZyhib2R5LmNsaWVudFdpZHRoLCBib2R5LmNsaWVudEhlaWdodCk7XG4gICAgICBpZiAoXG4gICAgICAgIGxhc3RTaXplLndpZHRoID09PSBib2R5LmNsaWVudFdpZHRoICYmXG4gICAgICAgIGxhc3RTaXplLmhlaWdodCA9PT0gYm9keS5jbGllbnRIZWlnaHRcbiAgICAgICkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsYXN0U2l6ZSA9IHtcbiAgICAgICAgd2lkdGg6IGJvZHkuY2xpZW50V2lkdGgsXG4gICAgICAgIGhlaWdodDogYm9keS5jbGllbnRIZWlnaHQsXG4gICAgICB9O1xuICAgICAgcmVzZXRIaWdobGlnaHRzKCk7XG4gICAgfSk7XG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZShib2R5KTtcbiAgfSxcbiAgZmFsc2Vcbik7XG5cbmV4cG9ydCBmdW5jdGlvbiByZWN0Rm9ySGlnaGxpZ2h0V2l0aElEKGlkKSB7XG4gIGNvbnN0IGNsaWVudFJlY3RzID0gZnJhbWVGb3JIaWdobGlnaHRXaXRoSUQoaWQpO1xuXG4gIHJldHVybiB7XG4gICAgc2NyZWVuV2lkdGg6IHdpbmRvdy5vdXRlcldpZHRoLFxuICAgIHNjcmVlbkhlaWdodDogd2luZG93Lm91dGVySGVpZ2h0LFxuICAgIGxlZnQ6IGNsaWVudFJlY3RzWzBdLmxlZnQsXG4gICAgd2lkdGg6IGNsaWVudFJlY3RzWzBdLndpZHRoLFxuICAgIHRvcDogY2xpZW50UmVjdHNbMF0udG9wLFxuICAgIGhlaWdodDogY2xpZW50UmVjdHNbMF0uaGVpZ2h0LFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2xlYXJIaWdobGlnaHRzKCkge1xuICBoaWRlQWxsSGlnaGxpZ2h0cygpO1xuICBfaGlnaGxpZ2h0cy5zcGxpY2UoMCwgX2hpZ2hsaWdodHMubGVuZ3RoKTtcbn1cblxuZnVuY3Rpb24gaGlkZUFsbEhpZ2hsaWdodHMoKSB7XG4gIGlmIChfaGlnaGxpZ2h0c0NvbnRhaW5lcikge1xuICAgIF9oaWdobGlnaHRzQ29udGFpbmVyLnJlbW92ZSgpO1xuICAgIF9oaWdobGlnaHRzQ29udGFpbmVyID0gbnVsbDtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNldEhpZ2hsaWdodHMoKSB7XG4gIGhpZGVBbGxIaWdobGlnaHRzKCk7XG5cbiAgbGV0IGkgPSBfaGlnaGxpZ2h0cy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBsZXQgaGlnaGxpZ2h0ID0gX2hpZ2hsaWdodHNbaV07XG4gICAgaWYgKGhpZ2hsaWdodC50cmFuc2llbnQpIHtcbiAgICAgIF9oaWdobGlnaHRzLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3JlYXRlSGlnaGxpZ2h0RE9NKGhpZ2hsaWdodCk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoaWdobGlnaHQobG9jYXRvcikge1xuICBsZXQgdGV4dCA9IGxvY2F0b3IudGV4dDtcbiAgaWYgKCF0ZXh0IHx8ICF0ZXh0LmhpZ2hsaWdodCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRyeSB7XG4gICAgbGV0IGFuY2hvciA9IG5ldyBUZXh0UXVvdGVBbmNob3IoZG9jdW1lbnQuYm9keSwgdGV4dC5oaWdobGlnaHQsIHtcbiAgICAgIHByZWZpeDogdGV4dC5iZWZvcmUsXG4gICAgICBzdWZmaXg6IHRleHQuYWZ0ZXIsXG4gICAgfSk7XG4gICAgYW5jaG9yLnRvUmFuZ2UoKTtcbiAgICBoaWdobGlnaHRSYW5nZShhbmNob3IudG9SYW5nZSgpKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGxvZ0Vycm9yKGUpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoaWdobGlnaHRSYW5nZShyYW5nZSkge1xuICAvLyBGSVhNRTogVXNlIHVzZXItcHJvdmlkZWQgSUQuXG4gIGxldCBpZCA9IFwiUjJfSElHSExJR0hUX1wiICsgRGF0ZS5ub3coKTtcblxuICBkZXN0cm95SGlnaGxpZ2h0KGlkKTtcblxuICBjb25zdCBoaWdobGlnaHQgPSB7XG4gICAgY29sb3I6IGRlZmF1bHRCYWNrZ3JvdW5kQ29sb3IsXG4gICAgaWQsXG4gICAgcG9pbnRlckludGVyYWN0aW9uOiB0cnVlLFxuICAgIHJhbmdlOiByYW5nZSxcbiAgICB0cmFuc2llbnQ6IHRydWUsXG4gIH07XG4gIF9oaWdobGlnaHRzLnB1c2goaGlnaGxpZ2h0KTtcbiAgY3JlYXRlSGlnaGxpZ2h0RE9NKGhpZ2hsaWdodCk7XG5cbiAgcmV0dXJuIGhpZ2hsaWdodDtcbn1cblxuZnVuY3Rpb24gZGVzdHJveUhpZ2hsaWdodChpZCkge1xuICBsZXQgaSA9IC0xO1xuICBsZXQgX2RvY3VtZW50ID0gd2luZG93LmRvY3VtZW50O1xuICBjb25zdCBoaWdobGlnaHQgPSBfaGlnaGxpZ2h0cy5maW5kKChoLCBqKSA9PiB7XG4gICAgaSA9IGo7XG4gICAgcmV0dXJuIGguaWQgPT09IGlkO1xuICB9KTtcbiAgaWYgKGhpZ2hsaWdodCAmJiBpID49IDAgJiYgaSA8IF9oaWdobGlnaHRzLmxlbmd0aCkge1xuICAgIF9oaWdobGlnaHRzLnNwbGljZShpLCAxKTtcbiAgfVxuICBjb25zdCBoaWdobGlnaHRDb250YWluZXIgPSBfZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpO1xuICBpZiAoaGlnaGxpZ2h0Q29udGFpbmVyKSB7XG4gICAgaGlnaGxpZ2h0Q29udGFpbmVyLnJlbW92ZSgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUhpZ2hsaWdodERPTShoaWdobGlnaHQpIHtcbiAgaWYgKCFoaWdobGlnaHQucmFuZ2UpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgY29uc3Qgc2Nyb2xsRWxlbWVudCA9IGRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnQ7XG5cbiAgY29uc3QgcGFnaW5hdGVkID0gIWlzU2Nyb2xsTW9kZUVuYWJsZWQoKTtcbiAgY29uc3QgaGlnaGxpZ2h0c0NvbnRhaW5lciA9IGVuc3VyZUNvbnRhaW5lcih3aW5kb3cpO1xuICBjb25zdCBoaWdobGlnaHRQYXJlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXG4gIGhpZ2hsaWdodFBhcmVudC5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBoaWdobGlnaHQuaWQpO1xuICBoaWdobGlnaHRQYXJlbnQuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgQ0xBU1NfSElHSExJR0hUX0NPTlRBSU5FUik7XG5cbiAgaGlnaGxpZ2h0UGFyZW50LnN0eWxlLnNldFByb3BlcnR5KFwicG9pbnRlci1ldmVudHNcIiwgXCJub25lXCIpO1xuICBpZiAoaGlnaGxpZ2h0LnBvaW50ZXJJbnRlcmFjdGlvbikge1xuICAgIGhpZ2hsaWdodFBhcmVudC5zZXRBdHRyaWJ1dGUoXCJkYXRhLWNsaWNrXCIsIFwiMVwiKTtcbiAgfVxuXG4gIGNvbnN0IGJvZHlSZWN0ID0gZG9jdW1lbnQuYm9keS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgY29uc3QgZHJhd1VuZGVybGluZSA9IGZhbHNlO1xuICBjb25zdCBkcmF3U3RyaWtlVGhyb3VnaCA9IGZhbHNlO1xuICBjb25zdCBkb05vdE1lcmdlSG9yaXpvbnRhbGx5QWxpZ25lZFJlY3RzID0gZHJhd1VuZGVybGluZSB8fCBkcmF3U3RyaWtlVGhyb3VnaDtcbiAgY29uc3QgY2xpZW50UmVjdHMgPSBnZXRDbGllbnRSZWN0c05vT3ZlcmxhcChcbiAgICBoaWdobGlnaHQucmFuZ2UsXG4gICAgZG9Ob3RNZXJnZUhvcml6b250YWxseUFsaWduZWRSZWN0c1xuICApO1xuICBjb25zdCByb3VuZGVkQ29ybmVyID0gMztcbiAgY29uc3QgdW5kZXJsaW5lVGhpY2tuZXNzID0gMjtcbiAgY29uc3Qgc3RyaWtlVGhyb3VnaExpbmVUaGlja25lc3MgPSAzO1xuICBjb25zdCBvcGFjaXR5ID0gZGVmYXVsdEJhY2tncm91bmRPcGFjaXR5O1xuICBsZXQgZXh0cmEgPSBcIlwiO1xuXG4gIGxldCB4T2Zmc2V0ID0gcGFnaW5hdGVkID8gLXNjcm9sbEVsZW1lbnQuc2Nyb2xsTGVmdCA6IGJvZHlSZWN0LmxlZnQ7XG4gIGxldCB5T2Zmc2V0ID0gcGFnaW5hdGVkID8gLXNjcm9sbEVsZW1lbnQuc2Nyb2xsVG9wIDogYm9keVJlY3QudG9wO1xuXG4gIGZvciAoY29uc3QgY2xpZW50UmVjdCBvZiBjbGllbnRSZWN0cykge1xuICAgIGNvbnN0IGhpZ2hsaWdodEFyZWEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXG4gICAgaGlnaGxpZ2h0QXJlYS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBDTEFTU19ISUdITElHSFRfQVJFQSk7XG5cbiAgICBpZiAoZGVidWcpIHtcbiAgICAgIGNvbnN0IHJnYiA9IE1hdGgucm91bmQoMHhmZmZmZmYgKiBNYXRoLnJhbmRvbSgpKTtcbiAgICAgIGNvbnN0IHIgPSByZ2IgPj4gMTY7XG4gICAgICBjb25zdCBnID0gKHJnYiA+PiA4KSAmIDI1NTtcbiAgICAgIGNvbnN0IGIgPSByZ2IgJiAyNTU7XG4gICAgICBleHRyYSA9IGBvdXRsaW5lLWNvbG9yOiByZ2IoJHtyfSwgJHtnfSwgJHtifSk7IG91dGxpbmUtc3R5bGU6IHNvbGlkOyBvdXRsaW5lLXdpZHRoOiAxcHg7IG91dGxpbmUtb2Zmc2V0OiAtMXB4O2A7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChkcmF3VW5kZXJsaW5lKSB7XG4gICAgICAgIGV4dHJhICs9IGBib3JkZXItYm90dG9tOiAke3VuZGVybGluZVRoaWNrbmVzc31weCBzb2xpZCByZ2JhKCR7aGlnaGxpZ2h0LmNvbG9yLnJlZH0sICR7aGlnaGxpZ2h0LmNvbG9yLmdyZWVufSwgJHtoaWdobGlnaHQuY29sb3IuYmx1ZX0sICR7b3BhY2l0eX0pICFpbXBvcnRhbnRgO1xuICAgICAgfVxuICAgIH1cbiAgICBoaWdobGlnaHRBcmVhLnNldEF0dHJpYnV0ZShcbiAgICAgIFwic3R5bGVcIixcbiAgICAgIGBib3JkZXItcmFkaXVzOiAke3JvdW5kZWRDb3JuZXJ9cHggIWltcG9ydGFudDsgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgke2hpZ2hsaWdodC5jb2xvci5yZWR9LCAke2hpZ2hsaWdodC5jb2xvci5ncmVlbn0sICR7aGlnaGxpZ2h0LmNvbG9yLmJsdWV9LCAke29wYWNpdHl9KSAhaW1wb3J0YW50OyAke2V4dHJhfWBcbiAgICApO1xuICAgIGhpZ2hsaWdodEFyZWEuc3R5bGUuc2V0UHJvcGVydHkoXCJwb2ludGVyLWV2ZW50c1wiLCBcIm5vbmVcIik7XG4gICAgaGlnaGxpZ2h0QXJlYS5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICBoaWdobGlnaHRBcmVhLnNjYWxlID0gMTtcbiAgICAvKlxuICAgICAgICAgaGlnaGxpZ2h0QXJlYS5yZWN0ID0ge1xuICAgICAgICAgaGVpZ2h0OiBjbGllbnRSZWN0LmhlaWdodCxcbiAgICAgICAgIGxlZnQ6IGNsaWVudFJlY3QubGVmdCAtIHhPZmZzZXQsXG4gICAgICAgICB0b3A6IGNsaWVudFJlY3QudG9wIC0geU9mZnNldCxcbiAgICAgICAgIHdpZHRoOiBjbGllbnRSZWN0LndpZHRoLFxuICAgICAgICAgfTtcbiAgICAgICAgICovXG4gICAgaGlnaGxpZ2h0QXJlYS5yZWN0ID0ge1xuICAgICAgaGVpZ2h0OiBjbGllbnRSZWN0LmhlaWdodCxcbiAgICAgIGxlZnQ6IGNsaWVudFJlY3QubGVmdCAtIHhPZmZzZXQsXG4gICAgICB0b3A6IGNsaWVudFJlY3QudG9wIC0geU9mZnNldCxcbiAgICAgIHdpZHRoOiBjbGllbnRSZWN0LndpZHRoLFxuICAgIH07XG5cbiAgICBoaWdobGlnaHRBcmVhLnN0eWxlLndpZHRoID0gYCR7aGlnaGxpZ2h0QXJlYS5yZWN0LndpZHRofXB4YDtcbiAgICBoaWdobGlnaHRBcmVhLnN0eWxlLmhlaWdodCA9IGAke2hpZ2hsaWdodEFyZWEucmVjdC5oZWlnaHR9cHhgO1xuICAgIGhpZ2hsaWdodEFyZWEuc3R5bGUubGVmdCA9IGAke2hpZ2hsaWdodEFyZWEucmVjdC5sZWZ0fXB4YDtcbiAgICBoaWdobGlnaHRBcmVhLnN0eWxlLnRvcCA9IGAke2hpZ2hsaWdodEFyZWEucmVjdC50b3B9cHhgO1xuICAgIGhpZ2hsaWdodFBhcmVudC5hcHBlbmQoaGlnaGxpZ2h0QXJlYSk7XG4gICAgaWYgKCFkZWJ1ZyAmJiBkcmF3U3RyaWtlVGhyb3VnaCkge1xuICAgICAgLy9pZiAoZHJhd1N0cmlrZVRocm91Z2gpIHtcbiAgICAgIGNvbnN0IGhpZ2hsaWdodEFyZWFMaW5lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIGhpZ2hsaWdodEFyZWFMaW5lLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIENMQVNTX0hJR0hMSUdIVF9BUkVBKTtcblxuICAgICAgaGlnaGxpZ2h0QXJlYUxpbmUuc2V0QXR0cmlidXRlKFxuICAgICAgICBcInN0eWxlXCIsXG4gICAgICAgIGBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKCR7aGlnaGxpZ2h0LmNvbG9yLnJlZH0sICR7aGlnaGxpZ2h0LmNvbG9yLmdyZWVufSwgJHtoaWdobGlnaHQuY29sb3IuYmx1ZX0sICR7b3BhY2l0eX0pICFpbXBvcnRhbnQ7YFxuICAgICAgKTtcbiAgICAgIGhpZ2hsaWdodEFyZWFMaW5lLnN0eWxlLnNldFByb3BlcnR5KFwicG9pbnRlci1ldmVudHNcIiwgXCJub25lXCIpO1xuICAgICAgaGlnaGxpZ2h0QXJlYUxpbmUuc3R5bGUucG9zaXRpb24gPSBwYWdpbmF0ZWQgPyBcImZpeGVkXCIgOiBcImFic29sdXRlXCI7XG4gICAgICBoaWdobGlnaHRBcmVhTGluZS5zY2FsZSA9IDE7XG4gICAgICAvKlxuICAgICAgICAgICAgIGhpZ2hsaWdodEFyZWFMaW5lLnJlY3QgPSB7XG4gICAgICAgICAgICAgaGVpZ2h0OiBjbGllbnRSZWN0LmhlaWdodCxcbiAgICAgICAgICAgICBsZWZ0OiBjbGllbnRSZWN0LmxlZnQgLSB4T2Zmc2V0LFxuICAgICAgICAgICAgIHRvcDogY2xpZW50UmVjdC50b3AgLSB5T2Zmc2V0LFxuICAgICAgICAgICAgIHdpZHRoOiBjbGllbnRSZWN0LndpZHRoLFxuICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgKi9cblxuICAgICAgaGlnaGxpZ2h0QXJlYUxpbmUucmVjdCA9IHtcbiAgICAgICAgaGVpZ2h0OiBjbGllbnRSZWN0LmhlaWdodCxcbiAgICAgICAgbGVmdDogY2xpZW50UmVjdC5sZWZ0IC0geE9mZnNldCxcbiAgICAgICAgdG9wOiBjbGllbnRSZWN0LnRvcCAtIHlPZmZzZXQsXG4gICAgICAgIHdpZHRoOiBjbGllbnRSZWN0LndpZHRoLFxuICAgICAgfTtcblxuICAgICAgaGlnaGxpZ2h0QXJlYUxpbmUuc3R5bGUud2lkdGggPSBgJHtoaWdobGlnaHRBcmVhTGluZS5yZWN0LndpZHRofXB4YDtcbiAgICAgIGhpZ2hsaWdodEFyZWFMaW5lLnN0eWxlLmhlaWdodCA9IGAke3N0cmlrZVRocm91Z2hMaW5lVGhpY2tuZXNzfXB4YDtcbiAgICAgIGhpZ2hsaWdodEFyZWFMaW5lLnN0eWxlLmxlZnQgPSBgJHtoaWdobGlnaHRBcmVhTGluZS5yZWN0LmxlZnR9cHhgO1xuICAgICAgaGlnaGxpZ2h0QXJlYUxpbmUuc3R5bGUudG9wID0gYCR7XG4gICAgICAgIGhpZ2hsaWdodEFyZWFMaW5lLnJlY3QudG9wICtcbiAgICAgICAgaGlnaGxpZ2h0QXJlYUxpbmUucmVjdC5oZWlnaHQgLyAyIC1cbiAgICAgICAgc3RyaWtlVGhyb3VnaExpbmVUaGlja25lc3MgLyAyXG4gICAgICB9cHhgO1xuICAgICAgaGlnaGxpZ2h0UGFyZW50LmFwcGVuZChoaWdobGlnaHRBcmVhTGluZSk7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgaGlnaGxpZ2h0Qm91bmRpbmcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICBoaWdobGlnaHRCb3VuZGluZy5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBDTEFTU19ISUdITElHSFRfQk9VTkRJTkdfQVJFQSk7XG5cbiAgaGlnaGxpZ2h0Qm91bmRpbmcuc3R5bGUuc2V0UHJvcGVydHkoXCJwb2ludGVyLWV2ZW50c1wiLCBcIm5vbmVcIik7XG4gIGhpZ2hsaWdodEJvdW5kaW5nLnN0eWxlLnBvc2l0aW9uID0gcGFnaW5hdGVkID8gXCJmaXhlZFwiIDogXCJhYnNvbHV0ZVwiO1xuICBoaWdobGlnaHRCb3VuZGluZy5zY2FsZSA9IDE7XG5cbiAgaWYgKGRlYnVnKSB7XG4gICAgaGlnaGxpZ2h0Qm91bmRpbmcuc2V0QXR0cmlidXRlKFxuICAgICAgXCJzdHlsZVwiLFxuICAgICAgYG91dGxpbmUtY29sb3I6IG1hZ2VudGE7IG91dGxpbmUtc3R5bGU6IHNvbGlkOyBvdXRsaW5lLXdpZHRoOiAxcHg7IG91dGxpbmUtb2Zmc2V0OiAtMXB4O2BcbiAgICApO1xuICB9XG5cbiAgY29uc3QgcmFuZ2VCb3VuZGluZ0NsaWVudFJlY3QgPSBoaWdobGlnaHQucmFuZ2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIGhpZ2hsaWdodEJvdW5kaW5nLnJlY3QgPSB7XG4gICAgaGVpZ2h0OiByYW5nZUJvdW5kaW5nQ2xpZW50UmVjdC5oZWlnaHQsXG4gICAgbGVmdDogcmFuZ2VCb3VuZGluZ0NsaWVudFJlY3QubGVmdCAtIHhPZmZzZXQsXG4gICAgdG9wOiByYW5nZUJvdW5kaW5nQ2xpZW50UmVjdC50b3AgLSB5T2Zmc2V0LFxuICAgIHdpZHRoOiByYW5nZUJvdW5kaW5nQ2xpZW50UmVjdC53aWR0aCxcbiAgfTtcblxuICBoaWdobGlnaHRCb3VuZGluZy5zdHlsZS53aWR0aCA9IGAke2hpZ2hsaWdodEJvdW5kaW5nLnJlY3Qud2lkdGh9cHhgO1xuICBoaWdobGlnaHRCb3VuZGluZy5zdHlsZS5oZWlnaHQgPSBgJHtoaWdobGlnaHRCb3VuZGluZy5yZWN0LmhlaWdodH1weGA7XG4gIGhpZ2hsaWdodEJvdW5kaW5nLnN0eWxlLmxlZnQgPSBgJHtoaWdobGlnaHRCb3VuZGluZy5yZWN0LmxlZnR9cHhgO1xuICBoaWdobGlnaHRCb3VuZGluZy5zdHlsZS50b3AgPSBgJHtoaWdobGlnaHRCb3VuZGluZy5yZWN0LnRvcH1weGA7XG5cbiAgaGlnaGxpZ2h0UGFyZW50LmFwcGVuZChoaWdobGlnaHRCb3VuZGluZyk7XG4gIGhpZ2hsaWdodHNDb250YWluZXIuYXBwZW5kKGhpZ2hsaWdodFBhcmVudCk7XG5cbiAgcmV0dXJuIGhpZ2hsaWdodFBhcmVudDtcbn1cblxuZnVuY3Rpb24gZW5zdXJlQ29udGFpbmVyKHdpbikge1xuICBjb25zdCBkb2N1bWVudCA9IHdpbi5kb2N1bWVudDtcblxuICBpZiAoIV9oaWdobGlnaHRzQ29udGFpbmVyKSB7XG4gICAgX2hpZ2hsaWdodHNDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIF9oaWdobGlnaHRzQ29udGFpbmVyLnNldEF0dHJpYnV0ZShcImlkXCIsIElEX0hJR0hMSUdIVFNfQ09OVEFJTkVSKTtcblxuICAgIF9oaWdobGlnaHRzQ29udGFpbmVyLnN0eWxlLnNldFByb3BlcnR5KFwicG9pbnRlci1ldmVudHNcIiwgXCJub25lXCIpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kKF9oaWdobGlnaHRzQ29udGFpbmVyKTtcbiAgfVxuXG4gIHJldHVybiBfaGlnaGxpZ2h0c0NvbnRhaW5lcjtcbn1cblxuZnVuY3Rpb24gZnJhbWVGb3JIaWdobGlnaHRXaXRoSUQoaWQpIHtcbiAgY29uc3QgaGlnaGxpZ2h0ID0gaGlnaGxpZ2h0V2l0aElEKGlkKTtcbiAgaWYgKCFoaWdobGlnaHQpIHJldHVybjtcblxuICBpZiAoIWhpZ2hsaWdodC5yYW5nZSkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBjb25zdCBkcmF3VW5kZXJsaW5lID0gZmFsc2U7XG4gIGNvbnN0IGRyYXdTdHJpa2VUaHJvdWdoID0gZmFsc2U7XG4gIGNvbnN0IGRvTm90TWVyZ2VIb3Jpem9udGFsbHlBbGlnbmVkUmVjdHMgPSBkcmF3VW5kZXJsaW5lIHx8IGRyYXdTdHJpa2VUaHJvdWdoO1xuICByZXR1cm4gZ2V0Q2xpZW50UmVjdHNOb092ZXJsYXAoXG4gICAgaGlnaGxpZ2h0LnJhbmdlLFxuICAgIGRvTm90TWVyZ2VIb3Jpem9udGFsbHlBbGlnbmVkUmVjdHNcbiAgKTtcbn1cblxuZnVuY3Rpb24gaGlnaGxpZ2h0V2l0aElEKGlkKSB7XG4gIHJldHVybiBfaGlnaGxpZ2h0cy5maW5kKChoKSA9PiB7XG4gICAgcmV0dXJuIGguaWQgPT09IGlkO1xuICB9KTtcbn1cbiIsIi8vXG4vLyAgQ29weXJpZ2h0IDIwMjEgUmVhZGl1bSBGb3VuZGF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IHRoZSBCU0Qtc3R5bGUgbGljZW5zZVxuLy8gIGF2YWlsYWJsZSBpbiB0aGUgdG9wLWxldmVsIExJQ0VOU0UgZmlsZSBvZiB0aGUgcHJvamVjdC5cbi8vXG5cbmltcG9ydCB7IGdldENsaWVudFJlY3RzTm9PdmVybGFwIH0gZnJvbSBcIi4vcmVjdFwiO1xuaW1wb3J0IHtcbiAgaXNTY3JvbGxNb2RlRW5hYmxlZCxcbiAgbG9nLFxuICBsb2dFcnJvck1lc3NhZ2UsXG4gIHJhbmdlRnJvbUxvY2F0b3IsXG59IGZyb20gXCIuL3V0aWxzXCI7XG5cbmxldCBzdHlsZXMgPSBuZXcgTWFwKCk7XG5sZXQgZ3JvdXBzID0gbmV3IE1hcCgpO1xudmFyIGxhc3RHcm91cElkID0gMDtcblxuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyU3R5bGVzKG5ld1N0eWxlcykge1xuICB2YXIgc3R5bGVzaGVldCA9IFwiXCI7XG5cbiAgZm9yIChjb25zdCBbaWQsIHN0eWxlXSBvZiBPYmplY3QuZW50cmllcyhuZXdTdHlsZXMpKSB7XG4gICAgdHJ5IHtcbiAgICAgIGxldCB0ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZW1wbGF0ZVwiKTtcbiAgICAgIHRlbXBsYXRlLmlubmVySFRNTCA9IHN0eWxlLmVsZW1lbnQudHJpbSgpO1xuICAgICAgc3R5bGUuZWxlbWVudCA9IHRlbXBsYXRlO1xuICAgICAgc3R5bGVzLnNldChpZCwgc3R5bGUpO1xuXG4gICAgICBpZiAoc3R5bGUuc3R5bGVzaGVldCkge1xuICAgICAgICBzdHlsZXNoZWV0ICs9IHN0eWxlLnN0eWxlc2hlZXQgKyBcIlxcblwiO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dFcnJvck1lc3NhZ2UoYEludmFsaWQgZGVjb3JhdGlvbiBzdHlsZSBcIiR7aWR9XCI6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICB9XG4gIH1cblxuICBpZiAoc3R5bGVzaGVldCkge1xuICAgIGxldCBzdHlsZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gICAgc3R5bGVFbGVtZW50LmlubmVySFRNTCA9IHN0eWxlc2hlZXQ7XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdLmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudCk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldERlY29yYXRpb25zKGdyb3VwSWRlbnRpZmllcikge1xuICB2YXIgZ3JvdXAgPSBncm91cHMuZ2V0KGdyb3VwSWRlbnRpZmllcik7XG4gIGlmICghZ3JvdXApIHtcbiAgICBsZXQgaWQgPSBcInIyLWRlY29yYXRpb24tXCIgKyBsYXN0R3JvdXBJZCsrO1xuICAgIGdyb3VwID0gRGVjb3JhdGlvbkdyb3VwKGlkKTtcbiAgICBncm91cHMuc2V0KGdyb3VwSWRlbnRpZmllciwgZ3JvdXApO1xuICB9XG4gIHJldHVybiBncm91cDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIERlY29yYXRpb25Hcm91cChncm91cElkKSB7XG4gIHZhciBpdGVtcyA9IFtdO1xuICB2YXIgbGFzdEl0ZW1JZCA9IDA7XG4gIHZhciBjb250YWluZXIgPSBudWxsO1xuXG4gIGZ1bmN0aW9uIGFkZChkZWNvcmF0aW9uKSB7XG4gICAgbGV0IGlkID0gZ3JvdXBJZCArIFwiLVwiICsgbGFzdEl0ZW1JZCsrO1xuXG4gICAgbGV0IHJhbmdlID0gcmFuZ2VGcm9tTG9jYXRvcihkZWNvcmF0aW9uLmxvY2F0b3IpO1xuICAgIGlmICghcmFuZ2UpIHtcbiAgICAgIGxvZyhcIkNhbid0IGxvY2F0ZSBET00gcmFuZ2UgZm9yIGRlY29yYXRpb25cIiwgZGVjb3JhdGlvbik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IGl0ZW0gPSB7IGlkLCBkZWNvcmF0aW9uLCByYW5nZSB9O1xuICAgIGl0ZW1zLnB1c2goaXRlbSk7XG4gICAgbGF5b3V0KGl0ZW0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlKGRlY29yYXRpb25JZGVudGlmaWVyKSB7XG4gICAgbGV0IGluZGV4ID0gaXRlbXMuZmluZEluZGV4KFxuICAgICAgKGkpID0+IGkuZGVjb3JhdGlvbi5pZGVudGlmaWVyID09PSBkZWNvcmF0aW9uSWRlbnRpZmllclxuICAgICk7XG4gICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBpdGVtID0gaXRlbXNbaW5kZXhdO1xuICAgIGl0ZW1zLnNwbGljZShpbmRleCwgMSk7XG4gICAgbGV0IGl0ZW1Db250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpdGVtLmlkKTtcbiAgICBpZiAoaXRlbUNvbnRhaW5lcikge1xuICAgICAgaXRlbUNvbnRhaW5lci5yZW1vdmUoKTtcbiAgICAgIGl0ZW1Db250YWluZXIgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZShkZWNvcmF0aW9uKSB7XG4gICAgcmVtb3ZlKGRlY29yYXRpb24uaWRlbnRpZmllcik7XG4gICAgYWRkKGRlY29yYXRpb24pO1xuICB9XG5cbiAgZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgY2xlYXJDb250YWluZXIoKTtcbiAgICBpdGVtcyA9IFtdO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVxdWVzdExheW91dCgpIHtcbiAgICBjbGVhckNvbnRhaW5lcigpO1xuICAgIGl0ZW1zLmZvckVhY2goKGl0ZW0pID0+IGxheW91dChpdGVtKSk7XG4gIH1cblxuICBmdW5jdGlvbiBsYXlvdXQoaXRlbSkge1xuICAgIGxldCBncm91cENvbnRhaW5lciA9IHJlcXVpcmVDb250YWluZXIoKTtcblxuICAgIGxldCBzdHlsZSA9IHN0eWxlcy5nZXQoaXRlbS5kZWNvcmF0aW9uLnN0eWxlKTtcbiAgICBpZiAoIXN0eWxlKSB7XG4gICAgICBsb2dFcnJvck1lc3NhZ2UoYFVua25vd24gZGVjb3JhdGlvbiBzdHlsZTogJHtpdGVtLmRlY29yYXRpb24uc3R5bGV9YCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IGl0ZW1Db250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGl0ZW1Db250YWluZXIuc2V0QXR0cmlidXRlKFwiaWRcIiwgaXRlbS5pZCk7XG4gICAgaXRlbUNvbnRhaW5lci5zdHlsZS5zZXRQcm9wZXJ0eShcInBvaW50ZXItZXZlbnRzXCIsIFwibm9uZVwiKTtcbiAgICBpZiAoaXRlbS5wb2ludGVySW50ZXJhY3Rpb24pIHtcbiAgICAgIGl0ZW1Db250YWluZXIuc2V0QXR0cmlidXRlKFwiZGF0YS1jbGlja1wiLCBcIjFcIik7XG4gICAgfVxuICAgIGxldCB0aW50ID0gaXRlbS5kZWNvcmF0aW9uLnRpbnQ7XG4gICAgaWYgKHRpbnQpIHtcbiAgICAgIGl0ZW1Db250YWluZXIuc3R5bGUuc2V0UHJvcGVydHkoXG4gICAgICAgIFwiLS1yMi1kZWNvcmF0aW9uLXRpbnRcIixcbiAgICAgICAgYHJnYigke3RpbnQucmVkfSwgJHt0aW50LmdyZWVufSwgJHt0aW50LmJsdWV9KWBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgbGV0IHZpZXdwb3J0V2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICBsZXQgY29sdW1uQ291bnQgPSBwYXJzZUludChcbiAgICAgIGdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KS5nZXRQcm9wZXJ0eVZhbHVlKFxuICAgICAgICBcImNvbHVtbi1jb3VudFwiXG4gICAgICApXG4gICAgKTtcbiAgICBsZXQgcGFnZVdpZHRoID0gdmlld3BvcnRXaWR0aCAvIChjb2x1bW5Db3VudCB8fCAxKTtcbiAgICBsZXQgc2Nyb2xsaW5nRWxlbWVudCA9IGRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnQ7XG4gICAgbGV0IHhPZmZzZXQgPSBzY3JvbGxpbmdFbGVtZW50LnNjcm9sbExlZnQ7XG4gICAgbGV0IHlPZmZzZXQgPSBzY3JvbGxpbmdFbGVtZW50LnNjcm9sbFRvcDtcblxuICAgIGZ1bmN0aW9uIHBvc2l0aW9uRWxlbWVudChlbGVtZW50LCByZWN0LCBib3VuZGluZ1JlY3QpIHtcbiAgICAgIGVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG5cbiAgICAgIGlmIChzdHlsZS53aWR0aCA9PT0gXCJ3cmFwXCIpIHtcbiAgICAgICAgZWxlbWVudC5zdHlsZS53aWR0aCA9IGAke3JlY3Qud2lkdGh9cHhgO1xuICAgICAgICBlbGVtZW50LnN0eWxlLmhlaWdodCA9IGAke3JlY3QuaGVpZ2h0fXB4YDtcbiAgICAgICAgZWxlbWVudC5zdHlsZS5sZWZ0ID0gYCR7cmVjdC5sZWZ0ICsgeE9mZnNldH1weGA7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUudG9wID0gYCR7cmVjdC50b3AgKyB5T2Zmc2V0fXB4YDtcbiAgICAgIH0gZWxzZSBpZiAoc3R5bGUud2lkdGggPT09IFwidmlld3BvcnRcIikge1xuICAgICAgICBlbGVtZW50LnN0eWxlLndpZHRoID0gYCR7dmlld3BvcnRXaWR0aH1weGA7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gYCR7cmVjdC5oZWlnaHR9cHhgO1xuICAgICAgICBsZXQgbGVmdCA9IE1hdGguZmxvb3IocmVjdC5sZWZ0IC8gdmlld3BvcnRXaWR0aCkgKiB2aWV3cG9ydFdpZHRoO1xuICAgICAgICBlbGVtZW50LnN0eWxlLmxlZnQgPSBgJHtsZWZ0ICsgeE9mZnNldH1weGA7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUudG9wID0gYCR7cmVjdC50b3AgKyB5T2Zmc2V0fXB4YDtcbiAgICAgIH0gZWxzZSBpZiAoc3R5bGUud2lkdGggPT09IFwiYm91bmRzXCIpIHtcbiAgICAgICAgZWxlbWVudC5zdHlsZS53aWR0aCA9IGAke2JvdW5kaW5nUmVjdC53aWR0aH1weGA7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gYCR7cmVjdC5oZWlnaHR9cHhgO1xuICAgICAgICBlbGVtZW50LnN0eWxlLmxlZnQgPSBgJHtib3VuZGluZ1JlY3QubGVmdCArIHhPZmZzZXR9cHhgO1xuICAgICAgICBlbGVtZW50LnN0eWxlLnRvcCA9IGAke3JlY3QudG9wICsgeU9mZnNldH1weGA7XG4gICAgICB9IGVsc2UgaWYgKHN0eWxlLndpZHRoID09PSBcInBhZ2VcIikge1xuICAgICAgICBlbGVtZW50LnN0eWxlLndpZHRoID0gYCR7cGFnZVdpZHRofXB4YDtcbiAgICAgICAgZWxlbWVudC5zdHlsZS5oZWlnaHQgPSBgJHtyZWN0LmhlaWdodH1weGA7XG4gICAgICAgIGxldCBsZWZ0ID0gTWF0aC5mbG9vcihyZWN0LmxlZnQgLyBwYWdlV2lkdGgpICogcGFnZVdpZHRoO1xuICAgICAgICBlbGVtZW50LnN0eWxlLmxlZnQgPSBgJHtsZWZ0ICsgeE9mZnNldH1weGA7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUudG9wID0gYCR7cmVjdC50b3AgKyB5T2Zmc2V0fXB4YDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgYm91bmRpbmdSZWN0ID0gaXRlbS5yYW5nZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgIGlmIChzdHlsZS5sYXlvdXQgPT09IFwiYm94ZXNcIikge1xuICAgICAgbGV0IGRvTm90TWVyZ2VIb3Jpem9udGFsbHlBbGlnbmVkUmVjdHMgPSB0cnVlO1xuICAgICAgbGV0IGNsaWVudFJlY3RzID0gZ2V0Q2xpZW50UmVjdHNOb092ZXJsYXAoXG4gICAgICAgIGl0ZW0ucmFuZ2UsXG4gICAgICAgIGRvTm90TWVyZ2VIb3Jpem9udGFsbHlBbGlnbmVkUmVjdHNcbiAgICAgICk7XG5cbiAgICAgIGZvciAobGV0IGNsaWVudFJlY3Qgb2YgY2xpZW50UmVjdHMpIHtcbiAgICAgICAgY29uc3QgbGluZSA9IHN0eWxlLmVsZW1lbnQuY29udGVudC5maXJzdEVsZW1lbnRDaGlsZC5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICAgIGxpbmUuc3R5bGUuc2V0UHJvcGVydHkoXCJwb2ludGVyLWV2ZW50c1wiLCBcIm5vbmVcIik7XG4gICAgICAgIHBvc2l0aW9uRWxlbWVudChsaW5lLCBjbGllbnRSZWN0LCBib3VuZGluZ1JlY3QpO1xuICAgICAgICBpdGVtQ29udGFpbmVyLmFwcGVuZChsaW5lKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHN0eWxlLmxheW91dCA9PT0gXCJib3VuZHNcIikge1xuICAgICAgY29uc3QgYm91bmRzID0gc3R5bGUuZWxlbWVudC5jb250ZW50LmZpcnN0RWxlbWVudENoaWxkLmNsb25lTm9kZSh0cnVlKTtcbiAgICAgIGJvdW5kcy5zdHlsZS5zZXRQcm9wZXJ0eShcInBvaW50ZXItZXZlbnRzXCIsIFwibm9uZVwiKTtcbiAgICAgIHBvc2l0aW9uRWxlbWVudChib3VuZHMsIGJvdW5kaW5nUmVjdCwgYm91bmRpbmdSZWN0KTtcblxuICAgICAgaXRlbUNvbnRhaW5lci5hcHBlbmQoYm91bmRzKTtcbiAgICB9XG5cbiAgICBncm91cENvbnRhaW5lci5hcHBlbmQoaXRlbUNvbnRhaW5lcik7XG4gIH1cblxuICBmdW5jdGlvbiByZXF1aXJlQ29udGFpbmVyKCkge1xuICAgIGlmICghY29udGFpbmVyKSB7XG4gICAgICBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgY29udGFpbmVyLnNldEF0dHJpYnV0ZShcImlkXCIsIGdyb3VwSWQpO1xuICAgICAgY29udGFpbmVyLnN0eWxlLnNldFByb3BlcnR5KFwicG9pbnRlci1ldmVudHNcIiwgXCJub25lXCIpO1xuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmQoY29udGFpbmVyKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFyQ29udGFpbmVyKCkge1xuICAgIGlmIChjb250YWluZXIpIHtcbiAgICAgIGNvbnRhaW5lci5yZW1vdmUoKTtcbiAgICAgIGNvbnRhaW5lciA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHsgYWRkLCByZW1vdmUsIHVwZGF0ZSwgY2xlYXIsIHJlcXVlc3RMYXlvdXQgfTtcbn1cblxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXG4gIFwibG9hZFwiLFxuICBmdW5jdGlvbiAoKSB7XG4gICAgLy8gb24gcGFnZSBsb2FkXG4gICAgY29uc3QgYm9keSA9IGRvY3VtZW50LmJvZHk7XG4gICAgdmFyIGxhc3RTaXplID0geyB3aWR0aDogMCwgaGVpZ2h0OiAwIH07XG4gICAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoKCkgPT4ge1xuICAgICAgaWYgKFxuICAgICAgICBsYXN0U2l6ZS53aWR0aCA9PT0gYm9keS5jbGllbnRXaWR0aCAmJlxuICAgICAgICBsYXN0U2l6ZS5oZWlnaHQgPT09IGJvZHkuY2xpZW50SGVpZ2h0XG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGFzdFNpemUgPSB7XG4gICAgICAgIHdpZHRoOiBib2R5LmNsaWVudFdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGJvZHkuY2xpZW50SGVpZ2h0LFxuICAgICAgfTtcblxuICAgICAgZ3JvdXBzLmZvckVhY2goZnVuY3Rpb24gKGdyb3VwKSB7XG4gICAgICAgIGdyb3VwLnJlcXVlc3RMYXlvdXQoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIG9ic2VydmVyLm9ic2VydmUoYm9keSk7XG4gIH0sXG4gIGZhbHNlXG4pO1xuIiwiLy9cbi8vICBDb3B5cmlnaHQgMjAyMSBSZWFkaXVtIEZvdW5kYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgdGhlIEJTRC1zdHlsZSBsaWNlbnNlXG4vLyAgYXZhaWxhYmxlIGluIHRoZSB0b3AtbGV2ZWwgTElDRU5TRSBmaWxlIG9mIHRoZSBwcm9qZWN0LlxuLy9cblxuLy8gQmFzZSBzY3JpcHQgdXNlZCBieSBib3RoIHJlZmxvd2FibGUgYW5kIGZpeGVkIGxheW91dCByZXNvdXJjZXMuXG5cbmltcG9ydCBcIi4vZ2VzdHVyZXNcIjtcbmltcG9ydCB7XG4gIHJlbW92ZVByb3BlcnR5LFxuICBzY3JvbGxMZWZ0LFxuICBzY3JvbGxSaWdodCxcbiAgc2Nyb2xsVG9JZCxcbiAgc2Nyb2xsVG9Qb3NpdGlvbixcbiAgc2Nyb2xsVG9UZXh0LFxuICBzZXRQcm9wZXJ0eSxcbn0gZnJvbSBcIi4vdXRpbHNcIjtcbmltcG9ydCB7IGdldEN1cnJlbnRTZWxlY3Rpb25JbmZvLCBnZXRTZWxlY3Rpb25SZWN0IH0gZnJvbSBcIi4vc2VsZWN0aW9uXCI7XG5pbXBvcnQgeyBjbGVhckhpZ2hsaWdodHMsIGhpZ2hsaWdodCB9IGZyb20gXCIuL2hpZ2hsaWdodFwiO1xuaW1wb3J0IHsgZ2V0RGVjb3JhdGlvbnMsIHJlZ2lzdGVyU3R5bGVzIH0gZnJvbSBcIi4vZGVjb3JhdG9yXCI7XG5cbi8vIFB1YmxpYyBBUEkgdXNlZCBieSB0aGUgbmF2aWdhdG9yLlxud2luZG93LnJlYWRpdW0gPSB7XG4gIC8vIHV0aWxzXG4gIHNjcm9sbFRvSWQ6IHNjcm9sbFRvSWQsXG4gIHNjcm9sbFRvUG9zaXRpb246IHNjcm9sbFRvUG9zaXRpb24sXG4gIHNjcm9sbFRvVGV4dDogc2Nyb2xsVG9UZXh0LFxuICBzY3JvbGxMZWZ0OiBzY3JvbGxMZWZ0LFxuICBzY3JvbGxSaWdodDogc2Nyb2xsUmlnaHQsXG4gIHNldFByb3BlcnR5OiBzZXRQcm9wZXJ0eSxcbiAgcmVtb3ZlUHJvcGVydHk6IHJlbW92ZVByb3BlcnR5LFxuXG4gIC8vIGRlY29yYXRpb25cbiAgcmVnaXN0ZXJEZWNvcmF0aW9uU3R5bGVzOiByZWdpc3RlclN0eWxlcyxcbiAgZ2V0RGVjb3JhdGlvbnM6IGdldERlY29yYXRpb25zLFxuXG4gIC8vIHNlbGVjdGlvblxuICBnZXRTZWxlY3Rpb25SZWN0OiBnZXRTZWxlY3Rpb25SZWN0LFxuICBnZXRDdXJyZW50U2VsZWN0aW9uSW5mbzogZ2V0Q3VycmVudFNlbGVjdGlvbkluZm8sXG59O1xuIiwiLy9cbi8vICBDb3B5cmlnaHQgMjAyMSBSZWFkaXVtIEZvdW5kYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgdGhlIEJTRC1zdHlsZSBsaWNlbnNlXG4vLyAgYXZhaWxhYmxlIGluIHRoZSB0b3AtbGV2ZWwgTElDRU5TRSBmaWxlIG9mIHRoZSBwcm9qZWN0LlxuLy9cblxuLy8gU2NyaXB0IHVzZWQgZm9yIHJlZmxvd2FibGUgcmVzb3VyY2VzLlxuXG5pbXBvcnQgXCIuL2luZGV4XCI7XG5cbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCBmdW5jdGlvbiAoKSB7XG4gIC8vIE5vdGlmaWVzIG5hdGl2ZSBjb2RlIHRoYXQgdGhlIHBhZ2UgaXMgbG9hZGVkIGFmdGVyIGl0IGlzIHJlbmRlcmVkLlxuICAvLyBXYWl0aW5nIGZvciB0aGUgbmV4dCBhbmltYXRpb24gZnJhbWUgc2VlbXMgdG8gZG8gdGhlIHRyaWNrIHRvIG1ha2Ugc3VyZSB0aGUgcGFnZSBpcyBmdWxseSByZW5kZXJlZC5cbiAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgd2Via2l0Lm1lc3NhZ2VIYW5kbGVycy5zcHJlYWRMb2FkZWQucG9zdE1lc3NhZ2Uoe30pO1xuICB9KTtcblxuICAvLyBTZXR1cHMgdGhlIGB2aWV3cG9ydGAgbWV0YSB0YWcgdG8gZGlzYWJsZSB6b29taW5nLlxuICBsZXQgbWV0YSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJtZXRhXCIpO1xuICBtZXRhLnNldEF0dHJpYnV0ZShcIm5hbWVcIiwgXCJ2aWV3cG9ydFwiKTtcbiAgbWV0YS5zZXRBdHRyaWJ1dGUoXG4gICAgXCJjb250ZW50XCIsXG4gICAgXCJ3aWR0aD1kZXZpY2Utd2lkdGgsIGluaXRpYWwtc2NhbGU9MS4wLCBtYXhpbXVtLXNjYWxlPTEuMCwgdXNlci1zY2FsYWJsZT1ubywgc2hyaW5rLXRvLWZpdD1ub1wiXG4gICk7XG4gIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQobWV0YSk7XG59KTtcblxuLy8gSW5qZWN0cyBSZWFkaXVtIENTUyBzdHlsZXNoZWV0cy5cbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsIGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gY3JlYXRlTGluayhuYW1lKSB7XG4gICAgdmFyIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKTtcbiAgICBsaW5rLnNldEF0dHJpYnV0ZShcInJlbFwiLCBcInN0eWxlc2hlZXRcIik7XG4gICAgbGluay5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsIFwidGV4dC9jc3NcIik7XG4gICAgbGluay5zZXRBdHRyaWJ1dGUoXCJocmVmXCIsIHdpbmRvdy5yZWFkaXVtQ1NTQmFzZVVSTCArIG5hbWUgKyBcIi5jc3NcIik7XG4gICAgcmV0dXJuIGxpbms7XG4gIH1cblxuICB2YXIgaGVhZCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKVswXTtcbiAgaGVhZC5hcHBlbmRDaGlsZChjcmVhdGVMaW5rKFwiUmVhZGl1bUNTUy1hZnRlclwiKSk7XG4gIGhlYWQuaW5zZXJ0QmVmb3JlKGNyZWF0ZUxpbmsoXCJSZWFkaXVtQ1NTLWJlZm9yZVwiKSwgaGVhZC5jaGlsZHJlblswXSk7XG59KTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///611\n')}},__webpack_module_cache__={};function __webpack_require__(n){var t=__webpack_module_cache__[n];if(void 0!==t)return t.exports;var e=__webpack_module_cache__[n]={exports:{}};return __webpack_modules__[n](e,e.exports,__webpack_require__),e.exports}var __webpack_exports__=__webpack_require__(611)})();