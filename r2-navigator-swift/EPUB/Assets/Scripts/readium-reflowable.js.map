{"version":3,"sources":["webpack://readium-js/./src/gestures.js","webpack://readium-js/webpack/bootstrap","webpack://readium-js/./src/utils.js","webpack://readium-js/./src/selection.js","webpack://readium-js/./src/rect.js","webpack://readium-js/./src/highlight.js","webpack://readium-js/./src/index.js","webpack://readium-js/./src/index-reflowable.js"],"names":["onClick","event","window","getSelection","isCollapsed","webkit","messageHandlers","tap","postMessage","defaultPrevented","screenX","screenY","clientX","clientY","target","outerHTML","nearestInteractiveElement","element","indexOf","nodeName","toLowerCase","hasAttribute","getAttribute","parentElement","addEventListener","document","body","style","cursor","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","exports","module","__webpack_modules__","logError","message","filename","lineno","orientationChanged","snapCurrentPosition","func","timeout","last_known_scrollX_position","last_known_scrollY_position","ticking","maxScreenX","orientation","screen","width","height","isScrollModeEnabled","documentElement","getPropertyValue","toString","trim","scrollToOffset","offset","currentOffset","scrollX","pageWidth","innerWidth","scrollingElement","scrollLeft","Math","abs","snapOffset","value","currentOffsetSnapped","log","Array","prototype","slice","call","arguments","join","createOrderedRange","startNode","startOffset","endNode","endOffset","range","Range","setStart","setEnd","collapsed","rangeReverse","rangeInfo2Location","rangeInfo","cssSelector","startContainerElementCssSelector","domRange","start","textNodeIndex","startContainerChildTextNodeIndex","end","endContainerElementCssSelector","endContainerChildTextNodeIndex","fullQualifiedSelector","node","nodeType","Node","ELEMENT_NODE","localName","optimized","steps","contextNode","step","_cssPathStep","push","parentNode","reverse","cssPath","isTargetNode","idSelector","idd","escapeIdentifierIfNeeded","ident","test","shouldEscapeFirst","lastIndex","length","replace","c","ii","charCodeAt","isCSSIdentChar","isLast","hexByte","toHexByte","escapeAsciiChar","prefixedElementClassNames","nd","classAttribute","split","filter","Boolean","map","nm","lowerCaseName","id","parent","DOCUMENT_NODE","prefixedOwnClassNamesArray_","prefixedOwnClassNamesArray","forEach","arrItem","needsClassNames","needsNthChild","ownIndex","elementIndex","siblings","children","i","sibling","ownClassNames","ownClassNameCount","siblingClassNamesArray_","siblingClassNamesArray","siblingClass","ind","splice","result","prefixedName","substr","doNotMergeHorizontallyAlignedRects","clientRects","getClientRects","originalRects","rangeClientRect","bottom","left","right","top","newRects","replaceOverlapingRects","rects","tolerance","rectsToKeep","Set","rect","possiblyContainingRect","has","rectContains","delete","from","removeContainedRects","mergeTouchingRects","j","rect1","rect2","rectsLineUpVertically","almostEqual","rectsLineUpHorizontally","horizontalAllowed","rectsTouchOrOverlap","replacementClientRect","getBoundingRect","min","max","rectContainsPoint","x","y","toRemove","toPreserve","toAdd","subtractRects1","rectSubtract","subtractRects2","apply","rectIntersected","maxLeft","minRight","maxTop","minBottom","rectIntersect","rectA","rectB","rectC","rectD","a","b","e","scrollY","scrollHeight","scrollWidth","requestAnimationFrame","positionString","progressionChanged","info","selection","rangeCount","getRangeAt","getBoundingClientRect","selectionChanged","self","this","args","callback","clearTimeout","setTimeout","ID_HIGHLIGHTS_CONTAINER","CLASS_HIGHLIGHT_AREA","_highlights","_highlightsContainer","defaultBackgroundColor","blue","green","red","readium","getElementById","scrollIntoView","position","dir","console","scrollTop","text","Selection","markedRanges","removeWhitespaces","s","clear","removeAllRanges","mark","reset","addRange","adjust","direction","modify","isEmpty","getFirstRange","highlight","before","snippet","after","safeSnippet","found","find","safeSelection","includes","innerHeight","isRTL","documentWidth","minOffset","maxOffset","key","setProperty","removeProperty","sel","clientRect","screenWidth","outerWidth","screenHeight","outerHeight","logException","rawText","anchorNode","focusNode","anchorOffset","focusOffset","getCssSelector","startIsElement","startContainer","startContainerElement","childNodes","endIsElement","endContainer","endContainerElement","commonElementAncestor","node1","node2","contains","node1ElementAncestorChain","node2ElementAncestorChain","commonAncestor","node1ElementAncestor","node2ElementAncestor","getCommonAncestorElement","commonAncestorContainer","rangeCommonAncestorElement","convertRange","locations","selectionInfo","color","pointerInteraction","type","location","location2RangeInfo","Date","now","_document","h","highlightContainer","remove","destroyHighlight","win","scale","READIUM2","isFixedLayout","fxlViewportScale","scrollElement","startElement","querySelector","TEXT_NODE","endElement","paginated","highlightsContainer","createElement","setAttribute","append","ensureContainer","highlightParent","bodyRect","xOffset","yOffset","extra","highlightArea","highlightBounding","rangeBoundingClientRect","createHighlightDom","_createHighlight","spreadLoaded","meta","head","appendChild","createLink","name","link","getElementsByTagName","insertBefore"],"mappings":"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","file":"readium-reflowable.js","sourcesContent":["//\n//  Copyright 2021 Readium Foundation. All rights reserved.\n//  Use of this source code is governed by the BSD-style license\n//  available in the top-level LICENSE file of the project.\n//\n\nwindow.addEventListener('DOMContentLoaded', function(event) {\n  // If we don't set the CSS cursor property to pointer, then the click events are not triggered pre-iOS 13.\n  document.body.style.cursor = 'pointer';\n\n  document.addEventListener('click', onClick, false);\n});\n\nfunction onClick(event) {\n\n  if (!window.getSelection().isCollapsed) {\n    // There's an on-going selection, the tap will dismiss it so we don't forward it.\n    return;\n  }\n\n  // Send the tap data over the JS bridge even if it's been handled\n  // within the webview, so that it can be preserved and used\n  // by the WKNavigationDelegate if needed.\n  webkit.messageHandlers.tap.postMessage({\n    \"defaultPrevented\": event.defaultPrevented,\n    \"screenX\": event.screenX,\n    \"screenY\": event.screenY,\n    \"clientX\": event.clientX,\n    \"clientY\": event.clientY,\n    \"targetElement\": event.target.outerHTML,\n    \"interactiveElement\": nearestInteractiveElement(event.target),\n  });\n\n  // We don't want to disable the default WebView behavior as it breaks some features without bringing any value.\n//    event.stopPropagation();\n//    event.preventDefault();\n}\n\n// See. https://github.com/JayPanoz/architecture/tree/touch-handling/misc/touch-handling\nfunction nearestInteractiveElement(element) {\n  var interactiveTags = [\n    'a',\n    'audio',\n    'button',\n    'canvas',\n    'details',\n    'input',\n    'label',\n    'option',\n    'select',\n    'submit',\n    'textarea',\n    'video',\n  ]\n  if (interactiveTags.indexOf(element.nodeName.toLowerCase()) !== -1) {\n    return element.outerHTML;\n  }\n\n  // Checks whether the element is editable by the user.\n  if (element.hasAttribute('contenteditable') && element.getAttribute('contenteditable').toLowerCase() != 'false') {\n    return element.outerHTML;\n  }\n\n  // Checks parents recursively because the touch might be for example on an <em> inside a <a>.\n  if (element.parentElement) {\n    return nearestInteractiveElement(element.parentElement);\n  }\n\n  return null;\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","//\n//  Copyright 2021 Readium Foundation. All rights reserved.\n//  Use of this source code is governed by the BSD-style license\n//  available in the top-level LICENSE file of the project.\n//\n\n// Catch JS errors to log them in the app.\nwindow.addEventListener(\"error\", function(event) {\n    webkit.messageHandlers.logError.postMessage({\n        \"message\": event.message,\n        \"filename\": event.filename,\n        \"line\": event.lineno\n    });\n}, false);\n\n// Notify native code that the page has loaded.\nwindow.addEventListener(\"load\", function(){ // on page load\n    window.addEventListener(\"orientationchange\", function() {\n        orientationChanged();\n        snapCurrentPosition();\n    });\n    orientationChanged();\n}, false);\n\nvar last_known_scrollX_position = 0;\nvar last_known_scrollY_position = 0;\nvar ticking = false;\nvar maxScreenX = 0;\n\n// Position in range [0 - 1].\nfunction update(position) {\n    var positionString = position.toString()\n    webkit.messageHandlers.progressionChanged.postMessage(positionString);\n}\n\nwindow.addEventListener('scroll', function(e) {\n    last_known_scrollY_position = window.scrollY / document.scrollingElement.scrollHeight;\n    // Using Math.abs because for RTL books, the value will be negative.\n    last_known_scrollX_position = Math.abs(window.scrollX / document.scrollingElement.scrollWidth);\n\n    // Window is hidden\n    if (document.scrollingElement.scrollWidth === 0 || document.scrollingElement.scrollHeight === 0) {\n        return;\n    }\n\n    if (!ticking) {\n        window.requestAnimationFrame(function() {\n            update(isScrollModeEnabled() ? last_known_scrollY_position : last_known_scrollX_position);\n            ticking = false;\n        });\n    }\n    ticking = true;\n});\n\ndocument.addEventListener('selectionchange', debounce(50, function() {\n    var info = {}\n    var selection = document.getSelection();\n    if (selection && selection.rangeCount > 0) {\n        var rect = selection.getRangeAt(0).getBoundingClientRect();\n        info['text'] = selection.toString().trim();\n        info['frame'] = {\n            'x': rect.left,\n            'y': rect.top,\n            'width': rect.width,\n            'height': rect.height\n        };\n    }\n\n    webkit.messageHandlers.selectionChanged.postMessage(info);\n}));\n\nfunction orientationChanged() {\n    maxScreenX = (window.orientation === 0 || window.orientation == 180) ? screen.width : screen.height;\n}\n\nfunction isScrollModeEnabled() {\n    return document.documentElement.style.getPropertyValue(\"--USER__scroll\").toString().trim() === 'readium-scroll-on';\n}\n\n// Scroll to the given TagId in document and snap.\nexport function scrollToId(id) {\n    var element = document.getElementById(id);\n    if (!element) {\n        return false;\n    }\n    element.scrollIntoView();\n\n    if (!isScrollModeEnabled()) {\n        var currentOffset = window.scrollX;\n        var pageWidth = window.innerWidth;\n        // Adds half a page to make sure we don't snap to the previous page.\n        document.scrollingElement.scrollLeft = snapOffset(currentOffset + (pageWidth / 2));\n    }\n    return true;\n}\n\n// Position must be in the range [0 - 1], 0-100%.\nexport function scrollToPosition(position, dir) {\n    console.log(\"ScrollToPosition\");\n    if ((position < 0) || (position > 1)) {\n        console.log(\"InvalidPosition\");\n        return;\n    }\n\n    if (isScrollModeEnabled()) {\n        var offset = document.scrollingElement.scrollHeight * position;\n        document.scrollingElement.scrollTop = offset;\n        // window.scrollTo(0, offset);\n    } else {\n        var documentWidth = document.scrollingElement.scrollWidth;\n        var factor = (dir == 'rtl') ? -1 : 1;\n        var offset = documentWidth * position * factor;\n        document.scrollingElement.scrollLeft = snapOffset(offset);\n    }\n}\n\n// Scrolls to the first occurrence of the given text snippet.\n//\n// The expected text argument is a Locator Text object, as defined here:\n// https://readium.org/architecture/models/locators/\nexport function scrollToText(text) {\n    // Wrapper around a browser Selection object.\n    function Selection(selection) {\n        this.selection = selection;\n        this.markedRanges = []\n    }\n\n    // Removes all the ranges of the selection.\n    Selection.prototype.clear = function() {\n        this.selection.removeAllRanges();\n    }\n\n    // Saves the current selection ranges, to be restored later with reset().\n    Selection.prototype.mark = function() {\n        this.markedRanges = []\n        for (var i = 0; i < this.selection.rangeCount; i++) {\n            this.markedRanges.push(this.selection.getRangeAt(i));\n        }\n    }\n\n    // Resets the selection with ranges previously saved with mark().\n    Selection.prototype.reset = function() {\n        this.clear();\n        for (var i = 0; i < this.markedRanges.length; i++) {\n            this.selection.addRange(this.markedRanges[i]);\n        }\n    }\n\n    // Returns the text content of the selection.\n    Selection.prototype.toString = function() {\n        return this.selection.toString();\n    }\n\n    // Extends the selection by moving the start and end positions by the given offsets.\n    Selection.prototype.adjust = function(offset, length) {\n        for (var i = 0; i <= Math.abs(offset); i++) {\n            var direction = (offset >= 0 ? \"forward\" : \"backward\")\n            this.selection.modify(\"move\", direction, \"character\");\n        }\n        for (var i = 0; i <= length; i++) {\n            this.selection.modify(\"extend\", \"forward\", \"character\");\n        }\n    }\n\n    Selection.prototype.isEmpty = function() {\n        return this.selection.isCollapsed\n    }\n\n    Selection.prototype.getFirstRange = function() {\n        return this.selection.getRangeAt(0);\n    }\n\n    function removeWhitespaces(s) {\n        return s.replace(/\\s+/g, \"\");\n    }\n\n    var highlight = text.highlight;\n    var before  = text.before || \"\";\n    var after  = text.after || \"\";\n    var snippet = before + highlight + after;\n    var safeSnippet = removeWhitespaces(snippet);\n\n    if (!highlight || !safeSnippet) {\n        return false;\n    }\n\n    var selection = new Selection(window.getSelection());\n    // We need to reset any selection to begin the search from the start of the resource.\n    selection.clear();\n\n    var found = false;\n    while (window.find(text.highlight, true)) {\n        if (selection.isEmpty()) {\n            break; // Prevents infinite loop in edge cases.\n        }\n\n        // Get the surrounding context to compare to the expected snippet.\n        selection.mark();\n        selection.adjust(-before.length, snippet.length);\n        var safeSelection = removeWhitespaces(selection.toString());\n        selection.reset();\n\n        if (safeSelection !== \"\" && (safeSnippet.includes(safeSelection) || safeSelection.includes(safeSnippet))) {\n            found = true;\n            break;\n        }\n    }\n\n    if (!found || selection.isEmpty()) {\n        return false;\n    }\n\n    // WKWebView doesn't seem to scroll to the selection created by window.find().\n    // See https://bugs.webkit.org/show_bug.cgi?id=163911\n    scrollToRange(selection.getFirstRange())\n\n    // Resets the selection otherwise the last found occurrence will be highlighted.\n    selection.clear();\n\n    return true;\n}\n\nfunction scrollToRange(range) {\n    var rect = range.getBoundingClientRect();\n    if (isScrollModeEnabled()) {\n        document.scrollingElement.scrollTop = rect.top + window.scrollY - (window.innerHeight / 2);\n    } else {\n        document.scrollingElement.scrollLeft = rect.left + window.scrollX;\n        snapCurrentPosition();\n    }\n}\n\n// Returns false if the page is already at the left-most scroll offset.\nexport function scrollLeft(dir) {\n    var isRTL = (dir == \"rtl\");\n    var documentWidth = document.scrollingElement.scrollWidth;\n    var pageWidth = window.innerWidth;\n    var offset = window.scrollX - pageWidth;\n    var minOffset = isRTL ? -(documentWidth - pageWidth) : 0;\n    return scrollToOffset(Math.max(offset, minOffset));\n}\n\n// Returns false if the page is already at the right-most scroll offset.\nexport function scrollRight(dir) {\n    var isRTL = (dir == \"rtl\");\n    var documentWidth = document.scrollingElement.scrollWidth;\n    var pageWidth = window.innerWidth;\n    var offset = window.scrollX + pageWidth;\n    var maxOffset = isRTL ? 0 : (documentWidth - pageWidth);\n    return scrollToOffset(Math.min(offset, maxOffset));\n}\n\n// Scrolls to the given left offset.\n// Returns false if the page scroll position is already close enough to the given offset.\nfunction scrollToOffset(offset) {\n    var currentOffset = window.scrollX;\n    var pageWidth = window.innerWidth;\n    document.scrollingElement.scrollLeft = offset;\n    // In some case the scrollX cannot reach the position respecting to innerWidth\n    var diff = Math.abs(currentOffset - offset) / pageWidth;\n    return (diff > 0.01);\n}\n\n// Snap the offset to the screen width (page width).\nfunction snapOffset(offset) {\n    var value = offset + 1;\n\n    return value - (value % maxScreenX);\n}\n\nfunction snapCurrentPosition() {\n    if (isScrollModeEnabled()) {\n        return;\n    }\n    var currentOffset = window.scrollX;\n    var currentOffsetSnapped = snapOffset(currentOffset + 1);\n\n    document.scrollingElement.scrollLeft = currentOffsetSnapped;\n}\n\n/// User Settings.\n\n// For setting user setting.\nexport function setProperty(key, value) {\n    var root = document.documentElement;\n\n    root.style.setProperty(key, value);\n}\n\n// For removing user setting.\nexport function removeProperty(key) {\n    var root = document.documentElement;\n\n    root.style.removeProperty(key);\n}\n\n\n/// Toolkit\n\nfunction debounce(delay, func) {\n    var timeout;\n    return function() {\n        var self = this;\n        var args = arguments;\n        function callback() {\n            func.apply(self, args);\n            timeout = null;\n        }\n        clearTimeout(timeout);\n        timeout = setTimeout(callback, delay);\n    };\n}\n\nexport function log() {\n    var message = Array.prototype.slice.call(arguments).join(\" \");\n    webkit.messageHandlers.log.postMessage(message);\n}\n\nexport function logException(e) {\n    webkit.messageHandlers.logError.postMessage({\n        \"message\": e.message\n    });\n}\n","//\n//  Copyright 2021 Readium Foundation. All rights reserved.\n//  Use of this source code is governed by the BSD-style license\n//  available in the top-level LICENSE file of the project.\n//\n\nimport {log as logNative, logException} from \"./utils\";\n\nconst debug = true;\n\nexport function getSelectionRect() {\n    try {\n        let sel = window.getSelection();\n        if (!sel) {\n            return;\n        }\n        let range = sel.getRangeAt(0);\n\n        const clientRect = range.getBoundingClientRect();\n\n        return {\n            screenWidth: window.outerWidth,\n            screenHeight: window.outerHeight,\n            left: clientRect.left,\n            width: clientRect.width,\n            top: clientRect.top,\n            height: clientRect.height\n        };\n    } catch (e) {\n        logException(e)\n        return null;\n    }\n}\n\nexport function getCurrentSelectionInfo() {\n    const selection = window.getSelection();\n    if (!selection) {\n        return undefined;\n    }\n    if (selection.isCollapsed) {\n        log(\"^^^ SELECTION COLLAPSED.\");\n        return undefined;\n    }\n    const rawText = selection.toString();\n    const cleanText = rawText.trim().replace(/\\n/g, \" \").replace(/\\s\\s+/g, \" \");\n    if (cleanText.length === 0) {\n        log(\"^^^ SELECTION TEXT EMPTY.\");\n        return undefined;\n    }\n    if (!selection.anchorNode || !selection.focusNode) {\n        return undefined;\n    }\n    const range = selection.rangeCount === 1 ? selection.getRangeAt(0) :\n        createOrderedRange(selection.anchorNode, selection.anchorOffset, selection.focusNode, selection.focusOffset);\n    if (!range || range.collapsed) {\n        log(\"$$$$$$$$$$$$$$$$$ CANNOT GET NON-COLLAPSED SELECTION RANGE?!\");\n        return undefined;\n    }\n    const rangeInfo = convertRange(range, fullQualifiedSelector);\n    if (!rangeInfo) {\n        log(\"^^^ SELECTION RANGE INFO FAIL?!\");\n        return undefined;\n    }\n\n    return {\n        locations: rangeInfo2Location(rangeInfo),\n        text: {\n            highlight: rawText\n        }\n    };\n}\n\nfunction createOrderedRange(startNode, startOffset, endNode, endOffset) {\n    const range = new Range();\n    range.setStart(startNode, startOffset);\n    range.setEnd(endNode, endOffset);\n    if (!range.collapsed) {\n        return range;\n    }\n    log(\">>> createOrderedRange COLLAPSED ... RANGE REVERSE?\");\n    const rangeReverse = new Range();\n    rangeReverse.setStart(endNode, endOffset);\n    rangeReverse.setEnd(startNode, startOffset);\n    if (!rangeReverse.collapsed) {\n        log(\">>> createOrderedRange RANGE REVERSE OK.\");\n        return range;\n    }\n    log(\">>> createOrderedRange RANGE REVERSE ALSO COLLAPSED?!\");\n    return undefined;\n}\n\nfunction convertRange(range, getCssSelector) {\n    const startIsElement = range.startContainer.nodeType === Node.ELEMENT_NODE;\n    const startContainerElement = startIsElement ?\n        range.startContainer :\n        ((range.startContainer.parentNode && range.startContainer.parentNode.nodeType === Node.ELEMENT_NODE) ?\n            range.startContainer.parentNode : undefined);\n    if (!startContainerElement) {\n        return undefined;\n    }\n    const startContainerChildTextNodeIndex = startIsElement ? -1 :\n        Array.from(startContainerElement.childNodes).indexOf(range.startContainer);\n    if (startContainerChildTextNodeIndex < -1) {\n        return undefined;\n    }\n    const startContainerElementCssSelector = getCssSelector(startContainerElement);\n\n    const endIsElement = range.endContainer.nodeType === Node.ELEMENT_NODE;\n    const endContainerElement = endIsElement ?\n        range.endContainer :\n        ((range.endContainer.parentNode && range.endContainer.parentNode.nodeType === Node.ELEMENT_NODE) ?\n            range.endContainer.parentNode : undefined);\n    if (!endContainerElement) {\n        return undefined;\n    }\n    const endContainerChildTextNodeIndex = endIsElement ? -1 :\n        Array.from(endContainerElement.childNodes).indexOf(range.endContainer);\n    if (endContainerChildTextNodeIndex < -1) {\n        return undefined;\n    }\n    const endContainerElementCssSelector = getCssSelector(endContainerElement);\n\n    const commonElementAncestor = getCommonAncestorElement(range.startContainer, range.endContainer);\n    if (!commonElementAncestor) {\n        log(\"^^^ NO RANGE COMMON ANCESTOR?!\");\n        return undefined;\n    }\n    if (range.commonAncestorContainer) {\n        const rangeCommonAncestorElement = range.commonAncestorContainer.nodeType === Node.ELEMENT_NODE ?\n            range.commonAncestorContainer : range.commonAncestorContainer.parentNode;\n        if (rangeCommonAncestorElement && rangeCommonAncestorElement.nodeType === Node.ELEMENT_NODE) {\n            if (commonElementAncestor !== rangeCommonAncestorElement) {\n                log(\">>>>>> COMMON ANCESTOR CONTAINER DIFF??!\");\n                log(getCssSelector(commonElementAncestor));\n                log(getCssSelector(rangeCommonAncestorElement));\n            }\n        }\n    }\n    return {\n        endContainerChildTextNodeIndex,\n        endContainerElementCssSelector,\n        endOffset: range.endOffset,\n        startContainerChildTextNodeIndex,\n        startContainerElementCssSelector,\n        startOffset: range.startOffset,\n    };\n}\n\nfunction getCommonAncestorElement(node1, node2) {\n    if (node1.nodeType === Node.ELEMENT_NODE && node1 === node2) {\n        return node1;\n    }\n    if (node1.nodeType === Node.ELEMENT_NODE && node1.contains(node2)) {\n        return node1;\n    }\n    if (node2.nodeType === Node.ELEMENT_NODE && node2.contains(node1)) {\n        return node2;\n    }\n    const node1ElementAncestorChain = [];\n    let parent = node1.parentNode;\n    while (parent && parent.nodeType === Node.ELEMENT_NODE) {\n        node1ElementAncestorChain.push(parent);\n        parent = parent.parentNode;\n    }\n    const node2ElementAncestorChain = [];\n    parent = node2.parentNode;\n    while (parent && parent.nodeType === Node.ELEMENT_NODE) {\n        node2ElementAncestorChain.push(parent);\n        parent = parent.parentNode;\n    }\n    let commonAncestor = node1ElementAncestorChain.find((node1ElementAncestor) => {\n        return node2ElementAncestorChain.indexOf(node1ElementAncestor) >= 0;\n    });\n    if (!commonAncestor) {\n        commonAncestor = node2ElementAncestorChain.find((node2ElementAncestor) => {\n            return node1ElementAncestorChain.indexOf(node2ElementAncestor) >= 0;\n        });\n    }\n    return commonAncestor;\n}\n\nexport function convertRangeInfo(document, rangeInfo) {\n    const startElement = document.querySelector(rangeInfo.startContainerElementCssSelector);\n    if (!startElement) {\n        log(\"^^^ convertRangeInfo NO START ELEMENT CSS SELECTOR?!\");\n        return undefined;\n    }\n    let startContainer = startElement;\n    if (rangeInfo.startContainerChildTextNodeIndex >= 0) {\n        if (rangeInfo.startContainerChildTextNodeIndex >= startElement.childNodes.length) {\n            log(\"^^^ convertRangeInfo rangeInfo.startContainerChildTextNodeIndex >= startElement.childNodes.length?!\");\n            return undefined;\n        }\n        startContainer = startElement.childNodes[rangeInfo.startContainerChildTextNodeIndex];\n        if (startContainer.nodeType !== Node.TEXT_NODE) {\n            log(\"^^^ convertRangeInfo startContainer.nodeType !== Node.TEXT_NODE?!\");\n            return undefined;\n        }\n    }\n    const endElement = document.querySelector(rangeInfo.endContainerElementCssSelector);\n    if (!endElement) {\n        log(\"^^^ convertRangeInfo NO END ELEMENT CSS SELECTOR?!\");\n        return undefined;\n    }\n    let endContainer = endElement;\n    if (rangeInfo.endContainerChildTextNodeIndex >= 0) {\n        if (rangeInfo.endContainerChildTextNodeIndex >= endElement.childNodes.length) {\n            log(\"^^^ convertRangeInfo rangeInfo.endContainerChildTextNodeIndex >= endElement.childNodes.length?!\");\n            return undefined;\n        }\n        endContainer = endElement.childNodes[rangeInfo.endContainerChildTextNodeIndex];\n        if (endContainer.nodeType !== Node.TEXT_NODE) {\n            log(\"^^^ convertRangeInfo endContainer.nodeType !== Node.TEXT_NODE?!\");\n            return undefined;\n        }\n    }\n    return createOrderedRange(startContainer, rangeInfo.startOffset, endContainer, rangeInfo.endOffset);\n}\n\nfunction rangeInfo2Location(rangeInfo) {\n    return {\n        cssSelector: rangeInfo.startContainerElementCssSelector,\n        domRange: {\n            start: {\n                cssSelector: rangeInfo.startContainerElementCssSelector,\n                textNodeIndex: rangeInfo.startContainerChildTextNodeIndex,\n                offset: rangeInfo.startOffset\n            },\n            end: {\n                cssSelector: rangeInfo.endContainerElementCssSelector,\n                textNodeIndex: rangeInfo.endContainerChildTextNodeIndex,\n                offset: rangeInfo.endOffset\n            }\n        }\n    }\n}\n\nexport function location2RangeInfo(location) {\n    const locations = location.locations\n    const domRange = locations.domRange\n    const start = domRange.start\n    const end = domRange.end\n\n    return {\n        endContainerChildTextNodeIndex: end.textNodeIndex,\n        endContainerElementCssSelector: end.cssSelector,\n        endOffset: end.offset,\n        startContainerChildTextNodeIndex: start.textNodeIndex,\n        startContainerElementCssSelector: start.cssSelector,\n        startOffset: start.offset\n    };\n}\n\nfunction fullQualifiedSelector(node) {\n    if (node.nodeType !== Node.ELEMENT_NODE) {\n        return (node.localName && node.localName.toLowerCase())\n            || node.nodeName.toLowerCase();\n    }\n    //return cssPath(node, justSelector);\n    return cssPath(node, true);\n}\n\nfunction cssPath(node, optimized) {\n    if (node.nodeType !== Node.ELEMENT_NODE) {\n        return \"\";\n    }\n\n    const steps = [];\n    let contextNode = node;\n    while (contextNode) {\n        const step = _cssPathStep(contextNode, !!optimized, contextNode === node);\n        if (!step) {\n            break; // Error - bail out early.\n        }\n        steps.push(step.value);\n        if (step.optimized) {\n            break;\n        }\n        contextNode = contextNode.parentNode;\n    }\n    steps.reverse();\n    return steps.join(\" > \");\n}\n\n// https://chromium.googlesource.com/chromium/blink/+/master/Source/devtools/front_end/components/DOMPresentationUtils.js#316\nfunction _cssPathStep(node, optimized, isTargetNode) {\n\n    function idSelector(idd) {\n        return \"#\" + escapeIdentifierIfNeeded(idd);\n    }\n\n    function escapeIdentifierIfNeeded(ident) {\n        if (isCSSIdentifier(ident)) {\n            return ident;\n        }\n\n        const shouldEscapeFirst = /^(?:[0-9]|-[0-9-]?)/.test(ident);\n        const lastIndex = ident.length - 1;\n        return ident.replace(/./g, function (c, ii) {\n            return ((shouldEscapeFirst && ii === 0) || !isCSSIdentChar(c)) ? escapeAsciiChar(c, ii === lastIndex) : c;\n        });\n    }\n\n    function isCSSIdentifier(value) {\n        return /^-?[a-zA-Z_][a-zA-Z0-9_-]*$/.test(value);\n    }\n\n    function isCSSIdentChar(c) {\n        if (/[a-zA-Z0-9_-]/.test(c)) {\n            return true;\n        }\n        return c.charCodeAt(0) >= 0xA0;\n    }\n\n    function escapeAsciiChar(c, isLast) {\n        return \"\\\\\" + toHexByte(c) + (isLast ? \"\" : \" \");\n    }\n\n    function toHexByte(c) {\n        let hexByte = c.charCodeAt(0).toString(16);\n        if (hexByte.length === 1) {\n            hexByte = \"0\" + hexByte;\n        }\n        return hexByte;\n    }\n\n    function prefixedElementClassNames(nd) {\n        const classAttribute = nd.getAttribute(\"class\");\n        if (!classAttribute) {\n            return [];\n        }\n\n        return classAttribute.split(/\\s+/g).filter(Boolean).map((nm) => {\n            // The prefix is required to store \"__proto__\" in a object-based map.\n            return \"$\" + nm;\n        });\n    }\n\n    if (node.nodeType !== Node.ELEMENT_NODE) {\n        return undefined;\n    }\n    const lowerCaseName = (node.localName && node.localName.toLowerCase())\n        || node.nodeName.toLowerCase();\n\n    const element = node;\n\n    const id = element.getAttribute(\"id\");\n\n    if (optimized) {\n        if (id) {\n            return {\n                optimized: true,\n                value: idSelector(id),\n            };\n        }\n        if (lowerCaseName === \"body\" || lowerCaseName === \"head\" || lowerCaseName === \"html\") {\n            return {\n                optimized: true,\n                value: lowerCaseName, // node.nodeNameInCorrectCase(),\n            };\n        }\n    }\n\n    const nodeName = lowerCaseName; // node.nodeNameInCorrectCase();\n    if (id) {\n        return {\n            optimized: true,\n            value: nodeName + idSelector(id),\n        };\n    }\n\n    const parent = node.parentNode;\n\n    if (!parent || parent.nodeType === Node.DOCUMENT_NODE) {\n        return {\n            optimized: true,\n            value: nodeName,\n        };\n    }\n\n    const prefixedOwnClassNamesArray_ = prefixedElementClassNames(element);\n\n    const prefixedOwnClassNamesArray = []; // .keySet()\n    prefixedOwnClassNamesArray_.forEach((arrItem) => {\n        if (prefixedOwnClassNamesArray.indexOf(arrItem) < 0) {\n            prefixedOwnClassNamesArray.push(arrItem);\n        }\n    });\n\n    let needsClassNames = false;\n    let needsNthChild = false;\n    let ownIndex = -1;\n    let elementIndex = -1;\n    const siblings = parent.children;\n\n    for (let i = 0; (ownIndex === -1 || !needsNthChild) && i < siblings.length; ++i) {\n        const sibling = siblings[i];\n        if (sibling.nodeType !== Node.ELEMENT_NODE) {\n            continue;\n        }\n        elementIndex += 1;\n        if (sibling === node) {\n            ownIndex = elementIndex;\n            continue;\n        }\n        if (needsNthChild) {\n            continue;\n        }\n\n        // sibling.nodeNameInCorrectCase()\n        const siblingName = (sibling.localName && sibling.localName.toLowerCase()) || sibling.nodeName.toLowerCase();\n        if (siblingName !== nodeName) {\n            continue;\n        }\n        needsClassNames = true;\n\n        const ownClassNames = [];\n        prefixedOwnClassNamesArray.forEach((arrItem) => {\n            ownClassNames.push(arrItem);\n        });\n        let ownClassNameCount = ownClassNames.length;\n\n        if (ownClassNameCount === 0) {\n            needsNthChild = true;\n            continue;\n        }\n        const siblingClassNamesArray_ = prefixedElementClassNames(sibling);\n        const siblingClassNamesArray = []; // .keySet()\n        siblingClassNamesArray_.forEach((arrItem) => {\n            if (siblingClassNamesArray.indexOf(arrItem) < 0) {\n                siblingClassNamesArray.push(arrItem);\n            }\n        });\n\n        for (const siblingClass of siblingClassNamesArray) {\n            const ind = ownClassNames.indexOf(siblingClass);\n            if (ind < 0) {\n                continue;\n            }\n\n            ownClassNames.splice(ind, 1); // delete ownClassNames[siblingClass];\n\n            if (!--ownClassNameCount) {\n                needsNthChild = true;\n                break;\n            }\n        }\n    }\n\n    let result = nodeName;\n    if (isTargetNode &&\n        nodeName === \"input\" &&\n        element.getAttribute(\"type\") &&\n        !element.getAttribute(\"id\") &&\n        !element.getAttribute(\"class\")) {\n        result += \"[type=\\\"\" + element.getAttribute(\"type\") + \"\\\"]\";\n    }\n    if (needsNthChild) {\n        result += \":nth-child(\" + (ownIndex + 1) + \")\";\n    } else if (needsClassNames) {\n        for (const prefixedName of prefixedOwnClassNamesArray) {\n            result += \".\" + escapeIdentifierIfNeeded(prefixedName.substr(1));\n        }\n    }\n\n    return {\n        optimized: false,\n        value: result,\n    };\n}\n\nfunction log() {\n    if (debug) {\n        logNative.apply(null, arguments);\n    }\n}","//\n//  Copyright 2021 Readium Foundation. All rights reserved.\n//  Use of this source code is governed by the BSD-style license\n//  available in the top-level LICENSE file of the project.\n//\n\nimport {log as logNative} from \"./utils\";\n\nconst debug = false;\n\nexport function getClientRectsNoOverlap(range, doNotMergeHorizontallyAlignedRects) {\n    let clientRects = range.getClientRects();\n\n    const tolerance = 1;\n    const originalRects = [];\n    for (const rangeClientRect of clientRects) {\n        originalRects.push({\n            bottom: rangeClientRect.bottom,\n            height: rangeClientRect.height,\n            left: rangeClientRect.left,\n            right: rangeClientRect.right,\n            top: rangeClientRect.top,\n            width: rangeClientRect.width,\n        });\n    }\n    const mergedRects = mergeTouchingRects(originalRects, tolerance, doNotMergeHorizontallyAlignedRects);\n    const noContainedRects = removeContainedRects(mergedRects, tolerance);\n    const newRects = replaceOverlapingRects(noContainedRects);\n    const minArea = 2 * 2;\n    for (let j = newRects.length - 1; j >= 0; j--) {\n        const rect = newRects[j];\n        const bigEnough = (rect.width * rect.height) > minArea;\n        if (!bigEnough) {\n            if (newRects.length > 1) {\n                log(\"CLIENT RECT: remove small\");\n                newRects.splice(j, 1);\n            } else {\n                log(\"CLIENT RECT: remove small, but keep otherwise empty!\");\n                break;\n            }\n        }\n    }\n    log(`CLIENT RECT: reduced ${originalRects.length} --> ${newRects.length}`);\n    return newRects;\n}\n\nfunction mergeTouchingRects(rects, tolerance, doNotMergeHorizontallyAlignedRects) {\n    for (let i = 0; i < rects.length; i++) {\n        for (let j = i + 1; j < rects.length; j++) {\n            const rect1 = rects[i];\n            const rect2 = rects[j];\n            if (rect1 === rect2) {\n                log(\"mergeTouchingRects rect1 === rect2 ??!\");\n                continue;\n            }\n            const rectsLineUpVertically = almostEqual(rect1.top, rect2.top, tolerance) &&\n                almostEqual(rect1.bottom, rect2.bottom, tolerance);\n            const rectsLineUpHorizontally = almostEqual(rect1.left, rect2.left, tolerance) &&\n                almostEqual(rect1.right, rect2.right, tolerance);\n            const horizontalAllowed = !doNotMergeHorizontallyAlignedRects;\n            const aligned = (rectsLineUpHorizontally && horizontalAllowed) || (rectsLineUpVertically && !rectsLineUpHorizontally);\n            const canMerge = aligned && rectsTouchOrOverlap(rect1, rect2, tolerance);\n            if (canMerge) {\n                log(`CLIENT RECT: merging two into one, VERTICAL: ${rectsLineUpVertically} HORIZONTAL: ${rectsLineUpHorizontally} (${doNotMergeHorizontallyAlignedRects})`);\n                const newRects = rects.filter((rect) => {\n                    return rect !== rect1 && rect !== rect2;\n                });\n                const replacementClientRect = getBoundingRect(rect1, rect2);\n                newRects.push(replacementClientRect);\n                return mergeTouchingRects(newRects, tolerance, doNotMergeHorizontallyAlignedRects);\n            }\n        }\n    }\n    return rects;\n}\n\nfunction getBoundingRect(rect1, rect2) {\n    const left = Math.min(rect1.left, rect2.left);\n    const right = Math.max(rect1.right, rect2.right);\n    const top = Math.min(rect1.top, rect2.top);\n    const bottom = Math.max(rect1.bottom, rect2.bottom);\n    return {\n        bottom,\n        height: bottom - top,\n        left,\n        right,\n        top,\n        width: right - left,\n    };\n}\n\nfunction removeContainedRects(rects, tolerance) {\n    const rectsToKeep = new Set(rects);\n    for (const rect of rects) {\n        const bigEnough = rect.width > 1 && rect.height > 1;\n        if (!bigEnough) {\n            log(\"CLIENT RECT: remove tiny\");\n            rectsToKeep.delete(rect);\n            continue;\n        }\n        for (const possiblyContainingRect of rects) {\n            if (rect === possiblyContainingRect) {\n                continue;\n            }\n            if (!rectsToKeep.has(possiblyContainingRect)) {\n                continue;\n            }\n            if (rectContains(possiblyContainingRect, rect, tolerance)) {\n                log(\"CLIENT RECT: remove contained\");\n                rectsToKeep.delete(rect);\n                break;\n            }\n        }\n    }\n    return Array.from(rectsToKeep);\n}\n\nfunction rectContains(rect1, rect2, tolerance) {\n    return (rectContainsPoint(rect1, rect2.left, rect2.top, tolerance) &&\n        rectContainsPoint(rect1, rect2.right, rect2.top, tolerance) &&\n        rectContainsPoint(rect1, rect2.left, rect2.bottom, tolerance) &&\n        rectContainsPoint(rect1, rect2.right, rect2.bottom, tolerance));\n}\n\nfunction rectContainsPoint(rect, x, y, tolerance) {\n    return (rect.left < x || almostEqual(rect.left, x, tolerance)) &&\n        (rect.right > x || almostEqual(rect.right, x, tolerance)) &&\n        (rect.top < y || almostEqual(rect.top, y, tolerance)) &&\n        (rect.bottom > y || almostEqual(rect.bottom, y, tolerance));\n}\n\nfunction replaceOverlapingRects(rects) {\n    for (let i = 0; i < rects.length; i++) {\n        for (let j = i + 1; j < rects.length; j++) {\n            const rect1 = rects[i];\n            const rect2 = rects[j];\n            if (rect1 === rect2) {\n                log(\"replaceOverlapingRects rect1 === rect2 ??!\");\n                continue;\n            }\n            if (rectsTouchOrOverlap(rect1, rect2, -1)) {\n                let toAdd = [];\n                let toRemove;\n                let toPreserve;\n                const subtractRects1 = rectSubtract(rect1, rect2);\n                if (subtractRects1.length === 1) {\n                    toAdd = subtractRects1;\n                    toRemove = rect1;\n                    toPreserve = rect2;\n                } else {\n                    const subtractRects2 = rectSubtract(rect2, rect1);\n                    if (subtractRects1.length < subtractRects2.length) {\n                        toAdd = subtractRects1;\n                        toRemove = rect1;\n                        toPreserve = rect2;\n                    } else {\n                        toAdd = subtractRects2;\n                        toRemove = rect2;\n                        toPreserve = rect1;\n                    }\n                }\n                log(`CLIENT RECT: overlap, cut one rect into ${toAdd.length}`);\n                const newRects = rects.filter((rect) => {\n                    return rect !== toRemove;\n                });\n                Array.prototype.push.apply(newRects, toAdd);\n                return replaceOverlapingRects(newRects);\n            }\n        }\n    }\n    return rects;\n}\n\nfunction rectSubtract(rect1, rect2) {\n    const rectIntersected = rectIntersect(rect2, rect1);\n    if (rectIntersected.height === 0 || rectIntersected.width === 0) {\n        return [rect1];\n    }\n    const rects = [];\n    {\n        const rectA = {\n            bottom: rect1.bottom,\n            height: 0,\n            left: rect1.left,\n            right: rectIntersected.left,\n            top: rect1.top,\n            width: 0,\n        };\n        rectA.width = rectA.right - rectA.left;\n        rectA.height = rectA.bottom - rectA.top;\n        if (rectA.height !== 0 && rectA.width !== 0) {\n            rects.push(rectA);\n        }\n    }\n    {\n        const rectB = {\n            bottom: rectIntersected.top,\n            height: 0,\n            left: rectIntersected.left,\n            right: rectIntersected.right,\n            top: rect1.top,\n            width: 0,\n        };\n        rectB.width = rectB.right - rectB.left;\n        rectB.height = rectB.bottom - rectB.top;\n        if (rectB.height !== 0 && rectB.width !== 0) {\n            rects.push(rectB);\n        }\n    }\n    {\n        const rectC = {\n            bottom: rect1.bottom,\n            height: 0,\n            left: rectIntersected.left,\n            right: rectIntersected.right,\n            top: rectIntersected.bottom,\n            width: 0,\n        };\n        rectC.width = rectC.right - rectC.left;\n        rectC.height = rectC.bottom - rectC.top;\n        if (rectC.height !== 0 && rectC.width !== 0) {\n            rects.push(rectC);\n        }\n    }\n    {\n        const rectD = {\n            bottom: rect1.bottom,\n            height: 0,\n            left: rectIntersected.right,\n            right: rect1.right,\n            top: rect1.top,\n            width: 0,\n        };\n        rectD.width = rectD.right - rectD.left;\n        rectD.height = rectD.bottom - rectD.top;\n        if (rectD.height !== 0 && rectD.width !== 0) {\n            rects.push(rectD);\n        }\n    }\n    return rects;\n}\n\nfunction rectIntersect(rect1, rect2) {\n    const maxLeft = Math.max(rect1.left, rect2.left);\n    const minRight = Math.min(rect1.right, rect2.right);\n    const maxTop = Math.max(rect1.top, rect2.top);\n    const minBottom = Math.min(rect1.bottom, rect2.bottom);\n    return {\n        bottom: minBottom,\n        height: Math.max(0, minBottom - maxTop),\n        left: maxLeft,\n        right: minRight,\n        top: maxTop,\n        width: Math.max(0, minRight - maxLeft),\n    };\n}\n\nfunction rectsTouchOrOverlap(rect1, rect2, tolerance) {\n    return ((rect1.left < rect2.right || (tolerance >= 0 && almostEqual(rect1.left, rect2.right, tolerance))) &&\n        (rect2.left < rect1.right || (tolerance >= 0 && almostEqual(rect2.left, rect1.right, tolerance))) &&\n        (rect1.top < rect2.bottom || (tolerance >= 0 && almostEqual(rect1.top, rect2.bottom, tolerance))) &&\n        (rect2.top < rect1.bottom || (tolerance >= 0 && almostEqual(rect2.top, rect1.bottom, tolerance))));\n}\n\nfunction almostEqual(a, b, tolerance) {\n    return Math.abs(a - b) <= tolerance;\n}\n\nfunction log() {\n    if (debug) {\n        logNative.apply(null, arguments);\n    }\n}","//\n//  Copyright 2021 Readium Foundation. All rights reserved.\n//  Use of this source code is governed by the BSD-style license\n//  available in the top-level LICENSE file of the project.\n//\n\nimport {convertRangeInfo, location2RangeInfo} from \"./selection\";\nimport {getClientRectsNoOverlap} from \"./rect\";\n\nconst debug = false;\n\nconst ID_HIGHLIGHTS_CONTAINER = \"R2_ID_HIGHLIGHTS_CONTAINER\";\nconst CLASS_HIGHLIGHT_CONTAINER = \"R2_CLASS_HIGHLIGHT_CONTAINER\";\nconst CLASS_HIGHLIGHT_AREA = \"R2_CLASS_HIGHLIGHT_AREA\";\nconst CLASS_HIGHLIGHT_BOUNDING_AREA = \"R2_CLASS_HIGHLIGHT_BOUNDING_AREA\";\n\nconst _highlights = [];\nlet _highlightsContainer;\n\nconst defaultBackgroundOpacity = 0.3;\n\nconst defaultBackgroundColor = {\n    blue: 100,\n    green: 50,\n    red: 230,\n};\n\nexport function rectForHighlightWithID(id) {\n    const clientRects = frameForHighlightWithID(id);\n\n    return {\n        screenWidth: window.outerWidth,\n        screenHeight: window.outerHeight,\n        left: clientRects[0].left,\n        width: clientRects[0].width,\n        top: clientRects[0].top,\n        height: clientRects[0].height\n    };\n}\n\nexport function destroyAllHighlights() {\n    hideAllHighlights();\n    _highlights.splice(0, _highlights.length);\n}\n\nfunction hideAllHighlights() {\n    if (_highlightsContainer) {\n        _highlightsContainer.remove();\n        _highlightsContainer = null;\n    }\n}\n\nexport function createHighlight(selectionInfo, color, pointerInteraction) {\n    return _createHighlight(selectionInfo, color, pointerInteraction, ID_HIGHLIGHTS_CONTAINER)\n}\n\nfunction _createHighlight(locations, color, pointerInteraction, type) {\n    const rangeInfo = location2RangeInfo(locations)\n\n    // FIXME: Use user-provided ID.\n    let id = Date.now();\n    if (type === ID_HIGHLIGHTS_CONTAINER) {\n        id = \"R2_HIGHLIGHT_\" + id;\n    } else {\n        id = \"R2_ANNOTATION_\" + id;\n    }\n\n    destroyHighlight(id);\n\n    const highlight = {\n        color: color ? color : defaultBackgroundColor,\n        id,\n        pointerInteraction,\n        rangeInfo\n    };\n    _highlights.push(highlight);\n    createHighlightDom(window, highlight);\n\n    return highlight;\n}\n\nfunction destroyHighlight(id) {\n    let i = -1;\n    let _document = window.document\n    const highlight = _highlights.find((h, j) => {\n        i = j;\n        return h.id === id;\n    });\n    if (highlight && i >= 0 && i < _highlights.length) {\n        _highlights.splice(i, 1);\n    }\n    const highlightContainer = _document.getElementById(id);\n    if (highlightContainer) {\n        highlightContainer.remove();\n    }\n}\n\nfunction createHighlightDom(win, highlight) {\n\n    const document = win.document;\n\n    const scale = 1 / ((win.READIUM2 && win.READIUM2.isFixedLayout) ? win.READIUM2.fxlViewportScale : 1);\n\n    const scrollElement = document.scrollingElement;\n\n    const range = convertRangeInfo(document, highlight.rangeInfo);\n    if (!range) {\n        return undefined;\n    }\n\n    const paginated = !isScrollModeEnabled()\n    const highlightsContainer = ensureContainer(win);\n    const highlightParent = document.createElement(\"div\");\n\n    highlightParent.setAttribute(\"id\", highlight.id);\n    highlightParent.setAttribute(\"class\", CLASS_HIGHLIGHT_CONTAINER);\n\n    highlightParent.style.setProperty(\"pointer-events\", \"none\");\n    if (highlight.pointerInteraction) {\n        highlightParent.setAttribute(\"data-click\", \"1\");\n    }\n\n    const bodyRect = document.body.getBoundingClientRect();\n    const drawUnderline = false;\n    const drawStrikeThrough = false;\n    const doNotMergeHorizontallyAlignedRects = drawUnderline || drawStrikeThrough;\n    const clientRects = getClientRectsNoOverlap(range, doNotMergeHorizontallyAlignedRects);\n    const roundedCorner = 3;\n    const underlineThickness = 2;\n    const strikeThroughLineThickness = 3;\n    const opacity = defaultBackgroundOpacity;\n    let extra = \"\";\n\n    let xOffset;\n    let yOffset;\n\n    // if (navigator.userAgent.match(/Android/i)) {\n    xOffset = paginated ? (-scrollElement.scrollLeft) : bodyRect.left;\n    yOffset = paginated ? (-scrollElement.scrollTop) : bodyRect.top;\n    // } else if (navigator.userAgent.match(/iPhone|iPad|iPod/i)) {\n    //     xOffset = paginated ? 0 : (-scrollElement.scrollLeft);\n    //     yOffset = paginated ? 0 : (bodyRect.top);\n    //     annotationOffset = parseInt((rangeAnnotationBoundingClientRect.right/window.innerWidth) + 1);\n    // }\n\n    for (const clientRect of clientRects) {\n        const highlightArea = document.createElement(\"div\");\n\n        highlightArea.setAttribute(\"class\", CLASS_HIGHLIGHT_AREA);\n\n        if (debug) {\n            const rgb = Math.round(0xffffff * Math.random());\n            const r = rgb >> 16;\n            const g = rgb >> 8 & 255;\n            const b = rgb & 255;\n            extra = `outline-color: rgb(${r}, ${g}, ${b}); outline-style: solid; outline-width: 1px; outline-offset: -1px;`;\n        } else {\n            if (drawUnderline) {\n                extra += `border-bottom: ${underlineThickness * scale}px solid rgba(${highlight.color.red}, ${highlight.color.green}, ${highlight.color.blue}, ${opacity}) !important`;\n            }\n        }\n        highlightArea.setAttribute(\"style\", `border-radius: ${roundedCorner}px !important; background-color: rgba(${highlight.color.red}, ${highlight.color.green}, ${highlight.color.blue}, ${opacity}) !important; ${extra}`);\n        highlightArea.style.setProperty(\"pointer-events\", \"none\");\n        highlightArea.style.position = !paginated ? \"fixed\" : \"absolute\";\n        highlightArea.scale = scale;\n        /*\n         highlightArea.rect = {\n         height: clientRect.height,\n         left: clientRect.left - xOffset,\n         top: clientRect.top - yOffset,\n         width: clientRect.width,\n         };\n         */\n        highlightArea.rect = {\n            height: clientRect.height,\n            left: clientRect.left - xOffset,\n            top: clientRect.top - yOffset,\n            width: clientRect.width\n        };\n\n        highlightArea.style.width = `${highlightArea.rect.width * scale}px`;\n        highlightArea.style.height = `${highlightArea.rect.height * scale}px`;\n        highlightArea.style.left = `${highlightArea.rect.left * scale}px`;\n        highlightArea.style.top = `${highlightArea.rect.top * scale}px`;\n        highlightParent.append(highlightArea);\n        if (!debug && drawStrikeThrough) {\n            //if (drawStrikeThrough) {\n            const highlightAreaLine = document.createElement(\"div\");\n            highlightAreaLine.setAttribute(\"class\", CLASS_HIGHLIGHT_AREA);\n\n            highlightAreaLine.setAttribute(\"style\", `background-color: rgba(${highlight.color.red}, ${highlight.color.green}, ${highlight.color.blue}, ${opacity}) !important;`);\n            highlightAreaLine.style.setProperty(\"pointer-events\", \"none\");\n            highlightAreaLine.style.position = paginated ? \"fixed\" : \"absolute\";\n            highlightAreaLine.scale = scale;\n            /*\n             highlightAreaLine.rect = {\n             height: clientRect.height,\n             left: clientRect.left - xOffset,\n             top: clientRect.top - yOffset,\n             width: clientRect.width,\n             };\n             */\n\n            highlightAreaLine.rect = {\n                height: clientRect.height,\n                left: clientRect.left - xOffset,\n                top: clientRect.top - yOffset,\n                width: clientRect.width\n            };\n\n            highlightAreaLine.style.width = `${highlightAreaLine.rect.width * scale}px`;\n            highlightAreaLine.style.height = `${strikeThroughLineThickness * scale}px`;\n            highlightAreaLine.style.left = `${highlightAreaLine.rect.left * scale}px`;\n            highlightAreaLine.style.top = `${(highlightAreaLine.rect.top + (highlightAreaLine.rect.height / 2) - (strikeThroughLineThickness / 2)) * scale}px`;\n            highlightParent.append(highlightAreaLine);\n        }\n    }\n\n    const highlightBounding = document.createElement(\"div\");\n    highlightBounding.setAttribute(\"class\", CLASS_HIGHLIGHT_BOUNDING_AREA);\n\n    highlightBounding.style.setProperty(\"pointer-events\", \"none\");\n    highlightBounding.style.position = paginated ? \"fixed\" : \"absolute\";\n    highlightBounding.scale = scale;\n\n    if (debug) {\n        highlightBounding.setAttribute(\"style\", `outline-color: magenta; outline-style: solid; outline-width: 1px; outline-offset: -1px;`);\n    }\n\n    const rangeBoundingClientRect = range.getBoundingClientRect();\n    highlightBounding.rect = {\n        height: rangeBoundingClientRect.height,\n        left: rangeBoundingClientRect.left - xOffset,\n        top: rangeBoundingClientRect.top - yOffset,\n        width: rangeBoundingClientRect.width\n    };\n\n    highlightBounding.style.width = `${highlightBounding.rect.width * scale}px`;\n    highlightBounding.style.height = `${highlightBounding.rect.height * scale}px`;\n    highlightBounding.style.left = `${highlightBounding.rect.left * scale}px`;\n    highlightBounding.style.top = `${highlightBounding.rect.top * scale}px`;\n\n    highlightParent.append(highlightBounding);\n    highlightsContainer.append(highlightParent);\n\n    return highlightParent;\n}\n\nfunction isScrollModeEnabled() {\n    return document.documentElement.style.getPropertyValue(\"--USER__scroll\").toString().trim() === 'readium-scroll-on';\n}\n\nfunction ensureContainer(win) {\n    const document = win.document;\n\n    if (!_highlightsContainer) {\n        _highlightsContainer = document.createElement(\"div\");\n        _highlightsContainer.setAttribute(\"id\", ID_HIGHLIGHTS_CONTAINER);\n\n        _highlightsContainer.style.setProperty(\"pointer-events\", \"none\");\n        document.body.append(_highlightsContainer);\n    }\n\n    return _highlightsContainer;\n}\n\nfunction frameForHighlightWithID(id) {\n    const highlight = highlightWithID(id);\n    if (!highlight)\n        return;\n\n    const document = window.document;\n    const range = convertRangeInfo(document, highlight.rangeInfo);\n    if (!range) {\n        return undefined;\n    }\n\n\n    const drawUnderline = false;\n    const drawStrikeThrough = false;\n    const doNotMergeHorizontallyAlignedRects = drawUnderline || drawStrikeThrough;\n    return getClientRectsNoOverlap(range, doNotMergeHorizontallyAlignedRects);\n}\n\nfunction highlightWithID(id) {\n    let i = -1;\n    return _highlights.find((h, j) => {\n        i = j;\n        return h.id === id;\n    })\n}","//\n//  Copyright 2021 Readium Foundation. All rights reserved.\n//  Use of this source code is governed by the BSD-style license\n//  available in the top-level LICENSE file of the project.\n//\n\n// Base script used by both reflowable and fixed layout resources.\n\nimport './gestures'\nimport {removeProperty, scrollLeft, scrollRight, scrollToId, scrollToPosition, scrollToText, setProperty} from \"./utils\";\nimport {getCurrentSelectionInfo, getSelectionRect} from \"./selection\";\nimport {createHighlight} from \"./highlight\";\n\n\n// Public API used by the navigator.\nwindow.readium = {\n    // utils\n    'scrollToId': scrollToId,\n    'scrollToPosition': scrollToPosition,\n    'scrollToText': scrollToText,\n    'scrollLeft': scrollLeft,\n    'scrollRight': scrollRight,\n    'setProperty': setProperty,\n    'removeProperty': removeProperty,\n\n    // selection\n    'getSelectionRect': getSelectionRect,\n    'getCurrentSelectionInfo': getCurrentSelectionInfo,\n\n    // highlights\n    'createHighlight': createHighlight,\n};","//\n//  Copyright 2021 Readium Foundation. All rights reserved.\n//  Use of this source code is governed by the BSD-style license\n//  available in the top-level LICENSE file of the project.\n//\n\n// Script used for reflowable resources.\n\nimport './index'\n\nwindow.addEventListener(\"load\", function() {\n  // Notifies native code that the page is loaded after it is rendered.\n  // Waiting for the next animation frame seems to do the trick to make sure the page is fully rendered.\n  window.requestAnimationFrame(function() {\n    webkit.messageHandlers.spreadLoaded.postMessage({});\n  });\n\n  // Setups the `viewport` meta tag to disable zooming.\n  let meta = document.createElement(\"meta\");\n  meta.setAttribute(\"name\", \"viewport\");\n  meta.setAttribute(\"content\", \"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no\");\n  document.head.appendChild(meta);\n});\n\n// Injects Readium CSS stylesheets.\ndocument.addEventListener('DOMContentLoaded', function() {\n  function createLink(name) {\n    var link = document.createElement('link');\n    link.setAttribute('rel', 'stylesheet');\n    link.setAttribute('type', 'text/css');\n    link.setAttribute('href', '${readiumCSSBaseURL}' + name + '.css');\n    return link;\n  }\n\n  var head = document.getElementsByTagName('head')[0];\n  head.appendChild(createLink('ReadiumCSS-after'));\n  head.insertBefore(createLink('ReadiumCSS-before'), head.children[0]);\n});\n"],"sourceRoot":""}