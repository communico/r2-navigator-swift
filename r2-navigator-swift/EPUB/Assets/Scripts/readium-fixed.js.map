{"version":3,"sources":["webpack://readium-js/./node_modules/approx-string-match/dist/index.js","webpack://readium-js/./src/gestures.js","webpack://readium-js/webpack/bootstrap","webpack://readium-js/./src/utils.js","webpack://readium-js/./src/selection.js","webpack://readium-js/./src/rect.js","webpack://readium-js/./src/highlight.js","webpack://readium-js/./src/vendor/hypothesis/anchoring/match-quote.js","webpack://readium-js/./src/vendor/hypothesis/anchoring/text-range.js","webpack://readium-js/./src/vendor/hypothesis/anchoring/types.js","webpack://readium-js/./src/index.js"],"names":["reverse","s","split","join","oneIfNotZero","n","advanceBlock","ctx","peq","b","hIn","pV","P","mV","M","hInIsNegative","eq","xV","xH","pH","mH","hOut","lastRowMask","findMatchEnds","text","pattern","maxErrors","length","Math","min","matches","w","bMax","ceil","Uint32Array","fill","emptyPeq","Map","asciiPeq","i","push","c","val","charCodeAt","has","charPeq","set","r","idx","y","max","score","j","charCode","get","carry","maxBlockScore","splice","start","end","errors","exports","patRev","map","m","minStart","slice","reduce","rm","findMatchStarts","onClick","event","window","getSelection","isCollapsed","webkit","messageHandlers","tap","postMessage","defaultPrevented","screenX","screenY","clientX","clientY","target","outerHTML","nearestInteractiveElement","element","indexOf","nodeName","toLowerCase","hasAttribute","getAttribute","parentElement","addEventListener","document","body","style","cursor","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","module","__webpack_modules__","logError","message","filename","lineno","orientationChanged","snapCurrentPosition","func","timeout","last_known_scrollX_position","last_known_scrollY_position","ticking","maxScreenX","orientation","screen","width","height","isScrollModeEnabled","documentElement","getPropertyValue","toString","trim","scrollToOffset","offset","currentOffset","scrollX","pageWidth","innerWidth","scrollingElement","scrollLeft","abs","snapOffset","value","currentOffsetSnapped","log","Array","prototype","call","arguments","createOrderedRange","startNode","startOffset","endNode","endOffset","range","Range","setStart","setEnd","collapsed","rangeReverse","rangeInfo2Location","rangeInfo","cssSelector","startContainerElementCssSelector","domRange","textNodeIndex","startContainerChildTextNodeIndex","endContainerElementCssSelector","endContainerChildTextNodeIndex","fullQualifiedSelector","node","nodeType","Node","ELEMENT_NODE","localName","optimized","steps","contextNode","step","_cssPathStep","parentNode","cssPath","isTargetNode","idSelector","idd","escapeIdentifierIfNeeded","ident","test","shouldEscapeFirst","lastIndex","replace","ii","isCSSIdentChar","isLast","hexByte","toHexByte","escapeAsciiChar","prefixedElementClassNames","nd","classAttribute","filter","Boolean","nm","lowerCaseName","id","parent","DOCUMENT_NODE","prefixedOwnClassNamesArray_","prefixedOwnClassNamesArray","forEach","arrItem","needsClassNames","needsNthChild","ownIndex","elementIndex","siblings","children","sibling","ownClassNames","ownClassNameCount","siblingClassNamesArray_","siblingClassNamesArray","siblingClass","ind","result","prefixedName","substr","doNotMergeHorizontallyAlignedRects","clientRects","getClientRects","originalRects","rangeClientRect","bottom","left","right","top","newRects","replaceOverlapingRects","rects","tolerance","rectsToKeep","Set","rect","possiblyContainingRect","rectContains","delete","from","removeContainedRects","mergeTouchingRects","rect1","rect2","rectsLineUpVertically","almostEqual","rectsLineUpHorizontally","horizontalAllowed","rectsTouchOrOverlap","replacementClientRect","getBoundingRect","rectContainsPoint","x","toRemove","toPreserve","toAdd","subtractRects1","rectSubtract","subtractRects2","apply","rectIntersected","maxLeft","minRight","maxTop","minBottom","rectIntersect","rectA","rectB","rectC","rectD","a","e","scrollY","scrollHeight","scrollWidth","requestAnimationFrame","positionString","progressionChanged","info","selection","rangeCount","getRangeAt","getBoundingClientRect","selectionChanged","self","this","args","callback","clearTimeout","setTimeout","_highlights","_highlightsContainer","defaultBackgroundColor","blue","green","red","destroyHighlight","_document","find","h","highlightContainer","getElementById","remove","createHighlightFromRange","highlight","scale","READIUM2","isFixedLayout","fxlViewportScale","scrollElement","paginated","highlightsContainer","win","createElement","setAttribute","setProperty","append","ensureContainer","highlightParent","pointerInteraction","bodyRect","xOffset","yOffset","scrollTop","clientRect","highlightArea","color","position","highlightBounding","rangeBoundingClientRect","search","str","matchPos","exactMatches","textMatchScore","nodeTextLength","TEXT_NODE","previousSiblingsTextLength","previousSibling","resolveOffsets","offsets","nextOffset","shift","nodeIter","createNodeIterator","NodeFilter","SHOW_TEXT","results","textNode","currentNode","nextNode","data","RangeError","Error","contains","el","options","err","direction","tw","createTreeWalker","getRootNode","forwards","previousNode","fromPoint","textOffset","childNodes","relativeTo","resolve","startContainer","endContainer","root","TextPositionAnchor","textRange","selector","type","toRange","TextQuoteAnchor","exact","context","prefix","suffix","toPositionAnchor","match","quote","scoreMatch","quoteScore","prefixScore","suffixScore","posScore","hint","quoteWeight","scoredMatches","sort","matchQuote","readium","scrollIntoView","dir","console","Selection","markedRanges","removeWhitespaces","clear","removeAllRanges","mark","reset","addRange","adjust","modify","isEmpty","getFirstRange","before","snippet","after","safeSnippet","found","safeSelection","includes","innerHeight","isRTL","documentWidth","minOffset","maxOffset","key","removeProperty","sel","screenWidth","outerWidth","screenHeight","outerHeight","logException","rawText","anchorNode","focusNode","anchorOffset","focusOffset","getCssSelector","startIsElement","startContainerElement","endIsElement","endContainerElement","commonElementAncestor","node1","node2","node1ElementAncestorChain","node2ElementAncestorChain","commonAncestor","node1ElementAncestor","node2ElementAncestor","getCommonAncestorElement","commonAncestorContainer","rangeCommonAncestorElement","convertRange","locations","location","location2RangeInfo","Date","now","startElement","querySelector","endElement","createHighlightDom"],"mappings":"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","file":"readium-fixed.js","sourcesContent":["\"use strict\";\n/**\n * Implementation of Myers' online approximate string matching algorithm [1],\n * with additional optimizations suggested by [2].\n *\n * This has O((k/w) * n) complexity where `n` is the length of the text, `k` is\n * the maximum number of errors allowed (always <= the pattern length) and `w`\n * is the word size. Because JS only supports bitwise operations on 32 bit\n * integers, `w` is 32.\n *\n * As far as I am aware, there aren't any online algorithms which are\n * significantly better for a wide range of input parameters. The problem can be\n * solved faster using \"filter then verify\" approaches which first filter out\n * regions of the text that cannot match using a \"cheap\" check and then verify\n * the remaining potential matches. The verify step requires an algorithm such\n * as this one however.\n *\n * The algorithm's approach is essentially to optimize the classic dynamic\n * programming solution to the problem by computing columns of the matrix in\n * word-sized chunks (ie. dealing with 32 chars of the pattern at a time) and\n * avoiding calculating regions of the matrix where the minimum error count is\n * guaranteed to exceed the input threshold.\n *\n * The paper consists of two parts, the first describes the core algorithm for\n * matching patterns <= the size of a word (implemented by `advanceBlock` here).\n * The second uses the core algorithm as part of a larger block-based algorithm\n * to handle longer patterns.\n *\n * [1] G. Myers, “A Fast Bit-Vector Algorithm for Approximate String Matching\n * Based on Dynamic Programming,” vol. 46, no. 3, pp. 395–415, 1999.\n *\n * [2] Šošić, M. (2014). An simd dynamic programming c/c++ library (Doctoral\n * dissertation, Fakultet Elektrotehnike i računarstva, Sveučilište u Zagrebu).\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction reverse(s) {\n    return s\n        .split(\"\")\n        .reverse()\n        .join(\"\");\n}\n/**\n * Given the ends of approximate matches for `pattern` in `text`, find\n * the start of the matches.\n *\n * @param findEndFn - Function for finding the end of matches in\n * text.\n * @return Matches with the `start` property set.\n */\nfunction findMatchStarts(text, pattern, matches) {\n    var patRev = reverse(pattern);\n    return matches.map(function (m) {\n        // Find start of each match by reversing the pattern and matching segment\n        // of text and searching for an approx match with the same number of\n        // errors.\n        var minStart = Math.max(0, m.end - pattern.length - m.errors);\n        var textRev = reverse(text.slice(minStart, m.end));\n        // If there are multiple possible start points, choose the one that\n        // maximizes the length of the match.\n        var start = findMatchEnds(textRev, patRev, m.errors).reduce(function (min, rm) {\n            if (m.end - rm.end < min) {\n                return m.end - rm.end;\n            }\n            return min;\n        }, m.end);\n        return {\n            start: start,\n            end: m.end,\n            errors: m.errors\n        };\n    });\n}\n/**\n * Return 1 if a number is non-zero or zero otherwise, without using\n * conditional operators.\n *\n * This should get inlined into `advanceBlock` below by the JIT.\n *\n * Adapted from https://stackoverflow.com/a/3912218/434243\n */\nfunction oneIfNotZero(n) {\n    return ((n | -n) >> 31) & 1;\n}\n/**\n * Block calculation step of the algorithm.\n *\n * From Fig 8. on p. 408 of [1], additionally optimized to replace conditional\n * checks with bitwise operations as per Section 4.2.3 of [2].\n *\n * @param ctx - The pattern context object\n * @param peq - The `peq` array for the current character (`ctx.peq.get(ch)`)\n * @param b - The block level\n * @param hIn - Horizontal input delta ∈ {1,0,-1}\n * @return Horizontal output delta ∈ {1,0,-1}\n */\nfunction advanceBlock(ctx, peq, b, hIn) {\n    var pV = ctx.P[b];\n    var mV = ctx.M[b];\n    var hInIsNegative = hIn >>> 31; // 1 if hIn < 0 or 0 otherwise.\n    var eq = peq[b] | hInIsNegative;\n    // Step 1: Compute horizontal deltas.\n    var xV = eq | mV;\n    var xH = (((eq & pV) + pV) ^ pV) | eq;\n    var pH = mV | ~(xH | pV);\n    var mH = pV & xH;\n    // Step 2: Update score (value of last row of this block).\n    var hOut = oneIfNotZero(pH & ctx.lastRowMask[b]) -\n        oneIfNotZero(mH & ctx.lastRowMask[b]);\n    // Step 3: Update vertical deltas for use when processing next char.\n    pH <<= 1;\n    mH <<= 1;\n    mH |= hInIsNegative;\n    pH |= oneIfNotZero(hIn) - hInIsNegative; // set pH[0] if hIn > 0\n    pV = mH | ~(xV | pH);\n    mV = pH & xV;\n    ctx.P[b] = pV;\n    ctx.M[b] = mV;\n    return hOut;\n}\n/**\n * Find the ends and error counts for matches of `pattern` in `text`.\n *\n * Only the matches with the lowest error count are reported. Other matches\n * with error counts <= maxErrors are discarded.\n *\n * This is the block-based search algorithm from Fig. 9 on p.410 of [1].\n */\nfunction findMatchEnds(text, pattern, maxErrors) {\n    if (pattern.length === 0) {\n        return [];\n    }\n    // Clamp error count so we can rely on the `maxErrors` and `pattern.length`\n    // rows being in the same block below.\n    maxErrors = Math.min(maxErrors, pattern.length);\n    var matches = [];\n    // Word size.\n    var w = 32;\n    // Index of maximum block level.\n    var bMax = Math.ceil(pattern.length / w) - 1;\n    // Context used across block calculations.\n    var ctx = {\n        P: new Uint32Array(bMax + 1),\n        M: new Uint32Array(bMax + 1),\n        lastRowMask: new Uint32Array(bMax + 1)\n    };\n    ctx.lastRowMask.fill(1 << 31);\n    ctx.lastRowMask[bMax] = 1 << (pattern.length - 1) % w;\n    // Dummy \"peq\" array for chars in the text which do not occur in the pattern.\n    var emptyPeq = new Uint32Array(bMax + 1);\n    // Map of UTF-16 character code to bit vector indicating positions in the\n    // pattern that equal that character.\n    var peq = new Map();\n    // Version of `peq` that only stores mappings for small characters. This\n    // allows faster lookups when iterating through the text because a simple\n    // array lookup can be done instead of a hash table lookup.\n    var asciiPeq = [];\n    for (var i = 0; i < 256; i++) {\n        asciiPeq.push(emptyPeq);\n    }\n    // Calculate `ctx.peq` - a map of character values to bitmasks indicating\n    // positions of that character within the pattern, where each bit represents\n    // a position in the pattern.\n    for (var c = 0; c < pattern.length; c += 1) {\n        var val = pattern.charCodeAt(c);\n        if (peq.has(val)) {\n            // Duplicate char in pattern.\n            continue;\n        }\n        var charPeq = new Uint32Array(bMax + 1);\n        peq.set(val, charPeq);\n        if (val < asciiPeq.length) {\n            asciiPeq[val] = charPeq;\n        }\n        for (var b = 0; b <= bMax; b += 1) {\n            charPeq[b] = 0;\n            // Set all the bits where the pattern matches the current char (ch).\n            // For indexes beyond the end of the pattern, always set the bit as if the\n            // pattern contained a wildcard char in that position.\n            for (var r = 0; r < w; r += 1) {\n                var idx = b * w + r;\n                if (idx >= pattern.length) {\n                    continue;\n                }\n                var match = pattern.charCodeAt(idx) === val;\n                if (match) {\n                    charPeq[b] |= 1 << r;\n                }\n            }\n        }\n    }\n    // Index of last-active block level in the column.\n    var y = Math.max(0, Math.ceil(maxErrors / w) - 1);\n    // Initialize maximum error count at bottom of each block.\n    var score = new Uint32Array(bMax + 1);\n    for (var b = 0; b <= y; b += 1) {\n        score[b] = (b + 1) * w;\n    }\n    score[bMax] = pattern.length;\n    // Initialize vertical deltas for each block.\n    for (var b = 0; b <= y; b += 1) {\n        ctx.P[b] = ~0;\n        ctx.M[b] = 0;\n    }\n    // Process each char of the text, computing the error count for `w` chars of\n    // the pattern at a time.\n    for (var j = 0; j < text.length; j += 1) {\n        // Lookup the bitmask representing the positions of the current char from\n        // the text within the pattern.\n        var charCode = text.charCodeAt(j);\n        var charPeq = void 0;\n        if (charCode < asciiPeq.length) {\n            // Fast array lookup.\n            charPeq = asciiPeq[charCode];\n        }\n        else {\n            // Slower hash table lookup.\n            charPeq = peq.get(charCode);\n            if (typeof charPeq === \"undefined\") {\n                charPeq = emptyPeq;\n            }\n        }\n        // Calculate error count for blocks that we definitely have to process for\n        // this column.\n        var carry = 0;\n        for (var b = 0; b <= y; b += 1) {\n            carry = advanceBlock(ctx, charPeq, b, carry);\n            score[b] += carry;\n        }\n        // Check if we also need to compute an additional block, or if we can reduce\n        // the number of blocks processed for the next column.\n        if (score[y] - carry <= maxErrors &&\n            y < bMax &&\n            (charPeq[y + 1] & 1 || carry < 0)) {\n            // Error count for bottom block is under threshold, increase the number of\n            // blocks processed for this column & next by 1.\n            y += 1;\n            ctx.P[y] = ~0;\n            ctx.M[y] = 0;\n            var maxBlockScore = y === bMax ? pattern.length % w : w;\n            score[y] =\n                score[y - 1] +\n                    maxBlockScore -\n                    carry +\n                    advanceBlock(ctx, charPeq, y, carry);\n        }\n        else {\n            // Error count for bottom block exceeds threshold, reduce the number of\n            // blocks processed for the next column.\n            while (y > 0 && score[y] >= maxErrors + w) {\n                y -= 1;\n            }\n        }\n        // If error count is under threshold, report a match.\n        if (y === bMax && score[y] <= maxErrors) {\n            if (score[y] < maxErrors) {\n                // Discard any earlier, worse matches.\n                matches.splice(0, matches.length);\n            }\n            matches.push({\n                start: -1,\n                end: j + 1,\n                errors: score[y]\n            });\n            // Because `search` only reports the matches with the lowest error count,\n            // we can \"ratchet down\" the max error threshold whenever a match is\n            // encountered and thereby save a small amount of work for the remainder\n            // of the text.\n            maxErrors = score[y];\n        }\n    }\n    return matches;\n}\n/**\n * Search for matches for `pattern` in `text` allowing up to `maxErrors` errors.\n *\n * Returns the start, and end positions and error counts for each lowest-cost\n * match. Only the \"best\" matches are returned.\n */\nfunction search(text, pattern, maxErrors) {\n    var matches = findMatchEnds(text, pattern, maxErrors);\n    return findMatchStarts(text, pattern, matches);\n}\nexports.default = search;\n","//\n//  Copyright 2021 Readium Foundation. All rights reserved.\n//  Use of this source code is governed by the BSD-style license\n//  available in the top-level LICENSE file of the project.\n//\n\nwindow.addEventListener('DOMContentLoaded', function(event) {\n  // If we don't set the CSS cursor property to pointer, then the click events are not triggered pre-iOS 13.\n  document.body.style.cursor = 'pointer';\n\n  document.addEventListener('click', onClick, false);\n});\n\nfunction onClick(event) {\n\n  if (!window.getSelection().isCollapsed) {\n    // There's an on-going selection, the tap will dismiss it so we don't forward it.\n    return;\n  }\n\n  // Send the tap data over the JS bridge even if it's been handled\n  // within the webview, so that it can be preserved and used\n  // by the WKNavigationDelegate if needed.\n  webkit.messageHandlers.tap.postMessage({\n    \"defaultPrevented\": event.defaultPrevented,\n    \"screenX\": event.screenX,\n    \"screenY\": event.screenY,\n    \"clientX\": event.clientX,\n    \"clientY\": event.clientY,\n    \"targetElement\": event.target.outerHTML,\n    \"interactiveElement\": nearestInteractiveElement(event.target),\n  });\n\n  // We don't want to disable the default WebView behavior as it breaks some features without bringing any value.\n//    event.stopPropagation();\n//    event.preventDefault();\n}\n\n// See. https://github.com/JayPanoz/architecture/tree/touch-handling/misc/touch-handling\nfunction nearestInteractiveElement(element) {\n  var interactiveTags = [\n    'a',\n    'audio',\n    'button',\n    'canvas',\n    'details',\n    'input',\n    'label',\n    'option',\n    'select',\n    'submit',\n    'textarea',\n    'video',\n  ]\n  if (interactiveTags.indexOf(element.nodeName.toLowerCase()) !== -1) {\n    return element.outerHTML;\n  }\n\n  // Checks whether the element is editable by the user.\n  if (element.hasAttribute('contenteditable') && element.getAttribute('contenteditable').toLowerCase() != 'false') {\n    return element.outerHTML;\n  }\n\n  // Checks parents recursively because the touch might be for example on an <em> inside a <a>.\n  if (element.parentElement) {\n    return nearestInteractiveElement(element.parentElement);\n  }\n\n  return null;\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","//\n//  Copyright 2021 Readium Foundation. All rights reserved.\n//  Use of this source code is governed by the BSD-style license\n//  available in the top-level LICENSE file of the project.\n//\n\n// Catch JS errors to log them in the app.\n\nwindow.addEventListener(\"error\", function(event) {\n    webkit.messageHandlers.logError.postMessage({\n        \"message\": event.message,\n        \"filename\": event.filename,\n        \"line\": event.lineno\n    });\n}, false);\n\n// Notify native code that the page has loaded.\nwindow.addEventListener(\"load\", function(){ // on page load\n    window.addEventListener(\"orientationchange\", function() {\n        orientationChanged();\n        snapCurrentPosition();\n    });\n    orientationChanged();\n}, false);\n\nvar last_known_scrollX_position = 0;\nvar last_known_scrollY_position = 0;\nvar ticking = false;\nvar maxScreenX = 0;\n\n// Position in range [0 - 1].\nfunction update(position) {\n    var positionString = position.toString()\n    webkit.messageHandlers.progressionChanged.postMessage(positionString);\n}\n\nwindow.addEventListener('scroll', function(e) {\n    last_known_scrollY_position = window.scrollY / document.scrollingElement.scrollHeight;\n    // Using Math.abs because for RTL books, the value will be negative.\n    last_known_scrollX_position = Math.abs(window.scrollX / document.scrollingElement.scrollWidth);\n\n    // Window is hidden\n    if (document.scrollingElement.scrollWidth === 0 || document.scrollingElement.scrollHeight === 0) {\n        return;\n    }\n\n    if (!ticking) {\n        window.requestAnimationFrame(function() {\n            update(isScrollModeEnabled() ? last_known_scrollY_position : last_known_scrollX_position);\n            ticking = false;\n        });\n    }\n    ticking = true;\n});\n\ndocument.addEventListener('selectionchange', debounce(50, function() {\n    var info = {}\n    var selection = document.getSelection();\n    if (selection && selection.rangeCount > 0) {\n        var rect = selection.getRangeAt(0).getBoundingClientRect();\n        info['text'] = selection.toString().trim();\n        info['frame'] = {\n            'x': rect.left,\n            'y': rect.top,\n            'width': rect.width,\n            'height': rect.height\n        };\n    }\n\n    webkit.messageHandlers.selectionChanged.postMessage(info);\n}));\n\nfunction orientationChanged() {\n    maxScreenX = (window.orientation === 0 || window.orientation == 180) ? screen.width : screen.height;\n}\n\nfunction isScrollModeEnabled() {\n    return document.documentElement.style.getPropertyValue(\"--USER__scroll\").toString().trim() === 'readium-scroll-on';\n}\n\n// Scroll to the given TagId in document and snap.\nexport function scrollToId(id) {\n    var element = document.getElementById(id);\n    if (!element) {\n        return false;\n    }\n    element.scrollIntoView();\n\n    if (!isScrollModeEnabled()) {\n        var currentOffset = window.scrollX;\n        var pageWidth = window.innerWidth;\n        // Adds half a page to make sure we don't snap to the previous page.\n        document.scrollingElement.scrollLeft = snapOffset(currentOffset + (pageWidth / 2));\n    }\n    return true;\n}\n\n// Position must be in the range [0 - 1], 0-100%.\nexport function scrollToPosition(position, dir) {\n    console.log(\"ScrollToPosition\");\n    if ((position < 0) || (position > 1)) {\n        console.log(\"InvalidPosition\");\n        return;\n    }\n\n    if (isScrollModeEnabled()) {\n        var offset = document.scrollingElement.scrollHeight * position;\n        document.scrollingElement.scrollTop = offset;\n        // window.scrollTo(0, offset);\n    } else {\n        var documentWidth = document.scrollingElement.scrollWidth;\n        var factor = (dir == 'rtl') ? -1 : 1;\n        var offset = documentWidth * position * factor;\n        document.scrollingElement.scrollLeft = snapOffset(offset);\n    }\n}\n\n// Scrolls to the first occurrence of the given text snippet.\n//\n// The expected text argument is a Locator Text object, as defined here:\n// https://readium.org/architecture/models/locators/\nexport function scrollToText(text) {\n    // Wrapper around a browser Selection object.\n    function Selection(selection) {\n        this.selection = selection;\n        this.markedRanges = []\n    }\n\n    // Removes all the ranges of the selection.\n    Selection.prototype.clear = function() {\n        this.selection.removeAllRanges();\n    }\n\n    // Saves the current selection ranges, to be restored later with reset().\n    Selection.prototype.mark = function() {\n        this.markedRanges = []\n        for (var i = 0; i < this.selection.rangeCount; i++) {\n            this.markedRanges.push(this.selection.getRangeAt(i));\n        }\n    }\n\n    // Resets the selection with ranges previously saved with mark().\n    Selection.prototype.reset = function() {\n        this.clear();\n        for (var i = 0; i < this.markedRanges.length; i++) {\n            this.selection.addRange(this.markedRanges[i]);\n        }\n    }\n\n    // Returns the text content of the selection.\n    Selection.prototype.toString = function() {\n        return this.selection.toString();\n    }\n\n    // Extends the selection by moving the start and end positions by the given offsets.\n    Selection.prototype.adjust = function(offset, length) {\n        for (var i = 0; i <= Math.abs(offset); i++) {\n            var direction = (offset >= 0 ? \"forward\" : \"backward\")\n            this.selection.modify(\"move\", direction, \"character\");\n        }\n        for (var i = 0; i <= length; i++) {\n            this.selection.modify(\"extend\", \"forward\", \"character\");\n        }\n    }\n\n    Selection.prototype.isEmpty = function() {\n        return this.selection.isCollapsed\n    }\n\n    Selection.prototype.getFirstRange = function() {\n        return this.selection.getRangeAt(0);\n    }\n\n    function removeWhitespaces(s) {\n        return s.replace(/\\s+/g, \"\");\n    }\n\n    var highlight = text.highlight;\n    var before  = text.before || \"\";\n    var after  = text.after || \"\";\n    var snippet = before + highlight + after;\n    var safeSnippet = removeWhitespaces(snippet);\n\n    if (!highlight || !safeSnippet) {\n        return false;\n    }\n\n    var selection = new Selection(window.getSelection());\n    // We need to reset any selection to begin the search from the start of the resource.\n    selection.clear();\n\n    var found = false;\n    while (window.find(text.highlight, true)) {\n        if (selection.isEmpty()) {\n            break; // Prevents infinite loop in edge cases.\n        }\n\n        // Get the surrounding context to compare to the expected snippet.\n        selection.mark();\n        selection.adjust(-before.length, snippet.length);\n        var safeSelection = removeWhitespaces(selection.toString());\n        selection.reset();\n\n        if (safeSelection !== \"\" && (safeSnippet.includes(safeSelection) || safeSelection.includes(safeSnippet))) {\n            found = true;\n            break;\n        }\n    }\n\n    if (!found || selection.isEmpty()) {\n        return false;\n    }\n\n    // WKWebView doesn't seem to scroll to the selection created by window.find().\n    // See https://bugs.webkit.org/show_bug.cgi?id=163911\n    scrollToRange(selection.getFirstRange())\n\n    // Resets the selection otherwise the last found occurrence will be highlighted.\n    selection.clear();\n\n    return true;\n}\n\nfunction scrollToRange(range) {\n    var rect = range.getBoundingClientRect();\n    if (isScrollModeEnabled()) {\n        document.scrollingElement.scrollTop = rect.top + window.scrollY - (window.innerHeight / 2);\n    } else {\n        document.scrollingElement.scrollLeft = rect.left + window.scrollX;\n        snapCurrentPosition();\n    }\n}\n\n// Returns false if the page is already at the left-most scroll offset.\nexport function scrollLeft(dir) {\n    var isRTL = (dir == \"rtl\");\n    var documentWidth = document.scrollingElement.scrollWidth;\n    var pageWidth = window.innerWidth;\n    var offset = window.scrollX - pageWidth;\n    var minOffset = isRTL ? -(documentWidth - pageWidth) : 0;\n    return scrollToOffset(Math.max(offset, minOffset));\n}\n\n// Returns false if the page is already at the right-most scroll offset.\nexport function scrollRight(dir) {\n    var isRTL = (dir == \"rtl\");\n    var documentWidth = document.scrollingElement.scrollWidth;\n    var pageWidth = window.innerWidth;\n    var offset = window.scrollX + pageWidth;\n    var maxOffset = isRTL ? 0 : (documentWidth - pageWidth);\n    return scrollToOffset(Math.min(offset, maxOffset));\n}\n\n// Scrolls to the given left offset.\n// Returns false if the page scroll position is already close enough to the given offset.\nfunction scrollToOffset(offset) {\n    var currentOffset = window.scrollX;\n    var pageWidth = window.innerWidth;\n    document.scrollingElement.scrollLeft = offset;\n    // In some case the scrollX cannot reach the position respecting to innerWidth\n    var diff = Math.abs(currentOffset - offset) / pageWidth;\n    return (diff > 0.01);\n}\n\n// Snap the offset to the screen width (page width).\nfunction snapOffset(offset) {\n    var value = offset + 1;\n\n    return value - (value % maxScreenX);\n}\n\nfunction snapCurrentPosition() {\n    if (isScrollModeEnabled()) {\n        return;\n    }\n    var currentOffset = window.scrollX;\n    var currentOffsetSnapped = snapOffset(currentOffset + 1);\n\n    document.scrollingElement.scrollLeft = currentOffsetSnapped;\n}\n\n/// User Settings.\n\n// For setting user setting.\nexport function setProperty(key, value) {\n    var root = document.documentElement;\n\n    root.style.setProperty(key, value);\n}\n\n// For removing user setting.\nexport function removeProperty(key) {\n    var root = document.documentElement;\n\n    root.style.removeProperty(key);\n}\n\n\n/// Toolkit\n\nfunction debounce(delay, func) {\n    var timeout;\n    return function() {\n        var self = this;\n        var args = arguments;\n        function callback() {\n            func.apply(self, args);\n            timeout = null;\n        }\n        clearTimeout(timeout);\n        timeout = setTimeout(callback, delay);\n    };\n}\n\nexport function log() {\n    var message = Array.prototype.slice.call(arguments).join(\" \");\n    webkit.messageHandlers.log.postMessage(message);\n}\n\nexport function logException(e) {\n    webkit.messageHandlers.logError.postMessage({\n        \"message\": e.message\n    });\n}\n","//\n//  Copyright 2021 Readium Foundation. All rights reserved.\n//  Use of this source code is governed by the BSD-style license\n//  available in the top-level LICENSE file of the project.\n//\n\nimport {log as logNative, logException} from \"./utils\";\n\nconst debug = true;\n\nexport function getSelectionRect() {\n    try {\n        let sel = window.getSelection();\n        if (!sel) {\n            return;\n        }\n        let range = sel.getRangeAt(0);\n\n        const clientRect = range.getBoundingClientRect();\n\n        return {\n            screenWidth: window.outerWidth,\n            screenHeight: window.outerHeight,\n            left: clientRect.left,\n            width: clientRect.width,\n            top: clientRect.top,\n            height: clientRect.height\n        };\n    } catch (e) {\n        logException(e)\n        return null;\n    }\n}\n\nexport function getCurrentSelectionInfo() {\n    const selection = window.getSelection();\n    if (!selection) {\n        return undefined;\n    }\n    if (selection.isCollapsed) {\n        log(\"^^^ SELECTION COLLAPSED.\");\n        return undefined;\n    }\n    const rawText = selection.toString();\n    const cleanText = rawText.trim().replace(/\\n/g, \" \").replace(/\\s\\s+/g, \" \");\n    if (cleanText.length === 0) {\n        log(\"^^^ SELECTION TEXT EMPTY.\");\n        return undefined;\n    }\n    if (!selection.anchorNode || !selection.focusNode) {\n        return undefined;\n    }\n    const range = selection.rangeCount === 1 ? selection.getRangeAt(0) :\n        createOrderedRange(selection.anchorNode, selection.anchorOffset, selection.focusNode, selection.focusOffset);\n    if (!range || range.collapsed) {\n        log(\"$$$$$$$$$$$$$$$$$ CANNOT GET NON-COLLAPSED SELECTION RANGE?!\");\n        return undefined;\n    }\n    const rangeInfo = convertRange(range, fullQualifiedSelector);\n    if (!rangeInfo) {\n        log(\"^^^ SELECTION RANGE INFO FAIL?!\");\n        return undefined;\n    }\n\n    return {\n        locations: rangeInfo2Location(rangeInfo),\n        text: {\n            highlight: rawText\n        }\n    };\n}\n\nfunction createOrderedRange(startNode, startOffset, endNode, endOffset) {\n    const range = new Range();\n    range.setStart(startNode, startOffset);\n    range.setEnd(endNode, endOffset);\n    if (!range.collapsed) {\n        return range;\n    }\n    log(\">>> createOrderedRange COLLAPSED ... RANGE REVERSE?\");\n    const rangeReverse = new Range();\n    rangeReverse.setStart(endNode, endOffset);\n    rangeReverse.setEnd(startNode, startOffset);\n    if (!rangeReverse.collapsed) {\n        log(\">>> createOrderedRange RANGE REVERSE OK.\");\n        return range;\n    }\n    log(\">>> createOrderedRange RANGE REVERSE ALSO COLLAPSED?!\");\n    return undefined;\n}\n\nfunction convertRange(range, getCssSelector) {\n    const startIsElement = range.startContainer.nodeType === Node.ELEMENT_NODE;\n    const startContainerElement = startIsElement ?\n        range.startContainer :\n        ((range.startContainer.parentNode && range.startContainer.parentNode.nodeType === Node.ELEMENT_NODE) ?\n            range.startContainer.parentNode : undefined);\n    if (!startContainerElement) {\n        return undefined;\n    }\n    const startContainerChildTextNodeIndex = startIsElement ? -1 :\n        Array.from(startContainerElement.childNodes).indexOf(range.startContainer);\n    if (startContainerChildTextNodeIndex < -1) {\n        return undefined;\n    }\n    const startContainerElementCssSelector = getCssSelector(startContainerElement);\n\n    const endIsElement = range.endContainer.nodeType === Node.ELEMENT_NODE;\n    const endContainerElement = endIsElement ?\n        range.endContainer :\n        ((range.endContainer.parentNode && range.endContainer.parentNode.nodeType === Node.ELEMENT_NODE) ?\n            range.endContainer.parentNode : undefined);\n    if (!endContainerElement) {\n        return undefined;\n    }\n    const endContainerChildTextNodeIndex = endIsElement ? -1 :\n        Array.from(endContainerElement.childNodes).indexOf(range.endContainer);\n    if (endContainerChildTextNodeIndex < -1) {\n        return undefined;\n    }\n    const endContainerElementCssSelector = getCssSelector(endContainerElement);\n\n    const commonElementAncestor = getCommonAncestorElement(range.startContainer, range.endContainer);\n    if (!commonElementAncestor) {\n        log(\"^^^ NO RANGE COMMON ANCESTOR?!\");\n        return undefined;\n    }\n    if (range.commonAncestorContainer) {\n        const rangeCommonAncestorElement = range.commonAncestorContainer.nodeType === Node.ELEMENT_NODE ?\n            range.commonAncestorContainer : range.commonAncestorContainer.parentNode;\n        if (rangeCommonAncestorElement && rangeCommonAncestorElement.nodeType === Node.ELEMENT_NODE) {\n            if (commonElementAncestor !== rangeCommonAncestorElement) {\n                log(\">>>>>> COMMON ANCESTOR CONTAINER DIFF??!\");\n                log(getCssSelector(commonElementAncestor));\n                log(getCssSelector(rangeCommonAncestorElement));\n            }\n        }\n    }\n    return {\n        endContainerChildTextNodeIndex,\n        endContainerElementCssSelector,\n        endOffset: range.endOffset,\n        startContainerChildTextNodeIndex,\n        startContainerElementCssSelector,\n        startOffset: range.startOffset,\n    };\n}\n\nfunction getCommonAncestorElement(node1, node2) {\n    if (node1.nodeType === Node.ELEMENT_NODE && node1 === node2) {\n        return node1;\n    }\n    if (node1.nodeType === Node.ELEMENT_NODE && node1.contains(node2)) {\n        return node1;\n    }\n    if (node2.nodeType === Node.ELEMENT_NODE && node2.contains(node1)) {\n        return node2;\n    }\n    const node1ElementAncestorChain = [];\n    let parent = node1.parentNode;\n    while (parent && parent.nodeType === Node.ELEMENT_NODE) {\n        node1ElementAncestorChain.push(parent);\n        parent = parent.parentNode;\n    }\n    const node2ElementAncestorChain = [];\n    parent = node2.parentNode;\n    while (parent && parent.nodeType === Node.ELEMENT_NODE) {\n        node2ElementAncestorChain.push(parent);\n        parent = parent.parentNode;\n    }\n    let commonAncestor = node1ElementAncestorChain.find((node1ElementAncestor) => {\n        return node2ElementAncestorChain.indexOf(node1ElementAncestor) >= 0;\n    });\n    if (!commonAncestor) {\n        commonAncestor = node2ElementAncestorChain.find((node2ElementAncestor) => {\n            return node1ElementAncestorChain.indexOf(node2ElementAncestor) >= 0;\n        });\n    }\n    return commonAncestor;\n}\n\nexport function convertRangeInfo(document, rangeInfo) {\n    const startElement = document.querySelector(rangeInfo.startContainerElementCssSelector);\n    if (!startElement) {\n        log(\"^^^ convertRangeInfo NO START ELEMENT CSS SELECTOR?!\");\n        return undefined;\n    }\n    let startContainer = startElement;\n    if (rangeInfo.startContainerChildTextNodeIndex >= 0) {\n        if (rangeInfo.startContainerChildTextNodeIndex >= startElement.childNodes.length) {\n            log(\"^^^ convertRangeInfo rangeInfo.startContainerChildTextNodeIndex >= startElement.childNodes.length?!\");\n            return undefined;\n        }\n        startContainer = startElement.childNodes[rangeInfo.startContainerChildTextNodeIndex];\n        if (startContainer.nodeType !== Node.TEXT_NODE) {\n            log(\"^^^ convertRangeInfo startContainer.nodeType !== Node.TEXT_NODE?!\");\n            return undefined;\n        }\n    }\n    const endElement = document.querySelector(rangeInfo.endContainerElementCssSelector);\n    if (!endElement) {\n        log(\"^^^ convertRangeInfo NO END ELEMENT CSS SELECTOR?!\");\n        return undefined;\n    }\n    let endContainer = endElement;\n    if (rangeInfo.endContainerChildTextNodeIndex >= 0) {\n        if (rangeInfo.endContainerChildTextNodeIndex >= endElement.childNodes.length) {\n            log(\"^^^ convertRangeInfo rangeInfo.endContainerChildTextNodeIndex >= endElement.childNodes.length?!\");\n            return undefined;\n        }\n        endContainer = endElement.childNodes[rangeInfo.endContainerChildTextNodeIndex];\n        if (endContainer.nodeType !== Node.TEXT_NODE) {\n            log(\"^^^ convertRangeInfo endContainer.nodeType !== Node.TEXT_NODE?!\");\n            return undefined;\n        }\n    }\n    return createOrderedRange(startContainer, rangeInfo.startOffset, endContainer, rangeInfo.endOffset);\n}\n\nfunction rangeInfo2Location(rangeInfo) {\n    return {\n        cssSelector: rangeInfo.startContainerElementCssSelector,\n        domRange: {\n            start: {\n                cssSelector: rangeInfo.startContainerElementCssSelector,\n                textNodeIndex: rangeInfo.startContainerChildTextNodeIndex,\n                offset: rangeInfo.startOffset\n            },\n            end: {\n                cssSelector: rangeInfo.endContainerElementCssSelector,\n                textNodeIndex: rangeInfo.endContainerChildTextNodeIndex,\n                offset: rangeInfo.endOffset\n            }\n        }\n    }\n}\n\nexport function location2RangeInfo(location) {\n    const locations = location.locations\n    const domRange = locations.domRange\n    const start = domRange.start\n    const end = domRange.end\n\n    return {\n        endContainerChildTextNodeIndex: end.textNodeIndex,\n        endContainerElementCssSelector: end.cssSelector,\n        endOffset: end.offset,\n        startContainerChildTextNodeIndex: start.textNodeIndex,\n        startContainerElementCssSelector: start.cssSelector,\n        startOffset: start.offset\n    };\n}\n\nfunction fullQualifiedSelector(node) {\n    if (node.nodeType !== Node.ELEMENT_NODE) {\n        return (node.localName && node.localName.toLowerCase())\n            || node.nodeName.toLowerCase();\n    }\n    //return cssPath(node, justSelector);\n    return cssPath(node, true);\n}\n\nfunction cssPath(node, optimized) {\n    if (node.nodeType !== Node.ELEMENT_NODE) {\n        return \"\";\n    }\n\n    const steps = [];\n    let contextNode = node;\n    while (contextNode) {\n        const step = _cssPathStep(contextNode, !!optimized, contextNode === node);\n        if (!step) {\n            break; // Error - bail out early.\n        }\n        steps.push(step.value);\n        if (step.optimized) {\n            break;\n        }\n        contextNode = contextNode.parentNode;\n    }\n    steps.reverse();\n    return steps.join(\" > \");\n}\n\n// https://chromium.googlesource.com/chromium/blink/+/master/Source/devtools/front_end/components/DOMPresentationUtils.js#316\nfunction _cssPathStep(node, optimized, isTargetNode) {\n\n    function idSelector(idd) {\n        return \"#\" + escapeIdentifierIfNeeded(idd);\n    }\n\n    function escapeIdentifierIfNeeded(ident) {\n        if (isCSSIdentifier(ident)) {\n            return ident;\n        }\n\n        const shouldEscapeFirst = /^(?:[0-9]|-[0-9-]?)/.test(ident);\n        const lastIndex = ident.length - 1;\n        return ident.replace(/./g, function (c, ii) {\n            return ((shouldEscapeFirst && ii === 0) || !isCSSIdentChar(c)) ? escapeAsciiChar(c, ii === lastIndex) : c;\n        });\n    }\n\n    function isCSSIdentifier(value) {\n        return /^-?[a-zA-Z_][a-zA-Z0-9_-]*$/.test(value);\n    }\n\n    function isCSSIdentChar(c) {\n        if (/[a-zA-Z0-9_-]/.test(c)) {\n            return true;\n        }\n        return c.charCodeAt(0) >= 0xA0;\n    }\n\n    function escapeAsciiChar(c, isLast) {\n        return \"\\\\\" + toHexByte(c) + (isLast ? \"\" : \" \");\n    }\n\n    function toHexByte(c) {\n        let hexByte = c.charCodeAt(0).toString(16);\n        if (hexByte.length === 1) {\n            hexByte = \"0\" + hexByte;\n        }\n        return hexByte;\n    }\n\n    function prefixedElementClassNames(nd) {\n        const classAttribute = nd.getAttribute(\"class\");\n        if (!classAttribute) {\n            return [];\n        }\n\n        return classAttribute.split(/\\s+/g).filter(Boolean).map((nm) => {\n            // The prefix is required to store \"__proto__\" in a object-based map.\n            return \"$\" + nm;\n        });\n    }\n\n    if (node.nodeType !== Node.ELEMENT_NODE) {\n        return undefined;\n    }\n    const lowerCaseName = (node.localName && node.localName.toLowerCase())\n        || node.nodeName.toLowerCase();\n\n    const element = node;\n\n    const id = element.getAttribute(\"id\");\n\n    if (optimized) {\n        if (id) {\n            return {\n                optimized: true,\n                value: idSelector(id),\n            };\n        }\n        if (lowerCaseName === \"body\" || lowerCaseName === \"head\" || lowerCaseName === \"html\") {\n            return {\n                optimized: true,\n                value: lowerCaseName, // node.nodeNameInCorrectCase(),\n            };\n        }\n    }\n\n    const nodeName = lowerCaseName; // node.nodeNameInCorrectCase();\n    if (id) {\n        return {\n            optimized: true,\n            value: nodeName + idSelector(id),\n        };\n    }\n\n    const parent = node.parentNode;\n\n    if (!parent || parent.nodeType === Node.DOCUMENT_NODE) {\n        return {\n            optimized: true,\n            value: nodeName,\n        };\n    }\n\n    const prefixedOwnClassNamesArray_ = prefixedElementClassNames(element);\n\n    const prefixedOwnClassNamesArray = []; // .keySet()\n    prefixedOwnClassNamesArray_.forEach((arrItem) => {\n        if (prefixedOwnClassNamesArray.indexOf(arrItem) < 0) {\n            prefixedOwnClassNamesArray.push(arrItem);\n        }\n    });\n\n    let needsClassNames = false;\n    let needsNthChild = false;\n    let ownIndex = -1;\n    let elementIndex = -1;\n    const siblings = parent.children;\n\n    for (let i = 0; (ownIndex === -1 || !needsNthChild) && i < siblings.length; ++i) {\n        const sibling = siblings[i];\n        if (sibling.nodeType !== Node.ELEMENT_NODE) {\n            continue;\n        }\n        elementIndex += 1;\n        if (sibling === node) {\n            ownIndex = elementIndex;\n            continue;\n        }\n        if (needsNthChild) {\n            continue;\n        }\n\n        // sibling.nodeNameInCorrectCase()\n        const siblingName = (sibling.localName && sibling.localName.toLowerCase()) || sibling.nodeName.toLowerCase();\n        if (siblingName !== nodeName) {\n            continue;\n        }\n        needsClassNames = true;\n\n        const ownClassNames = [];\n        prefixedOwnClassNamesArray.forEach((arrItem) => {\n            ownClassNames.push(arrItem);\n        });\n        let ownClassNameCount = ownClassNames.length;\n\n        if (ownClassNameCount === 0) {\n            needsNthChild = true;\n            continue;\n        }\n        const siblingClassNamesArray_ = prefixedElementClassNames(sibling);\n        const siblingClassNamesArray = []; // .keySet()\n        siblingClassNamesArray_.forEach((arrItem) => {\n            if (siblingClassNamesArray.indexOf(arrItem) < 0) {\n                siblingClassNamesArray.push(arrItem);\n            }\n        });\n\n        for (const siblingClass of siblingClassNamesArray) {\n            const ind = ownClassNames.indexOf(siblingClass);\n            if (ind < 0) {\n                continue;\n            }\n\n            ownClassNames.splice(ind, 1); // delete ownClassNames[siblingClass];\n\n            if (!--ownClassNameCount) {\n                needsNthChild = true;\n                break;\n            }\n        }\n    }\n\n    let result = nodeName;\n    if (isTargetNode &&\n        nodeName === \"input\" &&\n        element.getAttribute(\"type\") &&\n        !element.getAttribute(\"id\") &&\n        !element.getAttribute(\"class\")) {\n        result += \"[type=\\\"\" + element.getAttribute(\"type\") + \"\\\"]\";\n    }\n    if (needsNthChild) {\n        result += \":nth-child(\" + (ownIndex + 1) + \")\";\n    } else if (needsClassNames) {\n        for (const prefixedName of prefixedOwnClassNamesArray) {\n            result += \".\" + escapeIdentifierIfNeeded(prefixedName.substr(1));\n        }\n    }\n\n    return {\n        optimized: false,\n        value: result,\n    };\n}\n\nfunction log() {\n    if (debug) {\n        logNative.apply(null, arguments);\n    }\n}","//\n//  Copyright 2021 Readium Foundation. All rights reserved.\n//  Use of this source code is governed by the BSD-style license\n//  available in the top-level LICENSE file of the project.\n//\n\nimport {log as logNative} from \"./utils\";\n\nconst debug = false;\n\nexport function getClientRectsNoOverlap(range, doNotMergeHorizontallyAlignedRects) {\n    let clientRects = range.getClientRects();\n\n    const tolerance = 1;\n    const originalRects = [];\n    for (const rangeClientRect of clientRects) {\n        originalRects.push({\n            bottom: rangeClientRect.bottom,\n            height: rangeClientRect.height,\n            left: rangeClientRect.left,\n            right: rangeClientRect.right,\n            top: rangeClientRect.top,\n            width: rangeClientRect.width,\n        });\n    }\n    const mergedRects = mergeTouchingRects(originalRects, tolerance, doNotMergeHorizontallyAlignedRects);\n    const noContainedRects = removeContainedRects(mergedRects, tolerance);\n    const newRects = replaceOverlapingRects(noContainedRects);\n    const minArea = 2 * 2;\n    for (let j = newRects.length - 1; j >= 0; j--) {\n        const rect = newRects[j];\n        const bigEnough = (rect.width * rect.height) > minArea;\n        if (!bigEnough) {\n            if (newRects.length > 1) {\n                log(\"CLIENT RECT: remove small\");\n                newRects.splice(j, 1);\n            } else {\n                log(\"CLIENT RECT: remove small, but keep otherwise empty!\");\n                break;\n            }\n        }\n    }\n    log(`CLIENT RECT: reduced ${originalRects.length} --> ${newRects.length}`);\n    return newRects;\n}\n\nfunction mergeTouchingRects(rects, tolerance, doNotMergeHorizontallyAlignedRects) {\n    for (let i = 0; i < rects.length; i++) {\n        for (let j = i + 1; j < rects.length; j++) {\n            const rect1 = rects[i];\n            const rect2 = rects[j];\n            if (rect1 === rect2) {\n                log(\"mergeTouchingRects rect1 === rect2 ??!\");\n                continue;\n            }\n            const rectsLineUpVertically = almostEqual(rect1.top, rect2.top, tolerance) &&\n                almostEqual(rect1.bottom, rect2.bottom, tolerance);\n            const rectsLineUpHorizontally = almostEqual(rect1.left, rect2.left, tolerance) &&\n                almostEqual(rect1.right, rect2.right, tolerance);\n            const horizontalAllowed = !doNotMergeHorizontallyAlignedRects;\n            const aligned = (rectsLineUpHorizontally && horizontalAllowed) || (rectsLineUpVertically && !rectsLineUpHorizontally);\n            const canMerge = aligned && rectsTouchOrOverlap(rect1, rect2, tolerance);\n            if (canMerge) {\n                log(`CLIENT RECT: merging two into one, VERTICAL: ${rectsLineUpVertically} HORIZONTAL: ${rectsLineUpHorizontally} (${doNotMergeHorizontallyAlignedRects})`);\n                const newRects = rects.filter((rect) => {\n                    return rect !== rect1 && rect !== rect2;\n                });\n                const replacementClientRect = getBoundingRect(rect1, rect2);\n                newRects.push(replacementClientRect);\n                return mergeTouchingRects(newRects, tolerance, doNotMergeHorizontallyAlignedRects);\n            }\n        }\n    }\n    return rects;\n}\n\nfunction getBoundingRect(rect1, rect2) {\n    const left = Math.min(rect1.left, rect2.left);\n    const right = Math.max(rect1.right, rect2.right);\n    const top = Math.min(rect1.top, rect2.top);\n    const bottom = Math.max(rect1.bottom, rect2.bottom);\n    return {\n        bottom,\n        height: bottom - top,\n        left,\n        right,\n        top,\n        width: right - left,\n    };\n}\n\nfunction removeContainedRects(rects, tolerance) {\n    const rectsToKeep = new Set(rects);\n    for (const rect of rects) {\n        const bigEnough = rect.width > 1 && rect.height > 1;\n        if (!bigEnough) {\n            log(\"CLIENT RECT: remove tiny\");\n            rectsToKeep.delete(rect);\n            continue;\n        }\n        for (const possiblyContainingRect of rects) {\n            if (rect === possiblyContainingRect) {\n                continue;\n            }\n            if (!rectsToKeep.has(possiblyContainingRect)) {\n                continue;\n            }\n            if (rectContains(possiblyContainingRect, rect, tolerance)) {\n                log(\"CLIENT RECT: remove contained\");\n                rectsToKeep.delete(rect);\n                break;\n            }\n        }\n    }\n    return Array.from(rectsToKeep);\n}\n\nfunction rectContains(rect1, rect2, tolerance) {\n    return (rectContainsPoint(rect1, rect2.left, rect2.top, tolerance) &&\n        rectContainsPoint(rect1, rect2.right, rect2.top, tolerance) &&\n        rectContainsPoint(rect1, rect2.left, rect2.bottom, tolerance) &&\n        rectContainsPoint(rect1, rect2.right, rect2.bottom, tolerance));\n}\n\nfunction rectContainsPoint(rect, x, y, tolerance) {\n    return (rect.left < x || almostEqual(rect.left, x, tolerance)) &&\n        (rect.right > x || almostEqual(rect.right, x, tolerance)) &&\n        (rect.top < y || almostEqual(rect.top, y, tolerance)) &&\n        (rect.bottom > y || almostEqual(rect.bottom, y, tolerance));\n}\n\nfunction replaceOverlapingRects(rects) {\n    for (let i = 0; i < rects.length; i++) {\n        for (let j = i + 1; j < rects.length; j++) {\n            const rect1 = rects[i];\n            const rect2 = rects[j];\n            if (rect1 === rect2) {\n                log(\"replaceOverlapingRects rect1 === rect2 ??!\");\n                continue;\n            }\n            if (rectsTouchOrOverlap(rect1, rect2, -1)) {\n                let toAdd = [];\n                let toRemove;\n                let toPreserve;\n                const subtractRects1 = rectSubtract(rect1, rect2);\n                if (subtractRects1.length === 1) {\n                    toAdd = subtractRects1;\n                    toRemove = rect1;\n                    toPreserve = rect2;\n                } else {\n                    const subtractRects2 = rectSubtract(rect2, rect1);\n                    if (subtractRects1.length < subtractRects2.length) {\n                        toAdd = subtractRects1;\n                        toRemove = rect1;\n                        toPreserve = rect2;\n                    } else {\n                        toAdd = subtractRects2;\n                        toRemove = rect2;\n                        toPreserve = rect1;\n                    }\n                }\n                log(`CLIENT RECT: overlap, cut one rect into ${toAdd.length}`);\n                const newRects = rects.filter((rect) => {\n                    return rect !== toRemove;\n                });\n                Array.prototype.push.apply(newRects, toAdd);\n                return replaceOverlapingRects(newRects);\n            }\n        }\n    }\n    return rects;\n}\n\nfunction rectSubtract(rect1, rect2) {\n    const rectIntersected = rectIntersect(rect2, rect1);\n    if (rectIntersected.height === 0 || rectIntersected.width === 0) {\n        return [rect1];\n    }\n    const rects = [];\n    {\n        const rectA = {\n            bottom: rect1.bottom,\n            height: 0,\n            left: rect1.left,\n            right: rectIntersected.left,\n            top: rect1.top,\n            width: 0,\n        };\n        rectA.width = rectA.right - rectA.left;\n        rectA.height = rectA.bottom - rectA.top;\n        if (rectA.height !== 0 && rectA.width !== 0) {\n            rects.push(rectA);\n        }\n    }\n    {\n        const rectB = {\n            bottom: rectIntersected.top,\n            height: 0,\n            left: rectIntersected.left,\n            right: rectIntersected.right,\n            top: rect1.top,\n            width: 0,\n        };\n        rectB.width = rectB.right - rectB.left;\n        rectB.height = rectB.bottom - rectB.top;\n        if (rectB.height !== 0 && rectB.width !== 0) {\n            rects.push(rectB);\n        }\n    }\n    {\n        const rectC = {\n            bottom: rect1.bottom,\n            height: 0,\n            left: rectIntersected.left,\n            right: rectIntersected.right,\n            top: rectIntersected.bottom,\n            width: 0,\n        };\n        rectC.width = rectC.right - rectC.left;\n        rectC.height = rectC.bottom - rectC.top;\n        if (rectC.height !== 0 && rectC.width !== 0) {\n            rects.push(rectC);\n        }\n    }\n    {\n        const rectD = {\n            bottom: rect1.bottom,\n            height: 0,\n            left: rectIntersected.right,\n            right: rect1.right,\n            top: rect1.top,\n            width: 0,\n        };\n        rectD.width = rectD.right - rectD.left;\n        rectD.height = rectD.bottom - rectD.top;\n        if (rectD.height !== 0 && rectD.width !== 0) {\n            rects.push(rectD);\n        }\n    }\n    return rects;\n}\n\nfunction rectIntersect(rect1, rect2) {\n    const maxLeft = Math.max(rect1.left, rect2.left);\n    const minRight = Math.min(rect1.right, rect2.right);\n    const maxTop = Math.max(rect1.top, rect2.top);\n    const minBottom = Math.min(rect1.bottom, rect2.bottom);\n    return {\n        bottom: minBottom,\n        height: Math.max(0, minBottom - maxTop),\n        left: maxLeft,\n        right: minRight,\n        top: maxTop,\n        width: Math.max(0, minRight - maxLeft),\n    };\n}\n\nfunction rectsTouchOrOverlap(rect1, rect2, tolerance) {\n    return ((rect1.left < rect2.right || (tolerance >= 0 && almostEqual(rect1.left, rect2.right, tolerance))) &&\n        (rect2.left < rect1.right || (tolerance >= 0 && almostEqual(rect2.left, rect1.right, tolerance))) &&\n        (rect1.top < rect2.bottom || (tolerance >= 0 && almostEqual(rect1.top, rect2.bottom, tolerance))) &&\n        (rect2.top < rect1.bottom || (tolerance >= 0 && almostEqual(rect2.top, rect1.bottom, tolerance))));\n}\n\nfunction almostEqual(a, b, tolerance) {\n    return Math.abs(a - b) <= tolerance;\n}\n\nfunction log() {\n    if (debug) {\n        logNative.apply(null, arguments);\n    }\n}","//\n//  Copyright 2021 Readium Foundation. All rights reserved.\n//  Use of this source code is governed by the BSD-style license\n//  available in the top-level LICENSE file of the project.\n//\n\nimport {convertRangeInfo, location2RangeInfo} from \"./selection\";\nimport {getClientRectsNoOverlap} from \"./rect\";\n\nconst debug = false;\n\nconst ID_HIGHLIGHTS_CONTAINER = \"R2_ID_HIGHLIGHTS_CONTAINER\";\nconst CLASS_HIGHLIGHT_CONTAINER = \"R2_CLASS_HIGHLIGHT_CONTAINER\";\nconst CLASS_HIGHLIGHT_AREA = \"R2_CLASS_HIGHLIGHT_AREA\";\nconst CLASS_HIGHLIGHT_BOUNDING_AREA = \"R2_CLASS_HIGHLIGHT_BOUNDING_AREA\";\n\nconst _highlights = [];\nlet _highlightsContainer;\n\nconst defaultBackgroundOpacity = 0.3;\n\nconst defaultBackgroundColor = {\n    blue: 100,\n    green: 50,\n    red: 230,\n};\n\nexport function rectForHighlightWithID(id) {\n    const clientRects = frameForHighlightWithID(id);\n\n    return {\n        screenWidth: window.outerWidth,\n        screenHeight: window.outerHeight,\n        left: clientRects[0].left,\n        width: clientRects[0].width,\n        top: clientRects[0].top,\n        height: clientRects[0].height\n    };\n}\n\nexport function destroyAllHighlights() {\n    hideAllHighlights();\n    _highlights.splice(0, _highlights.length);\n}\n\nfunction hideAllHighlights() {\n    if (_highlightsContainer) {\n        _highlightsContainer.remove();\n        _highlightsContainer = null;\n    }\n}\n\nexport function createHighlightRange(range) {\n\n    // FIXME: Use user-provided ID.\n    let id = \"R2_HIGHLIGHT_\" + Date.now();\n\n    destroyHighlight(id);\n\n    const highlight = {\n        color: defaultBackgroundColor,\n        id,\n        pointerInteraction: true,\n        rangeInfo: null\n    };\n    _highlights.push(highlight);\n    createHighlightFromRange(range, highlight);\n\n    return highlight;\n}\n\nexport function createHighlight(locations, color, pointerInteraction) {\n    const rangeInfo = location2RangeInfo(locations)\n\n    // FIXME: Use user-provided ID.\n    let id = \"R2_HIGHLIGHT_\" + Date.now();\n\n    destroyHighlight(id);\n\n    const highlight = {\n        color: color ? color : defaultBackgroundColor,\n        id,\n        pointerInteraction,\n        rangeInfo\n    };\n    _highlights.push(highlight);\n    createHighlightDom(highlight);\n\n    return highlight;\n}\n\nfunction destroyHighlight(id) {\n    let i = -1;\n    let _document = window.document\n    const highlight = _highlights.find((h, j) => {\n        i = j;\n        return h.id === id;\n    });\n    if (highlight && i >= 0 && i < _highlights.length) {\n        _highlights.splice(i, 1);\n    }\n    const highlightContainer = _document.getElementById(id);\n    if (highlightContainer) {\n        highlightContainer.remove();\n    }\n}\n\nfunction createHighlightDom(highlight) {\n    const range = convertRangeInfo(document, highlight.rangeInfo);\n    return createHighlightFromRange(range, highlight)\n}\n\nfunction createHighlightFromRange(range, highlight) {\n    if (!range) {\n        return undefined;\n    }\n\n    const scale = 1 / ((window.READIUM2 && window.READIUM2.isFixedLayout) ? window.READIUM2.fxlViewportScale : 1);\n\n    const scrollElement = document.scrollingElement;\n\n    const paginated = !isScrollModeEnabled()\n    const highlightsContainer = ensureContainer(window);\n    const highlightParent = document.createElement(\"div\");\n\n    highlightParent.setAttribute(\"id\", highlight.id);\n    highlightParent.setAttribute(\"class\", CLASS_HIGHLIGHT_CONTAINER);\n\n    highlightParent.style.setProperty(\"pointer-events\", \"none\");\n    if (highlight.pointerInteraction) {\n        highlightParent.setAttribute(\"data-click\", \"1\");\n    }\n\n    const bodyRect = document.body.getBoundingClientRect();\n    const drawUnderline = false;\n    const drawStrikeThrough = false;\n    const doNotMergeHorizontallyAlignedRects = drawUnderline || drawStrikeThrough;\n    const clientRects = getClientRectsNoOverlap(range, doNotMergeHorizontallyAlignedRects);\n    const roundedCorner = 3;\n    const underlineThickness = 2;\n    const strikeThroughLineThickness = 3;\n    const opacity = defaultBackgroundOpacity;\n    let extra = \"\";\n\n    let xOffset;\n    let yOffset;\n\n    // if (navigator.userAgent.match(/Android/i)) {\n    xOffset = paginated ? (-scrollElement.scrollLeft) : bodyRect.left;\n    yOffset = paginated ? (-scrollElement.scrollTop) : bodyRect.top;\n    // } else if (navigator.userAgent.match(/iPhone|iPad|iPod/i)) {\n    //     xOffset = paginated ? 0 : (-scrollElement.scrollLeft);\n    //     yOffset = paginated ? 0 : (bodyRect.top);\n    //     annotationOffset = parseInt((rangeAnnotationBoundingClientRect.right/window.innerWidth) + 1);\n    // }\n\n    for (const clientRect of clientRects) {\n        const highlightArea = document.createElement(\"div\");\n\n        highlightArea.setAttribute(\"class\", CLASS_HIGHLIGHT_AREA);\n\n        if (debug) {\n            const rgb = Math.round(0xffffff * Math.random());\n            const r = rgb >> 16;\n            const g = rgb >> 8 & 255;\n            const b = rgb & 255;\n            extra = `outline-color: rgb(${r}, ${g}, ${b}); outline-style: solid; outline-width: 1px; outline-offset: -1px;`;\n        } else {\n            if (drawUnderline) {\n                extra += `border-bottom: ${underlineThickness * scale}px solid rgba(${highlight.color.red}, ${highlight.color.green}, ${highlight.color.blue}, ${opacity}) !important`;\n            }\n        }\n        highlightArea.setAttribute(\"style\", `border-radius: ${roundedCorner}px !important; background-color: rgba(${highlight.color.red}, ${highlight.color.green}, ${highlight.color.blue}, ${opacity}) !important; ${extra}`);\n        highlightArea.style.setProperty(\"pointer-events\", \"none\");\n        highlightArea.style.position = !paginated ? \"fixed\" : \"absolute\";\n        highlightArea.scale = scale;\n        /*\n         highlightArea.rect = {\n         height: clientRect.height,\n         left: clientRect.left - xOffset,\n         top: clientRect.top - yOffset,\n         width: clientRect.width,\n         };\n         */\n        highlightArea.rect = {\n            height: clientRect.height,\n            left: clientRect.left - xOffset,\n            top: clientRect.top - yOffset,\n            width: clientRect.width\n        };\n\n        highlightArea.style.width = `${highlightArea.rect.width * scale}px`;\n        highlightArea.style.height = `${highlightArea.rect.height * scale}px`;\n        highlightArea.style.left = `${highlightArea.rect.left * scale}px`;\n        highlightArea.style.top = `${highlightArea.rect.top * scale}px`;\n        highlightParent.append(highlightArea);\n        if (!debug && drawStrikeThrough) {\n            //if (drawStrikeThrough) {\n            const highlightAreaLine = document.createElement(\"div\");\n            highlightAreaLine.setAttribute(\"class\", CLASS_HIGHLIGHT_AREA);\n\n            highlightAreaLine.setAttribute(\"style\", `background-color: rgba(${highlight.color.red}, ${highlight.color.green}, ${highlight.color.blue}, ${opacity}) !important;`);\n            highlightAreaLine.style.setProperty(\"pointer-events\", \"none\");\n            highlightAreaLine.style.position = paginated ? \"fixed\" : \"absolute\";\n            highlightAreaLine.scale = scale;\n            /*\n             highlightAreaLine.rect = {\n             height: clientRect.height,\n             left: clientRect.left - xOffset,\n             top: clientRect.top - yOffset,\n             width: clientRect.width,\n             };\n             */\n\n            highlightAreaLine.rect = {\n                height: clientRect.height,\n                left: clientRect.left - xOffset,\n                top: clientRect.top - yOffset,\n                width: clientRect.width\n            };\n\n            highlightAreaLine.style.width = `${highlightAreaLine.rect.width * scale}px`;\n            highlightAreaLine.style.height = `${strikeThroughLineThickness * scale}px`;\n            highlightAreaLine.style.left = `${highlightAreaLine.rect.left * scale}px`;\n            highlightAreaLine.style.top = `${(highlightAreaLine.rect.top + (highlightAreaLine.rect.height / 2) - (strikeThroughLineThickness / 2)) * scale}px`;\n            highlightParent.append(highlightAreaLine);\n        }\n    }\n\n    const highlightBounding = document.createElement(\"div\");\n    highlightBounding.setAttribute(\"class\", CLASS_HIGHLIGHT_BOUNDING_AREA);\n\n    highlightBounding.style.setProperty(\"pointer-events\", \"none\");\n    highlightBounding.style.position = paginated ? \"fixed\" : \"absolute\";\n    highlightBounding.scale = scale;\n\n    if (debug) {\n        highlightBounding.setAttribute(\"style\", `outline-color: magenta; outline-style: solid; outline-width: 1px; outline-offset: -1px;`);\n    }\n\n    const rangeBoundingClientRect = range.getBoundingClientRect();\n    highlightBounding.rect = {\n        height: rangeBoundingClientRect.height,\n        left: rangeBoundingClientRect.left - xOffset,\n        top: rangeBoundingClientRect.top - yOffset,\n        width: rangeBoundingClientRect.width\n    };\n\n    highlightBounding.style.width = `${highlightBounding.rect.width * scale}px`;\n    highlightBounding.style.height = `${highlightBounding.rect.height * scale}px`;\n    highlightBounding.style.left = `${highlightBounding.rect.left * scale}px`;\n    highlightBounding.style.top = `${highlightBounding.rect.top * scale}px`;\n\n    highlightParent.append(highlightBounding);\n    highlightsContainer.append(highlightParent);\n\n    return highlightParent;\n}\n\nfunction isScrollModeEnabled() {\n    return document.documentElement.style.getPropertyValue(\"--USER__scroll\").toString().trim() === 'readium-scroll-on';\n}\n\nfunction ensureContainer(win) {\n    const document = win.document;\n\n    if (!_highlightsContainer) {\n        _highlightsContainer = document.createElement(\"div\");\n        _highlightsContainer.setAttribute(\"id\", ID_HIGHLIGHTS_CONTAINER);\n\n        _highlightsContainer.style.setProperty(\"pointer-events\", \"none\");\n        document.body.append(_highlightsContainer);\n    }\n\n    return _highlightsContainer;\n}\n\nfunction frameForHighlightWithID(id) {\n    const highlight = highlightWithID(id);\n    if (!highlight)\n        return;\n\n    const document = window.document;\n    const range = convertRangeInfo(document, highlight.rangeInfo);\n    if (!range) {\n        return undefined;\n    }\n\n\n    const drawUnderline = false;\n    const drawStrikeThrough = false;\n    const doNotMergeHorizontallyAlignedRects = drawUnderline || drawStrikeThrough;\n    return getClientRectsNoOverlap(range, doNotMergeHorizontallyAlignedRects);\n}\n\nfunction highlightWithID(id) {\n    let i = -1;\n    return _highlights.find((h, j) => {\n        i = j;\n        return h.id === id;\n    })\n}","import approxSearch from 'approx-string-match';\n\n/**\n * @typedef {import('approx-string-match').Match} StringMatch\n */\n\n/**\n * @typedef Match\n * @prop {number} start - Start offset of match in text\n * @prop {number} end - End offset of match in text\n * @prop {number} score -\n *   Score for the match between 0 and 1.0, where 1.0 indicates a perfect match\n *   for the quote and context.\n */\n\n/**\n * Find the best approximate matches for `str` in `text` allowing up to `maxErrors` errors.\n *\n * @param {string} text\n * @param {string} str\n * @param {number} maxErrors\n * @return {StringMatch[]}\n */\nfunction search(text, str, maxErrors) {\n  // Do a fast search for exact matches. The `approx-string-match` library\n  // doesn't currently incorporate this optimization itself.\n  let matchPos = 0;\n  let exactMatches = [];\n  while (matchPos !== -1) {\n    matchPos = text.indexOf(str, matchPos);\n    if (matchPos !== -1) {\n      exactMatches.push({\n        start: matchPos,\n        end: matchPos + str.length,\n        errors: 0,\n      });\n      matchPos += 1;\n    }\n  }\n  if (exactMatches.length > 0) {\n    return exactMatches;\n  }\n\n  // If there are no exact matches, do a more expensive search for matches\n  // with errors.\n  return approxSearch(text, str, maxErrors);\n}\n\n/**\n * Compute a score between 0 and 1.0 for the similarity between `text` and `str`.\n *\n * @param {string} text\n * @param {string} str\n */\nfunction textMatchScore(text, str) {\n  /* istanbul ignore next - `scoreMatch` will never pass an empty string */\n  if (str.length === 0) {\n    return 0.0;\n  }\n  const matches = search(text, str, str.length);\n\n  // prettier-ignore\n  return 1 - (matches[0].errors / str.length);\n}\n\n/**\n * Find the best approximate match for `quote` in `text`.\n *\n * Returns `null` if no match exceeding the minimum quality threshold was found.\n *\n * @param {string} text - Document text to search\n * @param {string} quote - String to find within `text`\n * @param {Object} context -\n *   Context in which the quote originally appeared. This is used to choose the\n *   best match.\n *   @param {string} [context.prefix] - Expected text before the quote\n *   @param {string} [context.suffix] - Expected text after the quote\n *   @param {number} [context.hint] - Expected offset of match within text\n * @return {Match|null}\n */\nexport function matchQuote(text, quote, context = {}) {\n  if (quote.length === 0) {\n    return null;\n  }\n\n  // Choose the maximum number of errors to allow for the initial search.\n  // This choice involves a tradeoff between:\n  //\n  //  - Recall (proportion of \"good\" matches found)\n  //  - Precision (proportion of matches found which are \"good\")\n  //  - Cost of the initial search and of processing the candidate matches [1]\n  //\n  // [1] Specifically, the expected-time complexity of the initial search is\n  //     `O((maxErrors / 32) * text.length)`. See `approx-string-match` docs.\n  const maxErrors = Math.min(256, quote.length / 2);\n\n  // Find closest matches for `quote` in `text` based on edit distance.\n  const matches = search(text, quote, maxErrors);\n\n  if (matches.length === 0) {\n    return null;\n  }\n\n  /**\n   * Compute a score between 0 and 1.0 for a match candidate.\n   *\n   * @param {StringMatch} match\n   */\n  const scoreMatch = match => {\n    const quoteWeight = 50; // Similarity of matched text to quote.\n    const prefixWeight = 20; // Similarity of text before matched text to `context.prefix`.\n    const suffixWeight = 20; // Similarity of text after matched text to `context.suffix`.\n    const posWeight = 2; // Proximity to expected location. Used as a tie-breaker.\n\n    const quoteScore = 1 - match.errors / quote.length;\n\n    const prefixScore = context.prefix\n      ? textMatchScore(\n          text.slice(match.start - context.prefix.length, match.start),\n          context.prefix\n        )\n      : 1.0;\n    const suffixScore = context.suffix\n      ? textMatchScore(\n          text.slice(match.end, match.end + context.suffix.length),\n          context.suffix\n        )\n      : 1.0;\n\n    let posScore = 1.0;\n    if (typeof context.hint === 'number') {\n      const offset = Math.abs(match.start - context.hint);\n      posScore = 1.0 - offset / text.length;\n    }\n\n    const rawScore =\n      quoteWeight * quoteScore +\n      prefixWeight * prefixScore +\n      suffixWeight * suffixScore +\n      posWeight * posScore;\n    const maxScore = quoteWeight + prefixWeight + suffixWeight + posWeight;\n    const normalizedScore = rawScore / maxScore;\n\n    return normalizedScore;\n  };\n\n  // Rank matches based on similarity of actual and expected surrounding text\n  // and actual/expected offset in the document text.\n  const scoredMatches = matches.map(m => ({\n    start: m.start,\n    end: m.end,\n    score: scoreMatch(m),\n  }));\n\n  // Choose match with highest score.\n  scoredMatches.sort((a, b) => b.score - a.score);\n  return scoredMatches[0];\n}\n","/**\n * Return the combined length of text nodes contained in `node`.\n *\n * @param {Node} node\n */\nfunction nodeTextLength(node) {\n  switch (node.nodeType) {\n    case Node.ELEMENT_NODE:\n    case Node.TEXT_NODE:\n      // nb. `textContent` excludes text in comments and processing instructions\n      // when called on a parent element, so we don't need to subtract that here.\n\n      return /** @type {string} */ (node.textContent).length;\n    default:\n      return 0;\n  }\n}\n\n/**\n * Return the total length of the text of all previous siblings of `node`.\n *\n * @param {Node} node\n */\nfunction previousSiblingsTextLength(node) {\n  let sibling = node.previousSibling;\n  let length = 0;\n  while (sibling) {\n    length += nodeTextLength(sibling);\n    sibling = sibling.previousSibling;\n  }\n  return length;\n}\n\n/**\n * Resolve one or more character offsets within an element to (text node, position)\n * pairs.\n *\n * @param {Element} element\n * @param {number[]} offsets - Offsets, which must be sorted in ascending order\n * @return {{ node: Text, offset: number }[]}\n */\nfunction resolveOffsets(element, ...offsets) {\n  let nextOffset = offsets.shift();\n  const nodeIter = /** @type {Document} */ (\n    element.ownerDocument\n  ).createNodeIterator(element, NodeFilter.SHOW_TEXT);\n  const results = [];\n\n  let currentNode = nodeIter.nextNode();\n  let textNode;\n  let length = 0;\n\n  // Find the text node containing the `nextOffset`th character from the start\n  // of `element`.\n  while (nextOffset !== undefined && currentNode) {\n    textNode = /** @type {Text} */ (currentNode);\n    if (length + textNode.data.length > nextOffset) {\n      results.push({ node: textNode, offset: nextOffset - length });\n      nextOffset = offsets.shift();\n    } else {\n      currentNode = nodeIter.nextNode();\n      length += textNode.data.length;\n    }\n  }\n\n  // Boundary case.\n  while (nextOffset !== undefined && textNode && length === nextOffset) {\n    results.push({ node: textNode, offset: textNode.data.length });\n    nextOffset = offsets.shift();\n  }\n\n  if (nextOffset !== undefined) {\n    throw new RangeError('Offset exceeds text length');\n  }\n\n  return results;\n}\n\nexport let RESOLVE_FORWARDS = 1;\nexport let RESOLVE_BACKWARDS = 2;\n\n/**\n * Represents an offset within the text content of an element.\n *\n * This position can be resolved to a specific descendant node in the current\n * DOM subtree of the element using the `resolve` method.\n */\nexport class TextPosition {\n  /**\n   * Construct a `TextPosition` that refers to the text position `offset` within\n   * the text content of `element`.\n   *\n   * @param {Element} element\n   * @param {number} offset\n   */\n  constructor(element, offset) {\n    if (offset < 0) {\n      throw new Error('Offset is invalid');\n    }\n\n    /** Element that `offset` is relative to. */\n    this.element = element;\n\n    /** Character offset from the start of the element's `textContent`. */\n    this.offset = offset;\n  }\n\n  /**\n   * Return a copy of this position with offset relative to a given ancestor\n   * element.\n   *\n   * @param {Element} parent - Ancestor of `this.element`\n   * @return {TextPosition}\n   */\n  relativeTo(parent) {\n    if (!parent.contains(this.element)) {\n      throw new Error('Parent is not an ancestor of current element');\n    }\n\n    let el = this.element;\n    let offset = this.offset;\n    while (el !== parent) {\n      offset += previousSiblingsTextLength(el);\n      el = /** @type {Element} */ (el.parentElement);\n    }\n\n    return new TextPosition(el, offset);\n  }\n\n  /**\n   * Resolve the position to a specific text node and offset within that node.\n   *\n   * Throws if `this.offset` exceeds the length of the element's text. In the\n   * case where the element has no text and `this.offset` is 0, the `direction`\n   * option determines what happens.\n   *\n   * Offsets at the boundary between two nodes are resolved to the start of the\n   * node that begins at the boundary.\n   *\n   * @param {Object} [options]\n   *   @param {RESOLVE_FORWARDS|RESOLVE_BACKWARDS} [options.direction] -\n   *     Specifies in which direction to search for the nearest text node if\n   *     `this.offset` is `0` and `this.element` has no text. If not specified\n   *     an error is thrown.\n   * @return {{ node: Text, offset: number }}\n   * @throws {RangeError}\n   */\n  resolve(options = {}) {\n    try {\n      return resolveOffsets(this.element, this.offset)[0];\n    } catch (err) {\n      if (this.offset === 0 && options.direction !== undefined) {\n        const tw = document.createTreeWalker(\n          this.element.getRootNode(),\n          NodeFilter.SHOW_TEXT\n        );\n        tw.currentNode = this.element;\n        const forwards = options.direction === RESOLVE_FORWARDS;\n        const text = /** @type {Text|null} */ (\n          forwards ? tw.nextNode() : tw.previousNode()\n        );\n        if (!text) {\n          throw err;\n        }\n        return { node: text, offset: forwards ? 0 : text.data.length };\n      } else {\n        throw err;\n      }\n    }\n  }\n\n  /**\n   * Construct a `TextPosition` that refers to the `offset`th character within\n   * `node`.\n   *\n   * @param {Node} node\n   * @param {number} offset\n   * @return {TextPosition}\n   */\n  static fromCharOffset(node, offset) {\n    switch (node.nodeType) {\n      case Node.TEXT_NODE:\n        return TextPosition.fromPoint(node, offset);\n      case Node.ELEMENT_NODE:\n        return new TextPosition(/** @type {Element} */ (node), offset);\n      default:\n        throw new Error('Node is not an element or text node');\n    }\n  }\n\n  /**\n   * Construct a `TextPosition` representing the range start or end point (node, offset).\n   *\n   * @param {Node} node - Text or Element node\n   * @param {number} offset - Offset within the node.\n   * @return {TextPosition}\n   */\n  static fromPoint(node, offset) {\n    switch (node.nodeType) {\n      case Node.TEXT_NODE: {\n        if (offset < 0 || offset > /** @type {Text} */ (node).data.length) {\n          throw new Error('Text node offset is out of range');\n        }\n\n        if (!node.parentElement) {\n          throw new Error('Text node has no parent');\n        }\n\n        // Get the offset from the start of the parent element.\n        const textOffset = previousSiblingsTextLength(node) + offset;\n\n        return new TextPosition(node.parentElement, textOffset);\n      }\n      case Node.ELEMENT_NODE: {\n        if (offset < 0 || offset > node.childNodes.length) {\n          throw new Error('Child node offset is out of range');\n        }\n\n        // Get the text length before the `offset`th child of element.\n        let textOffset = 0;\n        for (let i = 0; i < offset; i++) {\n          textOffset += nodeTextLength(node.childNodes[i]);\n        }\n\n        return new TextPosition(/** @type {Element} */ (node), textOffset);\n      }\n      default:\n        throw new Error('Point is not in an element or text node');\n    }\n  }\n}\n\n/**\n * Represents a region of a document as a (start, end) pair of `TextPosition` points.\n *\n * Representing a range in this way allows for changes in the DOM content of the\n * range which don't affect its text content, without affecting the text content\n * of the range itself.\n */\nexport class TextRange {\n  /**\n   * Construct an immutable `TextRange` from a `start` and `end` point.\n   *\n   * @param {TextPosition} start\n   * @param {TextPosition} end\n   */\n  constructor(start, end) {\n    this.start = start;\n    this.end = end;\n  }\n\n  /**\n   * Return a copy of this range with start and end positions relative to a\n   * given ancestor. See `TextPosition.relativeTo`.\n   *\n   * @param {Element} element\n   */\n  relativeTo(element) {\n    return new TextRange(\n      this.start.relativeTo(element),\n      this.end.relativeTo(element)\n    );\n  }\n\n  /**\n   * Resolve the `TextRange` to a DOM range.\n   *\n   * The resulting DOM Range will always start and end in a `Text` node.\n   * Hence `TextRange.fromRange(range).toRange()` can be used to \"shrink\" a\n   * range to the text it contains.\n   *\n   * May throw if the `start` or `end` positions cannot be resolved to a range.\n   *\n   * @return {Range}\n   */\n  toRange() {\n    let start;\n    let end;\n\n    if (\n      this.start.element === this.end.element &&\n      this.start.offset <= this.end.offset\n    ) {\n      // Fast path for start and end points in same element.\n      [start, end] = resolveOffsets(\n        this.start.element,\n        this.start.offset,\n        this.end.offset\n      );\n    } else {\n      start = this.start.resolve({ direction: RESOLVE_FORWARDS });\n      end = this.end.resolve({ direction: RESOLVE_BACKWARDS });\n    }\n\n    const range = new Range();\n    range.setStart(start.node, start.offset);\n    range.setEnd(end.node, end.offset);\n    return range;\n  }\n\n  /**\n   * Convert an existing DOM `Range` to a `TextRange`\n   *\n   * @param {Range} range\n   * @return {TextRange}\n   */\n  static fromRange(range) {\n    const start = TextPosition.fromPoint(\n      range.startContainer,\n      range.startOffset\n    );\n    const end = TextPosition.fromPoint(range.endContainer, range.endOffset);\n    return new TextRange(start, end);\n  }\n\n  /**\n   * Return a `TextRange` from the `start`th to `end`th characters in `root`.\n   *\n   * @param {Element} root\n   * @param {number} start\n   * @param {number} end\n   */\n  static fromOffsets(root, start, end) {\n    return new TextRange(\n      new TextPosition(root, start),\n      new TextPosition(root, end)\n    );\n  }\n}\n","/**\n * This module exports a set of classes for converting between DOM `Range`\n * objects and different types of selectors. It is mostly a thin wrapper around a\n * set of anchoring libraries. It serves two main purposes:\n *\n *  1. Providing a consistent interface across different types of anchors.\n *  2. Insulating the rest of the code from API changes in the underlying anchoring\n *     libraries.\n */\n\nimport { matchQuote } from './match-quote';\nimport { TextRange, TextPosition } from './text-range';\nimport { nodeFromXPath, xpathFromNode } from './xpath';\n\n/**\n * @typedef {import('../../types/api').RangeSelector} RangeSelector\n * @typedef {import('../../types/api').TextPositionSelector} TextPositionSelector\n * @typedef {import('../../types/api').TextQuoteSelector} TextQuoteSelector\n */\n\n/**\n * Converts between `RangeSelector` selectors and `Range` objects.\n */\nexport class RangeAnchor {\n  /**\n   * @param {Node} root - A root element from which to anchor.\n   * @param {Range} range -  A range describing the anchor.\n   */\n  constructor(root, range) {\n    this.root = root;\n    this.range = range;\n  }\n\n  /**\n   * @param {Node} root -  A root element from which to anchor.\n   * @param {Range} range -  A range describing the anchor.\n   */\n  static fromRange(root, range) {\n    return new RangeAnchor(root, range);\n  }\n\n  /**\n   * Create an anchor from a serialized `RangeSelector` selector.\n   *\n   * @param {Element} root -  A root element from which to anchor.\n   * @param {RangeSelector} selector\n   */\n  static fromSelector(root, selector) {\n    const startContainer = nodeFromXPath(selector.startContainer, root);\n    if (!startContainer) {\n      throw new Error('Failed to resolve startContainer XPath');\n    }\n\n    const endContainer = nodeFromXPath(selector.endContainer, root);\n    if (!endContainer) {\n      throw new Error('Failed to resolve endContainer XPath');\n    }\n\n    const startPos = TextPosition.fromCharOffset(\n      startContainer,\n      selector.startOffset\n    );\n    const endPos = TextPosition.fromCharOffset(\n      endContainer,\n      selector.endOffset\n    );\n\n    const range = new TextRange(startPos, endPos).toRange();\n    return new RangeAnchor(root, range);\n  }\n\n  toRange() {\n    return this.range;\n  }\n\n  /**\n   * @return {RangeSelector}\n   */\n  toSelector() {\n    // \"Shrink\" the range so that it tightly wraps its text. This ensures more\n    // predictable output for a given text selection.\n    const normalizedRange = TextRange.fromRange(this.range).toRange();\n\n    const textRange = TextRange.fromRange(normalizedRange);\n    const startContainer = xpathFromNode(textRange.start.element, this.root);\n    const endContainer = xpathFromNode(textRange.end.element, this.root);\n\n    return {\n      type: 'RangeSelector',\n      startContainer,\n      startOffset: textRange.start.offset,\n      endContainer,\n      endOffset: textRange.end.offset,\n    };\n  }\n}\n\n/**\n * Converts between `TextPositionSelector` selectors and `Range` objects.\n */\nexport class TextPositionAnchor {\n  /**\n   * @param {Element} root\n   * @param {number} start\n   * @param {number} end\n   */\n  constructor(root, start, end) {\n    this.root = root;\n    this.start = start;\n    this.end = end;\n  }\n\n  /**\n   * @param {Element} root\n   * @param {Range} range\n   */\n  static fromRange(root, range) {\n    const textRange = TextRange.fromRange(range).relativeTo(root);\n    return new TextPositionAnchor(\n      root,\n      textRange.start.offset,\n      textRange.end.offset\n    );\n  }\n  /**\n   * @param {Element} root\n   * @param {TextPositionSelector} selector\n   */\n  static fromSelector(root, selector) {\n    return new TextPositionAnchor(root, selector.start, selector.end);\n  }\n\n  /**\n   * @return {TextPositionSelector}\n   */\n  toSelector() {\n    return {\n      type: 'TextPositionSelector',\n      start: this.start,\n      end: this.end,\n    };\n  }\n\n  toRange() {\n    return TextRange.fromOffsets(this.root, this.start, this.end).toRange();\n  }\n}\n\n/**\n * @typedef QuoteMatchOptions\n * @prop {number} [hint] - Expected position of match in text. See `matchQuote`.\n */\n\n/**\n * Converts between `TextQuoteSelector` selectors and `Range` objects.\n */\nexport class TextQuoteAnchor {\n  /**\n   * @param {Element} root - A root element from which to anchor.\n   * @param {string} exact\n   * @param {Object} context\n   *   @param {string} [context.prefix]\n   *   @param {string} [context.suffix]\n   */\n  constructor(root, exact, context = {}) {\n    this.root = root;\n    this.exact = exact;\n    this.context = context;\n  }\n\n  /**\n   * Create a `TextQuoteAnchor` from a range.\n   *\n   * Will throw if `range` does not contain any text nodes.\n   *\n   * @param {Element} root\n   * @param {Range} range\n   */\n  static fromRange(root, range) {\n    const text = /** @type {string} */ (root.textContent);\n    const textRange = TextRange.fromRange(range).relativeTo(root);\n\n    const start = textRange.start.offset;\n    const end = textRange.end.offset;\n\n    // Number of characters around the quote to capture as context. We currently\n    // always use a fixed amount, but it would be better if this code was aware\n    // of logical boundaries in the document (paragraph, article etc.) to avoid\n    // capturing text unrelated to the quote.\n    //\n    // In regular prose the ideal content would often be the surrounding sentence.\n    // This is a natural unit of meaning which enables displaying quotes in\n    // context even when the document is not available. We could use `Intl.Segmenter`\n    // for this when available.\n    const contextLen = 32;\n\n    return new TextQuoteAnchor(root, text.slice(start, end), {\n      prefix: text.slice(Math.max(0, start - contextLen), start),\n      suffix: text.slice(end, Math.min(text.length, end + contextLen)),\n    });\n  }\n\n  /**\n   * @param {Element} root\n   * @param {TextQuoteSelector} selector\n   */\n  static fromSelector(root, selector) {\n    const { prefix, suffix } = selector;\n    return new TextQuoteAnchor(root, selector.exact, { prefix, suffix });\n  }\n\n  /**\n   * @return {TextQuoteSelector}\n   */\n  toSelector() {\n    return {\n      type: 'TextQuoteSelector',\n      exact: this.exact,\n      prefix: this.context.prefix,\n      suffix: this.context.suffix,\n    };\n  }\n\n  /**\n   * @param {QuoteMatchOptions} [options]\n   */\n  toRange(options = {}) {\n    return this.toPositionAnchor(options).toRange();\n  }\n\n  /**\n   * @param {QuoteMatchOptions} [options]\n   */\n  toPositionAnchor(options = {}) {\n    const text = /** @type {string} */ (this.root.textContent);\n    const match = matchQuote(text, this.exact, {\n      ...this.context,\n      hint: options.hint,\n    });\n    if (!match) {\n      throw new Error('Quote not found');\n    }\n    return new TextPositionAnchor(this.root, match.start, match.end);\n  }\n}\n","//\n//  Copyright 2021 Readium Foundation. All rights reserved.\n//  Use of this source code is governed by the BSD-style license\n//  available in the top-level LICENSE file of the project.\n//\n\n// Base script used by both reflowable and fixed layout resources.\n\nimport './gestures'\nimport {removeProperty, scrollLeft, scrollRight, scrollToId, scrollToPosition, scrollToText, setProperty} from \"./utils\";\nimport {getCurrentSelectionInfo, getSelectionRect} from \"./selection\";\nimport {createHighlight, createHighlightRange} from \"./highlight\";\nimport {TextQuoteAnchor} from \"./vendor/hypothesis/anchoring/types\";\n\n\n// Public API used by the navigator.\nwindow.readium = {\n    // utils\n    'scrollToId': scrollToId,\n    'scrollToPosition': scrollToPosition,\n    'scrollToText': scrollToText,\n    'scrollLeft': scrollLeft,\n    'scrollRight': scrollRight,\n    'setProperty': setProperty,\n    'removeProperty': removeProperty,\n\n    // selection\n    'getSelectionRect': getSelectionRect,\n    'getCurrentSelectionInfo': getCurrentSelectionInfo,\n\n    // highlights\n    'createHighlight': createHighlight,\n    'createHighlightRange': createHighlightRange,\n\n    // Hypothesis' anchoring\n    'TextQuoteAnchor': TextQuoteAnchor,\n};"],"sourceRoot":""}